Below is all the contents of our docs: 



 This is the content for the doc .github/ISSUE_TEMPLATE/epic.md 

 ---
name: Create an EPIC üîπ 
about: Create an epic of work that tracks several issues
title: "üîπ[EPIC] "
labels: Epic
assignees: ''

---

### Description

(Problem statement with a description of work to be accomplished.)

---

### Goal

(Define success. What is the desired outcome?)

---

### Resources

(Relevant documentation, Figma links, and other reference material)

- Item 1
- Item 2
- Item 3

---

```[tasklist]
### Related Issues
- [ ] https://github.com/near/docs/issues/1
- [ ] https://github.com/near/docs/issues/2
- [ ] https://github.com/near/docs/issues/3
```


 This is the content for the doc CODE_OF_CONDUCT.md 

 # Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at privacy@near.org. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq


 This is the content for the doc CONTRIBUTING.md 

 # Contributing to NEAR

NEAR welcomes help in many forms, including development, code review, documentation improvements, and outreach.
Please visit [the contribution overview](https://wiki.near.org/contribute/near-contributing) for more information.

## Using GitHub issues and pull requests

Some repositories (including this one) have specific issue templates that will be helpful for maintainers and community contributors. Please use the templates whenever available.

Please include steps to reproduce if you are reporting an error. Information on all applicable versions is quite helpful. Some versions can be found using the command line. (For example: `node --version` or `rustc --version`.) Other version information may be packaged as dependencies. (For example: in `package.json` or `Cargo.toml`.)

If verbosity flags are available, please include those to offer as much information as possible.

When opening a pull request, please use the typical open-source flow of forking the desired repository and opening a pull request from your forked repository. (More information on [technical contributions here](https://wiki.near.org/development/how-to-contribute).)

## Testing

Please note that for technical contributions, NEAR runs a battery of continuous integration tools and tests for each pull request.

It's encouraged to write unit tests on new features. Many NEAR repositories have built-in scripts that run tests locally. Tests may check linting and must be addressed.

For example, a repository might have `yarn test` available. It's a good idea to run tests locally before submitting a pull request, as these will be caught during the CI process.

### Thank you

NEAR values all contributors to the projects in the ecosystem and invites public discussion on the tech and vision. Please feel free to join the conversation using the links offered at [near.help](https://near.help).


 This is the content for the doc README.md 

 <br />
<br />

<p align="center">
<img src="website/static/docs/assets/near-logo.png" width="240">
</p>

<br />
<br />

## NEAR Protocol - scalable and usable blockchain

[![Discord](https://img.shields.io/discord/490367152054992913.svg)](http://near.chat)
[![CI](https://github.com/near/docs/actions/workflows/build-check.yml/badge.svg)](https://github.com/near/docs/actions/workflows/build-check.yml)

This is the repository for the official documentation of NEAR Protocol, a user-friendly and carbon-neutral blockchain, built from the ground up to be performant, secure, and infinitely scalable.

## Quick start

Check out the following links:

- Deployed, live documentation: https://docs.near.org
- Example applications: https://github.com/near-examples
- Community chat: https://near.chat

## Contributing

NEAR uses [Docusaurus](https://docusaurus.io) for documentation. Please refer to their documentation for details on major structural contributions to the documentation.

For simple content changes you have 2 options:

- [Submit an issue](https://github.com/near/docs/issues)
- [Submit a pull request](https://github.com/near/docs/pulls) *(we prefer PRs of course)*

### The instant PR

This is the fastest way to submit content changes directly from the page where you notice a mistake.

1. Open any page in the docs on https://docs.near.org
2. Click the `[ Edit ]` button at the top right hand side of _every_ content page
3. Make your edits to the document that opens in GitHub by clicking the ‚úé (pencil) icon
4. Submit a PR with your changes and comments for context

### The typical PR

This is the standard fork-branch-commit workflow for submitting pull requests to open-source repositories:

1. Fork this repo to your own GitHub account (or just clone it directly if you are currently a member of NEAR)

2. Open your editor to the _top level repo folder_ to view the directory structure as seen below

3. Move into the `/website` folder where you will run the following commands:

   - Make sure all the dependencies for the website are installed:

     ```sh
     # Install dependencies
     yarn
     ```

   - Run the local docs development server

      ```sh
      # Start the site
      yarn start
      ```

      _Expected Output_

      ```sh
      # Website with live reload is started
      LiveReload server started on port 35729
      Docusaurus server started on port 3000
      ```

      The website for docs will open your browser locally to port `3000`

4. Make changes to the docs

5. Observe those changes reflected in the local docs

6. Submit a pull request with your changes - **[Please check for broken links before opening PR üôè](#check-for-broken-links)**

## Directory Structure

Your project file structure should look something like this with a few key files and folders highlighted

```
‚îú‚îÄ‚îÄ CODE_OF_CONDUCT.md
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ LICENSE-APACHE.txt
‚îú‚îÄ‚îÄ LICENSE-MIT.txt
‚îú‚îÄ‚îÄ README.md             <-- the document you are reading right now
‚îú‚îÄ‚îÄ docs                  <-- all the content for the site is in this folder as markdown files
‚îî‚îÄ‚îÄ website
    ‚îú‚îÄ‚îÄ build
    ‚îú‚îÄ‚îÄ core
    ‚îú‚îÄ‚îÄ i18n
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ pages
    ‚îú‚îÄ‚îÄ sidebars.js     <-- rarely used for changing left-hand-side page navigation
    ‚îú‚îÄ‚îÄ docusaurus.config.js     <-- rarely used for general site configuration (including header links)
    ‚îú‚îÄ‚îÄ static
    ‚îî‚îÄ‚îÄ test-links.sh     <-- always used to test links before submitting changes
```

## Found a broken link?

For broken links internal to the docs, please submit an issue or PR request as per above.

If you found a broken link from a Google search, please request to remove it from their index here: https://www.google.com/webmasters/tools/removals

## Check for broken links

Before opening a pull request, please check for broken links by navigating to `./website` directory and run:

```bash
yarn full-test
```


 This is the content for the doc blog/2024-04-23.md 

 ---
title: We have a blog now!
authors: [gagdiez]
slug: we-have-a-blog
tags: [updates]
---

*Check check check. Is this thing on? Hello, world!*

<p><img src="/assets/images/protocol-b73c2a3ace3307226ee7eb2149ee432f.png" /></p>

<!-- truncate -->

## Hello there!
Welcome to the new NEAR documentation blog! We're excited to inaugurate this new space where we can share news and updates. We know what you are thinking ‚Äî why a blog? Well, it allows us to interact with you in a different way!

When writing documentation, it is important for us to keep the content focused and concise. This way, when you read it, you have nothing to distract you, and you can focus on learning a new concept.

The problem with this is that many times, we want to share ideas, thoughts, or insights into why some things are the way they are. However, this would imply going off on a tangent and explaining why some decisions were made, which will probably add noise to the document. Most of the time, users just want a link to an example or working code. Also, people don't like to read long texts.

Besides that, sometimes we just want to share what we did during the week. For example, did you notice that we fixed the nightmare that was the URL structure, or that we added new landing pages for all concepts? We want to share these things with you, but they don't really belong in the Docs.

:::tip
You would not believe the number of times we said during a review _"let's remove that, we are writing technical documentation, not a blog post"_ ... well, now we can make the blog post!
:::

## What to expect

We will be using this space to share updates about our docs, as well as **complement them** with additional information that we think you'll find interesting.

Our aim is to keep the blog updated at least once a week, but given the limited amount of time we have, we will see how that goes.

Moreover, we want to remind you that our Docs are an open source and **collaborative project**. If you feel like you have something to share, or want to contribute to the blog, feel free to reach out. And by reaching out, we mean [opening a PR](https://github.com/near/docs/pulls)!

## A new era for NEAR docs

We are super excited to start this new section and hope it helps us to connect with all of you in a better way. We are looking forward to hearing your thoughts and feedback, and hope you enjoy the content we'll be sharing.

See you in the next post! üöÄ


 This is the content for the doc blog/2024-04-24.md 

 ---
title: Reorganizing our docs
authors: [gagdiez]
slug: reorganizing-docs
tags: [docusaurus, updates]
hide_table_of_contents: true
---

*We released a mayor reorganization of our repository, so we can improve docs for everyone... including us*

<p><img src="https://img.freepik.com/free-photo/ancient-books-adorn-library-carefully-arranged-with-classics-rare-gems_157027-2332.jpg" /></p>

<!-- truncate -->

## Organic growth
Our documentation is the result of multiple people collaborating across the span of four very active years, and it has seen a lot of changes: [2942 commits and counting](https://github.com/near/docs/commits/master/).

In the beginning, our docs only needed to explain how to create [smart contracts](/build/smart-contracts/what-is), and how to [interact with them through a frontend](/build/web3-apps/quickstart). Fast forward to today, and we have more than 200 pages of documentation, covering topics such as [chain abstraction](/chain-abstraction/what-is), [data infrastructure](/build/data-infrastructure/what-is), and [primitives such as NFT, FT](/build/primitives/what-is).

The best thing is that new features are released every single month. However, all progress comes at a cost, and as our ecosystem grew, so did the disorganization of our documentation.

## What link was that again?
Let's briefly explain how [docusaurus](https://docusaurus.io/) (the framework we use in our docs) works so you can understand the problem.

In docusaurus, all the pages are written as simple markdown files. These files go inside the `./docs` folder, and can be organized in folders. Each file has a unique ID on its header that identifies it (e.g. `id: what-is`), and this ID, alongside its folder path, is used to generate the URL. 

> For example, the document [`docs/build/smart-contracts/what-is.md`](https://github.com/near/docs/blob/master/docs/2.build/2.smart-contracts/what-is.md) has the `id: what-is`, so it ends being served in the URL https://docs.near.org/build/smart-contracts/what-is.

### The problem

About a year ago, we noticed that our organic growth had left us with a very inconsistent URL structure. Basically, we had a lot of folders, and the files related to the same topic (e.g. NEAR components) would be all over the place.

For example, you would be in the "Build" section reading about "What is a NEAR Component?" and the URL was `/bos/tutorial/quickstart`. The next page was "Setup an Environment" located at `/bos/dev/intro`, followed by "Anatomy of a Component -> State" at `/bos/api/state`. Talk about consistency!

Of course, we did not do this on purpose, it is just how things evolved. You might even notice that we are now talking about "NEAR Components" but the URL talks about "BOS". This is because when we started, "BOS" (Blockchain Operating System) felt like a good name, but community feedback made us know that, indeed, it was not. 

### The migration

We [re-organized more than 200 files](https://github.com/near/docs/pull/1890/files) to a new structure that is more consistent. This makes it easier for users to remember the URLs, improves our SEO, and makes it easier for contributors to find where to add new content. No more need to search across multiple folders trying to find the right file!

In the process, we updated all **internal links**, aided by our [link-checker script](https://github.com/near/docs/blob/master/website/test-links.sh) to make sure we left **no broken links**. We also added **URL redirects** in our server, so all users coming from an external site are redirected to the correct URLs.

Besides checking broken links, we took the time to make sure all the **translations were correctly migrated**. The system Docusaurus uses (called [Crowdin](https://crowdin.com/)) is not very good at detecting changes in a file, so migrating all the translations was a huge effort in itself. 

We could write a blog post just about migrating translations in docusaurus + crowdin... but we will spare you the pain.

:::tip Missing URL
If you come across a URL that is not working, please let us know by using the `Feedback` button on the right side of the page, or by opening an [issue in our repository](https://github.com/near/docs/issues)
:::

## What's next
Now that most of our documentation is in a better shape, we can focus on improving the content itself. We have a lot of ideas on how to make the docs more interactive, and we are excited to start working on them.

Stay tuned for more updates, and remember that if you have any feedback or ideas, you can always reach out to us. We are always happy to hear from you!

See you in the next post! üöÄ


 This is the content for the doc blog/2024-05-15.md 

 ---
title: Use cases for Chain Signatures
authors: [bucanero]
slug: chain-signatures-use-cases
tags: [docusaurus, updates]
hide_table_of_contents: true
---


*Chain signatures enable you to implement multichain and cross-chain workflows in a simple way. Let's take a look at a few possible use cases*

<!-- truncate -->


## Trade Blockchain assets without transactions

Trading assets across different blockchains usually requires using a bridge that supports them, bringing longer settlement times as the trades are not atomic and require confirmation on both blockchains.

Using Chain signatures, you can trade assets across chains simply swapping the ownership of NEAR accounts that control funds on different blockchains. For example, you could trade a NEAR account that controls a Bitcoin account with `X BTC` for another NEAR account that controls an Ethereum account with `Y ETH`.

This way, you can keep native tokens on their native blockchain (e.g., `BTC` on Bitcoin, `ETH` on Ethereum, `ARB` on Arbitrum) and trade them without bridges.
As an added bonus, trades are atomic across chains, settlement takes just 2 seconds, and supports any token on any chain.

:::tip Keep in mind

 There are transactions happening on different blockchains.
 The difference is that a [Multi-Party Computation service](/chain-abstraction/chain-signatures#multi-party-computation-service) (MPC) signs a transaction for you, and that transaction is then broadcast to another blockchain RPC node or API.

:::

For example, a basic trade flow could be:

1. Users create an account controlled by NEAR chain signatures
2. Users funds these accounts on the native blockchains (depositing)
3. Place orders by funding a new account for the total amount of the order
4. Another user accepts the order
5. Users swap control of the keys to fulfill the order

![docs](/docs/native-cross-chain.png)

<details>
- User A has `ETH` on the Ethereum blockchain, and wants to buy native Bitcoin
- User B wants to sell Bitcoin for Ethereum

**Steps**

1. User B, using NEAR, creates and funds a new account on Bitcoin with 1 `BTC`
2. User B, using the spot marketplace smart contract, signs a transaction to create a limit order. This transfers control of the Bitcoin account to the smart contract
3. User A creates a batch transaction with two steps
    - Creating and funding a new Ethereum account with 10 `ETH`
    - Accepting the order and atomically swapping control of the accounts
4. User A takes ownership of the Bitcoin account with 1 `BTC`, and User B takes ownership of the Ethereum account with 10 `ETH`
5. User A and B can _"withdraw"_ their asset from the order by transferring the assets to their respective _"main"_ accounts
</details>

---

## Oauth-controlled Blockchain accounts

On-boarding is a huge problem for decentralized applications. If you want widespread adoption you can't expect people to keep seed phrases safe in order to use an application.

An attractive way of managing Web3 accounts is to use existing Web2 accounts to on-board users. This can be done in the following way:

1. Deploy a NEAR contract that allows the bearer of a user's [JWT token](https://jwt.io/) to sign a blockchain transaction (Ethereum, Polygon, Avalanche, and others)
2. The user validates their identity with a third-party receiving a JWT Token
3. The user holding that token can interact with blockchain applications on Ethereum/Polygon/+++ via the NEAR contract for the duration of its validity

Any method of controlling a NEAR account can also be used to control a cross-chain account.

:::info About JWT tokens
JSON Web Tokens are a standard RFC 7519 method for representing claims securely between two parties. They are used in this example to represent the claim that someone is the owner of an Oauth account.
:::

---

## Cross-chain Zero-friction onboarding

Using unique features of the NEAR account model, [Keypom](https://docs.keypom.xyz/) provides zero-friction onboarding and transactions on NEAR. They are generally used for NFT drops, FT drops, and ticketing.

A generic Keypom user-flow could be:

1. The developer creates a restricted NEAR account
2. The account is funded with `NEAR`
3. The user receives a key with limited control of the account
4. The user uses the funded account to call controlled endpoints on NEAR
5. The user returns the remaining funds to the developer and their account is unlocked

:::tip
This allows easy onboarding to decentralized apps. The accounts are initially restricted to prevent the user being able to simply withdraw the `NEAR` from the account.
:::

## DeFi on Bitcoin (and other non-smart contract chains).

Using chain signatures, smart contracts on NEAR can control externally-owned accounts on non-smart contract chains like Bitcoin, Dogecoin, XRP Ledger, Bittensor, Cosmos Hub, etc. This enables developers to use NEAR as a smart contract ‚Äúlayer‚Äù for chains that do not support this functionality natively.

For example, a developer can build a decentralized exchange for Bitcoin Ordinals, using a smart contract on NEAR to manage deposits (into Bitcoin addresses controlled by the contract) and to verify and execute swaps when two users agree to trade BTC for an Ordinal or BRC20 token.

Example:
1. Seller generates a deposit address on Bitcoin that is controlled by the marketplace smart contract on NEAR via chain signatures
2. Seller deposits a Bitcoin Ordinal to the deposit address
3. The Ordinal is listed for sale with a price and a pre-commitment signature from the seller
4. Buyer accepts the order, deposits USDC
5. The control of the Bitcoin Ordinal address is given to the buyer, USDC on NEAR is transferred to the seller

#### Using Chain Signatures

With Chain Signatures you can do the same but across many chains, for example Polygon:

1. The developer creates a restricted NEAR account with a key
2. The account is funded with `NEAR` and `MATIC`
3. The user receives a key with limited control of the account
4. The user uses the funded account to sign payloads calling controlled endpoints on Polygon
5. The user returns the remaining funds to the developer and their account is unlocked

This allows developers to pay for users to use arbitrary contracts on arbitrary chains.

---

## Decentralized Clients

A big problem in decentralized applications is that while the smart contracts are tamper-proof, the clients that access them generally are not. This allows practically complete control over any user account provided they are using the frontend assets that you serve. This has security, trust, and regulatory implications.

When smart contracts can sign payloads you can start using [signed exchanges](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-introduction) (or polyfills) to require HTTP exchanges to be signed by a certain key. If it is not signed with this key the SSL certificate is considered invalid. This means that individual users cannot be served invalid frontends without it being generally observable and non repudiable.

---

## Communication with private NEAR Shards

Companies like [Calimero](https://www.calimero.network/) offer private NEAR shards. Currently, sending messages to and from these NEAR shards is troublesome. If each shard had the ability to sign their message queues, they could be securely sent from one shard to another. Thus you could communicate bidirectionally with any shard as easily as you can with a contract on your own shard.

:::tip
This could also simplify NEAR's sharding model, by treating each NEAR shard like one would a private shard.
:::


 This is the content for the doc blog/2024-05-30.md 

 ---
title: It's gonna be Legen... wait for it...
authors: [gagdiez]
slug: yield-resume
tags: [protocol, updates]
hide_table_of_contents: true
---

*dary! Legendary! NEAR protocol is getting updated with the ability to yield and resume computations*

![waiting on a loop](/docs/blog/legendary.jpg)

<!-- truncate -->

:::tip üéâ September Update üéâ

We now have an [example of how to use `yield` and `resume`](https://github.com/near-examples/yield-resume) in your contracts. Check it out!

There is also a new documentation page on [Yield and Resume](/build/smart-contracts/anatomy/yield-resume) that explains how to use this feature

:::

## The problem of waiting
Currently, smart contracts have no way to wait for an external event to happen. This can be a problem when the contract relies on an external service to provide a result.

We encountered this issue while implementing [Chain Signatures](/chain-abstraction/chain-signatures), which work by requiring an external service to provide a signature.

Until now, the only workaround has been to make the contract call itself in a loop, checking on each iteration if the result is ready. Each call delays the result by one block (~1 second), allowing the contract to wait almost a minute before running out of gas.

![waiting on a loop](/docs/blog/contract-wait-loop.png)
*Until now, contracts had to wait by calling themselves until a external service replies... more often than not the contract will run out of gas waiting*

While this method works, it's far from ideal. It wastes a lot of gas on looping and - more often than not - runs out of gas, forcing the user to retry the transaction.

## Yield and Resume
Starting from version `1.40` of the protocol, developers can **delay the execution** of a function until certain conditions are met (e.g. an external service provides a result).

This way, instead of the contract calling itself on a loop waiting, the contract can simply **yield** calling the function that gives the result. When an external response is provided, the contract will **resume** and return the result.

![waiting on a yield](/docs/blog/contract-wait-yield.png)
*Contracts can now yield the execution of a function until an external service signals that the result is ready*

### What is exactly being yielded?
It is important to notice that the contract is not **halting** or **blocking** its ability to execute, nor **halting in the middle of a function** to later resume it.

In the same way that a function can return a promise to call another contract, now a function can return a **yield** to call another function.

Indeed, the contract is not halting, but simply **delaying the execution of a callback** until an external agent signals that it is ok to resume.

If the contract does not trigger a resume after 200 blocks - around 4 minutes - the yielded function will resume receiving a "timeout error" as input.

:::warning State Changes
People can keep calling functions on the contract between a `yield`/`resume`, and the function that creates the `yield` can be called multiple times.

The state **can change** between the `yield` and the `resume`, since people can keep interacting with the contract.

Moreover, since the function used to signal is public, developers must make sure to guard it properly to avoid unwanted calls. This can be done by simply checking the caller of the function.
:::

### How does it change for the user?
Between the `yield` and `resume` the user will simply be waiting to receive the result. But, in contrast with waiting on a loop, the user will not pay GAS just for having the contract waiting!

## How I can use yield/resume in my contract?
While we have not created any official `yield/resume` example, you can refer to [Saketh Are's example](https://github.com/near/near-sdk-rs/pull/1133/files), who has been working on the `yield/resume` implementation.

The basic idea is that the SDK now exposes two functions:
- A `yield(function_to_yield)` that returns a `yield_ID` which identifies the yield
- A `resume(yield_ID)` that signals which instance of `function_to_yield` can now execute

#### Simplified Example

```rust
// const DATA_ID_REGISTER: u64 = 0;

pub fn request_weather(&mut self, city: String) {
    let index = self.next_available_request_index;
    self.next_available_request_index += 1;

    let yield_promise = env::promise_yield_create(
        "callback_return_result",
        &serde_json::to_vec(&(index,)).unwrap(),
        SIGN_ON_FINISH_CALL_GAS,
        GasWeight(0),
        DATA_ID_REGISTER,
    );

    // Store the request, so an external service can easily fetch it
    // This is optional, as an indexer could simply observe it in the receipts
    let data_id: CryptoHash =
        env::read_register(DATA_ID_REGISTER).expect("").try_into().expect("");
    self.requests.insert(&index, WeatherRequest{&data_id, &city});

    // The return will be the result of "callback_return_result" (defined below)
    env::promise_return(yield_promise);
}

/// Called by external participants to submit a response
pub fn respond(&mut self, data_id: String, weather: String) {
    let mut data_id_buf = [0u8; 32];
    hex::decode_to_slice(data_id, &mut data_id_buf).expect("");
    let data_id = data_id_buf;

    // check that caller is allowed to respond, weather is valid, etc.
    // ...

    log!("submitting response {} for data id {:?}", &weather, &data_id);
    env::promise_yield_resume(&data_id, &serde_json::to_vec(&weather).unwrap());
}

/// Callback receiving the external data (or a PromiseError in case of timeout)
pub fn callback_return_result(
    &mut self,
    request_index: u64,
    #[callback_result] weather: Result<String, PromiseError>,
) -> String {
    // Clean up the local state
    self.requests.remove(&request_index);

    match weather {
        Ok(weather) => "weather received: ".to_owned() + &weather,
        Err(_) => "request timed out".to_string(),
    }
}
```

## Conclusion
The ability to `yield` and `resume` computations is a big step forward for the NEAR protocol, as it enables developers to create contracts that rely on external services.

Currently, the feature is only **available on testnet**, and we are looking for feedback on how to improve it.

We expect to have a more user-friendly way to use `yield` and `resume` in the future, so stay tuned!


 This is the content for the doc blog/2024-06-05.md 

 ---
title: Getting Started on NEAR Using Windows
authors: [flmel]
slug: getting-started-on-windows
tags: [windows, tutorial, getting-started]
hide_table_of_contents: true
---
In this article, we will cover how to install WSL and setup a NEAR development environment on Windows.

<!-- truncate -->

### WSL

WSL, or Windows Subsystem for Linux, is a compatibility layer for running Linux binary executables natively on Windows. It allows us to run a GNU/Linux environment directly on Windows without the overhead of a traditional virtual machine or dual-boot setup.

#### Enable WSL from `Windows Features`
First of all, make sure that WSL is enabled, for this go to:
`Control Panel > Programs > Turn Windows Features on or off`
Scrolling down will reveal the option `Windows Subsystem for Linux`. Make sure it is enabled and press OK to confirm (you will be asked to reboot your computer).

![Windows Features WSL Enabled](/docs/blog/windows-features-wsl-enabled.jpg)

#### Start WSL and Install Ubuntu

Now we will spend some time in either `PowerShell` or [Windows Terminal](https://apps.microsoft.com/detail/9n0dx20hk701), which is a modern terminal application that supports various command-line tools and shells.

```bash
# may be desirable for seamless integration between WSL2 distros of linux and docker with WSL backend 
wsl --set-default-version 2
```

```
wsl --install --d Ubuntu
```

**Read more on WSL:**
https://learn.microsoft.com/en-us/windows/wsl/install
https://learn.microsoft.com/en-us/windows/wsl/setup/environment
https://learn.microsoft.com/en-us/windows/wsl/

### Install Required Packages
Once the installation is completed you will have Ubuntu installed as any other application on Windows. Open it from the start menu and you will be dropped into the [Ubuntu bash shell](https://ubuntu.com/tutorials/command-line-for-beginners#1-overview)

Enter the following commands to install all the packages that Rust and Node might need later:

```bash
apt-get update
apt-get install gcc make libudev-dev openssl pkg-config unzip -y
```

:::tip Permission Denied?
Depending on your setup, you might need to run the commands with `sudo`. This temporarily grants your user elevated privileges to perform tasks that require higher permissions.
:::

### Setup Developer Environment

Now that we have WSL enabled and running Ubuntu, it is time to setup our developer environment. At NEAR we currently support using JS/TS and Rust to develop smart contracts, and JS/TS to develop web applications.

Bellow we will explain how to install both `Node.js` and `Rust`. If you want, you can install only one of them (e.g. if you are only planning to create a Rust contract, you don't need Node.js). However, we do recommend to install both so your environment is ready if you want to try something different later.

#### Node (JS/TS)

Node.js is a JavaScript runtime environment that executes code outside a web browser, enabling the development of server-side applications. In NEAR development, it can be used to write smart contracts in [TypeScript](https://www.typescriptlang.org/), as well as to create Web applications that interact with NEAR.

```
# installs nvm (Node Version Manager)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
# download and install Node.js
nvm install 20
# verifies the right Node.js version is in the environment
node -v # should print `v20.14.0`
# verifies the right NPM version is in the environment
npm -v # should print `10.7.0`
```

**Read more:**
[NodeJS Website](https://nodejs.org/)

#### Rust

[Rust](https://www.rust-lang.org/) is a programming language known for its safety and performance. It's used in NEAR development to write secure and efficient smart contracts.

Next, we need to add the `wasm32-unknown-unknown` toolchain. This toolchain is required because the contracts we build will be compiled to [WASM](https://webassembly.org/) to run on the NEAR blockchain.

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
# When prompted, press enter for default install options
. source $HOME/.cargo/env
rustup target add wasm32-unknown-unknown
```

**Read more:**
[Getting Started with Rust](https://www.rust-lang.org/learn/get-started)

### That's It

At this point, we are ready to install the relevant tooling and start building on NEAR. Head over to the [Quickstart](http://docs.near.org/build/smart-contracts/quickstart) section of the docs for more information or jump right into the [examples](https://github.com/near-examples).


 This is the content for the doc blog/2024-06-28.md 

 ---
title: One place for all Smart Contracts Docs
authors: [gagdiez]
slug: sdks-unified
tags: [updates]
---

*We have consolidated all our documentation in a single section, so you don't need to go searching around for it*

<p><img src="/assets/images/contracts-landing-5a9c76a78e71b0e5f9a96033f1f23d23.png" /></p>

<!-- truncate -->

Smart contracts are small pieces of logic that can live on every NEAR account. To build a contract you use the NEAR SDKs, which comes in two flavours: Rust and JavaScript.

Until today, we had multiple docs explaining how to build smart contracts:
- `/sdk/rust` dedicated to explain how to use the Rust SDK
- `/sdk/js` dedicated to explain how to use the JS SDK
- [`/build/smart-contracts/what-is`](/build/smart-contracts/what-is) - that explains general concepts, and how to implement them using both SDKs

Today, this is over, as all the information on how to build smart contracts is located in a single area: [`/build/smart-contracts/what-is`](/build/smart-contracts/what-is).

Meanwhile, we have transformed the [SDK page](/tools/sdk) to be a simple landing page with links to:
- The [Rust SDK reference docs](https://docs.rs/near-sdk/latest/near_sdk/)
- The [JS SDK reference docs](https://near.github.io/near-api-js/)
- The [Smart Contract Section](/build/smart-contracts/what-is)

## Why did we have 3 sections explaining the same topic?

The reason we had 3 different sections was that, historically, the engineers of each SDK were working on their own docs in isolation. To help mitigate this, we created a section on NEAR docs, meant to consolidate all the external documentation.

One day, the individual SDK pages were deleted - if I remember correctly, it was because we wanted to have fewer domains - and we had to migrate everything in a rush.

This left us in a very weird situation: we already had a section explaining how to build a smart contract... and now we had 3.

## A single source of truth

Luckily, this is now fixed! We have finally conquered the original dream of having a single section for [Smart Contracts](/build/smart-contracts/what-is), with all the information consolidated in there. 

Now, we can focus on maintaining a single section, thus making it easier to keep it updated and relevant.

## What's next?

We are currently undergoing a process of **consolidating** all the documentation. This means that we are looking at all the sections that have overlapping information, and trying to merge them into a single place.

This will not only improve the quality of our docs, but also make it easier for you to find the information you need. In fact, improving search is one of the main motors of this change, since we noticed that our search tool ([Algolia](https://www.algolia.com/)) gets confused when the same concept is spread all over the place.

Moreover, having consistent and coherent documentation will allow us to further expand our search capabilities using AI! This is something we are very excited about, as it will allow us to provide you with even more relevant information.

## If you don't like this change, please let us know!

As always, we are more than open to feedback. If you think that this change is not good, or that we are missing something, please let us know! You can reach out to us through the blue feedback button you see at the side of the screen.

We are looking forward to hearing your thoughts and feedback, and hope you enjoy the content we'll be sharing.

Happy coding, and see you in the next post! üöÄ

 This is the content for the doc blog/2024-07-01.md 

 ---
title: Pagoda Pauses the B.O.S. Web Engine R&D Project
authors: [thisisjoshford]
slug: bos-web-engine-sunset
tags: [updates, BWE, VM2, BOS]
hide_table_of_contents: true
---

*After careful consideration, Pagoda has decided to discontinue its active efforts to improve the B.O.S. Web Engine*

<p><img src="/assets/images/protocol-b73c2a3ace3307226ee7eb2149ee432f.png" /></p>

<!-- truncate -->

After many discussions with NEAR‚Äôs B.O.S. component developers and careful consideration, Pagoda has decided to discontinue its active development for [B.O.S. Web Engine R&D ](https://github.com/near/bos-web-engine)for an improved execution layer for NEAR B.O.S. Components. (also known as ‚ÄúBWE‚Äù & ‚ÄúVM2‚Äù)

## Background

Last year, [NEAR introduced the Blockchain Operating System](https://near.org/blog/near-announces-the-blockchain-operating-system), demonstrating how NEAR‚Äôs performant tech stack could support a full-stack decentralized development platform that was multi-chain compatible. A core feature of this system consisted of composable decentralized front-ends (B.O.S. Components) paired with a user-centric data storage contract (social-db). This model, [pioneered by NEAR Social](https://thewiki.near.page/PastPresentAndFutureOfNearSocial), aimed to continue NEAR‚Äôs mission of empowering users to own their data as well as eliminate reliance on centralized, single-entity-controlled web applications. The potential of a fully decentralized web and the creation of real dApps became closer to reality with these inherently open and customizable experiences.

As the community started to adopt B.O.S. it soon became clear that, while devs loved how fast it was to go from an idea to a product, its intrinsic technical limitations made it hard to use B.O.S. for any real-world application. This consistent feedback from multiple members of the community prompted Pagoda to start an R&D effort to improve B.O.S. such that:

- It was as close to vanilla React as possible
- Supported npm package imports
- Unlocked multi-chain scalability limitations
- Improved performance
- Improved security

## B.O.S. Web Engine

In order to act on this feedback and accomplish these goals, improvements had to be made to the execution layer that makes this all possible. At its core, a virtual machine, ([NEAR Social VM](https://github.com/NearSocial/VM)) renders front-end code that developers store in a smart contract onchain (social-db). It was determined that a new approach to the original VM solution was needed, and the B.O.S. Web Engine project was created. Countless hours of hard work and dedication have gone into this project, yielding many significant achievements along the way. However, one major challenge still stands in the way of a production-ready beta release: expanding support for npm packages, particularly UI libraries.

During the alpha testing phase of this project, we anticipated a fairly straightforward path in resolving wider npm support but unfortunately, the team discovered a more complex scenario. While standard JavaScript packages work well, React UI libraries frequently encounter difficulties. These challenges stem from the unique packaging methods of each library and the complexities involved in synchronizing changes between the iframe and the outer DOM. Although we have identified several theoretical solutions, each requires further research and development to assess their practicality and effectiveness. This has been more fully detailed in [a GitHub discussion within the BWE Repo](https://github.com/near/react-on-chain/discussions/425).

We reached out to leading B.O.S. component contributors to determine whether this limitation would be unnegotiable and to learn what features they value most. Do they prioritize unrestricted NPM support over secure iframe composability? How important is composability, and how would they define it? (considering our approach dissects it down to the atomic level of every element)

This revealed some interesting findings, one of which was that secure composability on an atomic level was not at the top of the list. Most favored the ease of quick prototyping, deployment, and onboarding with managed infra and wallet connections. Many valued social-db features and the ability to create custom gateways (websites) using code and user data publicly available to them.

In short, there were three camps:

### True Believers

- Decentralize all the things!
- Love bleeding-edge unique tech
- Love inherent open-source
- Love social-db and its features

### Quick Builders

- Love the speed of development, prototyping, remixing
- Love reverse engineering existing components
- Quick onboarding with managed infra and wallet connections
- Great for hackathons

### Detractors

- Don't like anything about B.O.S. components
- DevX is poor and UI is slow
- Value convenience over decentralization

After reviewing our findings and engaging extensively with developers using this platform, it became clear that continuing with the release of the B.O.S. web engine as currently planned could potentially have a net negative impact. The majority of developers indicated that they do not favor a version of the BWE with limited npm support, even if it means enhanced secure composability. Additionally, while a minority of builders prioritize decentralization over performance and convenience, those who truly value decentralized frontends might find simpler ways to achieve their objectives once the need for secure composability is eliminated.

For those who may disagree with this perspective, the B.O.S. Web Engine remains, and will always be an open-source project. Anyone who sees value in the work we have done and wishes to advance this initiative is welcome to carry this torch and continue the development. https://github.com/near/bos-web-engine

## What does this mean for B.O.S. components & the current VM?

During the development of the B.O.S. Web Engine, a large focus was placed on addressing the security aspects of the existing VM and B.O.S. component architecture. The primary concern is with the composability and attack vectors that are exposed when importing components authored by third parties. Despite numerous patches to address discovered exploits, the inherent complexities of JavaScript and the current VM‚Äôs architecture suggest that such vulnerabilities may continue to persist. Pagoda has diligently monitored and addressed these issues to date but we anticipate challenges in continuing to proactively discover and mitigate future vulnerabilities.

_For examples of previously discovered vulnerabilities, view the [VM changelog](https://github.com/NearSocial/VM/releases) going back to `v2.5.1`, paying attention to lines tagged as `FIX` on issues Reported by `BrunoModificato` from OtterSec._

If you find value in creating B.O.S. components and leveraging the features of the social-db smart contract, rest assured that this framework will remain open-source and permanently accessible on-chain. However, we urge caution when incorporating and using third-party components. Due to the current virtual machine's limitations, we cannot guarantee protection against potential future exploits.

## Should I migrate my project off of B.O.S.?

If your application relies on community-contributed or unreviewed third-party components, then **yes**. As described above, we cannot guarantee protection against future security vulnerabilities in the VM and B.O.S. component architecture. However, you can mitigate (but not eliminate) these security risks by reviewing all third-party components and either forking them or locking down dependencies to the specific version that you reviewed.

If you are not relying on any untrusted component code, then **maybe**. You are not being forced to migrate and there are still teams actively building new applications leveraging B.O.S. Additionally, there are no plans to deprecate main B.O.S. gateways at [dev.near.org](https://dev.near.org), [near.social](https://near.social), [dapdap](https://dapdap.net) or [bos.gg](https://bos.gg). However, the underlying framework and virtual machine are no longer actively developed or maintained by the original team. Consequently, the pace at which new features are introduced and existing bugs or vulnerabilities are addressed may be slower than expected. We openly welcome new maintainers for [this codebase](https://github.com/nearsocial). However, as previously mentioned, we anticipate that additional security vulnerabilities may still be discovered.

We have updated [‚ÄúFrontends for Web3 dApps‚Äù in docs.near.org](https://docs.near.org/build/web3-apps/integrate-contracts)  to help you choose a solution that is right for you. If you need help, please reach out to one of our support channels on [Telegram](https://t.me/neardev) or [Discord](https://near.chat) and we will be happy to assist you or answer any questions you have.


 This is the content for the doc blog/2024-07-18.md 

 ---
title: An update on the near.org / RPC outage on July 11, 2024
authors: [ewiner]
slug: 2024-07-11-near-org-outage
tags: [updates, postmortems]
hide_table_of_contents: true
---

From Thursday, July 11 to Saturday, July 13, many visitors to [near.org](https://near.org) and its subdomains (like [dev.near.org](https://dev.near.org) and [docs.near.org](https://docs.near.org/)) were unable to reach those websites. Also, NEAR applications that rely on [RPC services](https://docs.near.org/api/rpc/providers) hosted on near.org were affected. This was due to a security incident followed by an outage from one of our vendors, Squarespace. During this period, the NEAR protocol & blockchain was unaffected by this incident, as it does not rely on any centralized services.

<!-- truncate -->

### Our Use of Squarespace DNS

The near.org domain is operated by [Pagoda](https://www.pagoda.co/), an engineering arm of the NEAR Foundation. An important part of operating a domain like near.org is choosing a DNS provider; to learn more about DNS and how it operates, please see [this introduction](https://www.cloudflare.com/learning/dns/what-is-dns/). For years, we happily used Google‚Äôs domain name registration & DNS service to manage near.org, as part of our broad usage of Google Cloud services. In June 2023, Google announced it had [sold its Domains business to Squarespace](https://support.google.com/domains/answer/13689670?hl=en), and that our account would be transitioned to Squarespace ‚Äúin the next few months.‚Äù We expected that the new service from Squarespace would closely match the feature set, reliability, and security we had enjoyed while using Google Domains, and if there were any problems then we could easily switch from Squarespace to another DNS provider after the transition.

Our first domain, near.wiki, was automatically moved over to Squarespace in May 2024. As we explored the new offering, our Security & IT teams quickly had concerns about the feature set, security controls, and level of enterprise support we could get from Squarespace. After some meetings with Squarespace sales and support failed to assuage our concerns, we decided to explore other DNS providers and to start migrating our domains off of Squarespace, starting with the ‚Äòsimpler‚Äô ones and ending with near.org, our most complex and important domain name. As of last week, when this incident began, we had not yet begun migrating near.org to our new provider, Amazon Web Services, so it was still using Squarespace as its DNS provider.


### The Squarespace Security Incident

Unbeknownst to us, Squarespace had a major security vulnerability. You can read about the problem in [this in-depth blog post from Security Alliance](https://securityalliance.notion.site/A-Squarespace-Retrospective-or-How-to-Coordinate-an-Industry-Wide-Incident-Response-fead693b66c14543a48283d85aec19ad). In short, when each domain was migrated from Google to Squarespace, all existing users on the Google Domains account were sent an email inviting them to create a new Squarespace account. But not everybody clicked on that email right away ‚Äì some people, e.g. managers or our accounting team, only needed to log into the DNS service rarely or in emergencies. From what we can tell, all the attacker needed to do was identify one of those email addresses and sign up for a new Squarespace account using that email address, and they would be instantly granted full access to change or delete DNS entries for near.org. From our investigation, Squarespace did not require the attacker to verify ownership of the email address before letting them have full control on our account. In fact, we see no evidence that Squarespace even sent a ‚Äúwelcome‚Äù email to that address upon account creation, which might have raised warning flags.

On July 11, an attacker gained access to our Squarespace account. They deleted the DNS entries for near.org and its subdomains, causing the outage described above. But unlike some other domains affected by this attack, the impact on near.org seems limited to an outage; we have seen no evidence that the attacker put in place an ‚Äòimposter‚Äô site to try and phish or scam users.

Through a combination of our actions and Squarespace‚Äôs actions behind the scenes, we were able to quickly regain control of the account. However, due to other issues with Squarespace, it took another two days for near.org and its subdomains and services to get fully back online.


### The Squarespace Outage

Even with full and exclusive access to our Squarespace, we were unable to restore service on near.org. The attacker had deleted our DNS entries, and when we re-added them, Squarespace failed to propagate those new entries to other DNS providers around the world. We attempted to quickly execute a switch to Amazon Web Service‚Äôs DNS provider, but the feature to switch to a different DNS service was also broken on the Squarespace site.

The next morning, on Friday July 12, on a hunch we deleted and re-added all of our DNS entries once again. This time, it did take effect and DNS providers around the world quickly saw the new information. That resolved the outage for many users, but not for everyone. near.org had been set up with an additional security feature, DNSSEC, in which Squarespace was supposed to digitally sign our DNS entries to prove that the entries had not been forged by another DNS provider. But Squarespace wasn‚Äôt properly updating and signing new DNSSEC entries, so any other DNS provider that validates DNSSEC was detecting near.org‚Äôs DNS entries as a forgery and refusing to allow access to near.org. This affected [approximately 34% of users](https://stats.labs.apnic.net/dnssec), especially in Europe. There is a button on the Squarespace site to turn off DNSSEC, but unsurprisingly, that button also just showed an error message.

Finally, on Saturday July 13, we were able to make contact with a specialist on the Squarespace team, and later that day they were able to fix the DNSSEC issue. Once that change propagated to other DNS providers around the world over the next few hours, near.org and the RPC service was restored for everyone.


### Reflections on this Incident

You may have noticed that we made a few assumptions in this blog post, saying ‚Äúfrom what we can tell‚Äù and ‚Äúwe see no evidence of‚Ä¶‚Äù a few times. Ideally, almost a week after the incident began, we would have more hard truths and solid information about what happened.

Unfortunately, we‚Äôve seen little to no communication from Squarespace throughout this period. We tried multiple support tickets, chat, personal contacts, LinkedIn messages, and going through our Google support team, and still didn‚Äôt hear anything back from Squarespace until late on Friday July 12, about 36 hours after the incident began. Other affected companies also reported total silence from the Squarespace team. As far as we know, Squarespace has still not acknowledged this incident publicly, let alone shared details of the issue and how they remediated it, and their [status page](https://status.squarespace.com/) showed no outages or issues during this time.

I personally find this lack of support, communication, and forthrightness to be unacceptable for any service provider. I‚Äôm also somewhat disappointed in Google for transitioning a security-critical service to a new provider without proper vetting. We are accelerating our plans to move near.org and other domains out of Squarespace to Amazon Web Services‚Äôs domain registrar and DNS provider, which has a great track record of reliability and security.

DNS is a core part of internet infrastructure, but it‚Äôs far from a perfect system. Every domain name owner must rely on one centralized DNS provider to maintain their DNS entries, and every user and application must rely on one or more centralized DNS providers to look up entries as they navigate the internet. Various projects in the blockchain industry have created non-custodial on-chain alternatives to DNS, such as [Unstoppable Domains](https://unstoppabledomains.com/) and [3DNS](https://3dns.box/) (FYI: neither have sponsored or were made aware of this post), but the existing DNS system is so entrenched that adoption has been a challenge. Hopefully as an industry we can make headway on a more decentralized, trustless open web before further incidents like this happen.

I‚Äôm deeply sorry to anyone affected by this outage, especially people exploring NEAR for the first time during the EthCC conference and EthGlobal hackathon. We will be more vigilant about using high-quality vendor services going forward ‚Äì and, where possible, moving to decentralized on-chain solutions.

-Eric Winer<br />
CTO & Managing Director, Pagoda


 This is the content for the doc blog/2024-08-13.md 

 ---
title: Future of Pagoda Services
authors: [ewiner]
slug: 2024-08-13-pagoda-services
tags: [updates]
hide_table_of_contents: false
---

As the NEAR ecosystem continues to decentralize, Pagoda will cease operations within the next six months and decentralize its functions into NEAR ecosystem teams and committees.  This document describes the transition plan for each of the services, activities, and tools that Pagoda develops or operates.

<!-- truncate -->

### Critical NEAR Services

The critical services below will continue to be operated and maintained by Pagoda until they are smoothly transitioned to new operators in the NEAR ecosystem during the second half of 2024:

-   [near.org RPC](https://docs.near.org/api/rpc/providers) ([Request for Proposals](https://dev.near.org/infrastructure-committee.near/widget/app?page=rfp&id=2))
-   [NEAR Lake](https://docs.near.org/build/data-infrastructure/lake-framework/near-lake-framework) ([Request for Proposals](https://dev.near.org/infrastructure-committee.near/widget/app?page=rfp&id=3))
-   [BigQuery Public Dataset](https://docs.near.org/build/data-infrastructure/big-query) ([Request for Proposals](https://dev.near.org/infrastructure-committee.near/widget/app?page=rfp&id=4))
-   [Node Snapshots](https://near-nodes.io/intro/node-data-snapshots) 
-   [State Sync](https://near-nodes.io/rpc/state-sync)
-   Undocumented but critical services:
    -   KitWallet Indexer API ([Request for Proposals](https://dev.near.org/infrastructure-committee.near/widget/app?page=rfp&id=1))
    -   near-cli Testnet Faucet

Each transition will be independently planned and communicated on its own timeline and this page will be updated accordingly.

The NEAR [Infrastructure Committee](https://dev.near.org/infrastructure-committee.near/widget/near-prpsls-bos.components.pages.app?page=about) will manage this transition process by soliciting proposals from the community for continued operation of these services, then will select, fund, and oversee the new operator.

#### A Note About near.org RPC

The Infrastructure Committee feels that Pagoda's fully-subsidized near.org RPC service is getting in the way of decentralization efforts and is preventing high-quality commercial RPC offerings from gaining traction. If a NEAR core team continues to support a free-to-use near.org RPC service, it will be required to gradually lower its rate limits over the coming months to prevent abuse. More details on this plan will be communicated by the end of September 2024. In light of this proposed change, **high-traffic near.org RPC users should start making plans to switch to other RPC providers**.

### Chain Abstraction Services

[Chain Signatures](https://docs.near.org/chain-abstraction/chain-signatures), Multichain Gas Relayer, and [FastAuth](https://docs.near.org/chain-abstraction/fastauth-sdk) will continue to be developed by Pagoda, then will be taken over by the new Chain Abstraction / Multichain spinout from Pagoda and Proximity. More information will be shared in September or October 2024.

### Pagoda Operations & Ecosystem Services

Pagoda‚Äôs ecosystem services will transition as follows:

-   [Infrastructure Committee](https://dev.near.org/infrastructure-committee.near/widget/near-prpsls-bos.components.pages.app?page=about) administration, the recently rebooted Security Assessment Program, and management of the [near.org](http://near.org) website will move under the purview of NEAR Foundation.
-   [Bug bounty](https://hackenproof.com/company/near/programs) triage will be transitioned to the protocol team at NEAR One.
-   The [NEAR Helpdesk](https://help.near.org/) will be turned into self-service documentation.
-   Pagoda's informal technical / smart contract advisory services for other ecosystem companies will wind down over the next few months.

### Open-Source Libraries

These open-source libraries and tools will be developed by Pagoda until they reach a logical completion or stopping point:

-   [Pagoda Metatransaction Relayer](https://github.com/near/pagoda-relayer-rs)
-   [Chain Hosted UI](https://github.com/near/chain-hosted-ui)
-   [Modularization and Refactor](https://t.me/neardev/53280) of `near-api-js`

Once active development by Pagoda has ceased, it doesn't mean these tools have to languish. We encourage the NEAR community to continue this work. If you need funding to do so, you can submit proposals to [DevHub](https://dev.near.org/devhub.near/widget/app) or the [Infrastructure Committee](https://dev.near.org/infrastructure-committee.near/widget/near-prpsls-bos.components.pages.app?page=about).

### Deprecated Services

Between now and February 2025, Pagoda's development work will slow down or stop on the following products and services:

-   QueryAPI
-   Enhanced API
-   Alerts & Triggers

These are open-source services and we encourage the community to continue with their development and operation. If we can't identify new operators quickly, we will encourage remaining users of these services to switch to alternative solutions, then communicate a timeline for these services to be turned off.


 This is the content for the doc blog/2024-10-24.md 

 ---
title: New Tutorial - Master Applications on NEAR
authors: [pivortex]
slug: 2024-10-24-new-tutorial
tags: [updates, tutorial, getting-started]
hide_table_of_contents: true
---

You might have noticed that a [new tutorial](https://docs.near.org/tutorials/auction/introduction) has been added to the docs! This multi-part series is all about learning to build full applications on NEAR; you will see how to build an on-chain auction from start to finish, including the smart contract, deploying it on-chain, and creating a frontend to interact with it.

<!-- truncate -->

Along the way you will learn several key concepts and how to use many key primitives along the way: 
- Creating a simple smart contract
- Writing tests for a contract
- Deploying a contract to `testnet`
- Locking a contract
- Creating a frontend to interact with the contract
- Using an indexing API to view historical bids
- Making cross-contract calls
- Using Non-Fungible Tokens
- Using Fungible Tokens
- Modifying a factory contract to deploy your own contracts

This tutorial is a great for beginners to follow all the way through, but each section can also be used as a reference guide for different concepts. If you have any feedback or any questions regarding the tutorial please feel free to reach out in the [Developer Telegram Channel](https://t.me/neardev). 

**Start the tutorial [here](https://docs.near.org/tutorials/auction/introduction)**

Let's keep building! üöÄ


 This is the content for the doc blog/2024-11-07.md 

 ---
title: Hello Ethereum Wallets!
authors: [gagdiez, slava]
slug: hello-ethereum-wallets
tags: [updates]
---

*You can now login using MetaMask, WalletConnect and +400 Ethereum Wallets on Near!*

<p><img src="/docs/blog/web3wallets/cover.png" /></p>

<!-- truncate -->

## Ethereum Wallets on NEAR

We are excited to announce that NEAR now supports Ethereum wallets! This means that you can now login to NEAR applications using MetaMask, WalletConnect, and over 400 other Ethereum wallets.

In this post, we will explain how Ethereum wallets work on NEAR, and where to find information on how to integrate them into your applications.

## How it works

The idea of bringing Ethereum wallets to Near was born on the [NEP-518](https://github.com/near/NEPs/issues/518), and the [Aurora Labs team](https://aurora.dev) worked for over a year to make it a reality.

Since Ethereum wallets create **ethereum transactions** and talk with **ethereum RPCs**, the Aurora team had to create three components:

1. A Translator API, that translates Ethereum RPC calls into NEAR RPC calls
2. A "Wallet Contract" deployed on Near, that can process Ethereum transactions

<img src="/docs/blog/web3wallets/diagram.png" height="600px" style={{width: "auto", display: "block", margin: "0 auto"}} />


### Login

Imagine your account on Metamask is `0xD79...314`, and you want to login on a Near application. 

The first time you login, `ethereum-wallets.near` will create the Near account `0xD79...314` for you.

<img src="/docs/blog/web3wallets/login.png" style={{width: "auto", display: "block", margin: "0 auto"}} />

Your new Near account already has a `Wallet Contract` deployed on it, which can **translate ethereum transactions** into **account actions**.

:::tip
In Near, smart contracts can do anything an account can do, including sending tokens and calling other contracts!
:::

### Using your Account

Once you have logged in, you can start interacting with the application. If at some point the application needs to interact with the blockchain, Metamask will ask you to sign a transaction.

Under the hood, Metamask will create an Ethereum transaction and send it to the `Translator API`, deployed at `https://eth-rpc.mainnet.near.org`.

The `Translator API` will then translate the Ethereum transaction into a **function call** into the `Wallet Contract` deployed in your account. Particularly, it will call the `rlp_execute` function, passing the Ethereum transaction as an argument. 

<img src="/docs/blog/web3wallets/function-call.png" style={{width: "auto", display: "block", margin: "0 auto"}} />

The `Wallet Contract` will then execute the function call, and the application will receive the result.

:::tip

Check [this transaction](https://testnet.nearblocks.io/txns/GrVGFVFmGBcNP5xkoA21gEJ7d5bUGVxtmkfHAzyUW895#enhanced) in our explorer to see the full execution path

:::

## Updating your Application

In order to support Ethereum wallets, you only need to update your version of `wallet-selector`, and configure it to include the new `ethereum-wallets` module.

Do not worry! it is very simple, check our [**tutorial**](/build/web3-apps/ethereum-wallets) and working example [**hello world frontend**](https://github.com/near-examples/hello-near-examples/tree/main/frontend).

---

## Resources

1. [**Integration Tutorial**](/build/web3-apps/ethereum-wallets)

2. [Hello World Example](https://github.com/near-examples/hello-near-examples/blob/main/frontend/)

3. [Recording of the Ethereum Wallet Presentation](https://drive.google.com/file/d/1xGWN1yRLzFmRn1e29kbSiO2W1JsxuJH-/view?usp=sharing)

4. [NEP-518](https://github.com/near/NEPs/issues/518), the proposal that started it all


 This is the content for the doc blog/2025-01-01.md 

 ---
title: A Year in Docs
authors: [gagdiez]
slug: a-year-in-docs
tags: [updates]
---

*2024 was a great year for NEAR Docs! Let's take a look at what we achieved together*

<p><img src="/docs/blog/2024-review/2024-blog.jpg" /></p>

<!-- truncate -->

## New Year, New Opportunities

There is something that we like to do every new year, and that is to take a look at how our docs changed through the past year.

You see, NEAR is a live ecosystem, where new features are added constantly, products and projects emerge, and our docs need to reflect that. This means that we are always adding, removing, and updating content.

By looking at the changes we made, we get to remember what we achieved - it is always nice to see all we built in a year - and it also helps us discover what we lost along the way!

Join us while we take a look at the changes we made in 2024, and what we are planning for 2025.

## Consolidating Documentation

One of the main issues we tackled this year was consolidating our documentation.

Users often complained that we had a lot of content spread across different sections, pages, and repositories, and we wanted to bring it all together in one place.

At the beginning of 2024, we had different menus for [Concepts](/concepts/basics/protocol), [Smart Contracts](/build/smart-contracts/what-is), [Web Applications](/build/web3-apps/what-is), and [Data Infrastructure](/build/data-infrastructure/what-is).

We decided to merge all these pages into a single `Docs` section, with a shared navigation bar, so you can always easily jump from one topic to another.

![Navigation](/docs/blog/2024-review/2024-blog.jpg)
_Navigation before (left) and now (right), notice how many links were removed from both top and left navigation bars!_

To keep the sidebar clean, we added a `What is...` page for each major topic, which helps you to understand the basics and decide if that section is what you are looking for.

For example, we now have the following pages:

- [What is NEAR Protocol?](/concepts/basics/protocol)
- [What is Chain Abstraction?](/chain-abstraction/what-is)
- [What is a Smart Contract?](/build/smart-contracts/what-is)

## Code Explainer

During this year, we took a couple of weeks to build an in-house tool to simplify explaining code!

![code explainer](/docs/blog/2024-review/2024-blog-2.jpg)

The new `Code Explainer` allows us to easily explain long snippets of code, by highlighting the essential parts and adding text blocks to explain what is happening.

Our new [Smart Contract Anatomy](/build/smart-contracts/anatomy/) section looks amazing and is much easier to understand now!

## 2024: A Year of Growth

This year we have been busy adding new sections, pages, and tutorials to our documentation. Let's briefly go through some of them.

### Primitives

One of the first things we added was a section about [Primitives](/build/primitives/what-is), which explains the basic building blocks of NEAR Protocol.

![Primitives](/docs/blog/2024-review/2024-blog-3.jpg)

In the new Primitives section, we show how to create and use [NFTs](/build/primitives/nft), [FTs](/build/primitives/ft), [DAOs](/build/primitives/dao), [Linkdrops](/build/primitives/linkdrop), [Oracles](/build/primitives/oracles), and [Decentralized Exchanges](/build/primitives/dex).

Every page is full of snippets that explain how to leverage each primitive from any tool that you are using, be it the bash terminal, a web application, or from within a smart contract.

### Chain Abstraction

We also added a section about [Chain Abstraction](/chain-abstraction/what-is), which explains how NEAR accounts can be used to control accounts on other chains.

![alt text](/docs/blog/2024-review/2024-blog-4.jpg)
_Did you know you can control Ethereum and Bitcoin accounts from NEAR?_

We expect to make this section grow in 2025, as we plan to add more tutorials and examples on interacting with chains like Base, Solana, and Polygon.

### New Beginner's Guide

In 2024 we also released a brand new [Step-by-Step Guide to Mastering Near](/tutorials/auction/introduction). This guide is perfect for beginners, as it explains everything from creating an account to deploying a smart contract, creating a web application for it, and even how to monitor the contract's activity!

![Beginner's Guide](/docs/blog/2024-review/2024-blog-5.jpg)

It is our most complete guide yet! But stay tuned, as we are planning to add more tutorials and examples to it in 2025.

### NEAR API

We also released a new version of our [API documentation](/tools/near-api), which now includes all API flavors - JavaScript, Rust, and Python.

![API](/docs/blog/2024-review/2024-blog-6.jpg)

In this new version, we added a lot of examples on how to use the API in the most common scenarios, as well as linked all the code to a single [GitHub repository](https://github.com/near-examples), to make it easier for us to test it, and for you to copy and paste the code.

### Near Examples

An important part of our documentation is the examples it references. We have been working hard to make sure that all examples are up-to-date and working.

For example, we have updated all our canonical examples (Hello Near, Counter, Donations, NFT, FT) to use the latest version of core libraries (`near-api`, `near-sdk` and `wallet-selector`)

## Looking Forward

We are excited to start 2025 with a lot of new ideas and projects in mind. We are planning to add new examples about how to build complex DeFi applications on NEAR, as well as adding community projects such as [Pikespeak](https://doc.pikespeak.ai/), [FastNear](https://github.com/fastnear/explorer-api), and [NearBlocks](https://api.nearblocks.io/api-docs/)

More importantly, we expect 2025 to be the year of AI, focusing on building docs showing how easy is to use [NEAR AI](https://near.ai) to build and deploy machine learning models on NEAR.

By focusing on AI, we also expect to bring new ways to engage with our documentation, such as a chatbot that can help you find the right page!

Of course, everything is being developed using open-source tools and libraries, so you can easily replicate what we are doing.

We are excited to start this new year, and hope you are too! üöÄ


 This is the content for the doc docs/1.concepts/3.advanced/indexers.md 

 ---
sidebar_label: "Intro to Indexers"
---

# Introduction to Indexers

Here you will find everything you need to know in order to familiarize yourself with the concept of indexers and even build your own one.

:::info Disclaimer

The explanation on this page assumes you have a certain level of understanding of the blockchain technology.

:::


### Blockchains and their nature

Blockchain data is optimized for serialized **writes**, one block at a time, as the chain is being created. Querying the blockchain for data about a specific block or account is fairly straightforward or a "narrow" query. However, querying data across many blocks can be cumbersome because we have to aggregate results from multiple single-block queries. Therefore, we can consider these *"wide" queries*.

Given the fact that a blockchain itself is a distributed database, and a smart contract (decentralized application, dApp) is an application that runs on a virtual machine inside a blockchain, we need to understand that smart contracts should *not* be considered as a "backend". While some applications might consist only of smart contracts, building a dApp with only smart contracts, in most cases, is not possible.

Smart contracts are limited in terms of interactions. By "interactions" we mean things that are very common in the real world, like user notifications, integration with third-party applications, etc.

However, the nature of a blockchain is that it *must* be deterministic. A critical feature of a blockchain is that it knows the state at a given time, and for blockchains that time unit is a block. Think of them as being snapshots. A blockchain does snapshots of its state on every block. We as users can call smart contracts for a specific block, and the blockchain provides guarantees that execution will always produce the same result for the same block any time we call it.

The deterministic nature of a blockchain closes it from external (off-chain) variables. It is totally impossible to perform a call to an API from within a smart contract. A blockchain and a smart contract are closed off from the external (off-chain) world.

![Blockchain closed from outer world](/docs/intro/blockchain.png)

Blockchains are great at providing a way to apply the requested changes to the state in a decentralized manner. However, in order to observe the changes, you need to actively pull the information from the network.

Instead of abstract explanations let's look at an example.

:::note Example dApp

Say, we have a smart contract that sells e-books. Once a user buys a book we want to send them a copy via email.

:::


The dApp has a helper deployed somewhere off-chain, and this helper has code that can send an email with a copy of an e-book. But how would we trigger the helper?

### Getting the data from a blockchain from the external world

NEAR blockchain implements a [JSON-RPC endpoint](https://docs.near.org/api/rpc/introduction) for everyone to interact with the blockchain. Through the JSON-RPC API users can call smart contracts triggering them to be executed with given parameters. Also, users can view the data from the blockchain.

So, continuing with our example we can make our helper pull a [Block](https://docs.near.org/api/rpc/block-chunk#block) every second, then pull all the [Chunks](https://docs.near.org/api/rpc/block-chunk#chunk) and analyze the Transactions included in the Block to check if there is a transaction to our smart contract with "buy an e-book" function call. If we observe such a Transaction, we need to ensure it is successful, so we don't send the e-book to a user whose "buy e-book" Transaction failed.

After the process is complete we can trigger the helper's code to send the user an email with the e-book they bought.

This approach is so-called *pull model* of getting the data. There is nothing wrong with this approach, but sometimes you might find it is not the most comfortable or reliable approach.

Also, not all the data is available through the JSON-RPC. *Local Receipts* for example are not available through the JSON-RPC, because they are not stored in NEAR node's internal database.

### Indexer

A blockchain indexer is an implementation of the *push model* of getting the data. Instead of actively pulling the data from the source, your helper waits for the data to be sent to it. The data is complete and so the helper can start analyzing it immediately; ideally the data is complete enough to avoid additional pulls to get more details.

Getting back to our example, the helper becomes **an indexer** that receives every *Block*, along with **Chunks**, **Transactions** with its statuses, etc. In the same way the helper analyzes the data and triggers the code to send the user an email with the e-book they bought.

![Indexer is streaming the data from the blockchain](/docs/intro/indexer.png)

:::info An indexer concept

An indexer listens to the *stream of data as it's being written on chain* and can then be immediately filtered and processed to detect interesting events or patterns.

:::


## Indexers and "wide" queries

The term *"wide" queries* was mentioned in the beginning of this document. Here's a recap:

:::note "Wide" queries definition

To query data across many blocks requires the aggregation of results from multiple single-block queries. We can consider these aggregates as coming from *"wide" queries*.

:::

Because indexers listen to the *stream of data* from the blockchain and the data can be immediately filtered and processed according to defined requirements, they can be used to simplify the "wide" queries execution. For example, a stream of data can be written to a permanent database for later data analysis using a convenient query language like SQL.

Another example that highlights the need for a "wide query" is when you use a seed phrase to recover one or more accounts. Since a seed phrase essentially represents a signing key pair, the recovery is for all accounts that share the associated public key. Therefore, when a seed phrase is used to recover an account via [NEAR Wallet](https://wallet.near.org), the query requires that all accounts with a matching public key are found and recovered. Utilizing [Near Lake Framework](https://github.com/near/near-lake-framework-rs) can be used to store this data in a permanent database and this allows [NEAR Wallet](https://wallet.near.org) to perform such "wide queries". This is impossible to achieve using JSON-RPC only.

## Summary

We hope this article gives you an understanding of the Indexer concept. Also, we hope now you can easily decide whether you need an indexer for your application.

## What's next?
We encourage you to learn more about the [Lake Indexer project](/build/data-infrastructure/lake-framework/near-lake). Please, proceed to [Tutorials](/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer) section to learn how to build an indexer on practice.

Alternatively, there are a few other third-party indexers that are tightly integrated with the NEAR ecosystem. You can review all of your data sourcing options (including The Graph, Pagoda, Pikespeak, and SubQuery) under [indexing tools](/tools/indexing).


 This is the content for the doc docs/1.concepts/basics/epoch.md 

 ---
id: epoch
title: Epoch
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


An **epoch** is a unit of time when validators of the network remain constant. It is measured in blocks:

- Both `testnet` and `mainnet` have an epoch duration of 43,200 blocks. Ideally epochs last about 12 hours, since blocks are created every second (in reality, they take slightly longer to be created).
- You can view this setting by querying the **[`protocol_config`](/api/rpc/protocol#protocol-config)** RPC endpoint and searching for `epoch_length`.

**Note:** Nodes garbage collect blocks after 5 epochs (~2.5 days) unless they are [archival nodes](https://near-nodes.io/intro/node-types#archival-node).

**Example:**

<Tabs>

<TabItem value="json" label="JSON" default>

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_protocol_config",
  "params": {
    "finality": "final"
  }
}
```

</TabItem>

<TabItem value="http" label="HTTPie">

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_protocol_config \
  params:='{
    "finality": "final"
  }'
```

</TabItem>

</Tabs>

**Example Response:**

```json
{
    "jsonrpc": "2.0",
    "result": {
        "protocol_version": 44,
        "genesis_time": "2020-07-21T16:55:51.591948Z",
        "chain_id": "mainnet",
        "genesis_height": 9820210,
        "num_block_producer_seats": 100,
        "num_block_producer_seats_per_shard": [
            100
        ],
        "avg_hidden_validator_seats_per_shard": [
            0
        ],
        "dynamic_resharding": false,
        "protocol_upgrade_stake_threshold": [
            4,
            5
        ],
        "epoch_length": 43200,
        "gas_limit": 1000000000000000,
        "min_gas_price": "1000000000",
        "max_gas_price": "10000000000000000000000",
        "block_producer_kickout_threshold": 90,
        "chunk_producer_kickout_threshold": 90,

// ---- snip ----
}
```

You can learn more about how epochs are used to manage network validation in the [Validator FAQ](https://github.com/near/wiki/blob/master/Archive/validators/faq.md#what-is-an-epoch).

:::tip Got a question?

<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>

:::


 This is the content for the doc docs/1.concepts/basics/networks.md 

 ---
id: networks
title: NEAR Networks
sidebar_label: Networks
---

NEAR Protocol operates on several networks each operating with their own independent validators and unique state. These networks are as follows:

- [`mainnet`](/concepts/basics/networks#mainnet)
- [`testnet`](/concepts/basics/networks#testnet)
- [`localnet`](/concepts/basics/networks#localnet)

## Mainnet {#mainnet}

`mainnet` is for production ready smart contracts and live token transfers. Contracts ready for `mainnet` should have gone through rigorous testing and independent security reviews if necessary. `mainnet` is the only network where state is guaranteed to persist over time _(subject to the typical security guarantees of the network's validation process)_.

- Status: `https://rpc.mainnet.near.org/status`
- [ [NearBlocks Explorer](https://nearblocks.io) ]
- [ [Wallet](https://wallet.near.org) ]
- [ [Data Snapshots](https://near-nodes.io/intro/node-data-snapshots) ]

## Testnet {#testnet}

`testnet` is a public network and the final testing network for `nearcore` changes before deployment to `mainnet`. `testnet` is intended for testing all aspects of the NEAR platform prior to `mainnet` deployment. From account creation, mock token transfers, development tooling, and smart contract development, the `testnet` environment closely resembles `mainnet` behavior. All `nearcore` changes are deployed as release candidates on first testnet, before the changes are released on `mainnet`. A number of `testnet` validators validate transactions and create new blocks. dApp developers deploy their applications on `testnet` before deploying on `mainnet`. It is important to note that `testnet` has its own transactions and states.

- Status: `https://rpc.testnet.near.org/status`
- [ [Explorer](https://testnet.nearblocks.io) ]
- [ [Wallet](https://testnet.mynearwallet.com/) ]
- [ [Data Snapshots](https://near-nodes.io/intro/node-data-snapshots) ]

## Localnet {#localnet}

`localnet` is intended for developers who want to work with the NEAR platform independent of the public blockchain. You will need to generate nodes yourself. `localnet` gives you the total control over accounts, economics, and other factors for more advanced use cases (including making changes to `nearcore`). For developers, `localnet` is the right choice if you prefer to avoid leaking information about your work during the development process.

More on local development [here](https://near-nodes.io/validator/running-a-node)


---

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer">
<h8>Ask it on StackOverflow!</h8>
</a>
:::


 This is the content for the doc docs/1.concepts/basics/protocol.md 

 ---
id: protocol
title: What is NEAR?
---

NEAR is a **user-friendly** and [**carbon-neutral**](https://near.org/blog/near-climate-neutral-product/) blockchain, built to be [fast, secure, and infinitely scalable](https://www.leewayhertz.com/comparison-of-blockchain-protocols#Parallel-comparison-of-various-blockchain-networks).

![img](@site/static/docs/assets/welcome-pages/protocol.png)

In technical terms, NEAR is a [layer one](https://coinmarketcap.com/academy/glossary/layer-1-blockchain), [sharded](https://near.org/blog/near-launches-nightshade-sharding-paving-the-way-for-mass-adoption), [proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) blockchain built with usability in mind.

In simpler terms, NEAR is the **blockchain for everyone**.

<details>

<summary> What do these Technical Terms mean? </summary>

In technical terms, NEAR is a [layer-one](https://coinmarketcap.com/academy/glossary/layer-1-blockchain), [sharded](https://near.org/blog/near-launches-nightshade-sharding-paving-the-way-for-mass-adoption), [proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) blockchain built with usability in mind.

[Layer-1](https://coinmarketcap.com/academy/glossary/layer-1-blockchain) means NEAR is the foundation that supports everything else built on it. It keeps all the transaction records safe and unchangeable which keeps the network secure and trustworthy.

[Sharded](https://near.org/blog/near-launches-nightshade-sharding-paving-the-way-for-mass-adoption) means the network is broken into pieces that work in parallel. This helps NEAR process transactions quickly and efficiently.

[Proof-of-stake](https://en.wikipedia.org/wiki/Proof_of_stake) uses less electricity compared with other blockchains which use proof-of-work. Users show they own NEAR tokens to help run the network. This makes it cheaper and lets more people use it.

</details>

---

## Why Choose NEAR? {#why-build-on-near}

NEAR is a technical marvel, offering built-in features such as named accounts and account abstraction. For developers, NEAR offers everything needed for their applications, from smart contracts to indexers. All while being interoperable with other chains.

### ‚≠ê Simple to Use

1. Use [**named accounts**](../protocol/account-model.md) like `alice.near`
2. Simple sign-up: make an account using [email](https://dev.near.org/signup) or [telegram](https://web.telegram.org/k/#@herewalletbot)
3. Transactions are **fast** _(~1.3s transactions)_ and **cheap** _(< 1¬¢ in fees)_
4. You don't need to buy crypto thanks to **built-in account abstraction**
5. [Access Keys](../protocol/access-keys.md) make it safe and easy to use
6. Control accounts on **other chains** thanks to [chain signatures](../../chain-abstraction/chain-signatures.md)

### üõ°Ô∏è Battle-Tested

1. 4 years of **100% uptime** and [**3 Billion** transactions](https://pikespeak.ai/near-world/overview) processed
2. NEAR has sustained peaks of [>13M transactions](https://pikespeak.ai/near-world/overview) in a single day
3. NEAR is home to decentralized apps with [millions of users](https://dappradar.com/rankings?range=30d):
    - [Kai-ching](https://cosmose.ai/)
    - [Sweat](https://sweateconomy.com/)
    - [Hot Wallet](https://t.me/herewalletbot/)

### üßë‚Äçüíª Great Developer Experience

1. Build smart contracts with **Javascript** or **Rust**
2. **Simple onboarding**, thanks to its complete documentation and examples
3. Get answers and learn at NEAR DevRel **office hours**, where anybody can participate
4. Earn from your contract's gas fees
5. **EVM compatible** with [Project Aurora](http://www.aurora.dev) _(Deploy your Solidity contracts with ease)_

### ‚ôªÔ∏è Environmentally Friendly

1. NEAR is **[certified carbon-neutral](https://near.org/blog/the-near-blockchain-is-climate-neutral/)**
2. NEAR **consumes in a year** the same energy [**bitcoin consumes in 3 minutes**](https://medium.com/nearprotocol/how-near-went-carbon-neutral-e656db96da47#:~:text=The%20firm%20found%20that%20NEAR,PoS%20technology%20instead%20of%20PoW)


 This is the content for the doc docs/1.concepts/basics/runtime.md 

 ---
id: runtime
title: Runtime
---

This section contains videos that explore the core Runtime, its operation, and how it implements cross-contract calls.

## Runtime Overview

An in-depth code overview of NEAR Runtime.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/Xi_8PapFCjo"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>

## Runtime Action and Data Receipts

An in-depth code review of how NEAR Runtime implements cross contract calls.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/RBb3rJGtqOE"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>

## Runtime State

An in-depth overview of how NEAR runtime operates with its state.

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/JCkSNL4ie1U"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>


 This is the content for the doc docs/1.concepts/basics/staking.md 

 ---
id: staking
title: Validator Staking
sidebar_label: Staking
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

The NEAR blockchain uses a Proof-of-Stake (PoS) consensus mechanism, where participants (validators) secure the network by staking NEAR tokens. Users who don't want to run a validator node can still participate by delegating their tokens to a staking pool.

In this article you'll find a detailed explanation of the staking process, including delegating, viewing balances, and withdrawing using the [NEAR CLI](../../4.tools/cli.md).

:::note Contract source code
You can review the Staking pool smart contract source code in [this GitHub repository](https://github.com/near/core-contracts/tree/master/staking-pool).
:::

## Staking overview

When you stake your NEAR tokens, you help secure the network and participate in the consensus process.
Delegating your tokens means you are entrusting them to a validator, who will stake them on your behalf. You earn rewards based on the performance of the validator.

:::info Staking concepts

- **Staking**: Locking up NEAR tokens to support the network's security and operations.
- **Validators**: Nodes that validate transactions and produce blocks. They must stake a minimum amount of NEAR to participate.
- **Delegators**: Users who delegate their NEAR tokens to validators to earn rewards without running a node themselves.
- **Staking Pool**: A smart contract that aggregates delegated tokens and distributes rewards.

:::


## How delegating works

When you delegate NEAR tokens to a staking pool:
- Your tokens are locked in the pool and used to support a validator.
- You earn staking rewards proportional to your stake.
- The validator takes a commission (a percentage of the rewards) for their services.

:::tip Key Considerations

- **Rewards**: Staking rewards are distributed at the end of each epoch and depend on the total stake in the network and the validator's performance. (note: an epoch is approximately 12 hours)
- **Commission**: Validators charge a commission on rewards, so choose one with a fair rate.
- **Liquidity**: Staked tokens are locked and cannot be transferred until unstaked and withdrawn.
- **Validator Performance**: If a validator underperforms (e.g., goes offline), they may be slashed, reducing your rewards.

:::

## Delegating NEAR tokens

Before delegating, you need to choose a validator (a node that participates in staking). You can find a list of validators on [NearBlocks](https://nearblocks.io/node-explorer) Node explorer or through various blockchain explorers like [Pikespeak](https://pikespeak.ai/validators/overview) and [Near Staking](https://near-staking.com/).

Once you select a validator and the stake transaction is confirmed, your tokens are delegated to the staking pool.
You will start earning staking rewards after the next epoch (approximately 12 hours).

:::info Delegation without a staking pool

For validators, there's also an option to stake NEAR tokens without deploying a staking pool smart contract.
Check [this section](../../4.tools/cli.md#staking) to learn how to stake using the [`near-validator`](../../4.tools/cli.md#validator-extension) CLI.

:::

### Selecting a Staking Pool

Use [NearBlocks](https://nearblocks.io/node-explorer), [Pikespeak](https://pikespeak.ai/validators/overview) or [Near Staking](https://near-staking.com/) to find a validator and their staking pool.
Look for validators with a good track record, uptime, and reasonable commission rates.

:::tip Validator selection tips

- **Validator Selection**: It's wise to research validators based on their performance, fees, and community reputation before making a selection.
- **Regular Monitoring**: Keep an eye on the validator‚Äôs performance; continuously delegating to a poorly performing validator can affect your staking rewards.
- **Fees**: Be aware that validators may charge fees from the rewards earned.

:::

If you prefer, you can get the list of current validators by using the [`near-validator`](../../4.tools/cli.md#validator-extension) CLI:

```sh
near-validator validators network-config mainnet now
```

### Staking using CLI

Once you have chosen a validator you want to delegate your tokens to, follow these steps to stake them using the NEAR CLI:

1. Connect your wallet to the CLI and ensure you have NEAR tokens to delegate.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near account import-account using-web-wallet network-config mainnet
```

  </TabItem>
  <TabItem value="Short">

```sh
near login
```

  </TabItem>
</Tabs>


2. Deposit and stake tokens to the `<my_validator>` staking pool:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> deposit-and-stake '100 NEAR' <my_validator> network-config mainnet sign-with-keychain
```

  </TabItem>
  <TabItem value="Short">
  
Deposit the tokens to the staking pool:

```sh
near call <my_validator> deposit '{}' --accountId <user-account.near> --deposit 100
```

Stake the deposited tokens by calling the `stake` method:

```sh
near call <my_validator> stake '{"amount": "100000000000000000000000000"}' --accountId <user-account.near>
```

  </TabItem>
</Tabs>

:::tip Interactive CLI

If you want to manage your staking actions with an interactive CLI, use this command and follow the prompts on your screen:

```sh
near staking delegation
```

:::

3. Confirm Delegation:

Once the transaction is confirmed, your tokens are delegated to the staking pool.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> view-balance <my_validator> network-config mainnet now
```

  </TabItem>
  <TabItem value="Short">

```sh
near view <my_validator> get_account_staked_balance '{"account_id": "<user-account.near>"}'
```

  </TabItem>
</Tabs>

:::info Using a wallet to check your staked tokens

You can see your staked balance, rewards earned, and the validator you delegated to using a web3 wallet. For example, you can try `https://app.mynearwallet.com/profile/<user-account.near>`.

:::

## Viewing staked balances and rewards

After delegating, you can view your staked tokens and accrued rewards.
The rewards are typically distributed periodically, and you will be able to see how many rewards you have earned based on your validator's performance.

#### User total balance

To check your total balance on the `<my_validator>` pool:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> view-balance <my_validator> network-config mainnet now
```

  </TabItem>
  <TabItem value="Short">

```sh
near view <my_validator> get_account_total_balance '{"account_id": "<user-account.near>"}'
```

  </TabItem>
</Tabs>

#### User staked balance

To check your staked balance on the `<my_validator>` pool:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> view-balance <my_validator> network-config mainnet now
```

  </TabItem>
  <TabItem value="Short">

```sh
near view <my_validator> get_account_staked_balance '{"account_id": "<user-account.near>"}'
```

  </TabItem>
</Tabs>

<details>
<summary>Staking pool balances</summary>

You can view additional information and balances from the staking pool using the following CLI commands:

#### Total staked balance of the entire pool

```sh
near view <my_validator> get_total_staked_balance '{}'
```

#### Owner of the staking pool

```sh
near view <my_validator> get_owner_id '{}'
```

#### Current reward fee

```sh
near view <my_validator> get_reward_fee_fraction '{}'
```

#### Owner's balance

```sh
near view <my_validator> get_account_total_balance '{"account_id": "owner"}'
```

#### Staking key

```sh
near view <my_validator> get_staking_key '{}'
```

</details>

## Withdrawing staked tokens

To withdraw your staked tokens, first you need to "un-delegate" them from your validator. Your tokens will enter a 4 epoch (approximately 48 hours) unbonding period before they can be withdrawn.
Once they're unlocked, you can execute the withdrawal, and once the transaction is processed, your funds will be available in your account.

### Unstaking using CLI

To un-delegate the tokens:

1. First execute the `unstake` method on the `<my_validator>` contract:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> unstake '1 NEAR' <my_validator> network-config mainnet sign-with-keychain
```

:::info

If you want to unstake all tokens, you can use the `unstake-all` command:

```sh
near staking delegation <user-account.near> unstake-all <my_validator> network-config mainnet sign-with-keychain
```

:::

  </TabItem>
  <TabItem value="Short">

```sh
near call <my_validator> unstake '{"amount": "100000000000000000000000000"}' --accountId <user-account.near>
```

  </TabItem>
</Tabs>

2. Check the unstaked balance for your `<user-account.near>` account:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> view-balance <my_validator> network-config mainnet now
```

  </TabItem>
  <TabItem value="Short">

```sh
near view <my_validator> get_account_unstaked_balance '{"account_id": "<user-account.near>"}'
```

  </TabItem>
</Tabs>

3. After 4 epochs, check if you can withdraw:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near contract call-function as-read-only <my_validator> is_account_unstaked_balance_available json-args '{"account_id": "<user-account.near>"}' network-config mainnet now
```

  </TabItem>
  <TabItem value="Short">

```sh
near view <my_validator> is_account_unstaked_balance_available '{"account_id": "<user-account.near>"}'
```

  </TabItem>
</Tabs>

If the Validator's response is `true`, then your tokens are ready for the last step.

4. Finally, withdraw the unstaked tokens:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near staking delegation <user-account.near> withdraw '1 NEAR' <my_validator> network-config mainnet sign-with-keychain
```

:::info

If you want to withdraw all available tokens, you can use the `withdraw-all` command:

```sh
near staking delegation <user-account.near> withdraw-all <my_validator> network-config mainnet sign-with-keychain
```

:::

  </TabItem>
  <TabItem value="Short">

```sh
near call <my_validator> withdraw '{"amount": "100000000000000000000000000"}' --accountId <user-account.near>
```

  </TabItem>
</Tabs>

---

## Tools and Resources

- Supported wallets for staking and managing your tokens:
  - [Ecosystem Wallets](https://wallet.near.org/)
- To explore validators and staking pools:
  - [NearBlocks](https://nearblocks.io/)
  - [Pikespeak](https://pikespeak.ai/)
  - [NEAR Staking](https://near-staking.com/)


 This is the content for the doc docs/1.concepts/basics/token-loss.md 

 ---
id: token-loss
title: Avoiding Token Loss
sidebar_label: Avoiding Token Loss
---

:::warning
Careful! Losing tokens means losing money!
:::


Token loss is possible under multiple scenarios. These scenarios can be grouped into a few related classes:

1. Improper key management
2. Refunding deleted accounts
3. Failed function calls in batches

---

## Improper key management

Improper key management may lead to token loss. Mitigating such scenarios may be done by issuing backup keys
allowing for recovery of accounts whose keys have been lost or deleted.

### Loss of `FullAccess` key

A user may lose their private key of a `FullAccess` key pair for an account with no other keys.
No one will be able to recover the funds. Funds will remain locked in the account forever.

### Loss of `FunctionCall` access key

An account may have its one and only `FunctionCall` access key deleted.
No one will be able to recover the funds. Funds will remain locked in the account forever.

---
## Refunding deleted accounts

When a refund receipt is issued for an account, if that account no longer exists, the funds will be dispersed among
validators proportional to their stake in the current epoch.

### Deleting account with non-existent beneficiary

When you delete an account, you must assign a beneficiary.
Once deleted, a transfer receipt is generated and sent to the beneficiary account.
If the beneficiary account does not exist, a refund receipt will be generated and sent back to the original account.
Since the original account has already been deleted, the funds will be dispersed among validators.

### Account with zero balance is garbage-collected, just before it receives refund

If an account `A` transfers all of its funds to another account `B` and account `B` does not exist,
a refund receipt will be generated for account `A`. During the period of this round trip,
account `A` is vulnerable to deletion by garbage collection activities on the network.
If account `A` is deleted before the refund receipt arrives, the funds will be dispersed among validators.

---
## Failed function calls in batches

:::warning
When designing a smart contract, you should always consider the asynchronous nature of NEAR Protocol.
:::

If a contract function `f1` calls two (or more) other functions `f2` and `f3`, and at least one of these functions, `f2` and `f3` fails, then tokens will be refunded from the function that failed, but tokens will be appropriately credited to the function(s) which succeed.

The successful call's tokens may be considered lost depending on your use case if a single failure in the batch means the whole batch failed.



 This is the content for the doc docs/1.concepts/basics/token.md 

 ---
id: tokens
title: Tokens
---

# NEAR Token
This is the native token used in NEAR Protocol.
It has multiple use cases:
- Secures the network through staking
- Provides a unit of account - NEAR is used for processing transactions and storing data
- Serves as a medium of exchange

### Securing the Network
NEAR Protocol is a proof-of-stake (PoS) network, which means that resistance from various attacks comes from staking NEAR.
Staked NEAR represents the decentralized infrastructure of servers that maintain the network and process transactions for applications and users on NEAR.
Rewards for providing this service are received in NEAR.

## Providing a Unit of Account
NEAR is used to price computation and storage on the NEAR infrastructure.
The network charges transaction fees in NEAR to process changes and transactions.

## Medium of Exchange
NEAR is readily available on the protocol level, so it can be used to transfer value between NEAR applications and accounts.
This means that applications can use NEAR to charge for various functions, like access to data or other complex transactions.
Entities can also easily exchange NEAR between each other, without the need for trusted third parties to clear and settle transactions.


For a deeper dive on NEAR Economics: [https://near.org/blog/near-protocol-economics](https://near.org/blog/near-protocol-economics)

For more information about the NEAR token, visit [NEAR Token Supply and Distribution](https://near.org/blog/near-token-supply-and-distribution/) or [Nomicon](https://nomicon.io).


 This is the content for the doc docs/1.concepts/basics/validators.md 

 ---
id: validators
title: Validators
---

The NEAR network is decentralized, meaning that multiple people collaborate in order to keep it safe. We call such people **validators**.

In order to make sure that all the transactions in the network are valid, i.e. that nobody is trying to steal money, the validators follow a specific consensus
mechanism.

Currently, there are a few well-known consensus mechanisms to keep a blockchain working correctly and resistant to attacks.
NEAR Protocol uses a version of **Proof-of-Stake**, particularly [Thresholded Proof of Stake](https://near.org/blog/thresholded-proof-of-stake/).

In Proof-of-Stake, users show support to specific network validators by delegating NEAR tokens to them. This process is known as **staking**. The main idea is that, if a validator has a large amount of tokens delegated is because the community trusts them.

### Securing the Network
Validators have two main jobs. The first is to validate and execute transactions, aggregating them in the blocks that form the blockchain. Their second job is to oversee other validators, making sure no one produces an invalid block or creates an alternative chain (eg. with the goal of creating a double spend).

If a validator is caught misbehaving, then they get "slashed", meaning that their stake (or part of it) is burned.

In the NEAR networks, an attempt to manipulate the chain would mean taking control over the majority of the validators at once, so that the malicious activity won't be flagged. However, this would require putting a huge sum of capital at risk, since an unsuccessful attack would mean slashing your staked tokens.

### Validator's Economy
In exchange for servicing the network, validators are rewarded with a target number of NEAR every epoch. The target value is computed in such a way that, on an annualized basis, it will be 4.5% of the total supply.

All transaction fees (minus the part which is allocated as the rebate for contracts) which are collected within each epoch are burned by the system. The inflationary reward is paid out to validators at the same rate regardless of the number of fees collected or burned.


## Intro to Validators

[Validators](https://pages.near.org/papers/the-official-near-white-paper/#economics) are responsible for producing and validating blocks and chunks, ensuring the security and integrity of the NEAR network.

The hardware requirements for running a validator node vary depending on the staking position. Detailed specifications can be found here: [the hardware requirements](https://near-nodes.io/validator/hardware-validator).

You can view the list of currently active validators on platforms like [NEAR-STAKING](https://near-staking.com/stats). To become a validator, the minimum stake required is determined by the 300th largest staking proposal. If there are more than 300 proposals, the threshold will be set by the stake amount of the 300th proposal, as long as it exceeds the minimum threshold of 25,500 $NEAR. The current seat price to join the active validator set is updated in real-time on [NEAR BLOCKS](https://nearblocks.io/node-explorer). Any validator node with a stake greater than the current seat price can join the set of active validators.

<blockquote className="lesson">
<strong>Is there a plan to support GPU compute if certain validator nodes can offer that or is it just CPU?</strong><br /><br />

We don't need GPU support as we are a POS chain and we require very little compute power.

You can read more about our consensus strategy on our <a href="https://github.com/near/wiki/blob/master/Archive/validators/about.md" target="_blank" rel="noopener noreferrer">Validator Quickstart</a> and <a href="https://github.com/near/wiki/blob/master/Archive/validators/faq.md" target="_blank" rel="noopener noreferrer">Staking FAQ</a>.
</blockquote>

## Block & Chunk producers
The top 100 validators are responsible for producing and validating blocks, as well as producing chunks. Under normal circumstances, each validator is assigned to a single shard, for which it produces chunks.

Block & Chunk producers are guaranteed a minimum annual reward of 4.5%. If less than 100% of the network‚Äôs tokens are staked, validators have the potential to earn even higher annual rewards.

## Chunk Validators

[Note] Block & Chunk producers also serve as chunk validators.

Non-top 100 validators take on the role of chunk validators, which has lower hardware and staking requirements, making it more accessible. This role helps expand the network's validator set, increasing opportunities to earn rewards and strengthen the security of the NEAR ecosystem.

Chunk validators do not track shards. Their responsibilities are focused solely on validating and endorsing chunks.

Like block and chunk producers, chunk validators are guaranteed a minimum of 4.5% annual rewards. If less than 100% of the network‚Äôs tokens are staked, chunk validators may earn even higher rewards. For more details on validator economics, check out [NEAR‚Äôs Economics Explained](https://near.org/blog/near-protocol-economics/).

## Dedicated Validator Documentation Site

If you'd like to further explore Validators and Nodes in general, you can visit the [Dedicated Validator Documentation Site](https://near-nodes.io/).

<blockquote className="lesson">
<strong>If a developer writes a vulnerable or malicious dApp, is a validator implicitly taking on risk?</strong><br /><br />

No. We have handled the potential damages to the network on the protocol level. For example, we have a lot of limiters that constrain how much data you can pass into a function call or how much compute you can do in one function call, etc.

That said, smart contract developers will need to be responsible for their own dApps, as there is no stage gate or approval process. All vulnerabilities can only damage the smart contract itself. Luckily, updating smart contracts is very smooth on NEAR, so vulnerabilities can be updated/patched to an account in ways that cannot be done on other blockchains.
</blockquote>


 This is the content for the doc docs/1.concepts/data-flow/near-data-flow.md 

 ---
sidebar_label: "NEAR Data Flow"
---

# NEAR Data Flow


<iframe
 width="100%"
 height="500"
 src="https://www.youtube.com/embed/VSBJ-A69Km4"
 title="YouTube video player"
 frameborder="0"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
 allowfullscreen>
</iframe>


:::info Data flow

In this video we give a quick overview on the main concept of how the data flows across the NEAR Protocol blockchain.

:::

NEAR Protocol blockchain data flow might be a bit tricky at a glance. But it is pretty straightforward and follows well-defined rules. In this article, we are going to have a closer look at how the data flows in NEAR Protocol blockchain.

In fact, any blockchain flow can be represented as an infinite timeline that has a start but has no end.


![Blocks Timeline](/docs/flow/01-timeline.png)


And a block appears on that timeline with some interval. Each of these blocks holds the information about the previous one, thus, creating a *chain of blocks*.


NEAR Protocol has a sharded nature, meaning that more than one parallel network, called a [Shard](../../2.build/6.data-infrastructure/lake-data-structures/shard.mdx), can be live at any moment. And each Shard produces a chunk of a block at a given interval. A Block in NEAR Blockchain is a collection of the block chunks from all shards. Block chunk is shortened to [Chunk](../../2.build/6.data-infrastructure/lake-data-structures/chunk.mdx) in NEAR Protocol documentation.

Returning to the data flow itself. The best we can do is to imagine tracks like we could see in audio/video editing apps. Each Shard has its own set of tracks. The top track is for Chunks. They appear no matter what at a given interval, for NEAR Blockchain the interval is about one second. Chunks are being produced even if nothing is happening on the blockchain.

![Timeline as tracks](/docs/flow/02-tracks.png)

But what do we mean by saying something is happening? We mean that something has triggered some changes in the blockchain. And the most well-known method to trigger any changes is to send a [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) to the blockchain with instructions of what we want to change and who has requested those changes.

A transaction needs to be constructed, signed and sent to the blockchain. Once it is executed we expect to have a result - [ExecutionOutcome](../../2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx). Oh, that is simple. But it‚Äôs not really accurate for NEAR Blockchain.

![Transaction execution](/docs/flow/03-tx-outcome-receipt.png)

In the beginning there is a [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx), it contains instructions we want to be executed on the blockchain. Transaction is sent to NEAR Blockchain.

And yes, it is executed there immediately BUT the immediate result of the transaction execution is always just *an acknowledgment that it will be executed on the chain;* this internal execution request is known as [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx). You can think of the [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx) as an internal transaction that exists to pass information across shards.

Let‚Äôs get back to the tracks to look at the example.

Assuming we have two accounts living on different [Shards](../../2.build/6.data-infrastructure/lake-data-structures/shard.mdx) **alice.near** and **bob.near**. **alice.near** creates a [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) to send a few tokens to **bob.near**. The [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) is immediately executed and the [ExecutionOutcome](../../2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx) for the [Transaction](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) is always a [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx).

But this [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx) cannot be executed here, because **bob.near** doesn‚Äôt live on the same Shard as **alice.near**, so **the Receipt must be executed on the receiver‚Äôs Shard**. So the Receipt is moving to the Shard where **bob.near** belongs to.

On the destination Shard the Receipt is executed and the process is considered as done.

:::info The explanation here is simplified

Please refer to the [Token transfer](token-transfer-flow.md) flow article

:::

So the final scheme will look like:

![Complete scheme of sending tokens from an account from one Shard to an account on another](/docs/flow/04-send-nears-flow.png)

## Summary

We have learnt the main principles of how data is flowing in NEAR Protocol. We have found out that [Transactions](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx) execute and the [ExecutionOutcome](../../2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx) of the Transaction is always a [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx).

Now we know that [Receipt](../../2.build/6.data-infrastructure/lake-data-structures/receipt.mdx) is a main internal asset for NEAR Protocol blockchain and it has a power of traveling between [Shards](../../2.build/6.data-infrastructure/lake-data-structures/shard.mdx). We learnt the NEAR Data flow on a simple example. Of course in real life with more complex transactions that involve cross-contract calls, there will be more Receipts and ExecutionOutcomes.

We hope this article is useful and you will be able to build your dApps and indexers easily with the knowledge of how data if flowing in NEAR Protocol.


 This is the content for the doc docs/1.concepts/data-flow/token-transfer-flow.md 

 ---
sidebar_label: Token Transfer
---

# Token Transfer flow

In the [previous article](near-data-flow.md) we saw an example of token transfer between accounts found in different shards. That example was simplified and missed a few steps in the process. That was intentional, to keep the article and the video short yet explanatory, in order to give you a bigger picture for understanding concepts.

In this article we're going to have a look at the same data flow, but in detail and we will consider two additional scenarios:

- Token transfer between accounts found in different shards
- Token transfer between accounts found in the same shard

You may be asking what was missing in the previous explanation. The short answer is: **Gas Refunds** or simply **Refunds**.

If you don't know what **Gas** is, please [first read the article about Gas](https://docs.near.org/concepts/protocol/gas) from our docs.

As for *Refunds*, here's a quote from the [Gas](https://docs.near.org/concepts/protocol/gas) article:

> Attach extra gas; get refunded!
>
> ...
>
> - If you attach more gas than needed, you'll get refunded
>
> ...
>
> *From NEAR Protocol docs [Gas. Attach extra gas; get refunded!](https://docs.near.org/concepts/protocol/gas#attach-extra-gas-get-refunded)*


:::note What refunds mean in terms of data flow

It means that literally every Transaction includes a refund.

:::

OK, this should be enough for introduction, now let's move on to examples.


## Token transfer between accounts found in different shards

Basically it is an extension of the example from the [NEAR Data Flow](near-data-flow.md) article.

Assume we have two accounts **alice.near** and **bob.near**. They belong to different [Shards](/build/data-infrastructure/lake-data-structures/shard). **alice.near** sends a few tokens to **bob.near**.

A [Transaction](/build/data-infrastructure/lake-data-structures/transaction) signed by **alice.near** is sent to the network. It is immediately executed, [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) is the output or result from converting the transaction into a [Receipt](/build/data-infrastructure/lake-data-structures/receipt).

![Transaction execution](/docs/flow/03-tx-outcome-receipt.png)

During the above process **alice.near**, the sender, was charged a fee (gas). The [Receipt](/build/data-infrastructure/lake-data-structures/receipt) created as result of the [Transaction](/build/data-infrastructure/lake-data-structures/transaction) follows these rules:

1. It will be executed not earlier than next [Block](/build/data-infrastructure/lake-data-structures/block)
2. It **must** be executed on the receiver's [Shard](/build/data-infrastructure/lake-data-structures/shard)

So, in our case the receiver is **bob.near** and that account belongs to a different [Shard](/build/data-infrastructure/lake-data-structures/shard) that's why the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) moves to the receiver's Shard and is put in the execution queue.

In our example the Receipt is executed in the very next Block.

![The Receipt is executed in the next Block](/docs/flow/04-send-nears-flow.png)

Almost done. Remember the refund? So the [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) for the Receipt will be another Receipt that is refunding the Gas to the sender. **bob.near** has received tokens from **alice.near**. Now, **alice.near** becomes the receiver for a new (and last) Receipt (keep in mind the sender in this Receipt is always **system**).

Keep in mind rule #2: the Receipt must be executed on the receiver's Shard. So this Receipt moves to the Shard where **alice.near** belongs to. And it is the last execution in this process.

![Complete scheme of Token transfer between the accounts from different Shards](/docs/flow-token-transfer/01-diff-shards-complete.png)

This is it. Tokens have been transferred from the account on one Shard to the account on a different Shard, and the initial sender, **alice.near**, received a refund of Gas.


## Token transfer between accounts found on the same shard

Let's have a look at the example where both accounts are on the same [Shard](/build/data-infrastructure/lake-data-structures/shard). The process is the same as in the previous example, except there are no Receipts moving from one Shard to another.

A [Transaction](/build/data-infrastructure/lake-data-structures/transaction) signed by **alice.near** is sent to the network. It is immediately executed, [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) is the result of converting the transaction into a [Receipt](/build/data-infrastructure/lake-data-structures/receipt).

![Transaction execution](/docs/flow/03-tx-outcome-receipt.png)

The Receipt is already on the receiver's Shard, so it is put in the execution queue of the next [Block](/build/data-infrastructure/lake-data-structures/block). It is executed in the next Block, and the [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome) result is a new Receipt with the refund to the initial sender, **alice.near**. 
The Same rules apply to this Receipt, it is put into the execution queue and executed in the next Block.

![Complete scheme of Token transfer between the account from the same Shards](/docs/flow-token-transfer/02-same-shard-complete.png)

This is it. You may wonder why the process is overcomplicated for the same Shard case. The answer is: **the same rules are always applied**. Also, this mechanism allows to build the NEAR Protocol data flow by only one set of rules, no matter how many Shards exist. Also, we avoid a lot of "ifs" and we don't have to keep in mind different corner cases because the process always follows the same rules.



 This is the content for the doc docs/1.concepts/protocol/access-keys.md 

 ---
id: access-keys
title: Access Keys
---

In most blockchains, users control their accounts by holding a single [`private key`](https://en.wikipedia.org/wiki/Public-key_cryptography) (a secret only they know) and using it to sign [transactions](./transactions.md).

![img](@site/static/docs/assets/welcome-pages/access-keys.png)

In NEAR we distinguish two types of Access Keys:

1. `Full-Access Keys`: Have full control over the account, and should **never be shared**
2. `Function-Call Keys`: Can only sign calls for specific contracts, and are **meant to be shared**

Every account in NEAR can hold **multiple keys**, and keys can be added or removed, allowing a
fine-grained control over the account's permissions.

---

## Full-Access Keys {#full-access-keys}
As the name suggests, `Full-Access` keys have full control of an account, meaning they can be used to sign [transactions](transactions.md) doing any action in your account's behalf:

1. Transfer NEAR ‚ìÉ
2. Delete your account or create sub-accounts of it
3. Add or remove Access Keys
4. Deploy a smart contract in the account
5. Call methods on any contract

You should never share your `Full-Access`, otherwise you are giving **total control over the account**.

:::tip
[Implicit accounts](./account-id.md#implicit-address) already have a `Full-Access Key` by default, while for [`named accounts`](./account-id.md#named-address) their first `Full-Access Key` is added on creation
:::

---

## Function-Call Keys {#function-call-keys}

`Function-Call` keys can only sign transactions calling a **specific contract**, and do **not allow** to **attach NEAR tokens** to the call.

They are defined by three attributes:
1. `receiver_id`: The **only contract** which the key allows to call, no other contract can be called with this key
2. `method_names` (Optional): The contract's **methods** the key allows to call. If omitted, all contract's methods can be called
3. `allowance` (Optional): The **amount of NEAR** allowed to be spent on [gas](gas.md). If omitted, the key can consume **unlimited** gas

`Function Call Keys` are meant to be shared with applications, so third-parties can make contract calls in your name. This is useful in [multiple scenarios as we will see below](#benefits-of-function-call-keys).

:::tip 
`Function-Call` keys are secure to share, as they only permit calls to a specific contract and prohibit NEAR token transfers
:::

---

## Benefits of Function-Call Keys

`Function Call Keys` allows you to provide **restricted access** to third parties. This key type, unique to NEAR, enables several use-cases worth discussing.

### Enhancing User Experience
The most common use case for `Function-Call` keys is to allow an application to sign transactions on the user's behalf.

Imagine you are developing a game that records the user's score on a smart contract. On other chains, you would have to disrupt the user's experience to request transaction signatures each time the game needs to update the score.

With NEAR, you can request the user to generate a `Function-Call` key for the game's contract and share it with the game. This way, the game can sign transactions in the user's name, eliminating gameplay interruptions.

Sharing this key is safe for the user, because even in the case of somebody stealing it, they would only be able to call the score-keeping method, and nothing else.

<hr class="subsection" />

### Simple Onboarding

Another common use-case of `Function-Call` keys is to simplify the **onboarding** process for new users.

It works as follows:

1. Create a contract that has a method called `create_account`
    - This method should only be callable by the contract itself and
    - When executed, the method should create a new account and transfer some tokens to it

2. Add multiple `Function Call Keys` in the contract's account, that **only allow to call `create_account`**

3. Give these keys to your friends! They will be able to call the method, and easily create an account with some tokens

Your main account and your funds will never be at risk, as the keys can only be used to call the `create_account` method.

:::tip
This is the basic principle behind [NEAR Drops](../../2.build/5.primitives/linkdrop.md), a way to distribute assets to a large number of users
:::

<hr class="subsection" />

### Key Rotation and Recovery

The presence of multiple keys allows for easy **rotation** and **recovery**. If you suspect a key might be compromised, you can promptly remove it or replace it with a new one, similar to changing your password on a website.

You can also establish a key-recovery contract in your account and generate a "recovery key" for a trusted party. This key would only be used to initiate the recovery process.

In case of necessity, the trusted party can trigger the recovery process, assisting in the creation of a new full-access key for you.

---

## Locked Accounts
If you remove all keys from an account, then the account will become **locked**, meaning that no external actor can perform transactions in the
account's name.

In practice, this means that only the account's smart contract can transfer assets, create sub-accounts, or update its code.

Locking an account is very useful when one wants to deploy a contract, and let the community be assured that only the contract is in control of the account.

:::warning
An account could still add keys to itself through a smart contract, effectively allowing the contract to unlock the account. Notice that this can only be done if the contract is deployed before the account is locked
:::


 This is the content for the doc docs/1.concepts/protocol/account-id.md 

 ---
id: account-id
title: Address (Account ID)
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

NEAR accounts are identified by a unique address, which takes one of two forms:
1. [**Implicit address**](#implicit-address), which are 64 characters long (e.g. `fb9243ce...`)
2. [**Named address**](#named-address), which act as domains (e.g. `alice.near`)

:::tip Searching to create an account?
You have multiple ways to create an account, you can [sign-up using your email](https://dev.near.org/signup), get a mobile wallet through [telegram](https://web.telegram.org/k/#@herewalletbot), or create a [web wallet](https://wallet.meteorwallet.app/wallet).
:::

---

## Implicit Address
Implicit accounts are denoted by a 64 character address, which corresponds to a unique public/private key-pair. Who controls the [private key](./access-keys.md) of the implicit account controls the account.

For example:
- The private key: `ed25519:4x1xiJ6u3sZF3NgrwPUCnHqup2o...`
- Corresponds to the public key: `ed25519:CQLP1o1F3Jbdttek3GoRJYhzfT...`
- And controls the account: `a96ad3cb539b653e4b869bd7cf26590690e8971...`

Implicit accounts always *exist*, and thus do not need to be created. However, in order to use the account you will still need to fund it with NEAR tokens (or get a relayer to pay your transaction's [gas](./gas.md)).

:::tip

In NEAR, you can delete the private key of an implicit account, which effectively locks the account and prevents anyone to control it

:::

<details>

<summary> üßë‚Äçüíª Technical: How to obtain a key-pair  </summary>

The simplest way to obtain a public / private key that represents an account is using the [NEAR CLI](../../4.tools/cli.md)

```bash
near account create-account fund-later use-auto-generation save-to-folder ~/.near-credentials/implicit

# The file "~/.near-credentials/implicit/8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8.json" was saved successfully

# Here is your console command if you need to script it or re-run:
#     near account create-account fund-later use-auto-generation save-to-folder ~/.near-credentials/implicit
```

</details>

---

## Named Address
Users can register **named accounts** (e.g. `bob.near`) which are easy to remember and share.

An awesome feature of named accounts is that they can create **sub-accounts** of themselves, effectively working as domains:

1. The [`registrar`](https://nearblocks.io/address/registrar) account can create top-level accounts (e.g. `near`, `sweat`, `kaiching`).
2. The `near` account can create sub-accounts such as `bob.near` or `alice.near`
3. `bob.near` can create sub-accounts of itself, such as `app.bob.near`
4. Accounts cannot create sub-accounts of other accounts
    - `near` **cannot** create `app.bob.near`
    - `account.near` **cannot** create `sub.another-account.near`
5. Accounts have **no control** over their sub-account, they are different entities

Anyone can create a `.near` or `.testnet` account, you just to call the `create_account` method of the corresponding top-level account - `testnet` on testnet, and `near` on mainnet.

<details>

<summary> üßë‚Äçüíª Technical: How to create a named account  </summary>

Named accounts are created by calling the `create_account` method of the network's top-level account - `testnet` on testnet, and `near` on mainnet. 

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call testnet create_account '{"new_account_id": "new-acc.testnet", "new_public_key": "ed25519:<data>"}' --deposit 0.00182 --accountId funding-account.testnet --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction testnet create_account json-args '{"new_account_id": "new-acc.testnet", "new_public_key": "ed25519:<data>"}' prepaid-gas '100.0 Tgas' attached-deposit '0.00182 NEAR' sign-as funding-account.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

We abstract this process in the [NEAR CLI](../../4.tools/cli.md) with the following command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near create-account new-acc.testnet --useAccount funding-account.testnet --publicKey ed25519:<data>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near account create-account fund-myself new-acc.testnet '1 NEAR' use-manually-provided-public-key ed25519:<data> sign-as funding-account.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

You can use the same command to create sub-accounts of an existing named account:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near create-account sub-acc.new-acc.testnet --useAccount new-acc.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near account create-account fund-myself sub-acc.new-acc.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as new-acc.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

</details>

:::tip
Accounts have **no control** over their sub-accounts, they are different entities. This means that `near` cannot control `bob.near`, and `bob.near` cannot control `sub.bob.near`.
:::


 This is the content for the doc docs/1.concepts/protocol/account-model.md 

 ---
id: account-model
title: NEAR Accounts
sidebar_label: Overview
---

Users participate in the NEAR ecosystem through their NEAR accounts. These accounts are identified by a [unique address](./account-id.md), can optionally hold a [smart contract](../../2.build/2.smart-contracts/what-is.md), and are controlled through [Access Keys](./access-keys.md).

By signing [transactions](./transactions.md) with their account, users can:

1. Send and receive **digital assets** (such as tokens or collectibles)
2. Create and interact with on-chain applications known as **smart contracts**
3. Control accounts in **other chains** (such as Ethereum or Bitcoin) ‚ú®
4. Help onboard new users by **covering the costs** of their transactions (gas fees)

:::tip Want to create an account?
You have multiple ways to create an account, you can [sign-up using your email](https://dev.near.org/signup), get a mobile wallet through [telegram](https://web.telegram.org/k/#@herewalletbot), or create a [web wallet](https://wallet.meteorwallet.app)
:::

---

## Account Model Overview 

Let's take a closer look at the different elements that compose the NEAR account model.

![img](@site/static/docs/assets/welcome-pages/accounts.png)


#### [Account ID](account-id.md)
NEAR **natively** implements two types of accounts:
1. **Named accounts** such as `alice.near`, which are simple to remember and share
2. **Implicit accounts** such as `0xfb9243ce...`, which are derived from a private key

#### [Permissions Through Access Keys](access-keys.md)
NEAR accounts can have multiple [keys](access-keys.md), each with their own set of permissions:
- You can easily swap keys if one gets compromised
- You can use keys as authorization tokens for third-party applications

#### [Simple to Develop Smart Contracts](../../2.build/2.smart-contracts/what-is.md)
NEAR accounts can optionally hold an application - known as a [smart contract](../../2.build/2.smart-contracts/what-is.md) - which can be written in Javascript or Rust.

---

## Comparison With Ethereum {#compared-to-ethereum}

If you're familiar with development on Ethereum, it's worth making a quick note about how accounts are different. The table below summarizes some key differences:

|                 | Ethereum Account         | NEAR Account                                                                           |
|-----------------|--------------------------|----------------------------------------------------------------------------------------|
| Account ID      | Public Key (`0x123...`)  | - Native named accounts (`alice.near`) <br />- Implicit accounts (`0x123...`)          |
| Secret Key      | Private Key (`0x456...`) | Multiple key-pairs with permissions:<br />- `FullAccess` key<br />- `FunctionCall` key |
| Smart Contracts | Synchronous execution    | Asynchronous execution                                                                 |
| Gas Fees        | In the order of dollars  | In the order of tenths of a cent                                                       |
| Block Time      | ~12 seconds              | ~1.3 second                                                                            |


 This is the content for the doc docs/1.concepts/protocol/gas.md 

 ---
id: gas
title: Gas (Execution Fees)
---

import {NearWidget} from "@site/src/components/near-widget"

On every transaction the NEAR network charges a tiny fee known as **gas**. This fee is a simple mechanism that allows us to:

1. **Prevent** bad actors from **spamming** the network with useless transactions
2. **Burn** a minuscule fraction of the **token supply** on each transaction
3. **Incentivize developers** by giving contracts 30% of the gas they burn while executing
4. Implement a **wall time** by capping transactions to `300Tgas` (~`300ms` of compute time)

Gas in NEAR is computed on [**gas units**](/concepts/protocol/gas#gas-units) and charged using $NEAR tokens based on the network's [**gas price**](/concepts/protocol/gas#gas-price).

:::tip Did you know?
In NEAR, attaching extra gas to a transaction does **not** make it faster. Actions cost a fixed amount of gas, and any extra gas attached is simply sent back to the user
:::

---

## Understanding Gas Fees
For every transaction, users get charged a small $NEAR fee which has to be paid **upfront**. This fee is calculated using deterministic **gas units**, and transformed into a cost in $NEAR using the network's **gas price**.

<hr class="subsection" />

### Gas Units
Every action in NEAR costs a fixed amount of **gas units**, meaning that the same operation will always cost the **same amount of gas units**.

Gas units were engineered in such a way that they can be translated into compute resources, where `1Tgas` gets you approx. `1ms` of compute time.

Transactions can use a maximum of `300Tgas`, meaning they should be processed in less than `300ms`, allowing the network to produce a new block approximately **every second**.

:::tip
Gas units encapsulate not only compute/CPU time but also bandwidth/network time and storage/IO time
:::

<hr class="subsection" />

### Gas Price
To determine the actual $NEAR fee, the cost of all actions in the transaction is multiplied by a **gas price**.

The gas price is **recalculated each block** based on the network's demand and floor at `1Tgas = 0.0001‚ìÉ`.

If the previous block is **more than half full** the price goes up by 1%, otherwise it goes down by 1% (until it reaches the floor).

<details>

<summary> What is the gas price now? </summary>

You can query how much a gas unit costs in `yoctoNEAR` (1‚ìÉ = `1e24` yocto) through the [`RPC`](/api/rpc/gas#gas-price). To convert in `Tgas` per `NEAR` simply divide by `1e12`.


<NearWidget height="40px">

```js
const query = fetch('https://rpc.near.org', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({
    jsonrpc: '2.0',
    id: 'dontcare',
    method: 'gas_price',
    params: [null]
  })
})

const yocto = query.body.result.gas_price
return `Right now, 1 Tgas costs ${Number(yocto) / 1e12}‚ìÉ`
```

</NearWidget>

</details>

<hr class="subsection" />

### Cost for Common Actions

Knowing that actions have a fixed cost in gas units, we can calculate the cost of common operations at the minimum gas price of `1Tgas = 0.0001‚ìÉ`.

| Action                       | TGas           | Fee (‚ìÉ)  |
|------------------------------|----------------|----------|
| Create Account               | 0.42           | 0.000042 |
| Transfer NEAR                | 0.45           | 0.000045 |
| Add Full Access Key          | 0.42           | 0.000042 |
| Delete Key                   | 0.41           | 0.000041 |
| Function Call*               | ‚â§ 300          | ‚â§ 0.03   |
| Deploying a `16`kb contract  | 2.65           | 0.000265 |
| Deploying a `X`kb contract** | 0.58 + 0.13`X` |          |


_Note that the fee is in $NEAR, to obtain the cost in dollars multiply by the current price of $NEAR_

:::tip Function Calls*
The cost of calling a function will depend on how complex the function is, but will be consistent across function calls. Learn more below.
:::

:::tip Deploying a Contract**
Note that this covers the gas cost of uploading and writing bytes to storage, but does **not** cover the cost of holding them in storage (which is `1‚ìÉ ~ 100kb`).
:::

<details className="info">
<summary>Where do these numbers come from?</summary>

NEAR is [configured](https://github.com/near/nearcore/blob/master/core/primitives/res/runtime_configs/parameters.yaml) with base costs. An example:

```json
  transfer_cost: {
    send_sir:     115123062500,
    send_not_sir: 115123062500,
    execution:    115123062500
  },
  deploy_contract_cost: 184765750000,
  deploy_contract_cost_per_byte: 64572944
```

The "sir" here stands for "sender is receiver". Yes, these are all identical, but that could change in the future.

When you make a request to transfer funds, NEAR immediately deducts the appropriate `send` amount from your account. Then it creates a [_receipt_, an internal book-keeping mechanism](./transaction-execution.md). Creating a receipt has its own associated costs:

```json
  action_receipt_creation_config: {
    send_sir:     108059500000,
    send_not_sir: 108059500000,
    execution:    108059500000
  }
```

You can query this value by using the [`protocol_config`](/api/rpc/protocol#protocol-config) RPC endpoint and search for `action_receipt_creation_config`.

The appropriate amount for creating this receipt is also immediately deducted from your account.

The "transfer" action won't be finalized until the next block. At this point, the `execution` amount for each of these actions will be deducted from your account (something subtle: the gas units on this next block could be multiplied by a gas price that's up to 1% different, since gas price is recalculated on each block). Adding it all up to find the total transaction fee:

```
    (transfer_cost.send_not_sir  + action_receipt_creation_config.send_not_sir ) * gas_price_at_block_1 +
    (transfer_cost.execution + action_receipt_creation_config.execution) * gas_price_at_block_2
```

</details>

---

## How Do I Buy Gas?

You don't buy gas, instead, the gas fee is automatically removed from your account's balance when the transaction [is first processed](./transaction-execution.md#block-1-the-transaction-arrives) based on the action's gas cost and the network's gas price.

The only exception to this rule is when you make a function call to a contract. In this case, you need to define how many gas units to use, up to a maximum value of `300Tgas`. This amount will be converted to $NEAR using the network's gas price and deducted from your account's balance.

Since many transactions will take more [than 1 block to execute](./transaction-execution.md), and the gas price is recalculated on each block and could go up, you will be charged a pessimistic estimate of $NEAR (see details below).

If the transaction ends up using less gas than the amount deducted, the difference will simply be **refunded to your account**.

<details>

<summary> Pessimistic Estimate </summary>

While actions have a fixed cost in gas units, the gas price might change block to block. Since transactions can take more than 1 block to execute, the gas price might go up during the transaction's execution.

To avoid the need to recalculate the gas price for each block, the network will charge you upfront a pessimistic estimate of the gas fee.

Let's take as an example [this transaction calling a contract method](https://testnet.nearblocks.io/txns/JD8Bg4u8kaYeaSsGBqkvhSDCEPgXhtwJRBBPKicCEPMs). The transaction was submitted with 10Tgas attached.

- 10Tgas would cost 0.001‚ìÉ at the price when the transaction was submitted
- The transaction used:
  - 2.4Tgas to convert the [transaction into a receipt](./transaction-execution.md#block-1-the-transaction-arrives): 0.00024‚ìÉ
  - 3.2Tgas to execute the function in the contract: 0.00032‚ìÉ
  - Total: 5.6Tgas or 0.00056‚ìÉ
- In the end, the user was returned  0.00104‚ìÉ

Since the system returned `0.00104‚ìÉ`, and the transaction expended `0.00056‚ìÉ`, the user was charged upfront `0.0016‚ìÉ`, this is 60% more than what the user expected to pay (0.001‚ìÉ).

This 60% up comes from assuming that the price of gas will go up by 1% on each block, and the transaction will take 50 blocks to execute (`1.01**50 ~ 1.64`).

</details>

:::tip
In other chains, paying a higher gas price gets your transaction processed faster. In NEAR, **gas costs are deterministic**, and you **can't pay extra**. Any extra gas attached to a transaction is simply sent back to the user.
:::

---

## Gas as a Developer Incentive

In NEAR, 30% of the gas fees burned while executing a contract go to the contract's account. This is a powerful incentive for developers to create and maintain useful contracts.

For example, in [this transaction](https://testnet.nearblocks.io/txns/JD8Bg4u8kaYeaSsGBqkvhSDCEPgXhtwJRBBPKicCEPMs) the user calls a function in the `guestbook.near-examples.testnet` contract.

Executing the function call burned a total of ~0.00032‚ìÉ, from which 30% went to the contract's account. This means that the contract's account received 0.000096‚ìÉ.

Notice that the fee comes from the gas burned during the function execution, and not from the total gas used.

---

## Estimating Costs for a Call

If you're developing a smart contract, you might want to estimate how much gas a function call will consume. This is useful to estimate limits for your function and avoid running into out-of-gas errors.

One of the most accurate ways to estimate gas costs is by running your function in `testnet`. To know exactly how much gas a specific part of your function uses, you can use the `used_gas` method from our SDK.

Another option is to use `Sandbox Testing` (available in [Rust](https://github.com/near/workspaces-rs/tree/main/examples/src) and [JavaScript](https://github.com/near/workspaces-js)), which simulates the NEAR network. There you can access the gas burnt after each function call.

 This is the content for the doc docs/1.concepts/protocol/transaction-anatomy.md 

 ---
id: transaction-anatomy
title: Anatomy of a Transaction
---

A transaction is a request from a user to the network to perform a set of actions. To create a transaction, the user must specify the following fields:

- `Signer`: the account that signs the transaction
- `Actions`: the set of actions to be performed (see below)
- `Receiver`: the account on which to perform the actions

In addition, a transaction has the following fields to ensure its integrity and validity:

- `PublicKey`: the public key used to sign the transaction (so the network can verify the signature)
- `Nonce`: a number that is incremented for each transaction sent by the `Signer`
- `BlockHash`: the hash of a recent block, to limit the time-validity of the transaction

Users create transactions and sign them with their private keys. Then, the **transaction and its signature** are broadcast together to the network, where they are validated and processed.

:::tip
Each transaction has exactly one `Signer` and `Receiver`, but can have multiple `Actions`
:::

---

## Actions
Each transaction can have **one or multiple** `Actions`, which are the actual operations to be performed on the `Receiver` account. There are 9 types of actions that can be performed:

1. `FunctionCall`: to invoke a function on a contract (optionally attaching NEAR to the call)
2. `Transfer`: to transfer tokens to another account
3. `DeployContract`: to deploy a contract in the account
4. `CreateAccount`: to create a new sub-account (e.g. `ana.near` can create `sub.ana.near`)
5. `DeleteAccount`: to delete the account (transferring the remaining balance to a beneficiary)
6. `AddKey`: to add a new key to the account (either `FullAccess` or `FunctionCall` access)
7. `DeleteKey`: to delete an existing key from the account
8. `DelegateActions`: to create a meta-transaction
9. `Stake`: special action to express interest in becoming a network validator

For example, `bob.near` can bundle the following actions in a single transaction:
- Create the account `contract.bob.near`
- Transfer 5 NEAR to `contract.bob.near`
- Deploy a contract in `contract.bob.near`
- Call the function `init` in `contract.bob.near`

The `Actions` are executed in the **order they are specified in the transaction**. If any of the **actions fails**, the transaction is discarded and none of the actions take effect.

:::warning One Receiver
Notice that all actions are performed on the same account. It is **not possible** to perform actions on multiple accounts in a single transaction, because transactions can have **only one receiver**
:::


 This is the content for the doc docs/1.concepts/protocol/transaction-execution.md 

 ---
id: transaction-execution
title: Lifecycle of a Transaction
---

`Transactions` are constructed by users to express the intent of performing actions in the network. Once in the network, transactions are converted into `Receipts`, which are messages exchanged between network nodes.

On this page, we will explore the lifecycle of a transaction, from its creation to its final status.


:::tip Recommended Reading
To dig deeper into transaction routing, we recommend reading the [nearcore documentation](https://near.github.io/nearcore/architecture/how/tx_routing.html)
:::

---

## Receipts & Finality

Let's walk through the lifecycle of a complex transaction and see how it is processed by the network using blocks as **time units**.

#### Block #1: The Transaction Arrives
After a transaction arrives, the network takes one block to validate it and transform it into a single `Receipt` that contains all the [actions](./transaction-anatomy.md) to be executed.

While creating the `Receipt`, the `signer` gets $NEAR deducted from its balance to **pay for the gas** and **any attached NEAR**.

If the `signer` and `receiver` coincide - e.g. the `signer` is adding a Key - the `Receipt` is immediately processed in this first block and the transaction is considered final.

#### Block #2: The Receipt is Processed
If the `signer` and `receiver` differs - e.g. the `signer` transfers NEAR to the `receiver` - the `Receipt` is processed in a second block. 

During this process a `FunctionCall` could span a **cross-contract call**, creating one or multiple new `Receipts`.

#### Block #3...: Function Calls
Each `Receipt` created from the function call take an additional block to be processed. Notice that, if those `Receipts` are `FunctionCall` they could spawn new `Receipts` and so on.

#### Final Block: Gas is Refunded
A final `Receipt` is processed in a new block, refunding any extra gas paid by the user.

:::info
A transaction is considered **final** when all its receipts are processed.
:::

:::tip
Most transactions will just spawn a receipt to process the actions, and a receipt to refund the gas, being final in 1-3 blocks (~1-3 seconds):

- [One block](https://testnet.nearblocks.io/txns/8MAvH96aMfDxPb3kVDrgj8nvJS7CAXP1GgtiivKAMGkF#execution) if the `signer` and `receiver` coincide - e.g. when adding a key
- [Three blocks](https://testnet.nearblocks.io/txns/B7gxJNxav1A9WhWvaNWYLrSTub1Mkfj3tAudoASVM5tG#) if the `signer` and `receiver` differ, since the first block creates the `Receipt`, and the last reimburses gas

Function calls might take longer, as they can spawn multiple receipts. Network congestion can also increase the time to process a receipt and, thus, a transaction.
:::

---

## Transaction Status

As the `Receipts` of a `Transaction` are processed, they get a status:

- `Success`: the actions on the receipt were executed successfully
- `Failed`: an action on the receipt failed
- `Unknown`: the receipt is not known by the network

If an action in a `Receipt` fails, all the actions in that `Receipt` are rolled back. Notice that we are talking about the `Receipt` status, and not the `Transaction` status.

The status of a transaction is determined by its first receipt, which contains all its actions. If any of the actions in the first receipt fail, the transaction is marked as failed.

Notice that, it could happen that a transaction is marked as successful, but some of its receipt fails. This happens when a `FunctionCall` successfully spawns a new receipt, but the consequent function call fails. In this case, the transaction is marked as successful because the original function call was successful.

See the examples below for more details.

<details>

<summary> Status Examples </summary>

#### Example: Transaction with Transfer

1. `bob.near` creates a transaction to transfer 10 NEAR to `alice.near`
2. The transaction is converted into a receipt
3. The conversion fails because `bob.near` does not have enough balance
4. The transaction is marked as failed ‚õî

#### Example: Deploying a Contract

1. `bob.near` creates a transaction to:
    - create the account `contract.bob.near`
    - transfer 5 NEAR to `contract.bob.near`
    - deploy a contract in `contract.bob.near`
2. The transaction is transformed into one receipt
3. The account is created, the money transfer and the contract deployed
4. The transaction is marked as successful ‚úÖ

#### Example: Deploying a Contract Fails

1. `bob.near` creates a transaction to:
    - create the account `contract.bob.near`
    - transfer 5 NEAR to `contract.bob.near`
    - deploy a contract in `contract.bob.near`
2. The transaction is transformed into one receipt
3. The account is created, but the transfer fails because `bob.near` does not have enough balance
4. The whole process is reverted (i.e. no account is created)
5. The transaction is marked as failed ‚õî

#### Example: Calling a Function
1. `bob.near` creates a transaction to call the function `cross-call` in `contract.near`
2. The transaction is transformed into one receipt
3. The function `cross-call` creates a promise to call the function `external-call` in `external.near`
4. The function finishes correctly and the transaction is marked as successful ‚úÖ
5. A new receipt is created to call the function `external-call` in `external.near`
5. The function `external-call` fails
6. The original transaction is still marked as successful ‚úÖ because the first receipt was successful

</details>

:::tip
You can check the status of a transaction using the [NearBlocks explorer](https://nearblocks.io/)
:::


 This is the content for the doc docs/1.concepts/protocol/transactions.md 

 ---
id: transactions
title: Transactions
---

Users interact with NEAR by creating transactions. Specifically, users use their account's [private keys](./access-keys.md) to sign transactions, which are then broadcasted and processed by the network.

![](@site/static/docs/assets/welcome-pages/data-lake.png)

A transaction is composed of one or more [`Actions`](./transaction-anatomy.md), and each action costs a deterministic amount of [gas units](./gas.md). These gas units are translated into a cost in NEAR tokens, which the user must pay for the transaction to be processed.

:::tip
You can use an <a href="https://nearblocks.io/" target="_blank" rel="noopener noreferrer">Explorer</a> to inspect transactions in the NEAR network
:::


 This is the content for the doc docs/1.concepts/storage/decentralized-storage.md 

 ---
id: storage-solutions
title: Decentralized Storage Solutions
sidebar_label: Alternative Solutions
---

> In this article you'll find a brief overview of different decentralized storage solutions that can be integrated into your decentralized applications (dApps). This will allow you to store large amounts of data using a more economical alternative to native NEAR storage.

- [Arweave](#arweave)
- [Crust](#crust)
- [IPFS](#ipfs)

---

## On-Chain Storage Constraints

For storing data on-chain it's important to keep in mind the following:

- You can store an unlimited amount of files, but will cost you 1‚ìÉ per 100KB
- There is a 4 MB limit on how much you can upload at once


For example, if you want to store an NFT purely on-chain (rather than using IPFS or some other decentralized storage solution as mentioned below) you'll have almost an unlimited amount of storage but will have to pay 1 $NEAR per 100 KB of storage used (see [Storage Staking](https://docs.near.org/concepts/storage/storage-staking))

Users will be limited to 4MB per contract call upload due to `MAX_GAS` constraints. The maximum amount of gas one can attach to a given `functionCall` is 300TGas.

## Arweave

[Arweave](https://www.arweave.org/) is a new type of storage that backs data with sustainable and perpetual endowments
(tokens held within the protocol that benefit from inflation and the decrease in the cost of storage over long periods of time). This allows users and developers to store data forever.
Arweave acts as a collectively owned hard drive, and allows their users to preserve valuable information, apps, and history indefinitely.

The Arweave protocol matches a torrent-like swarm of incentivised miners with massive collective hard drive space with those individuals and organizations that need to store data or host content permanently. This is achieved in a decentralized network, and all data stored is backed by block mining rewards and a [sustainable endowment](https://arwiki.wiki/#/en/storage-endowment) ensuring it is available in perpetuity.

:::info
To learn more about Arweave, check its [mining mechanism](https://arwiki.wiki/#/en/arweave-mining) and its [bandwidth-sharing system](https://arwiki.wiki/#/en/karma).
:::

### Example implementation

Let's see how to store some files on Arweave, by running a local Arweave gateway-like server.

### Arlocal setup

[Arlocal](https://github.com/textury/arlocal) essentially creates a simulated version of Arweave. Think of it like a local node that runs on your computer to store information.

In this example you'll need to run **two terminals**.

- Open your first terminal and run:

```bash
npx arlocal
```

You should see the response: `arlocal started on port 1984`.

:::tip
You can specify the port by using `npx arlocal <desired port number>`.
:::

### NEAR-Arweave frontend

The [NEAR-Arweave repository](https://github.com/near-examples/NEAR-Arweave-Tutorial) has a simple frontend that allows you to store `.png` files using arlocal.

- Now open your second terminal and clone the frontend by running the following command:

```bash
git clone https://github.com/near-examples/NEAR-Arweave-Tutorial.git
```

- Install dependencies by running the following in the project folder:

```bash
cd NEAR-Arweave-Tutorial
yarn
```

- Next, start the application by running:

```bash
yarn start
```


- Now you're ready to upload an image by selecting the <kbd>Choose File</kbd> button:

![Arweave step 1](/docs/assets/arweave-1.png)

- You should see the transaction ID window become populated after hitting the <kbd>Submit</kbd> button:

![Arweave step 2](/docs/assets/arweave-2.png)

:::tip
If you get an error, make sure your arlocal node is running in a **separate terminal.**
:::

### Mining your transaction

On Arweave your transaction goes through two stages; a pending stage and a confirmed stage. For the transaction to be complete and for you to be able to retrieve your data, your transaction must be confirmed.

- Visit `http://localhost:1984/mine` in your browser to send a mine request to your local node.

:::tip
you may find that you are still able to retrieve your data without this step, but that's because you are running a local node.
When dealing with a real Arweave node you will have to wait until your transaction has been mined and confirmed.
:::

### Retrieve the image

- Now you can copy and paste any of your listed arweave transaction IDs in step 5 on the frontend to retrieve your file from your local node:

![Arweave step 3](/docs/assets/arweave-3.png)

:::info
Using Arweave's live network will require purchasing artokens to pay for storage. You can find out more at [arweave.org](https://www.arweave.org/).
:::

:::tip
The [near-api-js](https://github.com/near/near-api-js) and [arweave-js](https://github.com/ArweaveTeam/arweave-js) JavaScript libraries allow you to automate most of these steps.
:::

---

## Crust

[Crust](https://crust.network) provides a Web3.0 decentralized storage network for the Metaverse.
It is designed to realize core values of decentralization, privacy and assurance.
Crust supports multiple storage-layer protocols such as IPFS and exposes instant accessible on-chain storage functions to users.
Crust ºs technical stack is also capable of supporting data manipulation and computing.

The Crust protocol is 100% compatible with the [IPFS](https://ipfs.io) protocol, and it matches people who have hard drive space to spare with those who need to store data or host content.
Crust is based on the Polkadot ecosystem and supports most contract platforms, including NEAR/Solana/Ethereum/Elrond/etc. with its cross-chain solution.

:::info
To learn more about Crust, check its [Decentralized Storage Market](https://wiki.crust.network/docs/en/DSM) and [Guaranteed Proof of Stake](https://wiki.crust.network/docs/en/GPoS).
Also, you can start with [Build-101](https://wiki.crust.network/docs/en/build101).
:::

### Integration example

Here's a simple integration example to store a file with Crust and NEAR.

#### 1. Upload the file to IPFS

First, you need to put your files into IPFS.

:::tip
If you want to learn how to upload **files and folders** into IPFS, please refer to [this section](https://wiki.crust.network/docs/en/buildFileStoringWithGWDemo#1-upload-files-to-ipfs-gateway).
:::

There are 2 ways to upload a file to IPFS:

- using a local IPFS node
- using a remote [IPFS W3Authed Gateway](https://docs.ipfs.io/concepts/ipfs-gateway/#authenticated-gateways)

:::info
- You can find more details about `ipfsW3GW` endpoints on [this link](https://github.com/crustio/ipfsscan/blob/main/lib/constans.ts#L29).
- You can also find a code example on how to upload a file to IPFS on [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L20-L51).
:::

#### 2. Place an storage order

Next, you need to send a transaction named `Place Storage Order` on Crust chain.
This transaction will dispatch your storage requirement to each Crust IPFS nodes through the blockchain.
Then the IPFS nodes will start pulling your file using the IPFS protocol.

:::info
- You can find more information about `crustChainEndpoint` on [this link](https://github.com/crustio/crust-apps/blob/master/packages/apps-config/src/endpoints/production.ts#L9).
- You can create your own account (`seeds`) following [these instructions](https://wiki.crust.network/docs/en/crustAccount#create-an-account-1).
- Check [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L82-L112) for a code example about placing a storage order on Crust.
:::

#### 3. Query order status

Then, you can query the storage order by calling on-chain status (`status{replica_count, storage_duration, ...}`).
This call will return:

```json
{
    "file_size": 23710,
    "spower": 24895,
    "expired_at": 2594488, // Storage duration
    "calculated_at": 2488,
    "amount": "545.3730 nCRU",
    "prepaid": 0,
    "reported_replica_count": 1, // Replica count
    "replicas": [{
        "who": "cTHATJrSgZM2haKfn5e47NSP5Y5sqSCCToxrShtVifD2Nfxv5",
        "valid_at": 2140,
        "anchor": "0xd9aa29dda8ade9718b38681adaf6f84126531246b40a56c02eff8950bb9a78b7c459721ce976c5c0c9cd4c743cae107e25adc3a85ed7f401c8dde509d96dcba0",
        "is_reported": true,
        "created_at": 2140
    }] // Who stores the file
}
```

:::info
Find a code example about querying storage status on [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L144-L147).
:::

#### 4. Add file prepaid

The default storage time for a single transaction (order) is 6 months.
If you want to extend the storage duration, Crust provides a prepaid pool so you can customize the file's storage time.
This pool allows you to put some tokens and will automatically extend the file's storage time.

:::info
Follow [this link](https://github.com/crustio/crust-demo/blob/main/near/src/index.ts#L114-L142) for a code snippet on how to add prepaid tokens to your files.
:::

---

## IPFS

The [InterPlanetary File System](https://ipfs.io/) (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices.

### Content identifier

When you add a file to IPFS it is split into cryptographically hashed smaller chunks and then given a unique fingerprint called a content identifier (CID).

:::tip
The CID acts as an permanent record of a file as it exists at that point in time.
:::

### Look-up

When a node looks up for a file, it ask the peer nodes for the content referenced by the file's CID. When a node views or downloads a file, it caches a copy and become another provider until the cache is cleared.

### Pinned content

On the IPFS network, each node stores only content it is interested in.
A node can pin content in order to keep it forever, or discard content it hasn't used to save space.

### File versions

When you add a new version of your file to IPFS it will get a new CID since the cryptographic hash is different.
This means that any changes to a file will not overwrite the original and common chunks across files can be reused in order to minimize storage costs.

### Naming system

IPFS offers a decentralized naming system so you don't need to remember a long string of CIDs.
IPFS can find the latest version of your file using the IPNS decentralized naming system and you can use DNSLink to map CIDs to human-readable DNS names.

### IPFS providers

- [Web3.Storage](https://web3.storage/): it's a service that simplifies building on top of IPFS and Filecoin. Web3.Storage is backed by Filecoin and makes content available via IPFS, leveraging the unique properties of each network.
- [NFT.Storage](https://nft.storage/): this service is built specifically for storing off-chain NFT data. Data is stored decentralized on IPFS and Filecoin. The data is referenced using content-addressed IPFS URIs that can be used in your smart contracts.
- [Filebase](https://filebase.com/): a geo-redundant IPFS pinning provider that pins all IPFS files with automatic 3x redundancy across diverse, geographic locations for additional performance, redundancy, and reliability.


 This is the content for the doc docs/1.concepts/storage/storage-staking.md 

 ---
id: storage-staking
title: Storage Staking
sidebar_label: Storage Staking
---

> When you deploy a smart contract to NEAR, you pay for the storage that this contract requires using a mechanism called storage staking.
>
> In storage staking (sometimes called _state_ staking), the account that owns a smart contract must stake (or lock) tokens according to the amount of data stored in that smart contract, effectively reducing the balance of the contract's account.

## How does NEAR's design align incentives?

Storage-staked tokens are unavailable for other uses, such as validation staking. This increases the yield that validators will receive. Learn more in [the economics whitepaper](https://pages.near.org/papers/economics-in-sharded-blockchain/).

## When do tokens get staked?

On each incoming transaction that adds data.

Let's walk through an example:

1. You launch [a guest book app](../../3.tutorials/examples/guest-book.md), deploying your app's smart contract to the account `example.near`
2. Visitors to your app can add messages to the guest book. This means your users will, [by default](/concepts/protocol/gas#understanding-gas-fees), pay a small gas fee to send their message to your contract.
3. When such a call comes in, NEAR will check that `example.near` has a large enough balance that it can stake an amount to cover the new storage needs. If it does not, the transaction will fail.

## The "million cheap data additions" attack

Note that this can create an attack surface. To continue the example above, if sending data to your guest book costs users close to nothing while costing the contract owner significantly more, then a malicious user can exploit the imbalance to make maintaining the contract prohibitively expensive.

Take care, then, when designing your smart contracts to ensure that such attacks cost potential attackers more than it would be worth.

## btw, you can remove data to unstake some tokens

People familiar with the "immutable data" narrative about blockchains find this surprising. While it's true that an _indexing node_ will keep all data forever, _validating nodes_ (that is, the nodes run by most validators in the network) do not. Smart contracts can provide ways to delete data, and this data will be purged from most nodes in the network within a few [epochs](../basics/epoch.md).

Note that a call to your smart contract to remove data has an associated gas fee. Given NEAR's gas limit, this creates an upper limit on how much data can be deleted in a single transaction.

## How much does it cost?

Storage staking is priced in an amount set by the network, which is set to **1E19 yoctoNEAR per byte**, or **100kb per NEAR token (‚ìÉ)**. [^1] [^2]

NEAR's JSON RPC API provides [a way to query this initial setting](/api/rpc/protocol#genesis-config) as well as a [a way to query the live config / recent blocks](/api/rpc/protocol#protocol-config).

## Example cost breakdown

Let's walk through an example.

A [non-fungible token](https://github.com/near/NEPs/pull/4) is unique, which means each token has its own ID. The contract must store a mapping from token IDs to owners' account ID.

If such an NFT is used to track **1 million** tokens, how much storage will be required for the token-ID-to-owner mapping? And how many tokens will need to be staked for that storage?

Let's calculate the storage needs when using a `PersistentMap` that stores data as UTF-8 strings.

Here's our `PersistentMap`:

```ts
type AccountId = string;
type TokenId = u64;
const tokenToOwner = new PersistentMap<TokenId, AccountId>("t2o");
```

Behind the scenes, all data stored on the NEAR blockchain is saved in a key-value database. That `'t2o'` variable that's passed to `PersistentMap` helps it keep track of all its values. If your account `example.near` owns token with ID `0`, then at the time of writing, here's the data that would get saved to the key-value database:

- key: `t2o::0`
- value: `example.near`

So for 1 million tokens, here are all the things we need to add up and multiply by 1 million:

1. The prefix, `t2o`, will be serialized as three bytes in UTF-8, and the two colons will add another two. That's 5 bytes.
2. For an implementation where `TokenId` auto-increments, the values will be between `0` and `999999`, which makes the average length 5 bytes.
3. Let's assume well-formed NEAR `AccountId`s, and let's guess that NEAR Account IDs follow the approximate pattern of domain names, which [average about 10 characters](https://www.gaebler.com/Domain-Length-Research.htm), plus a top-level name like `.near`. So a reasonable average to expect might be about 15 characters; let's keep our estimate pessimistic and say 25. This will equal 25 bytes, since NEAR account IDs must use characters from the ASCII set.

So:

    1_000_000 * (5 + 5 + 25)

35 million bytes. 350 times 100Kib, meaning ‚ìÉ350. To do the exact math: Multiplying by 1e19 yoctoNEAR per byte, we find that the `tokenToOwner` mapping with 35m bytes will require staking 3.5e26 yoctoNEAR, or ‚ìÉ350

Note that you can get this down to ‚ìÉ330 just by changing the prefix from `t2o` to a single character. Or get rid of it entirely! You can have a zero-length prefix on one `PersistentVector` in your smart contract. If you did that with this one, you could get it down to ‚ìÉ250.

## Calculate costs for your own contract

Doing manual byte math as shown above is difficult and error-prone. Good news: you don't have to!

You can test the storage used using the [SDK environment](../../2.build/2.smart-contracts/anatomy/environment.md) and checking `env.storage_usage()`

## Other ways to keep costs down

Storing data on-chain isn't cheap for the people running the network, and NEAR passes on this cost to developers. So, how do you, as a developer, keep your costs down? There are two popular approaches:

1. Use a binary serialization format, rather than JSON
2. Store data off-chain

### Use a binary serialization format, rather than JSON

The core NEAR team maintains a library called [borsh](https://borsh.io/),
which is used automatically when you use `near-sdk-rs`. Someday, it will probably also be used by `near-sdk-js`.

Imagine that you want to store an array like `[0, 1, 2, 3]`. You could serialize it as a string and store it as UTF-8 bytes. This is what `near-sdk-js` does today. Cutting out spaces, you end up using 9 bytes.

Using borsh, this same array gets saved as 8 bytes:

    \u0004\u0000\u0000\u0000\u0000\u0001\u0002\u0003

At first glance, saving 1 byte might not seem significant. But let's look closer.

The first four bytes here, `\u0004\u0000\u0000\u0000`, tell the serializer that this is a `u32` array of length `4` using little-endian encoding. The rest of the bytes are the literal numbers of the array ‚Äì `\u0000\u0001\u0002\u0003`. As you serialize more elements, each will add one byte to the data structure. With JSON, each new element requires adding two bytes, to represent both another comma and the number.

In general, Borsh is faster, uses less storage, and costs less gas. Use it if you can.

### Store data off-chain

This is especially important if you are storing user-generated data!

Let's use this [Guest Book](https://github.com/near-examples/guest-book-examples) as an example. As implemented today, visitors to the app can sign in with NEAR and leave a message. Their message is stored on-chain.

Imagine this app got very popular, and that visitors started leaving unexpectedly long messages. The contract owner might run out of funding for storage very quickly!

A better strategy could be to store data off-chain. If you want to keep the app decentralized, a popular off-chain data storage solution is [IPFS](https://ipfs.io/). With this, you can represent any set of data with a predictable content address such as:

    QmYwAPJzv5CZsnA625s3Xf2nemtYgPpHdWEz79ojWnPbdG

Such a content address could represent a JSON structure or an image or any other type of data. Where does this data get physically stored? You could use [Filecoin](https://filecoin.io/) or run your own IPFS server to pin your app's data.

With this approach, each record you add to your contract will be a predictable size.

## Summary

NEAR's structure incentivizes network operators while giving flexibility and predictability to contract developers. Managing storage is an important aspect of smart contract design, and NEAR's libraries make it easy to figure out how much storage will cost for your application.

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"><h8>Ask it on StackOverflow!</h8></a>
:::

## Footnotes

[^1]: [Storage staking price](https://gov.near.org/t/storage-staking-price/399)
[^2]: [Lower storage cost 10x](https://github.com/near/nearcore/pull/3881)


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/actions.md 

 ---
id: actions
title: Transfers & Actions
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Smart contracts can perform specific `Actions` such as transferring NEAR, or calling other contracts.

An important property of `Actions` is that they can be batched together when acting on the same contract. **Batched actions** act as a unit: they execute in the same [receipt](/concepts/protocol/transaction-execution#receipts--finality), and if **any fails**, then they **all get reverted**.

:::info
`Actions` can be batched only when they act on the **same contract**. You can batch calling two methods on a contract,
but **cannot** call two methods on different contracts.
:::

---

## Transfer NEAR ‚ìÉ

You can send $NEAR from your contract to any other account on the network. The Gas cost for transferring $NEAR is fixed and is based on the protocol's genesis config. Currently, it costs `~0.45 TGas`.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, NearPromise, call } from 'near-sdk-js'
  import { AccountId } from 'near-sdk-js/lib/types'

  @NearBindgen({})
  class Contract{
    @call({})
    transfer({ to, amount }: { to: AccountId, amount: bigint }) {
      return NearPromise.new(to).transfer(amount);
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, AccountId, Promise, NearToken};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  #[near]
  impl Contract {
    pub fn transfer(&self, to: AccountId, amount: NearToken){
      Promise::new(to).transfer(amount);
    }
  }
```

</TabItem>

</Tabs>

:::tip Why is there no callback?
The only case where a transfer will fail is if the receiver account does **not** exist.
:::

:::caution
Remember that your balance is used to cover for the contract's storage. When sending money, make sure you always leave enough to cover for future storage needs.
:::

---

## Function Call

Your smart contract can call methods in another contract. In the snippet below we call a method
in a deployed [Hello NEAR](../quickstart.md) contract, and check if everything went
right in the callback.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, bytes, NearPromise } from 'near-sdk-js'
  import { AccountId } from 'near-sdk-js/lib/types'

  const HELLO_NEAR: AccountId = "hello-nearverse.testnet";
  const NO_DEPOSIT: bigint = BigInt(0);
  const CALL_GAS: bigint = BigInt("10000000000000");

  @NearBindgen({})
  class Contract {
    @call({})
    call_method({}): NearPromise {
      const args = bytes(JSON.stringify({ message: "howdy" }))

      return NearPromise.new(HELLO_NEAR)
      .functionCall("set_greeting", args, NO_DEPOSIT, CALL_GAS)
      .then(
        NearPromise.new(near.currentAccountId())
        .functionCall("callback", bytes(JSON.stringify({})), NO_DEPOSIT, CALL_GAS)
      )
      .asReturn()
    }

    @call({privateFunction: true})
    callback({}): boolean {
      let result, success;

      try{ result = near.promiseResult(0); success = true }
      catch{ result = undefined; success = false }

      if (success) {
        near.log(`Success!`)
        return true
      } else {
        near.log("Promise failed...")
        return false
      }
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, log, Promise, Gas, PromiseError};
  use serde_json::json;

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const HELLO_NEAR: &str = "hello-nearverse.testnet";
  const NO_DEPOSIT: u128 = 0;
  const CALL_GAS: Gas = Gas(5_000_000_000_000);

  #[near]
  impl Contract {
    pub fn call_method(&self){
      let args = json!({ "message": "howdy".to_string() })
                .to_string().into_bytes().to_vec();

      Promise::new(HELLO_NEAR.parse().unwrap())
      .function_call("set_greeting".to_string(), args, NO_DEPOSIT, CALL_GAS)
      .then(
        Promise::new(env::current_account_id())
        .function_call("callback".to_string(), Vec::new(), NO_DEPOSIT, CALL_GAS)
      );
    }

    pub fn callback(&self, #[callback_result] result: Result<(), PromiseError>){
      if result.is_err(){
          log!("Something went wrong")
      }else{
          log!("Message changed")
      }
    }
  }
```

</TabItem>

</Tabs>

:::warning
The snippet showed above is a low level way of calling other methods. We recommend make calls to other contracts as explained in the [Cross-contract Calls section](crosscontract.md).
:::

---

## Create a Sub Account
Your contract can create direct sub accounts of itself, for example, `user.near` can create `sub.user.near`.

Accounts do **NOT** have control over their sub-accounts, since they have their own keys.

Sub-accounts are simply useful for organizing your accounts (e.g. `dao.project.near`, `token.project.near`).


<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, NearPromise } from 'near-sdk-js'

  const MIN_STORAGE: bigint = BigInt("1000000000000000000000") // 0.001‚ìÉ

  @NearBindgen({})
  class Contract {
    @call({payableFunction:true})
    create({prefix}:{prefix: String}) {
      const account_id = `${prefix}.${near.currentAccountId()}`

      NearPromise.new(account_id)
      .createAccount()
      .transfer(MIN_STORAGE)
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, NearToken};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const MIN_STORAGE: Balance = 1_000_000_000_000_000_000_000; //0.001‚ìÉ

  #[near]
  impl Contract {
    pub fn create(&self, prefix: String){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE);
    }
  }
```

</TabItem>

</Tabs>

:::tip
  Notice that in the snippet we are transferring some money to the new account for storage
:::

:::caution

When you create an account from within a contract, it has no keys by default. If you don't explicitly [add keys](#add-keys) to it or [deploy a contract](#deploy-a-contract) on creation then it will be [locked](../../../1.concepts/protocol/access-keys.md#locked-accounts).

:::

<hr className="subsection" />

#### Creating `.testnet` / `.near` Accounts

Accounts can only create immediate sub-accounts of themselves.

If your contract wants to create a `.mainnet` or `.testnet` account, then it needs to [call](#function-call)
the `create_account` method of `near` or `testnet` root contracts.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, bytes, NearPromise } from 'near-sdk-js'

  const MIN_STORAGE: bigint = BigInt("1820000000000000000000"); //0.00182‚ìÉ
  const CALL_GAS: bigint = BigInt("28000000000000");

  @NearBindgen({})
  class Contract {
    @call({})
    create_account({account_id, public_key}:{account_id: String, public_key: String}) {
      const args = bytes(JSON.stringify({
        "new_account_id": account_id,
        "new_public_key": public_key
      }))

      NearPromise.new("testnet")
      .functionCall("create_account", args, MIN_STORAGE, CALL_GAS);
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, Promise, Gas, NearToken };
  use serde_json::json;

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const CALL_GAS: Gas = Gas(28_000_000_000_000);
  const MIN_STORAGE: Balance = 1_820_000_000_000_000_000_000; //0.00182‚ìÉ

  #[near]
  impl Contract {
    pub fn create_account(&self, account_id: String, public_key: String){
      let args = json!({
                  "new_account_id": account_id,
                  "new_public_key": public_key,
                }).to_string().into_bytes().to_vec();

      // Use "near" to create mainnet accounts
      Promise::new("testnet".parse().unwrap())
      .function_call("create_account".to_string(), args, MIN_STORAGE, CALL_GAS);
    }
  }
```

</TabItem>

</Tabs>

---

## Deploy a Contract

When creating an account you can also batch the action of deploying a contract to it. Note that for this, you will need to pre-load the byte-code you want to deploy in your contract.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, NearToken};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const MIN_STORAGE: Balance = 1_100_000_000_000_000_000_000_000; //1.1‚ìÉ
  const HELLO_CODE: &[u8] = include_bytes!("./hello.wasm");

  #[near]
  impl Contract {
    pub fn create_hello(&self, prefix: String){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE)
      .deploy_contract(HELLO_CODE.to_vec());
    }
  }
```

</TabItem>

</Tabs>

:::tip
If an account with a contract deployed does **not** have any access keys, this is known as a locked contract. When the account is locked, it cannot sign transactions therefore, actions can **only** be performed from **within** the contract code.
:::

---

## Add Keys

When you use actions to create a new account, the created account does not have any [access keys](../../../1.concepts/protocol/access-keys.md), meaning that it **cannot sign transactions** (e.g. to update its contract, delete itself, transfer money).

There are two options for adding keys to the account:
1. `add_access_key`: adds a key that can only call specific methods on a specified contract.
2. `add_full_access_key`: adds a key that has full access to the account.

<br/>

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, NearPromise } from 'near-sdk-js'
  import { PublicKey } from 'near-sdk-js/lib/types'

  const MIN_STORAGE: bigint = BigInt("1000000000000000000000") // 0.001‚ìÉ

  @NearBindgen({})
  class Contract {
    @call({})
    create_hello({prefix, public_key}:{prefix: String, public_key: PublicKey}) {
      const account_id = `${prefix}.${near.currentAccountId()}`

      NearPromise.new(account_id)
      .createAccount()
      .transfer(MIN_STORAGE)
      .addFullAccessKey(public_key)
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, Balance, PublicKey};

  #[near(serializers = [json, borsh])]
  #[derive(Default)]
  pub struct Contract { }

  const MIN_STORAGE: Balance = 1_100_000_000_000_000_000_000_000; //1.1‚ìÉ
  const HELLO_CODE: &[u8] = include_bytes!("./hello.wasm");

  #[near]
  impl Contract {
    pub fn create_hello(&self, prefix: String, public_key: PublicKey){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE)
      .deploy_contract(HELLO_CODE.to_vec())
      .add_full_access_key(public_key);
    }
  }
```

</TabItem>

</Tabs>

Notice that what you actually add is a "public key". Whoever holds its private counterpart, i.e. the private-key, will be able to use the newly access key.

:::tip
If an account with a contract deployed does **not** have any access keys, this is known as a locked contract. When the account is locked, it cannot sign transactions therefore, actions can **only** be performed from **within** the contract code.
:::

---

## Delete Account

There are two scenarios in which you can use the `delete_account` action:
1. As the **last** action in a chain of batched actions.
2. To make your smart contract delete its own account.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```js
  import { NearBindgen, near, call, NearPromise } from 'near-sdk-js'
  import { AccountId } from 'near-sdk-js/lib/types'

  const MIN_STORAGE: bigint = BigInt("1000000000000000000000") // 0.001‚ìÉ

  @NearBindgen({})
  class Contract {
    @call({})
    create_delete({prefix, beneficiary}:{prefix: String, beneficiary: AccountId}) {
      const account_id = `${prefix}.${near.currentAccountId()}`

      NearPromise.new(account_id)
      .createAccount()
      .transfer(MIN_STORAGE)
      .deleteAccount(beneficiary)
    }

    @call({})
    self_delete({beneficiary}:{beneficiary: AccountId}) {
      NearPromise.new(near.currentAccountId())
      .deleteAccount(beneficiary)
    }
  }
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```rust
  use near_sdk::{near, env, Promise, Neartoken, AccountId};

  #[near(contract_state)]
  #[derive(Default)]
  pub struct Contract { }

  const MIN_STORAGE: Balance = 1_000_000_000_000_000_000_000; //0.001‚ìÉ

  #[near]
  impl Contract {
    pub fn create_delete(&self, prefix: String, beneficiary: AccountId){
      let account_id = prefix + "." + &env::current_account_id().to_string();
      Promise::new(account_id.parse().unwrap())
      .create_account()
      .transfer(MIN_STORAGE)
      .delete_account(beneficiary);
    }

    pub fn self_delete(beneficiary: AccountId){
      Promise::new(env::current_account_id())
      .delete_account(beneficiary);
    }
  }
```

</TabItem>

</Tabs>

:::warning Token Loss
If the beneficiary account does not exist the funds will be [**dispersed among validators**](../../../1.concepts/basics/token-loss.md).
:::

:::warning Token Loss
Do **not** use `delete` to try fund a new account. Since the account doesn't exist the tokens will be lost.
:::


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/anatomy.md 

 ---
id: anatomy
title: Basic Anatomy
hide_table_of_contents: true
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Let's illustrate the basic anatomy of a simple "Hello World" contract. The code on this page comes from our [Hello NEAR repository](https://github.com/near-examples/hello-near-examples) on GitHub.

<ExplainCode languages="js,rust" >

<Block highlights='{"js": "1", "rust": "1"}' fname="hello-near">

    ### Importing the SDK
    All contracts will import the **NEAR SDK**, enabling them to [access the execution environment](./environment.md), [call other contracts](./crosscontract.md), [transfer tokens](./actions.md), and much more.

    You can also use third-party libraries, though some might not work due to the limitations of the contract runtime.

</Block>

<Block highlights='{"js": "5-22", "rust":"5-7,20-31"}' fname="hello-near">

    ### Contract's Main Structure
    The contract is described through a structure:
    - The attributes define which data the contract stores
    - The functions define its public (and private) interface

</Block>

<Block highlights='{"js": "3"}' fname="hello-near">

    ### Contract Class Decorator
    
    Note that the contract's class is decorated with `@NearBindgen`. This decorator tells the SDK which class defines the contract, so it knows:
    1. What to fetch from storage when the contract is loaded
    2. What to store when the contract is done executing
    3. The methods that are exposed to the outside world
    4. If the contract needs to be initialized (we will cover this later)

    **Note:** Only one class can be decorated with the `@NearBindgen` decorator

</Block>

<Block highlights='{"rust": "4,19"}' fname="hello-near">

    ### Contract Struct Macro
    
    Note that the contract's struct definition and the implementation are decorated with macros
    
    The `#[near(contract_state)]` macro tell the SDK that this structure defines the contract's state, so it knows:
    1. What to fetch from storage when the contract is loaded
    2. What to store when the contract is done executing

    The `#[near]` macro tells the SDK which functions are exposed to the outside world.

    **Note:** Only one struct can be decorated with the `#[near(contract_state)]` macro.

</Block>

<Block highlights='{"rust": "4,19"}' fname="hello-near" type='info'>

    <details>

    <summary> Interaction with other macros </summary>

    When `near` is built for the wasm32 target, it generates the external NEAR contract bindings.  To achieve this it is actually generating another function with the signature `pub extern "C" fn function_name()` that first deserializes the contract struct from NEAR storage and then calls the `contract.function_name(parameter1, parameter2, ...)`.

    If you have annotated your function with any attribute-like macros, these are then executed _twice_.  Specifically if the attribute like macro makes any modification to the function signature, or inserts any code that depends on the contract struct (in the form of `&self`, `&mut self`, or `self`) this will fail in the second invocation, because the externally exposed function does not have any concept of this struct.

    It is possible to detect this by checking which build target you are building for and limit the execution of the macro to operate only on the first pass.

    </details>

</Block>

<Block highlights='{"js": "5", "rust": "6,10-16"}' fname="hello-near">

    ### Storage (State)
    We call the data stored in the contract [the contract's state](./storage.md).
    
    In our Hello World example, the contract stores a single string (`greeting`), and the state starts initialized with the default value `"Hello"`.

    **Note:** We will cover more about the contract's state in the [state section](./storage.md).

</Block>

<Block highlights='{"js": "7-9"}' fname="hello-near">

    Javascript contracts need to further include a `schema` object that defines the contract's state and its types. This object is used by the SDK to correctly serialize and deserialize the contract's state.

</Block>

<Block highlights='{"js": "12-14", "rust": "22-24"}' fname="hello-near">

    ### Read Only Functions
    Contract's functions can be read-only, meaning they don't modify the state. Calling them is free for everyone, and does not require to have a NEAR account.

    **Note:** We will cover more about function types in the [functions section](./functions.md).

</Block>

<Block highlights='{"js": "17-20", "rust": "27-30"}' fname="hello-near">

    ### State Mutating Functions
    Functions that modify the state or call other contracts are considered state mutating functions. It is necessary to have a NEAR account to call them, as they require a transaction to be sent to the network.

    **Note:** We will cover more about function types in the [functions section](./functions.md).

</Block>

<File language="js" fname="hello-near"
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
    start="2" end="32" />

<File language="rust" fname="hello-near"
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
    start="2" end="32" />

</ExplainCode>


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/best-practices.md 

 ---
id: best-practices
title: "Best Practices"
---

# Best practices

Here we lay out some best practices for writing smart contracts on NEAR, such as:

- [Enable overflow checks](#enable-overflow-checks)
- [Use `require!` early](#use-require-early)
- [Use `log!`](#use-log)
- [Return `Promise`](#return-promise)
- [Reuse crates from `near-sdk`](#reuse-crates-from-near-sdk)
- [The difference between `std::panic!` and `env::panic`](#stdpanic-vs-envpanic)
- [Use workspaces](#use-workspaces)

---

## Enable overflow checks

It's usually helpful to panic on integer overflow. To enable it, add the following into your `Cargo.toml` file:

```toml
[profile.release]
overflow-checks = true
```

## Use `require!` early

Try to validate the input, context, state and access using `require!` before taking any actions. The earlier you panic, the more [gas](https://docs.near.org/concepts/protocol/gas) you will save for the caller.

```rust
#[near]
impl Contract {
    pub fn set_fee(&mut self, new_fee: Fee) {
        require!(env::predecessor_account_id() == self.owner_id, "Owner's method");
        new_fee.assert_valid();
        self.internal_set_fee(new_fee);
    }
}
```

**Note**: If you want debug information in the panic message or if you are using an SDK version before `4.0.0-pre.2`, 
the Rust `assert!` macro can be used instead of `require!`.

```rust
#[near]
impl Contract {
    pub fn set_fee(&mut self, new_fee: Fee) {
        assert_eq!(env::predecessor_account_id(), self.owner_id, "Owner's method");
        new_fee.assert_valid();
        self.internal_set_fee(new_fee);
    }
}
```

## Use `log!`

Use logging for debugging and notifying user.

When you need a formatted message, you can use the following macro:

```rust
log!("Transferred {} tokens from {} to {}", amount, sender_id, receiver_id);
```

It's equivalent to the following message:

```rust
env::log_str(format!("Transferred {} tokens from {} to {}", amount, sender_id, receiver_id).as_ref());
```

## Return `Promise`

If your method makes a cross-contract call, you probably want to return the newly created `Promise`.
This allows the caller (such as a near-cli or near-api-js call) to wait for the result of the promise instead of returning immediately.
Additionally, if the promise fails for some reason, returning it will let the caller know about the failure, as well as enabling NEAR Explorer and other tools to mark the whole transaction chain as failing.
This can prevent false-positives when the first or first few transactions in a chain succeed but a subsequent transaction fails.

E.g.

```rust
#[near]
impl Contract {
    pub fn withdraw_100(&mut self, receiver_id: AccountId) -> Promise {
        Promise::new(receiver_id).transfer(100)
    }
}
```

## Reuse crates from `near-sdk`

`near-sdk` re-exports the following crates:

- `borsh`
- `base64`
- `bs58`
- `serde`
- `serde_json`

Most common crates include `borsh` which is needed for internal STATE serialization and
`serde` for external JSON serialization.

When marking structs with `serde::Serialize` you need to use `#[serde(crate = "near_sdk::serde")]`
to point serde to the correct base crate.

```rust
/// Main contract structure serialized with Borsh
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    pub pair: Pair,
}

/// Implements both `serde` and `borsh` serialization.
/// `serde` is typically useful when returning a struct in JSON format for a frontend.
#[near(serializers = [json, borsh])]
pub struct Pair {
    pub a: u32,
    pub b: u32,
}

#[near]
impl Contract {
    #[init]
    pub fn new(pair: Pair) -> Self {
        Self {
            pair,
        }
    }

    pub fn get_pair(self) -> Pair {
        self.pair
    }
}
```

## `std::panic!` vs `env::panic`

- `std::panic!` panics the current thread. It uses `format!` internally, so it can take arguments.
  SDK sets up a panic hook, which converts the generated `PanicInfo` from `panic!` into a string and uses `env::panic` internally to report it to Runtime.
  This may provide extra debugging information such as the line number of the source code where the panic happened.

- `env::panic` directly calls the host method to panic the contract.
  It doesn't provide any other extra debugging information except for the passed message.

## Use workspaces

Workspaces allow you to automate workflows and run tests for multiple contracts and cross-contract calls in a sandbox or testnet environment.
Read more, [workspaces-rs](https://github.com/near/workspaces-rs) or [workspaces-js](https://github.com/near/workspaces-js).


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/collections.md 

 ---
id: collections
title: Collections
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

When deciding on data structures it is important to understand their tradeoffs. Choosing the wrong structure can create a bottleneck as the application scales, and migrating the state to the new data structures will come at a cost.

You can choose between two types of collections:

1. Native collections (e.g. `Array`, `Map`, `Set`), provided by the language
2. SDK collections (e.g. `IterableMap`, `Vector`), provided by the NEAR SDK

Understanding how the contract stores and loads both types of collections is crucial to decide which one to use.

:::tip Native vs SDK Collections

Use native collections for small amounts of data that need to be accessed altogether, and SDK collections for large amounts of data that do not need to be accessed altogether.

If your collection has up to 100 entries, it's acceptable to use the native collection. For larger ones, prefer to use SDK collection. For comparison please refer to [this benchmark](https://www.github.com/volodymyr-matselyukh/near-benchmarking).

:::

<details>

<summary> How the State is Handled </summary>

Each time the contract is executed, the first thing it will do is to read the values and [deserialize](./serialization.md) them into memory, and after the function finishes, it will [serialize](./serialization.md) and write the values back to the database.

For native collections, the contract will fully load the collection into memory before any method executes. This happens even if the method you invoke does not use the collection. Know that this will have impact on GAS you spend for methods in your contract.

</details>

---

## Native Collections

Native collections are those provided by the language:
- JS: `Array`, `Set`, `Map`, `Object` ...
- Rust: `Vector`, `HashMap`, `Set` ...

All entries in a native collection are **serialized into a single value** and **stored together** into the state. This means that every time a function execute, the SDK will read and **deserialize all entries** in the native collection.

<details>

<summary> Serialization & Storage Example </summary>

The array `[1,2,3,4]` will be serialized into the JSON string `"[1,2,3,4]"` in Javascript, and the Borsh byte-stream `[0,0,0,4,1,2,3,4]` in Rust before being stored

</details>

:::tip When to use them

Native collections are useful if you are planning to store smalls amounts of data that need to be accessed all together

:::

:::danger Keep Native Collections Small

As the native collection grows, deserializing it from memory will cost more and more gas. If the collections grows too large, your contract might expend all the gas trying to read its state, making it fail on each function call

:::

---

## SDK Collections

The NEAR SDKs expose collections that are optimized for random access of large amounts of data. SDK collections are instantiated using a "prefix", which is used as an index to split the data into chunks. This way, SDK collections can defer reading and writing to the store until needed.

These collections are built to have an interface similar to native collections.

<details>

<summary> Serialization & Storage Example </summary>

The sdk array `[1,2,3,4]` with prefix `"p"` will be stored as the string `"p"` in the contract's attribute, and create four entries in the contract's storage: `p-0:1`, `p-1:2`...

</details>


:::tip when to use them

SDK collections are useful when you are planning to store large amounts of data that do not need to be accessed all together

:::

<hr class="subsection" />

### Exposed Collections

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

| SDK Collection | Native Equivalent | Description                                                                                                                                                                                      |
|----------------|-------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `Vector`       | `Array`           | A growable array type. The values are sharded in memory and can be used for iterable and indexable values that are dynamically sized.                                                            |
| `LookupSet`    | `Set`             | A set, which is similar to `LookupMap` but without storing values, can be used for checking the unique existence of values. This structure is not iterable and can only be used for lookups.     |
| `UnorderedSet` | `Set`             | An iterable equivalent of `LookupSet` which stores additional metadata for the elements contained in the set.                                                                                    |
| `LookupMap`    | `Map`             | This structure behaves as a thin wrapper around the key-value storage available to contracts. This structure does not contain any metadata about the elements in the map, so it is not iterable. |
| `UnorderedMap` | `Map`             | Similar to `LookupMap`, except that it stores additional data to be able to iterate through elements in the data structure.                                                                      |

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

| SDK collection                                | `std`&nbsp;equivalent             | Description                                                                                                                                                                                       |
|-----------------------------------------------|-----------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `store::Vector<T>`                            | `Vec<T>`                          | A growable array type. The values are sharded in memory and can be used for iterable and indexable values that are dynamically sized.                                                             |
| <code>store::LookupMap`<K,&nbsp;V>`</code>    | <code>HashMap`<K,&nbsp;V>`</code> | This structure behaves as a thin wrapper around the key-value storage available to contracts. This structure does not contain any metadata about the elements in the map, so it is not iterable.  |
| <code>store::IterableMap`<K,&nbsp;V>`</code>  | <code>HashMap`<K,&nbsp;V>`</code> | Similar to `LookupMap`, except that it stores additional data to be able to iterate through elements in the data structure.                                                                       |
| <code>store::UnorderedMap`<K,&nbsp;V>`</code> | <code>HashMap`<K,&nbsp;V>`</code> | Similar to `LookupMap`, except that it stores additional data to be able to iterate through elements in the data structure.                                                                       |
| `store::LookupSet<T>`                         | `HashSet<T>`                      | A set, which is similar to `LookupMap` but without storing values, can be used for checking the unique existence of values. This structure is not iterable and can only be used for lookups.      |
| `store::IterableSet<T>`                       | `HashSet<T>`                      | An iterable equivalent of `LookupSet` which stores additional metadata for the elements contained in the set.                                                                                     |
| `store::UnorderedSet<T>`                      | `HashSet<T>`                      | An iterable equivalent of `LookupSet` which stores additional metadata for the elements contained in the set.                                                                                     |

</TabItem>

<TabItem value="rust-legacy" label="ü¶Ä Rust (legacy)">

:::info Note

The `near_sdk::collections` is now deprecated in favor of `near_sdk::store`. To use `near_sdk::collections` you will have to use the [`legacy` feature](https://github.com/near-examples/storage-examples/blob/2a138a6e8915e08ce76718add3e36c04c2ea2fbb/collections-rs/legacy/Cargo.toml#L11).

:::

| SDK collection                                     | `std`&nbsp;equivalent              | Description                                                                                                                                                                                                                                        |
|----------------------------------------------------|------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `collections::Vector<T>`                            | `Vec<T>`                           | A growable array type. The values are sharded in memory and can be used for iterable and indexable values that are dynamically sized.                                                                                                              |
| <code>collections::LookupMap`<K,&nbsp;V>`</code>    | <code>HashMap`<K,&nbsp;V>`</code>  | This structure behaves as a thin wrapper around the key-value storage available to contracts. This structure does not contairn any metadata about the elements in the map, so it is not iterable.                                                  |
| <code>collections::UnorderedMap`<K,&nbsp;V>`</code> | <code>HashMap`<K,&nbsp;V>`</code>  | Similar to `LookupMap`, except that it stores additional data to be able to iterate through elements in the data structure.                                                                                                                        |
| <code>collections::TreeMap`<K,&nbsp;V>`</code>      | <code>BTreeMap`<K,&nbsp;V>`</code> | An ordered equivalent of `UnorderedMap`. The underlying implementation is based on an [AVL tree](https://en.wikipedia.org/wiki/AVL_tree). This structure should be used when a consistent order is needed or accessing the min/max keys is needed. |
| `collections::LookupSet<T>`                         | `HashSet<T>`                       | A set, which is similar to `LookupMap` but without storing values, can be used for checking the unique existence of values. This structure is not iterable and can only be used for lookups.                                                       |
| `collections::UnorderedSet<T>`                      | `HashSet<T>`                       | An iterable equivalent of `LookupSet` which stores additional metadata for the elements contained in the set.                                                                                                                                      |
| `collections::LazyOption<T>`                       | `Option<T>`                        | Optional value in storage. This value will only be read from storage when interacted with. This value will be `Some<T>` when the value is saved in storage, and `None` if the value at the prefix does not exist.                                  |
</TabItem>

</Tabs>

<hr class="subsection" />

### Features
| Type           | Iterable | Clear All Values | Preserves Insertion Order | Range Selection |
|----------------|:--------:|:----------------:|:-------------------------:|:---------------:|
| `Vector`       |    ‚úÖ     |        ‚úÖ         |             ‚úÖ             |        ‚úÖ        |
| `LookupSet`    |          |                  |                           |                 |
| `UnorderedSet` |    ‚úÖ     |        ‚úÖ         |                           |        ‚úÖ        |
| `IterableSet`  |    ‚úÖ     |        ‚úÖ         |                           |        ‚úÖ        |
| `LookupMap`    |          |                  |                           |                 |
| `UnorderedMap` |    ‚úÖ     |        ‚úÖ         |                           |        ‚úÖ        |
| `IterableMap`  |    ‚úÖ     |        ‚úÖ         |                           |        ‚úÖ        |
| `TreeMap`      |    ‚úÖ     |        ‚úÖ         |             ‚úÖ             |        ‚úÖ        |

<hr class="subsection" />

### Complexity

| Type           | Access |  Insert  |  Delete  |  Search  | Traverse | Clear |
|----------------|:------:|:--------:|:--------:|:--------:|:--------:|:-----:|
| `Vector`       |  O(1)  |  O(1)\*  | O(1)\*\* |   O(n)   |   O(n)   | O(n)  |
| `LookupSet`    |  O(1)  |   O(1)   |   O(1)   |   O(1)   |   N/A    |  N/A  |
| `UnorderedSet` |  O(1)  |   O(1)   |   O(1)   |   O(1)   |   O(n)   | O(n)  |
| `IterableSet`  |  O(1)  |   O(1)   |   O(1)   |   O(1)   |   O(n)   | O(n)  |
| `LookupMap`    |  O(1)  |   O(1)   |   O(1)   |   O(1)   |   N/A    |  N/A  |
| `IterableMap`  |  O(1)  |   O(1)   |   O(1)   |   O(1)   |   O(n)   | O(n)  |
| `TreeMap`      |  O(1)  | O(log n) | O(log n) | O(log n) |   O(n)   | O(n)  |

_\* - to insert at the end of the vector using `push_back` (or `push_front` for deque)_
_\*\* - to delete from the end of the vector using `pop` (or `pop_front` for deque), or delete using `swap_remove` which swaps the element with the last element of the vector and then removes it._

---

## SDK Collections Cookbook

Let's see how to use the SDK collections in practice

<hr class="subsection" />

### Instantiation

All structures need to be initialized using a **unique `prefix`**, which will be used to index the collection's values in the account's state

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">
    
    <Github fname="contract.ts" language="js"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts"
          start="6" end="25" />

:::tip

Do not forget to use the `schema` to define how your contract's state is structured

:::

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">
    <Github fname="lib.rs" language="rust" 
          url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/lib.rs"
          start="24" end="47"/>

  :::tip

  Notice how we use `enums` to ensure all collections have a different prefix. Another advantage of using `enums` is that they are serialized into a single `byte` prefix. 

  :::

  </TabItem>

  <TabItem value="rust-legacy" label="ü¶Ä Rust (legacy)">
    <Github fname="lib.rs" language="rust" 
            url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/legacy/src/lib.rs" start="33" end="62"/>

  :::tip

  Notice how we use `enums` to ensure all collections have a different prefix. Another advantage of using `enums` is that they are serialized into a single `byte` prefix. 

  :::

  </TabItem>

</Tabs>

:::danger

Be careful of not using the same prefix in two collections, otherwise, their storage space will collide, and you might overwrite information from one collection when writing in the other

:::

<hr className="subsection" />

### Vector

Implements a [vector/array](https://en.wikipedia.org/wiki/Array_data_structure) which persists in the contract's storage. Please refer to the Rust and JS SDK's for a full reference on their interfaces.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">
    <Github fname="contract.ts" language="js"
            url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts"
            start="48" end="73" />
  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
    <Github fname="vector.rs" language="rust"
            url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/vector.rs" start="4" end="29"/>
  </TabItem>
  <TabItem value="rust-legacy" label="ü¶Ä Rust (legacy)">
    <Github fname="vector.rs" language="rust"
            url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/legacy/src/vector.rs" start="6" end="31"/>
  </TabItem>
</Tabs>

<hr className="subsection" />

### LookupMap

Implements a [map/dictionary](https://en.wikipedia.org/wiki/Associative_array) which persists in the contract's storage. Please refer to the Rust and JS SDK's for a full reference on their interfaces.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">
    <Github fname="contract.ts" language="js"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts"
          start="111" end="131" />
  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
    <Github fname="lookup_map.rs" language="rust"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/lookup_map.rs" start="4" end="22"/>
  </TabItem>
</Tabs>

<hr className="subsection" />

### UnorderedMap / IterableMap

Implements a [map/dictionary](https://en.wikipedia.org/wiki/Associative_array) which persists in the contract's storage. Please refer to the Rust and JS SDK's for a full reference on their interfaces.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">
    <Github fname="contract.ts" language="js"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts"
          start="132" end="152" />
  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
    <Github fname="iterable_map.rs" language="rust"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/iterable_map.rs" start="4" end="29"/>
  </TabItem>
</Tabs>

<hr className="subsection" />

### LookupSet

Implements a [set](https://en.wikipedia.org/wiki/Set_(abstract_data_type)) which persists in the contract's storage. Please refer to the Rust and JS SDK's for a full reference on their interfaces.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">
    <Github fname="contract.ts" language="js"
      url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts" start="74" end="89" />
  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">
      <Github fname="lookup_set.rs" language="rust"
        url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/lookup_set.rs" start="4" end="18"/>
  </TabItem>

</Tabs>

<hr className="subsection" />

### UnorderedSet / IterableSet

Implements a [map/dictionary](https://en.wikipedia.org/wiki/Associative_array) which persists in the contract's storage. Please refer to the Rust and JS SDK's for a full reference on their interfaces.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">
    <Github fname="contract.ts" language="js"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts"
          start="90" end="110" />
  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
    <Github fname="iterable_set.rs" language="rust"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/iterable_set.rs" start="4" end="26"/>
  </TabItem>
</Tabs>

<hr className="subsection" />

### Tree

An ordered equivalent of Map. The underlying implementation is based on an [AVL](https://en.wikipedia.org/wiki/AVL_tree). You should use this structure when you need to: have a consistent order, or access the min/max keys.

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust">
    <Github fname="tree.rs" language="rust"
          url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/legacy/src/tree.rs" start="6" end="24"/>
  </TabItem>
</Tabs>

<hr class="subsection" />

### LazyOption (Legacy)

LazyOptions are great to store large values (i.e. a wasm file), since its value will not be read from storage until it is interacted with.

It acts like an `Option` that can either hold a value or not and also requires a unique prefix (a key in this case)
like other persistent collections.

Compared to other collections, `LazyOption` only allows you to initialize the value during initialization.

---

## Nesting Collections

When nesting SDK collections, be careful to **use different prefixes** for all collections, including the nested ones.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

    <Github fname="nested.ts" language="js"
            url="https://github.com/near-examples/storage-examples/blob/main/collections-js/src/contract.ts" start="153" end="196"/>

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="nested.ts" language="rust"
            url="https://github.com/near-examples/storage-examples/blob/main/collections-rs/store/src/nested.rs" start="4" end="30"/>

  :::tip

  Notice how we use `enums` that take a `String` argument to ensure all collections have a different prefix

  :::

  </TabItem>
</Tabs>


---

## Error prone patterns

Because the values are not kept in memory and are lazily loaded from storage, it's important to make sure if a collection is replaced or removed, that the storage is cleared. In addition, it is important that if the collection is modified, the collection itself is updated in state because most collections will store some metadata.

Some error-prone patterns to avoid that cannot be restricted at the type level are:

<Tabs>
<TabItem value="rust" label="ü¶Ä Rust">

```rust
use near_sdk::store::UnorderedMap;

let mut m = UnorderedMap::<u8, String>::new(b"m");
m.insert(1, "test".to_string());
assert_eq!(m.len(), 1);
assert_eq!(m.get(&1), Some(&"test".to_string()));

// Bug 1: Should not replace any collections without clearing state, this will reset any
// metadata, such as the number of elements, leading to bugs. If you replace the collection
// with something with a different prefix, it will be functional, but you will lose any
// previous data and the old values will not be removed from storage.
m = UnorderedMap::new(b"m");
assert!(m.is_empty());
assert_eq!(m.get(&1), Some(&"test".to_string()));

// Bug 2: Should not use the same prefix as another collection
// or there will be unexpected side effects.
let m2 = UnorderedMap::<u8, String>::new(b"m");
assert!(m2.is_empty());
assert_eq!(m2.get(&1), Some(&"test".to_string()));

// Bug 3: forgetting to save the collection in storage. When the collection is attached to
// the contract state (`self` in `#[near]`) this will be done automatically, but if
// interacting with storage manually or working with nested collections, this is relevant.
use near_sdk::store::Vector;

// Simulate roughly what happens during a function call that initializes state.
{
    let v = Vector::<u8>::new(b"v");
    near_sdk::env::state_write(&v);
}

// Simulate what happens during a function call that just modifies the collection
// but does not store the collection itself.
{
    let mut v: Vector<u8> = near_sdk::env::state_read().unwrap();
    v.push(1);
    // The bug is here that the collection itself if not written back
}

let v: Vector<u8> = near_sdk::env::state_read().unwrap();
// This will report as if the collection is empty, even though the element exists
assert!(v.get(0).is_none());
assert!(
    near_sdk::env::storage_read(&[b"v".as_slice(), &0u32.to_le_bytes()].concat()).is_some()
);

// Bug 4 (only relevant for `near_sdk::store`): These collections will cache writes as well
// as reads, and the writes are performed on [`Drop`](https://doc.rust-lang.org/std/ops/trait.Drop.html)
// so if the collection is kept in static memory or something like `std::mem::forget` is used,
// the changes will not be persisted.
use near_sdk::store::IterableSet;

let mut m: IterableSet<u8> = IterableSet::new(b"l");
m.insert(1);
assert!(m.contains(&1));

// This would be the fix, manually flushing the intermediate changes to storage.
// m.flush();
std::mem::forget(m);

m = IterableSet::new(b"l");
assert!(!m.contains(&1));
```

<hr class="subsection" />

### Nesting Errors

By extension of the error-prone patterns to avoid mentioned in the [collections section](./collections.md#error-prone-patterns), it is important to keep in mind how these bugs can easily be introduced into a contract when using nested collections.

Some issues for more context:
- https://github.com/near/near-sdk-rs/issues/560
- https://github.com/near/near-sdk-rs/issues/703

The following cases are the most commonly encountered bugs that cannot be restricted at the type level (only relevant for `near_sdk::collections`, not `near_sdk::store`):

```rust
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::BorshStorageKey;

#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Root,
    Nested(u8),
}

// Bug 1: Nested collection is removed without clearing its own state.
let mut root: LookupMap<u8, UnorderedSet<String>> = LookupMap::new(StorageKey::Root);
let mut nested = UnorderedSet::new(StorageKey::Nested(1));
nested.insert(&"test".to_string());
root.insert(&1, &nested);

// Remove inserted collection without clearing its sub-state.
let mut _removed = root.remove(&1).unwrap();

// This line would fix the bug:
// _removed.clear();

// This collection will now be in an inconsistent state if an empty UnorderedSet is put
// in the same entry of `root`.
root.insert(&1, &UnorderedSet::new(StorageKey::Nested(1)));
let n = root.get(&1).unwrap();
assert!(n.is_empty());
assert!(n.contains(&"test".to_string()));

// Bug 2: Nested collection is modified without updating the collection itself in the outer collection.
//
// This is fixed at the type level in `near_sdk::store` because the values are modified
// in-place and guarded by regular Rust borrow-checker rules.
root.insert(&2, &UnorderedSet::new(StorageKey::Nested(2)));

let mut nested = root.get(&2).unwrap();
nested.insert(&"some value".to_string());

// This line would fix the bug:
// root.insert(&2, &nested);

let n = root.get(&2).unwrap();
assert!(n.is_empty());
assert!(n.contains(&"some value".to_string()));
```

</TabItem>
</Tabs>

---

## Pagination

Persistent collections such as `IterableMap/UnorderedMap`, `IterableSet/UnorderedSet` and `Vector` may
contain more elements than the amount of gas available to read them all.
In order to expose them all through view calls, we can use pagination.



<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">
    With JavaScript this can be done using iterators with [`toArray`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Iterator/toArray) and [`slice`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).

    ```ts
      /// Returns multiple elements from the `UnorderedMap`.
      /// - `from_index` is the index to start from.
      /// - `limit` is the maximum number of elements to return.
      @view({})
      get_updates({ from_index, limit }: { from_index: number, limit:number }) {
        return this.status_updates.toArray().slice(from_index, limit);
      }
    ```
  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">
    With Rust this can be done using iterators with [`Skip`](https://doc.rust-lang.org/std/iter/struct.Skip.html) and [`Take`](https://doc.rust-lang.org/std/iter/struct.Take.html). This will only load elements from storage within the range.

    ```rust
      #[near(contract_state)]
      #[derive(PanicOnDefault)]
      pub struct Contract {
          pub status_updates: IterableMap<AccountId, String>,
      }

      #[near]
      impl Contract {
          /// Retrieves multiple elements from the `IterableMap`.
          /// - `from_index` is the index to start from.
          /// - `limit` is the maximum number of elements to return.
          pub fn get_updates(&self, from_index: usize, limit: usize) -> Vec<(AccountId, String)> {
              self.status_updates
                  .iter()
                  .skip(from_index)
                  .take(limit)
                  .collect()
          }
      }
    ```
  </TabItem>
</Tabs>

---

## Storage Cost
Your contract needs to lock a portion of their balance proportional to the amount of data they stored in the blockchain. This means that:
- If more data is added and the **storage increases ‚Üë**, then your contract's **balance decreases ‚Üì**.
- If data is deleted and the **storage decreases ‚Üì**, then your contract's **balance increases ‚Üë**. 

Currently, it costs approximately **1 ‚ìÉ** to store **100kb** of data.

:::info

You can save on smart contract storage if using NEAR Account IDs by encoding them using base32. Since they consist of `[a-z.-_]` characters with a maximum length of 64 characters, they can be encoded using 5 bits per character, with terminal `\0`. Going to a size of 65 * 5 = 325 bits from the original (64 + 4) * 8 = 544 bits. This is a 40% reduction in storage costs

:::

:::caution

Your contract will panic if you try to store data but don't have NEAR to cover its storage cost

:::

:::warning

Be mindful of potential [small deposit attacks](../security/storage.md)

:::

---

## Storage Constraints on NEAR

For storing data on-chain it‚Äôs important to keep in mind the following:

- There is a 4mb limit on how much you can upload at once

Let‚Äôs say for example, someone wants to put an NFT purely on-chain (rather than IPFS or some other decentralized storage solution) you‚Äôll have almost an unlimited amount of storage but will have to pay 1 $NEAR per 100kb of storage used.

Users will be limited to 4MB per contract call upload due to MAX_GAS constraints. The maximum amount of gas one can attach to a given functionCall is 300TGas.


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/crosscontract.md 

 ---
id: crosscontract
title: Cross-Contract Calls
---

import {CodeTabs, Language, Github} from '@site/src/components/codetabs'
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Your contract can interact with other deployed contracts, **querying** information and **executing functions** on them.

Since NEAR is a sharded blockchain, its cross-contract calls behave differently than calls do in other chains. In NEAR. cross-contract calls are asynchronous and independent.

:::info Cross-Contract Calls are **Independent**

You will need two independent functions: one to make the call, and another to receive the result

:::

:::info Cross-Contract Calls are **Asynchronous**

There is a delay between the call and the callback execution, usually of **1 or 2 blocks**. During this time, the contract is still active and can receive other calls.

:::

---

## Snippet: Querying Information

While making your contract, it is likely that you will want to query information from another contract. Below, you can see a basic example in which we query the greeting message from our [Hello NEAR](../quickstart.md) example.

<CodeTabs>
<Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="18" end="52" />

</Language>

<Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="1" end="29" />
    <Github fname="external_contract.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/external_contract.rs"
            start="1" end="8" />
    <Github fname="high_level.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/high_level.rs"
            start="8" end="37" />
    <Github fname="low_level.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/low_level.rs"
            start="7" end="39" />

</Language>

</CodeTabs>

---

## Snippet: Sending Information
Calling another contract passing information is also a common scenario. Below you can see a function that interacts with the [Hello NEAR](../quickstart.md) example to change its greeting message.

<CodeTabs>
<Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="54" end="87" />

</Language>

<Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="1" end="29" />
    <Github fname="external_contract.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/external_contract.rs"
            start="1" end="8" />
    <Github fname="high_level.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/high_level.rs"
            start="39" end="66" />
    <Github fname="low_level.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/low_level.rs"
            start="41" end="72" />

</Language>

</CodeTabs>

---

## Promises
Cross-contract calls work by creating two promises in the network:
1. A promise to execute code in the external contract (`Promise.create`)
2. Optional: A promise to call another function with the result (`Promise.then`)

Both promises will contain the following information:

- The address of the contract you want to interact with
- The function that you want to execute
- The (**encoded**) arguments to pass to the function
- The amount of GAS to use (deducted from the **attached Gas**)
- The amount of NEAR to attach (deducted from **your contract‚Äôs balance**)

:::tip

The callback can be made to **any** contract. Meaning that the result could potentially be handled by another contract

:::


<hr class="subsection" />

### Creating a Cross Contract Call

To create a cross-contract call with a callback, create two promises and use the `.then` method to link them:


<Tabs>
  <TabItem value="js" label="üåê JavaScript">

    ```ts
    NearPromise.new("external_address").functionCall("function_name", JSON.stringify(arguments), DEPOSIT, GAS)
    .then(
      // this function is the callback
      NearPromise.new(near.currentAccountId()).functionCall("callback_name", JSON.stringify(arguments), DEPOSIT, GAS)
    );
    ```

  </TabItem>
  <TabItem value="rs" label="ü¶Ä Rust">

    There is a helper macro that allows you to make cross-contract calls with the syntax `#[ext_contract(...)]`. It takes a Rust Trait and converts it to a module with static methods. Each of these static methods takes positional arguments defined by the Trait, then the `receiver_id`, the attached deposit and the amount of gas and returns a new `Promise`. *That's the high-level way to make cross-contract calls.*

    ```rust
    #[ext_contract(external_trait)]
    trait Contract {
        fn function_name(&self, param1: T, param2: T) -> T;
    }

    external_trait::ext("external_address")
    .with_attached_deposit(DEPOSIT)
    .with_static_gas(GAS)
    .function_name(arguments)
    .then(
      // this is the callback
      Self::ext(env::current_account_id())
      .with_attached_deposit(DEPOSIT)
      .with_static_gas(GAS)
      .callback_name(arguments)
    );

    ```

    <hr class="subsection" />

    There is another way to achieve the same result. You can create a new `Promise` without using a helper macro. *It's the low-level way to make cross-contract calls.*

    ```rust
    let arguments = json!({ "foo": "bar" })
        .to_string()
        .into_bytes();

    let promise = Promise::new("external_address").function_call(
        "function_name".to_owned(),
        arguments,
        DEPOSIT,
        GAS
    );

    promise.then(
        // Create a promise to callback query_greeting_callback
        Self::ext(env::current_account_id())
            .with_static_gas(GAS)
            .callback_name(),
    );

    ```

<details>
<summary> Gas </summary>

You can attach an unused GAS weight by specifying the `.with_unused_gas_weight()` method but it is defaulted to 1. The unused GAS will be split amongst all the functions in the current execution depending on their weights. If there is only 1 function, any weight above 1 will result in all the unused GAS being attached to that function. If you specify a weight of 0, however, the unused GAS will **not** be attached to that function. If you have two functions, one with a weight of 3, and one with a weight of 1, the first function will get `3/4` of the unused GAS and the other function will get `1/4` of the unused GAS.

</details>

  </TabItem>
</Tabs>

:::info

If a function returns a promise, then it will delegate the return value and status of transaction execution, but if you return a value or nothing, then the `Promise` result will not influence the transaction status

:::

:::caution

The Promises you are creating will **not execute immediately**. In fact, they will be queued in the network an:
- The cross-contract call will execute 1 or 2 blocks after your function finishes **correctly**.

:::

---

## Callback Function
If your function finishes correctly, then eventually your callback function will execute. This will happen whether the **external contract fails or not**.

In the callback function you will have access to the result, which will contain the status of the external function (if it worked or not), and the values in case of success.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="42" end="53" />

</Language>

<Language value="rust" language="rust">

  <Github fname="high_level.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/high_level.rs"
            start="23" end="37" />

</Language>

</CodeTabs>

:::info Callback with always execute

We repeat, if your function finishes correctly, then your callback will **always execute**. This will happen no matter if the external function finished correctly or not

:::

:::warning

Always make sure to have enough Gas for your callback function to execute

:::

:::tip

Remember to mark your callback function as private using macros/decorators, so it can only be called by the contract itself

:::

<hr class="subsection" />

### What happens if the function I call fails?
If the external function fails (i.e. it panics), then your callback will be **executed anyway**. Here you need to **manually rollback** any changes made in your
contract during the original call. Particularly:

1. **Refund the predecessor** if needed: If the contract attached NEAR to the call, the funds are now back in **the contract's account**
2. **Revert any state changes**: If the original function made any state changes (i.e. changed or stored data), you need to manually roll them back. **They won't revert automatically**

:::warning
If your original function finishes correctly then the callback executes **even if the external function panics**. Your state will **not** rollback automatically,
and $NEAR will **not** be returned to the signer automatically. Always make sure to check in the callback if the external function failed, and manually rollback any
operation if necessary.
:::

---

## Concatenating Functions and Promises

‚úÖ Promises can be concatenate using the `.and` operator: `P1.and(P2).and(P3).then(P4)`: `P1`, `P2`, and `P3` execute in parallel, after they finish, `P4` will execute and have access to all their results

‚õî You cannot **return** a joint promise without a callback: `return P1.and(P2)` is invalid since it misses the `then`

‚úÖ You can concatenate `then` promises: `P1.then(P2).then(P3)`: `P1` executes, then `P2` executes with the result of `P1`, then `P3` executes with the result of `P2`

‚õî You cannot use an `and` within a `then`: `P1.then(P2.and(P3))` is invalid

‚õî You cannot use a `then` within a `then`: `P1.then(P2.then(P3))` is invalid

<hr class="subsection" />

### Multiple Functions, Same Contract

You can call multiple functions in the same external contract, which is known as a **batch call**.

An important property of batch calls is that they **act as a unit**: they execute in the same [receipt](/concepts/protocol/transaction-execution#receipts--finality), and if **any function fails**, then they **all get reverted**.

<Tabs>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="batch_actions" language="js"
        url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/batch_actions.ts"
        start="5" end="17" />

  </TabItem>
  <TabItem value="rs" label="ü¶Ä Rust">

  <Github fname="lib.ts" language="rust"
        url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/batch_actions.rs"
        start="8" end="20" />

  </TabItem>
</Tabs>

:::tip

Callbacks only have access to the result of the **last function** in a batch call

:::

---

### Multiple Functions: Different Contracts

You can also call multiple functions in **different contracts**. These functions will be executed in parallel, and do not impact each other. This means that, if one fails, the others **will execute, and NOT be reverted**.

<Tabs>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="lib.ts" language="js"
        url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/multiple_contracts.ts"
        start="6" end="21" />

  </TabItem>
  <TabItem value="rs" label="ü¶Ä Rust">

  <Github fname="lib.rs" language="rust"
        url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/multiple_contracts.rs"
        start="17" end="55" />

  </TabItem>
</Tabs>

:::tip

Callbacks have access to the result of **all functions** in a parallel call

:::


---

## Security Concerns

While writing cross-contract calls there is a significant aspect to keep in mind: all the calls are **independent** and **asynchronous**. In other words:

- The function in which you make the call and function for the callback are **independent**.
- There is a **delay between the call and the callback**, in which people can still interact with the contract

This has important implications on how you should handle the callbacks. Particularly:

1. Make sure you don't leave the contract in a exploitable state between the call and the callback.
2. Manually rollback any changes to the state in the callback if the external call failed.

We have a whole [security section](../security/callbacks.md) dedicated to these specific errors, so please go and check it.

:::warning
Not following these basic security guidelines could expose your contract to exploits. Please check the [security section](../security/callbacks.md), and if still in doubt, [join us in Discord](https://near.chat).
:::


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/environment.md 

 ---
id: environment
title: Environment
#sidebar_label: üèûÔ∏è Environment
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Every method execution has an environment associated with information such as:

1. Who called the method
2. How much money is attached to the call
3. How many computational resources are available
4. The current timestamp
5. Helper functions for Public Key derivation, for example

---

## Environment Variables

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

| Variable Name          | SDK Variable                  | Description                                                                          |
|------------------------|-------------------------------|--------------------------------------------------------------------------------------|
| Predecessor            | `near.predecessorAccountId()` | Account ID that called this method                                                   |
| Current Account        | `near.currentAccountId()`     | Account ID of this smart contract                                                    |
| Signer                 | `near.signerAccountId()`      | Account ID that signed the transaction leading to this execution                     |
| Attached Deposit       | `near.attachedDeposit()`      | Amount in yoctoNEAR attached to the call by the predecessor                          |
| Account Balance        | `near.accountBalance()`       | Balance of this smart contract (including Attached Deposit)                          |
| Prepaid Gas            | `near.prepaidGas()`           | Amount of gas available for execution                                                |
| Timestamp              | `near.blockTimestamp()`       | Current timestamp (number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC) |
| Current Epoch          | `near.epochHeight()`          | Current epoch in the blockchain                                                      |
| Block Index            | `near.blockIndex()`           | Current block index (a.k.a. block height)                                            |
| Storage Used           | `near.storageUsage()`         | Current storage used by this smart contract                                          |
| Used Gas               | `near.usedGas()`              | Amount of gas used for execution                                                     |
| Signer Public Key      | `near.signerAccountPk()`      | Sender Public Key                                                                    |
| Account Locked Balance | `near.accountLockedBalance()` | Balance of this smart contract that is locked                                        |

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

| Variable Name          | SDK Variable                    | Description                                                                          |
|------------------------|---------------------------------|--------------------------------------------------------------------------------------|
| Predecessor            | `env::predecessor_account_id()` | Account ID that called this method                                                   |
| Current Account        | `env::current_account_id()`     | Account ID of this smart contract                                                    |
| Signer                 | `env::signer_account_id()`      | Account ID that signed the transaction leading to this execution                     |
| Attached Deposit       | `env::attached_deposit()`       | Amount in yoctoNEAR attached to the call by the predecessor                          |
| Account Balance        | `env::account_balance()`        | Balance of this smart contract (including Attached Deposit)                          |
| Prepaid Gas            | `env::prepaid_gas()`            | Amount of gas available for execution                                                |
| Timestamp              | `env::block_timestamp()`        | Current timestamp (number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC) |
| Current Epoch          | `env::epoch_height()`           | Current epoch in the blockchain                                                      |
| Block Index            | `env::block_index()`            | Current block index (a.k.a. block height)                                            |
| Storage Used           | `env::storage_usage()`          | Current storage used by this smart contract in bytes                                 |
| Storage Byte Cost      | `env::storage_byte_cost()`      | Current storage cost per byte in yoctoNEAR                                           |
| Used Gas               | `env::used_gas()`               | Amount of gas used for execution                                                     |
| Signer Public Key      | `env::signer_account_pk()`      | Sender Public Key                                                                    |
| Account Locked Balance | `env::account_locked_balance()` | Balance of this smart contract that is locked                                        |

</TabItem>

</Tabs>

---

## Who is Calling? Who am I?

The environment gives you access to 3 important users: the `current_account`, the `predecessor`, and the `signer`.

### Current Account

The `current_account` contains the address in which your contract is deployed. This is very useful to implement ownership, e.g. making a public method only callable by the contract itself.

### Predecessor and Signer

The `predecessor` is the account that called the method in the contract. Meanwhile, the `signer` is the account that _signed_ the initial transaction.

During a simple transaction (no [cross-contract calls](../anatomy/crosscontract.md)) the `predecessor` is the same as the `signer`. For example, if **alice.near** calls **contract.near**, from the contract's perspective, **alice.near** is both the `signer` and the `predecessor`. However, if **contract.near** creates a [cross-contract call](../anatomy/crosscontract.md), then the `predecessor` changes down the line. In the example below, when **pool.near** executes, it would see **contract.near** as the `predecessor` and **alice.near** as the `signer`.

![img](https://miro.medium.com/max/1400/1*LquSNOoRyXpITQF9ugsDpQ.png)
*You can access information about the users interacting with your smart contract*

:::tip
In most scenarios you will **only need to know the predecessor**. However, there are situations in which the signer is very useful. For example, when adding [NFTs](../../5.primitives/nft.md) into [this marketplace](https://github.com/near-examples/nft-tutorial/blob/7fb267b83899d1f65f1bceb71804430fab62c7a7/market-contract/src/nft_callbacks.rs#L42), the contract checks that the `signer`, i.e. the person who generated the transaction chain, is the NFT owner.
:::

---

## Balances and Attached NEAR
The environment gives you access to 3 token-related parameters, all expressed in yoctoNEAR (1 ‚ìÉ = 10<sup>24</sup>y‚ìÉ):

### Attached Deposit
`attached_deposit` represents the amount of yoctoNEAR the predecessor attached to the call.

This amount is **already deposited** in your contract's account, and is **automatically returned** to the `predecessor` if your **method panics**.

:::warning
If you make a [cross-contract call](../anatomy/crosscontract.md) and it panics, the funds are sent back to **your contract**. See how to handle this situation in the [callback section](../anatomy/crosscontract.md#what-happens-if-the-function-i-call-fails)
:::

### Account Balance

`account_balance` represents the balance of your contract (`current_account`).

It includes the `attached_deposit`, since it was deposited when the method execution started.

If the contract has any locked $NEAR, it will appear in `account_locked_balance`.

---

### Storage Used

`storage_used` represents the amount of [storage](../anatomy/storage.md) that is currently being used by your contract.

:::tip
If you want to know how much storage a structure uses, print the storage before and after storing it.
:::

---

## Telling the Time

The environment exposes three different ways to tell the pass of time, each representing a different dimension of the underlying blockchain.

### Timestamp

The `timestamp` attribute represents the approximated **UNIX timestamp** in **nanoseconds** at which this call was executed. It quantifies time passing in a human way, enabling us to check if a specific date has passed or not.

### Current Epoch

The NEAR blockchain groups blocks in [Epochs](../../../1.concepts/basics/epoch.md). The `current_epoch` attribute measures how many epochs have passed so far. It is very useful to coordinate with other contracts that measure time in epochs, such as the [validators](../../../1.concepts/basics/validators.md).

### Block Index

The `block_index` represents the index of the block in which this transaction will be added to the blockchain.

---

## Gas

Your contract has a **limited number of computational resources** to use on each call. Such resources are measured in [Gas](/concepts/protocol/gas).

Gas can be thought of as wall time, where 1 PetaGas (1_000 TGas) is ~1 second of compute time.

Each code instruction costs a certain amount of Gas, and if you run out of it, the execution halts with the error message `Exceeded the prepaid gas`.

The environment gives you access to two gas-related arguments: `prepaid_gas` and `used_gas`.

### Prepaid Gas
`prepaid_gas` represents the amount of Gas the `predecessor` attached to this call. It cannot exceed the limit 300TGas (300 * 10<sup>12</sup> Gas).

### Used Gas
`used_gas` contains the amount of Gas that has been used so far. It is useful to estimate the Gas cost of running a method.

:::warning
During [cross-contract calls](./crosscontract.md) always make sure the callback has enough Gas to fully execute.
:::

:::tip

If you already [estimated the Gas](../../../1.concepts/protocol/gas.md#estimating-costs-for-a-call) a method needs, you can ensure it never runs out of Gas by using `assert`

<Tabs className="language-tabs" groupId="code-tabs">
<TabItem value="rust" label="ü¶Ä Rust">

```rust
const REQUIRED_GAS: Gas = Gas(20_000_000_000_000); // 20 TGas
assert!(env::prepaid_gas() >= REQUIRED_GAS, "Please attach at least 20 TGas");
```

</TabItem>

</Tabs>

:::

---

## Environment Functions

Besides environmental variables, the SDK also exposes some functions to perform basic cryptographic operations

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

| Function Name         | SDK method                                       | Description                                                                                                                                                                                                                                                                                                                      |
|-----------------------|--------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SHA 256               | `near.sha256(value)`                             | Hashes a sequence of bytes using sha256.                                                                                                                                                                                                                                                                                         |
| Keccak 256            | `near.keccak256(value)`                          | Hashes a sequence of bytes using keccak256.                                                                                                                                                                                                                                                                                      |
| Keccak 512            | `near.keccak512(value)`                          | Hashes a sequence of bytes using keccak512.                                                                                                                                                                                                                                                                                      |
| RIPEMD 160            | `near.ripemd160(value)`                          | Hashes the bytes using the RIPEMD-160 hash function.                                                                                                                                                                                                                                                                             |
| EC Recover            | `near.ecrecover(hash, sig, v, malleabilityFlag)` | Recovers an ECDSA signer address from a 32-byte message `hash` and a corresponding `signature` along with `v` recovery byte. Takes in an additional flag to check for malleability of the signature which is generally only ideal for transactions. Returns 64 bytes representing the public key if the recovery was successful. |
| Log String            | `near.log(msg)`                                  | Logs the string message. This message is stored on chain.                                                                                                                                                                                                                                                                        |
| Validator Stake       | `near.validatorStake(accountId)`                 | For a given account return its current stake. If the account is not a validator, returns 0.                                                                                                                                                                                                                                      |
| Validator Total Stake | `near.validatorTotalStake()`                     | Returns the total stake of validators in the current epoch.                                                                                                                                                                                                                                                                      |

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

| Function Name         | SDK method                                              | Description                                                                                                                                                                                                                                                                                                                      |
|-----------------------|---------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SHA 256               | `env::sha256(value)`                                    | Hashes a sequence of bytes using sha256.                                                                                                                                                                                                                                                                                         |
| Keccak 256            | `env::keccak256(value)`                                 | Hashes a sequence of bytes using keccak256.                                                                                                                                                                                                                                                                                      |
| Keccak 512            | `env::keccak512(value)`                                 | Hashes a sequence of bytes using keccak512.                                                                                                                                                                                                                                                                                      |
| SHA 256 (Array)       | `env::sha256_array(value)`                              | Hashes the bytes using the SHA-256 hash function. This returns a 32 byte hash.                                                                                                                                                                                                                                                   |
| Keccak 256 (Array)    | `env::keccak256_array(value)`                           | Hashes the bytes using the Keccak-256 hash function. This returns a 32 byte hash.                                                                                                                                                                                                                                                |
| Keccak 512 (Array)    | `env::keccak512_array(value)`                           | Hashes the bytes using the Keccak-512 hash function. This returns a 64 byte hash.                                                                                                                                                                                                                                                |
| RIPEMD 160 (Array)    | `env::ripemd160_array(value)`                           | Hashes the bytes using the RIPEMD-160 hash function. This returns a 20 byte hash.                                                                                                                                                                                                                                                |
| EC Recover            | `env::ecrecover(hash, signature, v, malleability_flag)` | Recovers an ECDSA signer address from a 32-byte message `hash` and a corresponding `signature` along with `v` recovery byte. Takes in an additional flag to check for malleability of the signature which is generally only ideal for transactions. Returns 64 bytes representing the public key if the recovery was successful. |
| Panic String          | `env::panic_str(message)`                               | Terminates the execution of the program with the UTF-8 encoded message.                                                                                                                                                                                                                                                          |
| Log String            | `env::log_str(message)`                                 | Logs the string message. This message is stored on chain.                                                                                                                                                                                                                                                                        |
| Validator Stake       | `env::validator_stake(account_id)`                      | For a given account return its current stake. If the account is not a validator, returns 0.                                                                                                                                                                                                                                      |
| Validator Total Stake | `env::validator_total_stake()`                          | Returns the total stake of validators in the current epoch.                                                                                                                                                                                                                                                                      |

</TabItem>

</Tabs>

:::info
In the JS SDK, `throw new Error("message")` mimics the behavior of Rust's `env::panic_str("message")`.
:::

---


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/functions.md 

 ---
id: functions
title: External Interface
hide_table_of_contents: true
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs";
import CodeBlock from '@theme/CodeBlock';
import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Smart contracts expose functions so users can interact with them. There are different types of functions including `read-only`, `private` and `payable`.

<ExplainCode languages="js,rust">

<Block highlights='{"js": "16-20,23-42,45-50,53-55,58-60", "rust": "24-34,37-62,64-75,77-79,81-83"}' fname="auction">

### Contract's Interface

All **public** functions in the contract are part of its **interface**. They can be called by anyone, and are the only way to interact with the contract.

</Block>

<Block highlights='{"rust": ""}' fname="auction" type='details'>

<details>
<summary> Exposing trait implementations </summary>

Functions can also be exposed through trait implementations. This can be useful if implementing a shared interface or standard for a contract. This code generation is handled very similarly to basic `pub` functions, but the `#[near]` macro only needs to be attached to the trait implementation, not the trait itself:

```rust
pub trait MyTrait {
    fn trait_method(&mut self);
}

#[near]
impl MyTrait for MyContractStructure {
    fn trait_method(&mut self) {
        // .. method logic here
    }
}
```
</details>

</Block>

<Block highlights='{"js":"15-20", "rust": "22-34"}' fname="auction">

### Initialization Functions
A contract can opt to have an initialization function. If present, this function must be called before any other to [initialize the contract](./storage.md).

</Block>

<Block highlights='{"js": "15"}' fname="auction">

#### `@initialize({ privateFunction: true })`
The initialization function is marked with the `@initialize` decorator.

</Block>

<Block highlights='{"rust": "22"}' fname="auction">

#### `#[init]`
The initialization function is marked with the `#[init]` macro.

</Block>

<Block highlights='{"js":"22-42,44-50", "rust": "37-62,64-75"}' fname="auction">

### State Changing Functions
The functions that modify the [state](./storage.md) or perform [actions](./actions.md) need to be called by a user with a NEAR account, since a transaction is required to execute them.

</Block>

<Block highlights='{"js": "22,44"}' fname="auction">

#### `@call`
State changing functions are marked with the `@call` decorator.

</Block>

<Block highlights='{"rust": "37,64"}' fname="auction">

#### `&mut self`
State changing functions are those that take a **mutable** reference to `self` in Rust.

</Block>

<Block highlights='{"js": "25,28,29", "rust": "40,45,46"}' fname="auction" type='info'>

:::tip

The SDK provides [contextual information](./environment.md), such as which account is calling the function, or what time it is.

:::

</Block>

<Block highlights='{"js":"52-55,57-60", "rust": "77-79,81-83"}' fname="auction">

### Read-Only Functions
Contract's functions can be read-only, meaning they don't modify the state. Calling them is free for everyone, and does not require to have a NEAR account.

</Block>

<Block highlights='{"js": "52,57"}' fname="auction">

#### `@view`
Read-only functions are marked with the `@view` decorator in TS/JS.

</Block>

<Block highlights='{"rust": "77,81"}' fname="auction">

#### `&self`
Read-only functions are those that take an **immutable** reference to `self` in Rust.

</Block>

<Block highlights='{"js":"15", "rust": "23"}' fname="auction">

### Private Functions
Many times you will want to have functions that **are exposed** as part of the contract's interface, but **should not be called directly** by users.

Besides initialization functions, [callbacks from cross-contract calls](./crosscontract.md) should always be `private`.

These functions are marked as `private` in the contract's code, and can only be called by the contract itself.

</Block>

<Block highlights='{"js": "15"}' fname="auction">

#### `decorator({privateFunction: true})`
Private functions are marked by setting `privateFunction: true` in the `@call` or `@initialize` decorators.

</Block>

<Block highlights='{"rust": "23"}' fname="auction">

#### [#private]
Private functions are marked using the `#[private]` macro in Rust.

</Block>

<Block highlights='{"js":"22,28", "rust": "36,45"}' fname="auction">

### Payable Functions
By default, functions will panic if the user attaches NEAR Tokens to the call. Functions that accept NEAR Tokens must be marked as `payable`.

Within the function, the user will have access to the [attached deposit](./environment.md).

</Block>

<Block highlights='{"js": "22,28"}' fname="auction">

#### `@call({payableFunction: true})`
Payable functions are marked by setting `payableFunction: true` in the `@call` decorator.

</Block>

<Block highlights='{"rust": "36,45"}' fname="auction">

#### [#payable]
Payable functions are marked using the `#[payable]` macro in Rust.

</Block>

<Block highlights='{"js":"3-5"}' fname="example">

### Internal Functions
All the functions we covered so far are part of the interface, meaning they can be called by an external actor.

However, contracts can also have private internal functions - such as helper or utility functions - that are **not exposed** to the outside world.

To create internal private methods in a JS contract, simply omit the `@view` and `@call` decorators.

</Block>

<Block highlights='{"rust": "5-7"}' fname="example">

### Internal Functions
All the functions we covered so far are part of the interface, meaning they can be called by an external actor.

However, contracts can also have private internal functions - such as helper or utility functions - that are **not exposed** to the outside world.

To create internal private methods in a Rust contract, do not declare them as public (`pub fn`).

</Block>

<Block highlights='{"rust": "5-7"}' fname="example" type='details'>

  <details>
  <summary> Separate impl block </summary>

  Another way of not exporting methods is by having a separate `impl Contract` section, that is not marked with `#[near]`.

  ```rust
  #[near]
  impl Contract {
      pub fn increment(&mut self) {
          self.internal_increment();
      }
  }
  impl Contract {
      /// This methods is still not exported.
      pub fn internal_increment(&mut self) {
          self.counter += 1;
      }
  }
  ```

  </details>

</Block>


<Block highlights='{"rust": "9-11,13-15"}' fname="example">

### Pure Functions
Pure functions are a special kind of function that do not require to access data from the state.

They are useful to return hardcoded values on the contract.

</Block>

<File language="js" fname="auction" url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts" start="2" end="61" />

<File language="rust" fname="auction" url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs" start="2" end="84" />

<CodeBlock language="js" fname="example">

```js
@NearBindgen({})
class Contract {
  helper_function(params... ){
    // this function cannot be called from the outside
  }

  @view({})
  interface_view(params...){
    // this function can be called from outside
  }

  @call({privateFunction: true}){
    // this function can be called from outside, but
    // only by the contract's account
  }
}
```

</CodeBlock>

<CodeBlock language="rust" fname="example">

```rs
const SOME_VALUE: u64 = 8;

#[near]
impl MyContractStructure {
  fn internal_helper(&mut self, params... ){
    // this function cannot be called from the outside
  }

  pub fn public_log(/* Parameters here */) {
      near_sdk::log!("inside log message");
  }

  pub fn return_static_u64() -> u64 {
      SOME_VALUE
  }
}
```

</CodeBlock>

</ExplainCode>


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/reduce-size.md 

 ---
id: reduce-size
title: "Reducing Contract Size"
---
import {Github} from "@site/src/components/codetabs"

# Reducing a contract's size

## Advice & examples

This page is made for developers familiar with lower-level concepts who wish to reduce their contract size significantly, perhaps at the expense of code readability.

Some common scenarios where this approach may be helpful:

- contracts intended to be tied to one's account management
- contracts deployed using a factory
- future advancements similar to the EVM on NEAR

There have been a few items that may add unwanted bytes to a contract's size when compiled. Some of these may be more easily swapped for other approaches while others require more internal knowledge about system calls.

## Small wins

### Using flags

When compiling a contract make sure to pass flag `-C link-arg=-s` to the rust compiler:

```bash
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
```

Here is the parameters we use for the most examples in `Cargo.toml`:

```toml
[profile.release]
codegen-units = 1
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true
```

You may want to experiment with using `opt-level = "z"` instead of `opt-level = "s"` to see if generates a smaller binary. See more details on this in [The Cargo Book Profiles section](https://doc.rust-lang.org/cargo/reference/profiles.html#opt-level). You may also reference this [Shrinking .wasm Size](https://rustwasm.github.io/book/reference/code-size.html#tell-llvm-to-optimize-for-size-instead-of-speed) resource.

### Removing `rlib` from the manifest

Ensure that your manifest (`Cargo.toml`) doesn't contain `rlib` unless it needs to. Some NEAR examples have included this:

:::caution Adds unnecessary bloat

```toml
[lib]
crate-type = ["cdylib", "rlib"]
```
:::

  when it could be:

:::tip

```toml
[lib]
crate-type = ["cdylib"]
```
:::

3. When using the Rust SDK, you may override the default JSON serialization to use [Borsh](https://borsh.io) instead. [See this page](./serialization-interface.md#overriding-serialization-protocol-default) for more information and an example.
4. When using assertions or guards, avoid using the standard `assert` macros like [`assert!`](https://doc.rust-lang.org/std/macro.assert.html), [`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html), or [`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) as these may add bloat for information regarding the line number of the error. There are similar issues with `unwrap`, `expect`, and Rust's `panic!()` macro.

  Example of a standard assertion:

  :::caution Adds unnecessary bloat

  ```rust
  assert_eq!(contract_owner, predecessor_account, "ERR_NOT_OWNER");
  ```
  :::

  when it could be:

  :::tip

  ```rust
  if contract_owner != predecessor_account {
    env::panic(b"ERR_NOT_OWNER");
  }
  ```
  :::

  Example of removing `expect`:

  :::caution Adds unnecessary bloat

  ```rust
  let owner_id = self.owner_by_id.get(&token_id).expect("Token not found");
  ```
  :::

  when it could be:

  :::tip

  ```rust
  fn expect_token_found<T>(option: Option<T>) -> T {
    option.unwrap_or_else(|| env::panic_str("Token not found"))
  }
  let owner_id = expect_token_found(self.owner_by_id.get(&token_id));  
  ```
  :::

  Example of changing standard `panic!()`:

  :::caution Adds unnecessary bloat

  ```rust
  panic!("ERR_MSG_HERE"); 
  ```
  :::

  when it could be:

  :::tip

  ```rust
  env::panic_str("ERR_MSG_HERE");  
  ```
  :::

## Ready to use script
We have prepared a simple `bash` script that can be used to minify `.wasm` contract file. You can find it [here](https://github.com/near/near-sdk-rs/blob/master/minifier/minify.sh).

The current approach to minification is the following:
1. Snip (i.e. just replace with unreachable instruction) few known fat functions from the standard library (such as float formatting and panic-related) with `wasm-snip`.
2. Run `wasm-gc` to eliminate all functions reachable from the snipped functions.
3. Strip unneeded sections, such as names with `wasm-strip`.
4. Run `binaryen wasm-opt`, which cleans up the rest.

### Requirements to run the script:
- install [wasm-snip](https://docs.rs/wasm-snip/0.4.0/wasm_snip/) and [wasm-gc](https://docs.rs/crate/wasm-gc/0.1.6) with Cargo:
```bash
cargo install wasm-snip wasm-gc
```
- install [binaryen](https://github.com/WebAssembly/binaryen) and [wabt](https://github.com/WebAssembly/wabt) on your system. For Ubuntu and other Debian based Linux distributions run:
```bash
apt install binaryen wabt
```

:::danger

Minification could be rather aggressive, so you must test the contract after minification. Standalone NEAR runtime could be helpful [here](https://github.com/nearprotocol/nearcore/tree/master/runtime/near-vm-runner).

:::

## Lower-level approach

For a `no_std` approach to minimal contracts, observe the following examples:

- [Tiny contract](https://github.com/near/nearcore/tree/1e7c6613f65c23f87adf2c92e3d877f4ffe666ea/runtime/near-test-contracts/tiny-contract-rs)
- [NEAR ETH Gateway](https://github.com/ilblackdragon/near-eth-gateway/blob/master/proxy/src/lib.rs)
- [This YouTube video](https://youtu.be/Hy4VBSCqnsE) where Eugene demonstrates a fungible token in `no_std` mode. The code for this [example lives here](https://github.com/near/core-contracts/pull/88).
- [Examples using a project called `nesdie`](https://github.com/austinabell/nesdie/tree/main/examples).
- Note that Aurora has found success using [rjson](https://crates.io/crates/rjson) as a lightweight JSON serialization crate. It has a smaller footprint than [serde](https://crates.io/crates/serde) which is currently packaged with the Rust SDK. See [this example of rjson](https://github.com/aurora-is-near/aurora-engine/blob/65a1d11fcd16192cc1bda886c62005c603189a24/src/json.rs#L254) in an Aurora repository, although implementation details will have to be gleaned by the reader and won't be expanded upon here. [This nesdie example](https://github.com/austinabell/nesdie/blob/bb6beb77e32cd54077ac54bf028f262a9dfb6ad0/examples/multisig/src/utils/json/vector.rs#L26-L30) also uses the [miniserde crate](https://crates.io/crates/miniserde), which is another option to consider for folks who choose to avoid using the Rust SDK.

:::note Information on system calls

<details>
  <summary>Expand to see what's available from <code>sys.rs</code></summary>

<Github language="rust" start="" end="" url="https://github.com/near/near-sdk-rs/blob/master/near-sdk/src/environment/sys.rs" />

</details>

:::


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/reproducible-builds.md 

 ---
id: reproducible-builds
title: Reproducible Builds
---

Reproducible builds let different people build the same program and get the exact same outputs as one another. It helps users trust that deployed contracts are built correctly and correspond to the source code. To verify your contract user can build it themselves and check that the binaries are identical.

## Problem
If you will build your contract on two different machines, most likely you will get two similar but not identical binaries. Your build artifact can be affected by the locale, timezone, build path, and billion other factors in your build environment. Rust community has a long story of fighting this issue but still, [it is not achieved yet](https://github.com/rust-lang/rust/labels/A-reproducibility).

## CI solution
We recommend you to build your contracts with the use of our [Contract Builder](https://github.com/near/near-sdk-rs/tree/master/contract-builder). It's is using Docker, controlled and sharable environment that can be used by both you and your users. Docker image is available [here](https://hub.docker.com/r/nearprotocol/contract-builder). The contract built in it will result in a binary that is the same if built on other machines.


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/serialization-interface.md 

 ---
id: serialization-protocols
title: Serialization Protocols
---

import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Serialization formats within the SDK define how data structures are translated into bytes which are needed for passing data into methods of the smart contract or storing data in state. For the case of method parameters, [JSON](https://www.json.org/json-en.html) (default) and [Borsh](https://borsh.io/) are supported with the SDK and for storing data on-chain Borsh is used.

The qualities of JSON and Borsh are as follows:

JSON:
- Human-readable
- Self-describing format (don't need to know the underlying type)
- Easy interop with JavaScript
- Less efficient size and (de)serialization

Borsh:
- Compact, binary format that's efficient for serialized data size
- Need to know data format or have a schema to deserialize data
- Strict and canonical binary representation
- Fast and less overhead in most cases

In general, JSON will be used for contract calls and cross-contract calls for a better DevX, where Borsh can be used to optimize using less gas by having smaller parameter serialization and less deserialization computation within the contract.

### Overriding Serialization Protocol Default

The result and parameter serialization can be opted into separately, but all parameters must be of the same format (can't serialize some parameters as borsh and others as JSON). An example of switching both the result and parameters to borsh is as follows:

```rust
#[result_serializer(borsh)]
pub fn sum_borsh(#[serializer(borsh)] a: u32, #[serializer(borsh)] b: u32) -> u32 {
    a + b
}
```

Where the `result_serializer(borsh)` annotation will override the default result serialization protocol from JSON to borsh and the `serializer(borsh)` annotations will override the parameter serialization.

#### Example

A simple demonstration of getting a [Borsh-serialized](https://borsh.io), base64-encoded value from a unit test:

<Github language="rust" start="93" end="104" url="https://github.com/mikedotexe/rust-status-message/blob/b83c5126fdbe0f19bc904e547fda0bb12c2ea133/src/lib.rs" />

The following snippet shows a simple function that takes this value from a frontend or CLI. Note: this method doesn't have a return value, so the `#[result_serializer(borsh)]` isn't needed.

<Github language="rust" start="40" end="42" url="https://github.com/mikedotexe/rust-status-message/blob/b83c5126fdbe0f19bc904e547fda0bb12c2ea133/src/lib.rs" />

Note that this is using this simple struct:

<Github language="rust" start="13" end="17" url="https://github.com/mikedotexe/rust-status-message/blob/b83c5126fdbe0f19bc904e547fda0bb12c2ea133/src/lib.rs" />

To call this with NEAR CLI, use a command similar to this:

<Tabs groupId="cli-tabs">
<TabItem value="short" label="Short">

```bash
near call rust-status-message.demo.testnet set_status_borsh --base64 'DAAAAEFsb2hhIGhvbnVhIQ==' --accountId demo.testnet
```
</TabItem>
<TabItem value="full" label="Full">

```bash
near contract call-function as-transaction rust-status-message.demo.testnet set_status_borsh base64-args 'DAAAAEFsb2hhIGhvbnVhIQ==' prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as demo.testnet network-config testnet sign-with-keychain send
```
</TabItem>
</Tabs>


See more details in [this GitHub gist](https://gist.github.com/mfornet/d8a94af333a68d67affd8cb78464c7c0) from [Marcelo](https://gist.github.com/mfornet).

### JSON wrapper types

To help with serializing certain types to JSON which have unexpected or inefficient default formats, there are some wrapper types in [`near_sdk::json_types`](https://docs.rs/near-sdk/3.1.0/near_sdk/json_types/index.html) that can be used.

Because JavaScript only supports integers to value `2^53 - 1`, you will lose precision if deserializing the JSON integer is above this range. To counteract this, you can use the `I64`, `U64`, `I128`, and `U128` in place of the native types for these parameters or result to serialize the value as a string. By default, all integer types will serialize as an integer in JSON.

You can convert from `U64` to `u64` and back using `std::convert::Into`, e.g.

```rust
#[near]
impl Contract {
    pub fn mult(&self, a: U64, b: U64) -> U128 {
        let a: u64 = a.into();
        let b: u64 = b.into();
        let product = u128::from(a) * u128::from(b);
        product.into()
    }
}
```

You can also access inner values and using `.0`:

```diff
 #[near]
 impl Contract {
     pub fn mult(&self, a: U64, b: U64) -> U128 {
-        let a: u64 = a.into();
+        let a = a.0;
-        let b: u64 = b.into();
+        let b = b.0;
         let product = u128::from(a) * u128::from(b);
         product.into()
     }
 }
```

And you can cast the lower-case `u` variants to upper-case `U` variants using `U64(...)` and `U128(...)`:

```diff
 #[near]
 impl Contract {
     pub fn mult(&self, a: U64, b: U64) -> U128 {
         let a = a.0;
         let b = b.0;
         let product = u128::from(a) * u128::from(b);
-        product.into()
+        U128(product)
     }
 }
```

Combining it all:

```rust
#[near]
impl Contract {
    pub fn mult(&self, a: U64, b: U64) -> U128 {
        U128(u128::from(a.0) * u128::from(b.0))
    }
}
```

Although there are these JSON wrapper types included with the SDK, any custom type can be used, as long as it implements [`serde`](https://serde.rs/) serialize and deserialize respectively. All of these types just override the JSON format and will have a consistent `borsh` serialization and deserialization as the inner types.

### Base64VecU8

Another example of a type you may want to override the default serialization of is `Vec<u8>` which represents bytes in Rust. By default, this will serialize as an array of integers, which is not compact and very hard to use. There is a wrapper type [`Base64VecU8`](https://docs.rs/near-sdk/3.1.0/near_sdk/json_types/struct.Base64VecU8.html) which serializes and deserializes to a [Base-64](https://en.wikipedia.org/wiki/Base64) string for more compact JSON serialization.

Example here:

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    // Notice, internally we store `Vec<u8>` 
    pub data: Vec<u8>,
}

#[near]
impl Contract {
    #[init]
    pub fn new(data: Base64VecU8) -> Self {
        Self {
            data: data.into(),
        }
    }
    pub fn get_data(self) -> Base64VecU8 {
        self.data.into()
    }
}
```


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/serialization.md 

 ---
id: serialization
title: Notes on Serialization
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Smart contracts need to be able to **communicate complex data** in a simple way, while
also **reading and storing** such data into their states efficiently.

To achieve such simple communication and efficient storage, smart contracts morph the data
from their complex representation into simpler ones.

This process of translating **complex objects into simpler single-value** representations is called
**serialization**. NEAR uses two serialization formats: [JSON](https://www.json.org/json-en.html) and
[Borsh](https://borsh.io/).
1. [JSON](https://www.json.org/json-en.html) is used to serialize the contract's input/output during a function call
2. [Borsh](https://borsh.io/) is used to serialize the contract's state.

---

## Overview of Serialization Formats

Let's give a quick overview of both serialization formats, including their pros and cons, as well as
an example of what their serializations look like.

<hr className="subsection" />

### [JSON](https://www.json.org/json-en.html): Objects to Strings

#### Features
 - Self-describing format
 - Easy interoperability with JavaScript
 - Multiple implementations readily available
 - But... it is not efficient both in computational times and resulting size

#### Example
```js
Example{
  number: i32 = 2;
  arr: Vector<i32> = [0, 1];
}

// serializes to
"{\"number\": 2, \"arr\": [0, 1]}"
```

<hr className="subsection" />

### [Borsh](https://borsh.io/): Objects to Bytes

#### Features
  - Compact, binary format built to be efficiently (de)serialized
  - Strict and canonical binary representation
  - Less overhead: it does not need to store attributes names
  - But... it is necessary to know the schema to (de)serialize the data

#### Example
```js
Example{
  number: i32 = 2;
  arr: Vector<i32> = [0, 1];
}

// serializes into
[2, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0]
```
---

## Serializing Input & Output
NEAR contracts can implement methods that both take and return complex objects.
In order to handle this data in a simple way, JSON serialization is used.

Using JSON makes it easier for everyone to talk with the contracts, since most
languages readily implement a JSON (de)serializer.

#### Example
Let's look at this example, written only for educational purposes:

```rust
#[near(serializers = [json])]
pub struct A {
  pub a_number: i32,
  pub b_number: u128
}

#[near(serializers = [json])]
pub struct B {
  pub success: bool,
  pub other_number: i32
}

pub fn method(&self, struct_a: A): B {
  B {
     success: true,
     other_number: 0
  }
}
```


#### Receiving Data
When a user calls the `method`, the contract receives the arguments encoded as a JSON string
(e.g. `"{\"a_number\":0, \"b_number\":\"100\"}"`), and proceed to (de)serialize them into
the correct object (`A{0, 100}`) .


#### Returning Data
When returning the result, the contract will automatically encode the object `B{true, 0}`
into its JSON serialized value: `"{\"success\":true, \"other_number\":0}"` and return this
string.

:::caution JSON Limitations
Since JSON is limited to `52 bytes` numbers, you cannot use `u64`/`u128` as input
or output. JSON simply cannot serialize them. Instead, you must use `Strings`.

The `NEAR SDK RS` currently implements the `near_sdk::json_types::{U64, I64, U128, I128}`
that you can use for input / output of data.
:::


---

## Borsh: State Serialization

Under the hood smart contracts store data using simple **key/value pairs**. This means that
the contract needs to translate complex states into simple key-value pairs.

For this, NEAR contracts use [borsh](https://borsh.io) which is optimized for (de)serializing
complex objects into smaller streams of bytes.

:::tip SDK-JS still uses json
The JavaScript SDK uses JSON to serialize objects in the state, but the borsh implementation
should arrive soon
:::

#### Example
Let's look at this example, written only for educational purposes:

```rust
#[near(serializers = [json, borsh])]
#[derive(PanicOnDefault)]
pub struct Contract {
  string: String,
  vector: Vector<u8>
}

#[near]
impl Contract {
  #[init]
  pub fn init(string: String, first_u8: u8) -> Self {
    let mut vector: Vector<u8> = Vector::new("prefix".as_bytes());
    vector.push(&first_u8);

    Self { string, vector }
  }

  pub fn change_state(&mut self, string: String, number: u8) {
    self.string = string;
    self.vector.push(&number);
  }
}
```

#### Empty State On Deploy
If we deploy the contract into a new account and immediately ask for the state we will see
it is empty:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view-state $CONTRACT --finality optimistic

  # Result is: []
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract view-storage $CONTRACT all as-json network-config testnet now
  ```
  </TabItem>
</Tabs>

#### Initializing the State
If we initialize the state we can see how Borsh is used to serialize the state

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # initialize with the string "hi" and 0
  near call $CONTRACT init '{"string":"hi", "first_u8":0}' --accountId $CONTRACT

  # check the state
  near view-state $CONTRACT --utf8 --finality optimistic
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # initialize with the string "hi" and 0
  near contract call-function as-transaction $CONTRACT init json-args '{"string":"hi", "first_u8":0}' prepaid-gas '30.0 Tgas' attached-deposit '0 NEAR' sign-as $CONTRACT network-config testnet sign-with-keychain send

  # check the state
  near contract view-storage $CONTRACT all as-json network-config testnet now
  ```
  </TabItem>
</Tabs>

<details>

<summary> Result </summary>

```bash
[
  {
    key: 'STATE',
    value: '\x02\x00\x00\x00hi\x01\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00prefix'
  },
  { key: 'prefix\x00\x00\x00\x00\x00\x00\x00\x00', value: '\x00' }
]
```
</details>

The first key-value is:

```js
key: 'STATE'
value: '\x02\x00\x00\x00hi\x01\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00prefix'
```

Since the `Contract` has a structure `string, Vector<u8>` the value is interpreted as:

```bash
[2, 0, 0, 0, "h", "i"] -> The `string` has 2 elements: "h" and "i".
[1, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, "prefix"] -> The Vector has 1 element, and to see the values search for keys that start with (the 6 bytes prefix): "prefix"
```

Then, the second key-value shows the entries of the `Vector` denoted by the `"prefix"` string:

```js
key: 'prefix\x00\x00\x00\x00\x00\x00\x00\x00'
value: '\x00'
```

#### Modifying the State
If we modify the stored string and add a new number, the state changes accordingly:

<Tabs>
  <TabItem value="short" label="Short">

  ```bash
  near call $CONTRACT change_state '{"string":"bye", "number":1}' --accountId $CONTRACT
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $CONTRACT change_state json-args '{"string":"bye", "number":1}' prepaid-gas '30.0 Tgas' attached-deposit '0 NEAR' sign-as $CONTRACT network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<details>

<summary> Result </summary>

```bash
[
  {
    key: 'STATE',
    value: '\x03\x00\x00\x00bye\x02\x00\x00\x00\x00\x00\x00\x00\x06\x00\x00\x00prefix'
  },
  { key: 'prefix\x00\x00\x00\x00\x00\x00\x00\x00', value: '\x00' },
  { key: 'prefix\x01\x00\x00\x00\x00\x00\x00\x00', value: '\x01' }
]
```
</details>

We can see that the `STATE` key changes to reflect the storage of the new string (`bye`), and that
the vector now has 2 elements.

At the same time, a new key-value was added adding the new vector entry: the `1u8` we just added.

<hr className="subsection" />

<!-- We should see where to move/replicate this -->

### Deserialization Error
When somebody invokes a smart contract method, the first step for the contract is to deserialize
its own state.

In the example used above, the contract will start by reading the `STATE` key and
try to deserialize its value into an object `Contract{string: String, vector: Vector<u8>}`.

If you deploy a contract into the account with a different Contract structure, then the
contract will fail to deserialize the `STATE` key and panic `Cannot deserialize the contract state`.

To solve this, you can either:
1. Rollback to the previous contract code
2. Implement a method to [migrate the contract's state](../release/upgrade.md)


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/storage.md 

 ---
id: storage
title: State
sidebar_label: State (Storage)
hide_table_of_contents: true
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs";
import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Smart contracts store data in their account's state, which is public on the chain. The storage starts **empty** until a contract is deployed and the state is initialized.

It is important to know that the account's **code** and account's **storage** are **independent**. [Updating the code](../release/upgrade.md) does **not erase** the state.

<hr class="subsection" />

<ExplainCode languages="js,rust" >

<Block highlights='{"js": "3-6,10-13"}' fname="auction">

    ### Defining the State
    The attributes of the `class` marked as the contract define the data that will be stored.
    
    The contract can store all native types (e.g. `number`, `string`, `Array`, `Map`) as well as complex objects.

    For example, our Auction contract stores when the auction ends, and an object representing the highest bid.

    **Note:** The SDK also provides [collections](./collections.md) to efficiently store collections of data.

</Block>

<Block highlights='{"rust": "6-9,13-18"}' fname="auction">

    ### Defining the State
    The attributes of the `struct` marked as the contract define the data that will be stored.

    The contract can store all native types (e.g. `u8`, `string`, `HashMap`, `Vector`) as well as complex objects.
    
    For example, our Auction contract stores when the auction ends, and an object representing the highest bid.

    **Note:** The structures that will be saved need a special macro, that tells the SDK to store them [serialized in Borsh](./serialization.md).

    **Note:** The SDK also provides [collections](./collections.md) to efficiently store collections of data.

</Block>

<Block highlights='{"js":"", "rust": ""}' fname="auction" type='info'>

:::warning

Contracts pay for their storage by locking part of their balance.
    
It currently costs ~**1‚ìÉ** to store **100KB** of data.

:::

</Block>

<Block highlights='{"js": "", "rust": ""}' fname="auction" >

    ### Initializing the State
    After the contract is deployed, its state is empty and needs to be initialized with
    some initial values.

    There are two ways to initialize a state:
      1. By creating an initialization function
      2. By setting default values

</Block>

<Block highlights='{"js": "8,15-20"}' fname="auction">

    ### I. Initialization Functions
    An option to initialize the state is to create an `initialization` function, which needs to be called before executing any other function.

    In our Auction example, the contract has an initialization function that sets when the auction ends. Note the `@initialization` decorator, and the forced initialization on `NearBindgen`.
    
    **Note:** It is a good practice to mark initialization functions as private. We will cover function types in the [functions section](./functions.md).

</Block>

<Block highlights='{"js": "10-13"}' fname="auction" type='info'>

:::warning

In TS/JS you still **must** set default values for the attributes, so the SDK can infer their types.

:::

</Block>

<Block highlights='{"rust": "12,22-34"}' fname="auction">

    ### I. Initialization Functions
    An option to initialize the state is to create an `initialization` function, which needs to be called before executing any other function.

    In our Auction example, the contract has an initialization function that sets when the auction ends. The contract derives the `PanicOnDefault`, which forces the user to call the init method denoted by the `#[init]` macro.
    
    **Note:** It is a good practice to mark initialization functions as private. We will cover function types in the [functions section](./functions.md).

</Block>

<Block highlights='{"js": "5"}' fname="hello">

    ### II. Default State
    Another option to initialize the state is to set default values for the attributes of the class.

    Such is the case for our "Hello World" contract, which stores a `greeting` with the default value `"Hello"`.

    The first time the contract is called (somebody executes `get_greeting` or `set_greeting`), the default values will be stored in the state, and the state will be considered initialized.

    **Note:** The state can only be initialized once.

</Block>

<Block highlights='{"rust": "10-16"}' fname="hello">

    ### II. Default State
    Another option to initialize the state is to create a `Default` version of our contract's `struct`.
    
    For example, our "Hello World" contract has a default state with a `greeting` set to `"Hello"`.

    The first time the contract executes, the `Default` will be stored in the state, and the state will be considered initialized.

    **Note:** The state can only be initialized once.

</Block>

<Block highlights='{"js": "", "rust":""}' fname="hello">

    ### Lifecycle of the State
    When a function is called, the contract's state is loaded from the storage and put into memory.

    The state is actually [stored serialized](./serialization.md), and the SDK takes a bit of time to deserialize it before the method can access it.

    When the method finishes executing successfully, all the changes to the state are serialized, and saved back to the storage.

</Block>

<Block highlights='{"js": "", "rust":""}' fname="hello" type='info'>

:::warning State and Code

In NEAR, the contract's code and contract's storage are **independent**.
    
Updating the code of a contract does **not erase** the state, and can indeed lead to unexpected behavior or errors.

Make sure to read the [updating a contract](../release/upgrade.md) if you run into issues.

:::

</Block>

<File language="js" fname="auction"
    url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts"
    start="2" end="60" />

<File language="js" fname="hello"
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
    start="2" end="18" />

<File language="rust" fname="auction"
    url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs"
    start="2" end="83" />

<File language="rust" fname="hello"
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
    start="2" end="32" />

</ExplainCode>


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/types.md 

 ---
id: types
title: SDK Types
hide_table_of_contents: true
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs";
import CodeBlock from '@theme/CodeBlock';

import {ExplainCode, Block, File} from '@site/src/components/CodeExplainer/code-explainer';

Lets discuss which types smart contracts use to input and output data, as well as how such data is stored and handled in the contract's code.

<ExplainCode languages="js,rust">

<Block highlights='{"js":"5,8,13"}' fname="hello-near">

    ### Native Types
    Smart contracts can receive, store and return data using JS native types:
    - `string`
    - `number`
    - `boolean`
    - `Array`
    - `Map`
    - `Object`
    - `BigInt`

</Block>

<Block highlights='{"rust":"6,13,22,27"}' fname="hello-near">

    ### Native Types
    Smart contracts can receive, store and return data using the following Rust types:
    - `string`
    - `i8-i32/u8-u32`
    - **`u64/128`**: It is preferable to use SDK types `U64` and `U128`
    - `bool`
    - `HashMap`
    - `Vector`

</Block>

<Block highlights='{"rust": "1,15,24,81"}' fname="auction" type='info'>

:::warning `U64/U128`

Smart contracts can store `u64` and `u128`, but these types need to be converted to `string` for input/output, since JSON cannot serialize values with more than 52 bits

To simplify development, the SDK provides the `U64` and `U128` types which are automatically casted to `u64/u128` when stored, and to `string` when used as input/output

:::

</Block>

<Block highlights='{"js":"3-6", "rust": "6-9"}' fname="auction">

    ### Complex Objects
    Smart contracts can store and return complex objects

    **Note:** Objects will always be received and returned as JSON

</Block>

<Block highlights='{"rust": "4"}' fname="auction">

    #### Serializers
    Objects that will be used as input or output need to be serializable to JSON, add the `#[near(serializer=json)]` macro

    Objects that will be stored in the contract's state need to be serializable to Borsh, add the `#[near(serializer=borsh)]` macro

</Block>

<Block highlights='{"js": "5,10,28"}' fname="auction">

    ### Handling Tokens
    `$NEAR` tokens are typed as `BigInt` in JS, and their values represented in `yoctonear`

    **Note:** 1 NEAR = 10^24 yoctoNEAR

</Block>

<Block highlights='{"rust": "8,28,45"}' fname="auction">

    ### Handling Tokens
    `$NEAR` tokens are handled through the `NearToken` struct, which exposes methods to represent the value in `yoctonear`, `milinear` and `near`

    **Note:** 1 NEAR = 10^24 yoctonear

</Block>

<Block highlights='{"js": "4,29", "rust": "7,46"}' fname="auction">

    ### Account
    The SDK exposes a special type to handle NEAR Accounts, which automatically checks if the account address is valid

</Block>

<File language="js" fname="hello-near"
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
    start="2" end="18" />

<File language="rust" fname="hello-near"
    url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
    start="2" end="32" />

<File language="js" fname="auction"
    url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts"
    start="2" end="61" />

<File language="rust" fname="auction"
    url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs"
    start="2" end="84" />

</ExplainCode>


 This is the content for the doc docs/2.build/2.smart-contracts/anatomy/yield-resume.md 

 ---
id: yield-resume
title: Yield and Resume
---
import {CodeTabs, Language, Github} from '@site/src/components/codetabs'

NEAR smart contracts can **yield** execution, until an **external** service **resumes** them. In practice, the contract yields a **cross-contract call** to itself, until an external service executes a function and the contract decides to resume.

This is a powerful feature that allows contracts to wait for external events, such as a response from an oracle, before continuing execution (read our [blog post](/blog/yield-resume)!).

:::info

Contract can wait for 200 blocks - around 4 minutes - after which the yielded function will execute, receiving a "timeout error" as input

:::

---

## Yielding a Promise

Let's look at an example that takes a prompt from a user (e.g. "What is 2+2"), and yields the execution until an external service provides a response.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/yield-resume/blob/main/contract/src/lib.rs"
            start="43" end="70" />
  </Language>
</CodeTabs>

#### Creating a Yielded Promise
In the example above, we are creating a [`Promise`](./crosscontract.md#promises) to call the contract's function `return_external_response`.

Notice that we create the `Promise` using `env::promise_yield_create`, which will create an **identifier** for the yielded promise in the `YIELD_REGISTER`.

#### Retrieving the Yielded Promise ID
We read the `YIELD_REGISTER` to retrieve the `ID` of our yielded promise. We store the `yield_id` and the user's `prompt` so the external service query them (the contract exposes has a function to list all requests).

#### Returning the Promise
Finally, we return the `Promise`, which will **not execute immediately**, but will be **yielded** until the external service provides a response.

<details>

<summary> What is that `self.request_id` in the code? </summary>

The `self.request_id` is an internal unique identifier that we use to keep track of stored requests. This way, we can delete the request once the external service provides a response (or the waiting times out)

Since we only use it to simplify the process of keeping track of the requests, you can remove it if you have a different way of tracking requests (e.g. an indexer)

</details>

---

## Signaling the Resume

The `env::promise_yield_resume` function allows us to signal which yielded promise should execute, as well as which parameters to pass to the resumed function.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/yield-resume/blob/main/contract/src/lib.rs"
            start="72" end="75" />
  </Language>
</CodeTabs>

In the example above, the `respond` function would be called by an external service, passing which promise should be resume (`yield_id`), and the response to the prompt. 

:::warning Gatekeeping the Resume

Since the function used to signal the resume is public, developers must make sure to guard it properly to avoid unwanted calls. This can be done by simply checking the caller of the function

:::

---

## The Function that Resumes

The function being resumed will have access to all parameters passed to it, including those passed during the yield creation, or the external service response.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/yield-resume/blob/main/contract/src/lib.rs"
            start="77" end="89" />
  </Language>
</CodeTabs>

In the example above, the `return_external_response` receives two parameters:

1. A `request_id` - passed on [creation](#creating-a-yielded-promise) - which is used to remove the request from the state
2. A `response` - passed when [signaling to resume](#signaling-the-resume) - which contains the external response, or a `PromiseError` if the contract timed out while waiting

:::tip There's plenty of time

The contract will be able to wait for 200 blocks - around 4 minutes - before timing out

:::

:::info

Notice that, in this particular example, we choose to return a value both if there is a response or a time out

The reason to not raise an error, is because we are changing the state (removing the request in line `#7`), and raising an error would revert this state change

:::

 This is the content for the doc docs/2.build/2.smart-contracts/quickstart.md 

 ---
id: quickstart
title: Hello Contract
sidebar_label: Quickstart ‚ú®
---

import {Github} from '@site/src/components/codetabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

Welcome! [NEAR accounts](../../1.concepts/protocol/account-model.md) can store small apps known as smart contracts. In this quick tutorial, we will guide you in creating your first contract on the NEAR **testnet**!

Join us in creating a friendly contract that stores a greeting, and exposes functions to interact with it.

---

## Prerequisites

Before starting, make sure to set up your development environment.

<details>
<summary>Working on Windows?</summary>

  See our blog post [getting started on NEAR using Windows](/blog/getting-started-on-windows) for a step-by-step guide on how to set up WSL and your environment

</details>

<Tabs groupId="code-tabs" queryString>
  <TabItem value="js" label="üåê JavaScript">

```bash
# Install Node.js using nvm (more options in: https://nodejs.org/en/download)
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
nvm install latest

# ‚ö†Ô∏è For Mac Silicon users only, Rosetta is needed to compile contracts
# /usr/sbin/softwareupdate --install-rosetta --agree-to-license

# Install NEAR CLI to deploy and interact with the contract
npm install -g near-cli-rs@latest
```

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```bash
# Install Rust: https://www.rust-lang.org/tools/install
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# Contracts will be compiled to wasm, so we need to add the wasm target
rustup target add wasm32-unknown-unknown

# Install NEAR CLI-RS to deploy and interact with the contract
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/latest/download/near-cli-rs-installer.sh | sh

# Install cargo near to help building the contract
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/cargo-near/releases/latest/download/cargo-near-installer.sh | sh
```

</TabItem>

</Tabs>

:::note
Some `near-cli` commands have two versions - a **full** one and a **short** one. If you want to explore all options provided by `near-cli` use [the interactive mode](../../4.tools/cli.md#interactive-mode).
:::

:::tip Testnet Account

There is no need to have a `testnet` account to follow this tutorial.

However, if you want to create one, you can do so through [a wallet](https://testnet.mynearwallet.com), and use it from the `near-cli` by invoking `near login`.

:::

---

## Creating the Contract

Create a smart contract by using one of the scaffolding tools and following their instructions:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">


```bash
  npx create-near-app@latest
```

![img](@site/static/docs/hello-near-ts.gif)
_Creating a project using `create-near-app`_

This will generate a project with the following structure:

```bash
hello-near
‚îú‚îÄ‚îÄ sandbox-test    # sandbox testing
‚îÇ   ‚îî‚îÄ‚îÄ main.ava.js
‚îú‚îÄ‚îÄ src             # contract's code
‚îÇ   ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ package.json    # package manager
‚îî‚îÄ‚îÄ tsconfig.json
```

:::tip

We recommend you to name your project `hello-near` for this tutorial, but feel free to use any name you prefer

:::

</TabItem>

<TabItem value="rust" label="ü¶Ä Rust">

```bash
  cargo near new hello-near
```

![img](@site/static/docs/hello-near-rs.gif)
_Creating a project using `cargo near new`_

This will generate a project with the following structure:

```bash
hello-near
‚îú‚îÄ‚îÄ src        # contract's code
‚îÇ   ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ tests      # sandbox testing
‚îÇ   ‚îî‚îÄ‚îÄ test_basics.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

:::tip

`hello-near` is the name we chose for this project so the tutorial is simpler to follow, but for future projects feel free to use any name you prefer

:::

</TabItem>

</Tabs>


---

## The Contract

The `Hello World` smart contract stores a greeting in its state, and exposes two functions to interact with it:
1. `set_greeting`: to change the greeting
2. `get_greeting`: to fetch the greeting

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

    <Github fname="index.js" language="js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/src/contract.ts"
            start="4" end="22" />

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="lib.rs" language="rust"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/src/lib.rs"
            start="4" end="32" />

  </TabItem>

</Tabs>

:::tip

After finishing this tutorial, check our [contract's anatomy](./anatomy/anatomy.md) page to learn more about the contract's structure

:::

---

## Test the Contract

Building and testing the contract is as simple as running the `test` command. The contract will be compiled and the tests will be executed.

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

    ```bash
    npm run test
    ````

    <details>
    <summary> Failing tests? </summary>

    Make sure that you are using `node v18`, `v20` or `v22` - you can manage multiple versions using `nvm` - and that you have `Rosetta` installed on MacOS if you have an Apple Silicon processor.

    </details>

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  ```bash
  cargo test
  ```

  </TabItem>

</Tabs>

In the background, these commands are calling the build tools for each language and using a [Sandbox](./testing/integration-test.md) to test the contract.

:::tip Sandbox

Testing the contracts within a Sandbox allows you to understand how the contract will behave once deployed to the network while having total control over the testing environment.

:::

---

## Create a Testnet Account

Now that you know the contract is passing the tests, let's create a `testnet` account in which to deploy the contract. [`near-cli`](../../4.tools/cli.md) supports two versions of some commands - full and short one. It's up to you which format you prefer, but full version provides more features.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

    ```bash
    # Replace <your-account-id.testnet> with a custom name
    near create-account <your-account-id.testnet> --useFaucet
    ```

    <details>
    <summary> Example Result </summary>

    ```bash
    $> near create-account lovely-event.testnet --useFaucet
    # New account "lovely-event.testnet" created successfully
    ```

    </details>
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    # Replace <your-account-id.testnet> with a custom name
    near account create-account sponsor-by-faucet-service <your-account-id.testnet> autogenerate-new-keypair save-to-keychain network-config testnet create
    ````

    <details>
    <summary> Example Result </summary>

    ```bash
    $> near account create-account sponsor-by-faucet-service lovely-event.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

    # New account "lovely-event.testnet" created successfully
    ```

    </details>

  </TabItem>

</Tabs>


:::tip

Remember that you can create a named account through any wallet (i.e. [MyNearWallet](https://testnet.mynearwallet.com)) and then use it from the `near-cli` by invoking `near login`.

:::

:::warning

When running the near account create-account command in a headless Linux environment (e.g., WSL), the `save-to-keychain` option may fail due to platform limitations. Use `save-to-legacy-keychain` instead of `save-to-keychain` to ensure compatibility.

:::


---

## Build the Contract

When you are ready to create a build of the contract run a one-line command depending on your environment.

<Tabs groupId="cli-tabs">
  <TabItem value="js" label="üåê JavaScript">

  ```bash
  npm run build
  ```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

  ```bash
  cargo near build
  ```

  
  :::info

  For this tutorial we will use the `non-reproducible-wasm` option when building the contract, but please know that you can create a reproducible build if you have `Docker` installed

  :::

  </TabItem>

</Tabs>

---

## Deploy the Contract

Having our account created, we can now deploy the contract:

<Tabs groupId="cli-tabs">
  <TabItem value="js" label="üåê JavaScript">
    <Tabs groupId="cli-tabs">
      <TabItem value="short" label="Short">

        ```bash
        near deploy <created-account> ./build/hello_near.wasm
        ```

      </TabItem>
      <TabItem value="full" label="Full">

        ```bash
        near contract deploy <created-account> use-file ./build/hello_near.wasm without-init-call network-config testnet sign-with-keychain send
        ```

      </TabItem>
    </Tabs>
  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

    <Tabs groupId="cli-tabs">
      <TabItem value="short" label="Short">

        ```bash
        near deploy <created-account> ./target/near/hello_near.wasm
        ```

      </TabItem>

      <TabItem value="full" label="Full">

        ```bash
        near contract deploy <created-account> use-file ./target/near/hello_near.wasm without-init-call network-config testnet sign-with-keychain send
        ```

      </TabItem>
    </Tabs>
  </TabItem>
</Tabs>

**Congrats**! Your contract now lives in the NEAR testnet network.

---

## Interacting with the Contract

To interact with your deployed smart contract, you can call its functions through the command line.

<hr class="subsection" />

#### Get Greeting
Let's start by fetching the greeting stored in the contract. The `get_greeting` function only reads from the contract's state, and can thus be called for **free**.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

    ```bash
    > near view <created-account> get_greeting
    # "Hello"
    ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    > near contract call-function as-read-only <created-account> get_greeting json-args {} network-config testnet now
    # "Hello"
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Set Greeting

We can now change the greeting stored in the contract. The `set_greeting` method writes on the contract's [storage](./anatomy/storage.md), and thus requires a user to sign a transaction in order to be executed.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  > near call <created-account> set_greeting '{"greeting": "Hola"}' --accountId <created-account>
  # Log: Saving greeting "Hola"
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    > near contract call-function as-transaction <created-account> set_greeting json-args '{"greeting": "Hola"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <created-account> network-config testnet sign-with-keychain send
    #Log: Saving greeting "Hola"
    ```
  </TabItem>
</Tabs>

:::tip

Notice that we are signing the transaction using `<created-account>`, so in this case, we are asking the contract's account to call its own function

:::


---

## Moving Forward

That's it for the quickstart tutorial. You have now seen a fully functional contract with a minimal user interface and testing.

To better understand the contract's structure, check our [contract's anatomy](./anatomy/anatomy.md) page.

If you prefer to see more examples, check our [examples](/tutorials/examples/count-near) page.

<MovingForwardSupportSection />

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- node: `20.18.0`
- rustc: `1.81.0`
- near-cli-rs: `0.17.0`
- cargo-near: `0.13.2`

:::


 This is the content for the doc docs/2.build/2.smart-contracts/release/deploy.md 

 ---
id: deploy
title: NEAR CLI - Basics
sidebar_label: Deploying and Using
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

After your contract is ready you can deploy it in the NEAR network for everyone to use it.

Let us guide you on how to use the [NEAR CLI](../../../4.tools/cli.md) to deploy your contract
and call its methods.

:::info
On this page, we will only cover the basics of NEAR CLI. For more information visit the
[NEAR CLI documentation page](../../../4.tools/cli.md).
:::

---

## Deploying the Contract

Thanks to the `NEAR CLI` deploying a contract is as simple as:

1. Compiling the contract to wasm.
2. [Create an account](../../../4.tools/cli.md#create) and [deploy the contract](../../../4.tools/cli.md#deploy) into it using `NEAR CLI`.

### Compile the Contract

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

  ```bash
  yarn build
  ```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

  ```bash
  cargo near build
  ```

  </TabItem>

</Tabs>

### Create an Account and Deploy


<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet

  # deploy the contract
  near deploy <accountId> <route_to_wasm>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

  # deploy the contract
  near contract deploy <my-new-dev-account>.testnet use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain
  ```
  </TabItem>
</Tabs>


### Deploy in an Existing Account

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # login into your account
  near login

  # deploy the contract
  near deploy <accountId> <route_to_wasm>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # login into your account
  near account import-account using-web-wallet network-config testnet

  # deploy the contract
  near contract deploy <accountId> use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

:::tip
You can overwrite a contract by deploying another on top of it. In this case, the account's logic
will change, but the state will persist
:::

:::info
By default `near-cli` uses the `testnet` network. Define `NEAR_ENV=mainnet` to deploy into `mainnet`.
:::

:::info Naming Convention for Public-Facing Methods
Once the contract is deployed to the network, anyone and any other contract (i.e., any other account on NEAR) can interact with it by calling its methods. Furthermore, any transactions involving the contract will also be included in the network's data stream, which means its activity can also be visible to any who listens to particular events.

Considering this, we advise to name methods using `snake_case` in all SDKs as this is compatible with the remainder of the NEAR ecosystem which is predominantly comprised of Rust contracts.
:::

---

## Initializing the Contract
If your contract has an [initialization method](../anatomy/storage.md) you can call it to
initialize the state. This is not necessary if your contract implements `default` values for the state.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Call the initialization method (`init` in our examples)
  near call <contractId> <initMethod> [<args>] --accountId <accountId>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Call the initialization method (`init` in our examples)
  near contract call-function as-transaction <contractId> <initMethod> json-args [<args>] prepaid-gas '30 TeraGas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

:::info
You can initialize your contract [during deployment](#deploying-the-contract) using the `--initFunction` & `--initArgs` arguments.
:::

---

## Calling the Contract

Once your contract is deployed you can interact with it right away using [NEAR CLI](../../../4.tools/cli.md).

<hr className="subsection" />

### View methods
View methods are those that perform **read-only** operations. Calling these methods is free, and do not require to specify which account is being used to make the call:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view <contractId> <methodName>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only <contractId> <methodName> text-args '' network-config testnet now
  ```
  </TabItem>
</Tabs>

:::tip
View methods have by default 200 TGAS for execution
:::

<hr className="subsection" />

### Change methods

Change methods are those that perform both read and write operations. For these methods we do need to specify the account being used to make the call,
since that account will expend GAS in the call.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call <contractId> <methodName> <jsonArgs> --accountId <yourAccount> [--deposit <amount>] [--gas <GAS>]
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction <AccountId> <MethodName> json-args <JsonArgs> prepaid-gas <PrepaidGas> attached-deposit <AttachedDeposit> sign-as <AccountId>  network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/2.smart-contracts/release/lock.md 

 ---
id: lock
title: Locking Accounts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Removing all [full access keys](/tools/near-cli#delete-key) from an account will effectively **lock it**.

When an account is locked nobody can perform transactions in the account's name (e.g. update the code or transfer money).

#### How to Lock an Account
<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near keys <dev-account>
  # result: [access_key: {"nonce": ..., "public_key": '<key>'}]

  near delete-key <dev-account> '<key>'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near account list-keys <dev-account> network-config testnet now
  # result:

  +---+------------+-------+-------------+
  | # | Public Key | Nonce | Permissions |
  +---+------------+-------+-------------+
  ..    '<key>'      ...        ...
  +---+------------+-------+-------------+

  near account delete-key <dev-account> '<key>' network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

#### Why Locking an Account

Locking an account brings more reassurance to end-users, since they know no external actor will be able to manipulate the account's
contract or balance.

:::tip Upgrading Locked Contracts

Please do note that, while no external actor can update the contract, the contract **can still upgrade itself**. See [this article](upgrade.md#programmatic-update) for details.

:::


 This is the content for the doc docs/2.build/2.smart-contracts/release/upgrade.md 

 ---
id: upgrade
title: Updating Contracts
---

import {CodeTabs, Language, Github} from "@site/src/components/codetabs"; import
Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

NEAR accounts separate their logic (contract's code) from their state (storage),
allowing the code to be changed.

Contract's can be updated in two ways:

1. **Through tools** such as [NEAR CLI](../../../4.tools/cli.md) or the
   [NEAR API](../../../4.tools/near-api.md) (if you hold
   the account's
   [full access key](../../../1.concepts/protocol/access-keys.md)).
2. **Programmatically**, by implementing a method that
   [takes the new code and deploys it](#programmatic-update).

---

## Updating Through Tools

Simply re-deploy another contract using your preferred tool, for example, using
[NEAR CLI](../../../4.tools/cli.md):

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

```bash
# (optional) If you don't have an account, create one
near create-account <account-id> --useFaucet

# Deploy the contract
near deploy <account-id> <wasm-file>
```

</TabItem>

<TabItem value="full" label="Full">

```bash
# (optional) If you don't have an account, create one
near account create-account sponsor-by-faucet-service somrnd.testnet autogenerate-new-keypair save-to-keychain network-config testnet create

# Deploy the contract
near contract deploy <accountId> use-file <route_to_wasm> without-init-call network-config testnet sign-with-keychain send
```

</TabItem>

</Tabs>

---

## Programmatic Update

A smart contract can also update itself by implementing a method that:

1. Takes the new wasm contract as input
2. Creates a Promise to deploy it on itself

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="update.rs"
        url="https://github.com/near-examples/update-migrate-rust/blob/main/self-updates/base/src/update.rs"
        start="10" end="31" />

</Language>

</CodeTabs>

#### How to Invoke Such Method?

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Near CLI (short)">

```bash
# Load the contract's raw bytes
CONTRACT_BYTES=`cat ./path/to/wasm.wasm | base64`

# Call the update_contract method
near call <contract-account> update_contract "$CONTRACT_BYTES" --base64 --accountId <manager-account> --gas 300000000000000
```

</TabItem>

<TabItem value="full" label="Near CLI (full)">

```bash
# Call the update_contract method
near contract call-function as-transaction <contract-account> update_contract file-args </path/to/wasm.wasm> prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as <manager-account> network-config testnet sign-with-keychain send
```

</TabItem>

<TabItem value="js" label="üåê JavaScript">

```js
// Load the contract's raw bytes
const code = fs.readFileSync("./path/to/wasm.wasm");

// Call the update_contract method
await wallet.callMethod({
  contractId: guestBook,
  method: "update_contract",
  args: code,
  gas: "300000000000000",
});
```

</TabItem>

</Tabs>

:::tip DAO Factories

This is how DAO factories
[update their contracts](https://github.com/near-daos/sputnik-dao-contract/blob/main/sputnikdao-factory2/src/factory_manager.rs#L60)

:::

---

## Migrating the State

Since the account's logic (smart contract) is separated from the account's state
(storage), **the account's state persists** when re-deploying a contract.

Because of this, **adding methods** or **modifying existing ones** will yield
**no problems**.

However, deploying a contract that **modifies or removes structures** stored in
the state will raise an error: `Cannot deserialize the contract state`, in which
case you can choose to:

1. Use a different account
2. Rollback to the previous contract code
3. Add a method to migrate the contract's state

<hr className="subsection" />

### The Migration Method

If you have no option but to migrate the state, then you need to implement a
method that:

1. Reads the current state of the contract
2. Applies different functions to transform it into the new state
3. Returns the new state

:::tip DAO Update

This is how DAOs
[update themselves](https://github.com/near-daos/sputnik-dao-contract/blob/main/sputnikdao2/src/upgrade.rs#L59)

:::

<hr className="subsection" />

### Example: Guest Book Migration

Imagine you have a Guest Book where you store messages, and the users can pay
for such messages to be "premium". You keep track of the messages and payments
using the following state:

<CodeTabs>
<Language value="js" language="js">

<Github fname="index.js"
      url="https://github.com/near/near-sdk-js/blob/develop/examples/src/basic-updates/basic-updates-base.js"
      start="12" end="33" />

</Language>

<Language value="rust" language="rust">

<Github fname="lib.rs"
    url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/base/src/lib.rs"
    start="10" end="21" />

</Language>

</CodeTabs>

#### Update Contract

At some point you realize that you could keep track of the `payments` inside of
the `PostedMessage` itself, so you change the contract to:

<CodeTabs>
<Language value="js" language="js">

<Github fname="index.js"
      url="https://github.com/near/near-sdk-js/blob/develop/examples/src/basic-updates/basic-updates-update.js"
      start="21" end="43" />

</Language>

<Language value="rust" language="rust">

<Github fname="lib.rs"
    url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/update/src/lib.rs"
    start="12" end="23" />

</Language>

</CodeTabs>

#### Incompatible States

If you deploy the update into an initialized account the contract will fail to
deserialize the account's state, because:

1. There is an extra `payments` vector saved in the state (from the previous
   contract)
2. The stored `PostedMessages` are missing the `payment` field (as in the
   previous contract)

#### Migrating the State

To fix the problem, you need to implement a method that goes through the old
state, removes the `payments` vector and adds the information to the
`PostedMessages`:

<CodeTabs>
<Language value="js" language="js">

<Github fname="index.js"
      url="https://github.com/near/near-sdk-js/blob/develop/examples/src/basic-updates/basic-updates-update.js"
      start="5" end="68" />

</Language>

<Language value="rust" language="rust">

<Github fname="lib.rs"
    url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/update/src/migrate.rs"
    start="3" end="46" />

</Language>

</CodeTabs>

Notice that `migrate` is actually an
[initialization method](../anatomy/storage.md)
that **ignores** the existing state (`[#init(ignore_state)]`), thus being able
to execute and rewrite the state.

:::tip

You can follow a migration step by step in the
[official migration example](https://github.com/near-examples/update-migrate-rust/tree/main/basic-updates/base)
Javascript migration example testfile can be found on here:
[test-basic-updates.ava.js](https://github.com/near/near-sdk-js/blob/develop/examples/__tests__/test-basic-updates.ava.js),
run by this command: `pnpm run test:basic-update` in examples directory.

:::


 This is the content for the doc docs/2.build/2.smart-contracts/security/callbacks.md 

 ---
id: callbacks
title: Cross-Contract Calls
---

While writing cross-contract calls there is a significant aspect to keep in mind: all the calls are **independent** and **asynchronous**. In other words:

- The method in which you make the call and method for the callback are **independent**.
- Between the call and the callback, people could interact with the contract.

This has important implications on how you should handle the callbacks. Particularly:

1. Your callback method needs to be public, but you want to make sure only your contract can call it.
2. Make sure you don't leave the contract in a exploitable state between the call and the callback.
3. Manually rollback any changes to the state in the callback if the external call failed.

---

## Private Callbacks
In order for your contract to call itself when a cross-contract call is done, you need to make the callback method public. However, most of the times you would want it to be private. You can make it private while keeping it public by asserting that the `predecessor` is `current_account`. In rust this is done automatically by adding the `#[private]` decorator.

---

## User's Money
When a method panics, the money attached to that transaction returns to the `predecessor`. This means that, if you make a cross-contract call and it fails, then the money **returns to your contract**. If the money came from a user calling your contract, then you should transfer it back during the callback.

![img](https://miro.medium.com/max/1400/1*Hp4TOcaBqm9LS0wkgWw3nA.png)
*If the user attached money, we need to manually return it in the callback*

:::caution
Make sure you pass have enough GAS in the callback to make the transfer
:::

---

## Async Callbacks
Between a cross-contract call and its callback **any method of your contract can be executed**. Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: reentrancy attacks.

Imagine that we develop a `deposit_and_stake` with the following **wrong logic**: (1) The user sends us money, (2) we add it to its balance, (3) we try to stake it in a validator, (4) if the staking fails, we remove the balance in the callback. Then, a user could schedule a call to withdraw between (2) and (4), and, if the staking failed, we would send money twice to the user.

![img](https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png)
*Between a cross-contract call and the callback anything could happen*

Luckily for us the solution is rather simple. Instead of immediately adding the money to our user‚Äôs balance, we wait until the callback. There we check, and if the staking went well, then we add it to their balance.

![img](https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png)
*Correct way to handle deposits in a cross-contract call*

 This is the content for the doc docs/2.build/2.smart-contracts/security/checklist.md 

 ---
id: checklist
title: ‚úÖ Checklist
---

Once you finished developing your smart contract please go through the following list in order to ensure everything is safe for the end user.

:::info
Check our [security articles](./welcome.md) to understand how to improve the security of your contract.
:::

---

## Anatomy
1. All private methods are decorated as `private`.

## Environment
2. `predecessor` and `signer` are used correctly through the entire contract.

## Storage
3. Each time the state grows it is ensured that there is enough balance to cover it
4. All collections (i.e. Vector, Map, Tree, etc) have an unique id
5. Check for underflow and overflow!. In rust, you can do this by simply adding the `overflow-checks = true` flag in your `Cargo.toml`.

## Actions
6. When sending money, you leave enough in the contract to cover the storage cost
7. If you are tracking user's fund, you **deduct them before** sending them back to the user. 

## Callbacks
8. All private callbacks are marked as `private`
9. All cross-contract calls have a callback
10. All callbacks check for errors and roll back the state if necessary
11. All callbacks return money to the `predecessor` if necessary
12. Callbacks are free of `panic!`
13. All the callbacks are given enough GAS to execute entirely
14. The contract is not left in an exploitable state between a cross-contract call and its callback


 This is the content for the doc docs/2.build/2.smart-contracts/security/frontrunning.md 

 ---
id: frontrunning
title: Front Running
---

In the NEAR network, validators have access to the transaction pool, and can therefore see them before they execute. This enables validators to analyze transactions for a potential profit and frontrun them with a transaction of their own.

For example, imagine that you make a game where users are paid for solving puzzles. If not handled carefully, a validator could swap a transaction with the valid answer for one of its own and claim the prize. You can read more about this in [this blog post](https://www.paradigm.xyz/2020/08/ethereum-is-a-dark-forest).


 This is the content for the doc docs/2.build/2.smart-contracts/security/one_yocto.md 

 ---
id: one-yocto
title: Ensure it is the User (1y‚ìÉ)
---

NEAR uses a system of [Access Keys](../../../1.concepts/protocol/access-keys.md) to simplify handling accounts.
There are basically two type of keys: `Full Access`, that have full control over an account (i.e. can perform all [actions](../anatomy/actions.md)), and 
`Function Call`, that only have permission to call a specified smart contract's method(s) that _do not_ attach ‚ìÉ as a deposit.

When a user [signs in on a website](../../4.web3-apps/integrate-contracts.md#user-sign-in--sign-out) to interact with your contract, what actually happens is
that a `Function Call` key is created and stored in the website. Since the website has access to the `Function Call` key, it can use it to
call the authorized methods as it pleases. While this is very user friendly for most cases, it is important to be careful in scenarios involving
transferring of valuable assets like [NFTs](../../../2.build/5.primitives/nft.md) or [FTs](../../../2.build/5.primitives/ft.md). In such cases, you need to ensure that
the person asking for the asset to be transfer is **actually the user**.

One direct and inexpensive way to ensure that the user is the one calling is by requiring to attach `1 y‚ìÉ`. In this case, the user will be
redirected to the wallet and be asked to accept the transaction. This is because, once again, only the `Full Access` key can be used to send NEAR.
Since the `Full Access` key is only in the user's wallet, you can trust that a transaction with `1 y‚ìÉ` was made by the user.

 This is the content for the doc docs/2.build/2.smart-contracts/security/random.md 

 ---
id: random
title: Random Numbers
---

When writing smart contracts in NEAR you have access to a `random seed` that enables you to create random numbers/strings
within your contract.

This `random seed` is **deterministic and verifiable**: it comes from the validator that produced the block signing the previous
block-hash with their private key.

The way the random seed is created implies two things:

- Only the validator mining the transaction **can predict** which random number will come out. **No one else** could predict it because nobody knows the validator's private key (except the validator itself).

- The validator **cannot interfere** with the random number being created. This is because they need to sign the previous block, over which (with a high probability) they had no control.


However, notice that this still leaves room for three types of attacks from the validator:
1. [Frontrunning](./frontrunning.md), which we cover in another page
2. Gaming the input
3. Refusing to mine the block. 

----

## Gaming the Input
Imagine you have a method that takes an input and gives a reward based on it. For example, you ask the user to choose a number,
and if it the same as your `random seed` you give them money.

Since the validator knows which `random seed` will come out, it can create a transaction with that specific input and win the prize.

----

## Refusing to Mine the Block
One way to fix the "gaming the input" problem is to force the user to send the input first, and then decide the result on a different block.
Let's call these two stages: "bet" and "resolve".

In this way, a validator cannot game the input, since the `random` number against which it will be compared is computed in a different block.

However, something that the validator can still do to increase their chance of winning is:
1. Create a "bet" transaction with an account.
2. When it's their turn to validate, decide if they want to "resolve" or not.

If the validator, on their turn, sees that generating a random number makes them win, they can add the transaction to the block. And if they
see that they will not, they can skip the transaction.

While this does not ensure that the validator will win (other good validators could mine the transaction), it can improve their chance of winning.

Imagine a flip-coin game, where you choose `heads` or `tails` in the "bet" stage, and later resolve if you won or not. If you are a validator
you can send a first transaction choosing either input.

Then, on your turn to validate, you can check if your chosen input came out. If not, you can simply skip the transaction. This brings your
probability of winning from `1/2` to `3/4`, that's a 25% increase!

These odds, of course, dilute in games with more possible outcomes.

<details>
<summary>How does the math work here?</summary>

Imagine you always bet for `heads`.

In a fair coin-flip game you have 50-50 percent chance of winning, this is because after the coin is flipped there are two possible outcomes:
`H` and `T`, and you only win in one (`H`).

However, if you can choose to flip again if `tails` comes out, now there are 4 scenarios: `H H` `T H` `H T` `T T`, and in 3 of those
you win (all the ones including an `H`)!!!.

</details>


 This is the content for the doc docs/2.build/2.smart-contracts/security/reentrancy.md 

 ---
id: reentrancy
title: Reentrancy Attacks
---

Between a cross-contract call and its callback **any method of your contract can be executed**. Not taking this into account is one of the main sources of exploits. It is so common that it has its own name: **reentrancy attacks**.

Always make sure to keep your state in a consistent state after a method finishes executing. Assume that:

- Any method could be executed between a method execution and its callback.
- The same method could be executed again before the callback kicks in.

---

### Example
Imagine that we develop a `deposit_and_stake` with the following **wrong logic**: (1) The user sends us money, (2) we add it to its balance, (3) we try to stake it in a validator, (4) if the staking fails, we remove the balance in the callback. Then, a user could schedule a call to withdraw between (2) and (4), and, if the staking failed, we would send money twice to the user.

![img](https://miro.medium.com/max/1400/1*VweWHQYGLBa70uceiWHLQA.png)
*Between a cross-contract call and the callback anything could happen*

Luckily for us the solution is rather simple. Instead of immediately adding the money to our user‚Äôs balance, we wait until the callback. There we check, and if the staking went well, then we add it to their balance.

![img](https://miro.medium.com/max/1400/1*o0YVDCp_7l-L3njJMGhU4w.png)
*Correct way to handle deposits in a cross-contract call*

 This is the content for the doc docs/2.build/2.smart-contracts/security/storage.md 

 ---
id: storage
title: Million Small Deposits
---

On NEAR, your contract pays for the storage it uses. This means that the more data you store, the more balance you need to cover for storage. If you don't handle these costs correctly (e.g. asking the user to cover their storage usage), then a million little deposits can drain your contract of its funds.

Let's walk through an example:

1. You launch [a guest book app](../../../3.tutorials/examples/guest-book.md), deploying your app's smart contract to the account `example.near`
2. Visitors to your app can add messages to the guest book. This means your users will pay a small gas fee to **store** their message to your contract.
3. When a new message comes in, NEAR will check if `example.near` has enough balance to cover the new storage needs. If it does not, the transaction will fail.

Note that this can create an attack surface. If sending data to your guest book is inexpensive to the user while costing the contract owner significantly more, a malicious user can exploit the imbalance to make maintaining the contract prohibitively expensive.

One possible way to tackle this problem is asking the user to attach money to the call to cover the storage used by their message.

:::tip
Remember that you can release the *balance locked for storage* by simply deleting data from the contract.
:::


 This is the content for the doc docs/2.build/2.smart-contracts/security/sybil.md 

 ---
id: sybil
title: Sybil Attacks
---

While developing your smart contract, keep in mind that an individual can potentially create multiple NEAR accounts. This is especially relevant in ecosystems involving crowd decisions, such as [DAOs](../../../2.build/5.primitives/dao.md). 

Imagine that you open the voting to anyone in the community. If each account can cast a vote, a malicious actor could span multiple accounts and gain a disproportionately large influence on the result.

 This is the content for the doc docs/2.build/2.smart-contracts/security/welcome.md 

 ---
id: welcome
title: Security
---

Here you will find information on how to keep your smart contract and decentralized applications secure.

:::tip
Please take some time to go through this section, it will help you to keep your dApp safe
:::

---

## üêû Bug Bounty Program
NEAR has a [bug bounty program](https://hackenproof.com/company/near/programs) . Please use it if you find any security errors in the protocol, core contracts or web. Hackers - help audit, test, and toughen NEAR up!

## ‚úÖ Security Checklist
Make sure to keep your smart contract safe by running through our [security checklist](checklist.md).

## üõ°Ô∏è Security Concepts
Learn important security concepts to keep your dApp safe and sound.  Read about:

- Keeping [callbacks safe](./callbacks.md)
- Understanding [frontrunning](./frontrunning.md)
- Understanding [sybil attacks](./sybil.md)
- Understanding [reentrancy attacks](./reentrancy.md)
- Making sure the owner of an account is [the one calling](./one_yocto.md)
- Understanding the complexity of [generating random numbers](./random.md)
- Protecting from a [small deposit attacks](./storage.md) draining your account

## üéûÔ∏è External Resources

An awesome video series on Smart Contract Security by [https://twitter.com/timurguvenkaya](https://twitter.com/timurguvenkaya) can be found on YouTube:

<iframe width="100%" height="315" src="https://www.youtube.com/embed/DrRr6nru0no?si=FxLJK-LYHrAqX0hc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

 This is the content for the doc docs/2.build/2.smart-contracts/testing/integration-test.md 

 ---
id: integration-test
title: Integration Tests
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Integration tests enable you to deploy a contract in the NEAR¬†`testnet`¬†or a local¬†`sandbox` and create test users to interact with it. This way, you can thoroughly test your contract in a realistic environment.

Moreover, when using the local `sandbox` you gain complete control of the network:

1. Create test `Accounts` and manipulate their `State` and `Balance`.
2. Simulate errors on callbacks.
3. Control the time-flow and fast-forward into the future (Rust ready, TS coming soon).

In NEAR, integration tests are implemented using a framework called **Workspaces**. Workspaces comes in two flavors: [ü¶Ä Rust](https://github.com/near/workspaces-rs) and [üåê Typescript](https://github.com/near/workspaces-js).

All of our [examples](https://github.com/near-examples) come with integration testing.

:::note Sandbox Testing

NEAR Workspaces allows you to write tests once, and run them either on `testnet` or a local `Sandbox`. By **default**, Workspaces will start a **sandbox** and run your tests **locally**. Lets dive into the features of our framework and see how they can help you.
:::

---

## Create Accounts

### Dev Account

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="15" end="19" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="49" end="69" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Subaccount

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="31" end="45" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="75" end="95" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Using Secret Key

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="54" end="61" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="101" end="128" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Using Credentials From File

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="70" end="74" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="134" end="161" />

  </TabItem>
</Tabs>

---

## WASM Files

### Compile Contract Code

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="83" end="88" />

  :::tip
  You don't need to assert compiling process everytime. You can use `?` operator to get the result as `Vec<u8>` without dealing with `Result<Vec<u8>>, Error>` type. That way you can directly use this vector to deploy the wasm file into account. Your test will still fail if compiling process fails.

  ```rust
  let contract_wasm = near_workspaces::compile_project("./").await?;
  ```
  :::
  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  If you want to compile a contract each time running tests, you can put following scripts into `package.json` file. In the code you can access path to compiled file using `process.argv[2]`.

  `package.json` file:
  ```json
  "scripts": {
    "build": "near-sdk-js build src/contract.ts build/hello_near.wasm",
    "test": "$npm_execpath run build && ava -- ./build/hello_near.wasm"
  },
  ```

  `main.ava.js` file:
  ```js
  const pathToWasm = process.argv[2];
  await contract.deploy(pathToWasm);
  ```

  </TabItem>
</Tabs>

<hr class="subsection" />

### Loading From File

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="95" end="102" />

  :::tip
  The same as in the case of compilation wasm from code, you don't need to assert reading file process everytime. You can use `expect` method to get the reading file result as `Vec<u8>` and provide error message as a parameter. Your test will still fail if compiling process fails.

  ```rust
  let contract_wasm = std::fs::read(artifact_path)
      .expect(format!("Could not read WASM file from {}", artifact_path).as_str());
  ```
  :::
  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  If you want to use pre-compiled a contract, you can put following scripts into `package.json` file. In the code you can access path to pre-compiled file using `process.argv[2]`.

  `package.json` file:
  ```json
  "scripts": {
    "build": "near-sdk-js build src/contract.ts build/hello_near.wasm",
    "test": "ava -- ./build/hello_near.wasm"
  },
  ```

  `main.ava.js` file:
  ```js
  const pathToWasm = process.argv[2];
  await contract.deploy(pathToWasm);
  ```

  </TabItem>
</Tabs>

---

## Deploy Contracts

### Dev Deploy

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="109" end="115" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="167" end="188" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Deploy To Account

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="127" end="134" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="17" end="23" />

  </TabItem>
</Tabs>

---

## Logs

Show contract's logs.

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  You can use `println` or `dbg!` when you want to see information from your code.

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="15" end="19" />

  In Rust, the output from your code is captured by default and not displayed in the terminal. In order to see the output, you have to use the `--nocapture` flag

    eg. `cargo test -- --nocapture`

    If you want to access the contracts logs, you can find them in the `tx_outcome.logs()` Vec.

    ```rust
    let tx_outcome = user_account
            .call(contract.id(), "set_greeting")
            .args_json(json!({"greeting": "Hello World!"}))
            .transact()
            .await?;
        assert!(tx_outcome.is_success());

        dbg!(tx_outcome.logs());
        // [tests/test_basics.rs:29:5] tx_outcome.logs() = [
        //     "Saving greeting: Hello World!",
        // ]
    ```

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  Use `console.log` method when you want to see debug information from your code.

  ```js
  const balance = await account.balance();

  console.log('balance: ', balance);
  // balance:  {
  //   total: <BN: 52b7d2dcc80cd2e4000000>,
  //   stateStaked: <BN: 62a992e53a0af00000>,
  //   staked: <BN: 0>,
  //   available: <BN: 52b77033352798d9100000>
  // }
  ```

  </TabItem>
</Tabs>

---

## Account Balance

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="146" end="155" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="194" end="205" />

  </TabItem>
</Tabs>

---

## Transactions

### Call

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="164" end="176" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="42" end="43" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### View

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="185" end="209" />

  </TabItem>
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="36" end="37" />

  </TabItem>
</Tabs>

---

## Patch State on the Fly

In Sandbox-mode, you can add or modify any contract state, contract code, account or access key with `patchState`.

You can alter contract code, accounts, and access keys using normal transactions via the `DeployContract`, `CreateAccount`, and `AddKey` [actions](https://nomicon.io/RuntimeSpec/Actions#addkeyaction). But this limits you to altering your own account or sub-account. `patchState` allows you to perform these operations on any account.

<Tabs groupId="code-tabs">

  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="218" end="239" />

  </TabItem>

  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="211" end="222" />

  To see a complete example of how to do this, see the [patch-state test](https://github.com/near/workspaces-js/blob/main/__tests__/02.patch-state.ava.ts).

  </TabItem>

</Tabs>

:::note
As an alternative to `patchState`, you can stop the node, dump state at genesis, edit the genesis, and restart the node.
This approach is more complex to do and also cannot be performed without restarting the node.
:::

---

## Time Traveling

`workspaces` offers support for forwarding the state of the blockchain to the future. This means contracts which require time sensitive data do not need to sit and wait the same amount of time for blocks on the sandbox to be produced. We can simply just call `worker.fast_forward` to get us further in time:

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="248" end="272" />

  _[See the full example on Github](https://github.com/near/workspaces-rs/blob/main/examples/src/fast_forward.rs)._

  </TabItem>

  <TabItem value="js" label="üåê JavaScript">

  <Github fname="main.ava.js" language="js"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
      start="228" end="248" />

  </TabItem>

</Tabs>

---

## Using Testnet

NEAR Workspaces is set up so that you can write tests once and run them against a local Sandbox node (the default behavior) or against [NEAR TestNet](../../../1.concepts/basics/networks.md). Some reasons this might be helpful:

* Gives higher confidence that your contracts work as expected
* You can test against deployed testnet contracts
* If something seems off in Sandbox mode, you can compare it to testnet

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust" default>

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="279" end="304" />

  :::tip
  If you can create a new account on each iteration as well.
  :::

  </TabItem>

  <TabItem value="js" label="üåê JavaScript">

    You can switch to testnet mode in three ways:

    <details>

    <summary> 1. Setting the `Worker` network to `testnet` </summary>

    When creating Worker set network to `testnet` and pass your master account (an account for which you have the private key):

    ```ts
    const worker = await Worker.init({
      network: 'testnet',
      testnetMasterAccountId: '<yourAccountName>',
      initialBalance: NEAR.parse("<X> N").toString(),
    })
    ```

    </details>

    <details>

    <summary> 2. Setting environment variables </summary>

    Set the `NEAR_WORKSPACES_NETWORK` and `TESTNET_MASTER_ACCOUNT_ID` (an account for which you have the private key) environment variables when running your tests:

    ```bash
    NEAR_WORKSPACES_NETWORK=testnet TESTNET_MASTER_ACCOUNT_ID=<your master account Id> node test.js
    ```

    If you set this environment variables and pass `{network: 'testnet', testnetMasterAccountId: <masterAccountId>}` to `Worker.init`, the config object takes precedence.

    </details>

    <details>

    <summary> 3. Config file </summary>

    If you are using AVA, you can use a custom config file. Other test runners allow similar config files; adjust the following instructions for your situation.

    Create a file in the same directory as your `package.json` called `ava.testnet.config.cjs` with the following contents:

    ```js
    module.exports = {
    ...require('near-workspaces/ava.testnet.config.cjs'),
    ...require('./ava.config.cjs'),
    };
    module.exports.environmentVariables = {
        TESTNET_MASTER_ACCOUNT_ID: '<masterAccountId>',
    };
    ```

    Where the master account is an account for which you have the private key.

    The [near-workspaces/ava.testnet.config.cjs](https://github.com/near/workspaces-js/blob/main/ava.testnet.config.cjs) import sets the `NEAR_WORKSPACES_NETWORK` environment variable for you. A benefit of this approach is that you can then easily ignore files that should only run in Sandbox mode.

    Now you'll also want to add a `test:testnet` script to your `package.json`'s `scripts` section:

    ```diff
    "scripts": {
      "test": "ava",
    +  "test:testnet": "ava --config ./ava.testnet.config.cjs"
    }
    ```

    </details>

    To use the accounts, you will need to create the `.near-credentials/workspaces/testnet` directory and add files for your master account, for example:

    ```js
    // .near-credentials/workspaces/testnet/<your-account>.testnet.json
    {"account_id":"<your-account>.testnet","public_key":"ed25519:...","private_key":"ed25519:..."}
    ```

  Example:

  <Github fname="main.ava.js" language="js"
    url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
    start="252" end="263" />

  </TabItem>

</Tabs>

---

## Spooning Contracts

[Spooning a blockchain](https://coinmarketcap.com/alexandria/glossary/spoon-blockchain) is copying the data from one network into a different network. NEAR Workspaces makes it easy to copy data from Mainnet or Testnet contracts into your local Sandbox environment:

<Tabs groupId="code-tabs">

  <TabItem value="rust" label="ü¶Ä Rust" default>

  Specify the contract name from `testnet` you want to be pulling, and a specific block ID referencing back to a specific time. (Just in case the contract you're referencing has been changed or updated)

  Create a function called `pull_contract` which will pull the contract's `.wasm` file from the chain and deploy it onto your local sandbox. You'll have to re-initialize it with all the data to run tests. This is because the contract's data is too big for the RPC service to pull down. (limits are set to 50Mb)

  <Github fname="basics.rs" language="rust"
      url="https://github.com/near-examples/near-workspaces-examples/blob/main/contract-rs/tests/basics.rs"
      start="331" end="353" />

  </TabItem>

<TabItem value="js" label="üåê JavaScript">

```ts
const refFinance = await root.importContract({
  mainnetContract: 'v2.ref-finance.near',
  blockId: 50_000_000,
  withData: true,
});
```

This would copy the Wasm bytes and contract state from [v2.ref-finance.near](https://nearblocks.io/address/v2.ref-finance.near) to your local blockchain as it existed at block `50_000_000`. This makes use of Sandbox's special [patch state](#patch-state-on-the-fly) feature to keep the contract name the same, even though the top level account might not exist locally (note that this means it only works in Sandbox testing mode). You can then interact with the contract in a deterministic way the same way you interact with all other accounts created with near-workspaces.

:::note

`withData` will only work out-of-the-box if the contract's data is 50kB or less. This is due to the default configuration of RPC servers; see [the "Heads Up" note here](/api/rpc/contracts#view-contract-state).

:::

See a [TypeScript example of spooning](https://github.com/near/workspaces-js/blob/main/__tests__/05.spoon-contract-to-sandbox.ava.ts) contracts.

</TabItem>

</Tabs>

---

## Snippets

### Snippet I: Testing Hello NEAR

Lets take a look at the test of our [Quickstart Project](../quickstart.md) [üëã Hello NEAR](https://github.com/near-examples/hello-near-examples), where we deploy the contract on an account and test it correctly retrieves and sets the greeting.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="test_basics.rs"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-rs/tests/test_basics.rs" start="1" end="32"/>
  </Language>
  <Language value="js" language="js">
    <Github fname="main.ava.ts"
            url="https://github.com/near-examples/hello-near-examples/blob/main/contract-ts/sandbox-test/main.ava.js" start="11" end="45"/>
  </Language>
</CodeTabs>

<hr class="subsection" />

### Snippet II: Testing Donations

In most cases we will want to test complex methods involving multiple users and money transfers. A perfect example for this is our [Donation Example](https://github.com/near-examples/donation-examples), which enables users to `donate` money to a beneficiary. Lets see its integration tests

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="workspaces.rs"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-rs/tests/workspaces.rs" start="1" end="106"/>
  </Language>
  <Language value="js" language="js">
    <Github fname="main.ava.ts"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
            start="51" end="75" />
  </Language>
</CodeTabs>

---

## Additional Resources

### Advanced Examples

- [Rust](https://github.com/near/near-workspaces-rs/tree/main/examples)
- [JavaScript](https://github.com/near/near-workspaces-js/tree/main/__tests__)

<hr class="subsection" />

### Test Driven Design Using Workspaces and AVA {#test-driven-design}

The video below walks through how to apply TDD with Workspaces and AVA for a simple contract:

<iframe
  width="560"
  height="315"
  src="https://www.youtube-nocookie.com/embed/LCu03IYwu1I"
  title="TDD Using Workspaces"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen>
</iframe>


 This is the content for the doc docs/2.build/2.smart-contracts/testing/introduction.md 

 ---
id: introduction
title: Introduction
---

While developing your smart contract you will want to test that it works as it is supposed to, and moreover, does so securely. In NEAR we have developed tools to help you carry out such tests. Basically, there are two types of tests you can perform:

1. **Unit Tests** to test methods individually. They are written in the contract's language and are executed locally.
2. **Integration Tests** to test how your contract behaves in a realistic environment. You can write them in Rust or Typescript, and execute in a local Sandbox or the NEAR testnet.

We recommend all developers to implement both types of tests, since each is suitable to detect different types of errors and make your code intentional. Furthermore, we strongly recommend to first release all projects on testnet, and give users time to try them before releasing them on mainnet.

---
## Setting Up Testing
Testing a smart contract involves using different pieces of software depending on which type of test you are performing. In order to save you from the trouble of setting them up, we recommend you copy the structure from one of our [example projects](https://github.com/near-examples).

 This is the content for the doc docs/2.build/2.smart-contracts/testing/kurtosis-localnet.md 

 ---
id: kurtosis-localnet
title: Creating a Local Development Environment
sidebar_label: Local Development
description: Using Kurtosis NEAR Package to develop locally
---

> [Kurtosis](https://www.kurtosis.com/) has created an easy way to spin up a local NEAR testing environment using a [Docker container](https://www.docker.com/).

This Kurtosis NEAR Package contains the following components:

- [Indexer for Explorer](https://github.com/near/near-indexer-for-explorer)
- [NEAR Explorer](https://github.com/near/near-explorer)
- [NEAR Wallet](https://github.com/near/near-wallet)
- Local RPC Endpoint

[Visit here](https://www.loom.com/share/8a1b8e2138334a81a380f5d523fba27e) to see a short demo of the package in action.

---

## Prerequisites {#prerequisites}

- [Docker](https://docs.docker.com/get-docker/)
- [Yarn](https://classic.yarnpkg.com/lang/en/docs/install)
- [NEAR-CLI](/tools/near-cli#installation)
- [Kurtosis CLI](https://docs.kurtosis.com/install)
  - Start Kurtosis engine after installation using: `kurtosis engine start`

---

## Setup

### Launch Kurtosis NEAR Package {#launching-cluster}

Launch your Kurtosis NEAR Package in four easy steps!

1. Launch [Docker](https://docs.docker.com/get-docker/)

2. Copy the [Kurtosis NEAR Package launch script](https://github.com/kurtosis-tech/near-package/blob/master/launch-local-near-cluster.sh) by running the following:

```bash
curl -o ~/launch-local-near-cluster.sh https://raw.githubusercontent.com/kurtosis-tech/near-package/master/launch-local-near-cluster.sh -L
```

3. Grant write permission to the script file you just downloaded:

```bash
chmod u+x ~/launch-local-near-cluster.sh
```

4. Launch the Kurtosis NEAR Package:

If you're running the NEAR-in-Kurtosis cluster on your local machine:

```bash
~/launch-local-near-cluster.sh
```

If you're running your NEAR-in-Kurtosis cluster on a machine you intend to access remotely, replace `1.2.3.4` with the IP address of the machine you're running the cluster on:

```bash
~/launch-local-near-cluster.sh '{"backend_ip_address":"1.2.3.4"}'
```

<details>
<summary>Example response: </summary>

```bash
Created directory '/Users/zerix/.neartosis' for storing all NEAR-in-Kurtosis output
INFO[2022-12-06T12:59:04+05:30] Creating a new enclave for Starlark to run inside...
INFO[2022-12-06T12:59:14+05:30] Enclave 'near' created successfully
INFO[2022-12-06T12:59:14+05:30] Kurtosis CLI is running in a non interactive terminal. Everything will work but progress information and the progress bar will not be displayed.

> print "Starting the near-package with input struct(backend_ip_address = \"127.0.0.1\")"
Starting the near-package with input struct(backend_ip_address = "127.0.0.1")

> print "Launching contract helper postgresql"
Launching contract helper postgresql

> print "Adding contract helper Posgresql DB running on port '5432'"
Adding contract helper Posgresql DB running on port '5432'

> add_service service_id="contract-helper-db"
Service 'contract-helper-db' added with service GUID 'contract-helper-db-1670311755'

> exec service_id="contract-helper-db" command=["sleep", "10"]
Command returned with exit code '0' with no output

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "\\l"]
Command returned with exit code '0' and the following output:
List of databases
   Name    | Owner | Encoding |  Collate   |   Ctype    | Access privileges
-----------+-------+----------+------------+------------+-------------------
 near      | near  | UTF8     | en_US.utf8 | en_US.utf8 |
 postgres  | near  | UTF8     | en_US.utf8 | en_US.utf8 |
 template0 | near  | UTF8     | en_US.utf8 | en_US.utf8 | =c/near          +
           |       |          |            |            | near=CTc/near
 template1 | near  | UTF8     | en_US.utf8 | en_US.utf8 | =c/near          +
           |       |          |            |            | near=CTc/near
(4 rows)

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "create database indexer with owner=near"]
Command returned with exit code '0' and the following output: 'CREATE DATABASE'

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "create database analytics with owner=near"]
Command returned with exit code '0' and the following output: 'CREATE DATABASE'

> exec service_id="contract-helper-db" command=["psql", "-U", "near", "-c", "create database telemetry with owner=near"]
Command returned with exit code '0' and the following output: 'CREATE DATABASE'

> print "Contract helper postgresql db info struct(analytics_db = \"analytics\", db_user_password = \"near\", db_username = \"near\", indexer_db = \"indexer\", private_url = struct(ip_address = \"contract-helper-db\", path = \"\", port_number = 5432, protocol = \"postgres\"), telemetry_db = \"telemetry\")"
Contract helper postgresql db info struct(analytics_db = "analytics", db_user_password = "near", db_username = "near", indexer_db = "indexer", private_url = struct(ip_address = "contract-helper-db", path = "", port_number = 5432, protocol = "postgres"), telemetry_db = "telemetry")

> print "Launching contract helper dynamo db"
Launching contract helper dynamo db

> print "Adding contract helper DynamoDB running on default port '8000'"
Adding contract helper DynamoDB running on default port '8000'

> add_service service_id="contract-helper-dynamo-db"
Service 'contract-helper-dynamo-db' added with service GUID 'contract-helper-dynamo-db-1670311770'

> print "Contract helper dynamodb info struct(private_url = struct(ip_address = \"contract-helper-dynamo-db\", path = \"\", port_number = 8000, protocol = \"TCP\"))"
Contract helper dynamodb info struct(private_url = struct(ip_address = "contract-helper-dynamo-db", path = "", port_number = 8000, protocol = "TCP"))

> print "Launching indexer"
Launching indexer

> print "Adding indexer service..."
Adding indexer service...

> upload_files src="github.com/kurtosis-tech/near-package/static_files/near-configs/localnet" artifact_id="8f5279c5-d012-4543-88e7-e9829b6d6040"
Files uploaded with artifact ID '8f5279c5-d012-4543-88e7-e9829b6d6040'

> add_service service_id="indexer-node"
Service 'indexer-node' added with service GUID 'indexer-node-1670311774'

> exec service_id="indexer-node" command=["sleep", "10"]
Command returned with exit code '0' with no output

> exec service_id="indexer-node" command=["cat", "/root/.near/validator_key.json"]
Command returned with exit code '0' and the following output:
{
  "account_id": "test.near",
  "public_key": "ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW",
  "secret_key": "ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"
}

> print "Indexer launched with struct(private_rpc_url = struct(ip_address = \"indexer-node\", path = \"\", port_number = 3030, protocol = \"http\"), public_rpc_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8332, protocol = \"http\"), validator_key = {\"account_id\": \"test.near\", \"public_key\": \"ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW\", \"secret_key\": \"ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW\"})"
Indexer launched with struct(private_rpc_url = struct(ip_address = "indexer-node", path = "", port_number = 3030, protocol = "http"), public_rpc_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8332, protocol = "http"), validator_key = {"account_id": "test.near", "public_key": "ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW", "secret_key": "ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"})

> print "Launching contract helper"
Launching contract helper

> print "Adding contract helper service running on port '3000'"
Adding contract helper service running on port '3000'

> add_service service_id="contract-helper-service"
Service 'contract-helper-service' added with service GUID 'contract-helper-service-1670311796'

> print "Contract helper launchded with struct(private_url = struct(ip_address = \"contract-helper-service\", path = \"\", port_number = 3000, protocol = \"http\"), public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8330, protocol = \"http\"))"
Contract helper launchded with struct(private_url = struct(ip_address = "contract-helper-service", path = "", port_number = 3000, protocol = "http"), public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8330, protocol = "http"))

> print "Launching explorer backend"
Launching explorer backend

> print "Adding explorer backend service"
Adding explorer backend service

> add_service service_id="explorer-backend"
Service 'explorer-backend' added with service GUID 'explorer-backend-1670311799'

> print "Explorer backend launchded with struct(private_url = struct(ip_address = \"explorer-backend\", path = \"\", port_number = 8080, protocol = \"http\"), public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 18080, protocol = \"http\"))"
Explorer backend launchded with struct(private_url = struct(ip_address = "explorer-backend", path = "", port_number = 8080, protocol = "http"), public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 18080, protocol = "http"))

> print "Launching explorer frontend"
Launching explorer frontend

> print "Adding explorer frontend service running on port '3000'"
Adding explorer frontend service running on port '3000'

> add_service service_id="explorer-frontend"
Service 'explorer-frontend' added with service GUID 'explorer-frontend-1670311803'

> print "Explorer frontend launchded with struct(public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8331, protocol = \"http\"))"
Explorer frontend launchded with struct(public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8331, protocol = "http"))

> print "Launching wallet"
Launching wallet

> print "Adding wallet service running on port '3004"
Adding wallet service running on port '3004

> print "Replacing variable 'NODE_URL' to 'http://127.0.0.1:8332' using regexp: '([,{])NODE_URL:[^,]*([,}])'"
Replacing variable 'NODE_URL' to 'http://127.0.0.1:8332' using regexp: '([,{])NODE_URL:[^,]*([,}])'

> print "Replacing variable 'ACCOUNT_HELPER_URL' to 'http://127.0.0.1:8330' using regexp: '([,{])ACCOUNT_HELPER_URL:[^,]*([,}])'"
Replacing variable 'ACCOUNT_HELPER_URL' to 'http://127.0.0.1:8330' using regexp: '([,{])ACCOUNT_HELPER_URL:[^,]*([,}])'

> print "Replacing variable 'EXPLORER_URL' to 'http://127.0.0.1:8331' using regexp: '([,{])EXPLORER_URL:[^,]*([,}])'"
Replacing variable 'EXPLORER_URL' to 'http://127.0.0.1:8331' using regexp: '([,{])EXPLORER_URL:[^,]*([,}])'

> print "Replacing variable 'NETWORK_ID' to 'localnet' using regexp: '([,{])NETWORK_ID:[^,]*([,}])'"
Replacing variable 'NETWORK_ID' to 'localnet' using regexp: '([,{])NETWORK_ID:[^,]*([,}])'

> print "Replacing variable 'ACCOUNT_ID_SUFFIX' to 'test.near' using regexp: '([,{])ACCOUNT_ID_SUFFIX:[^,]*([,}])'"
Replacing variable 'ACCOUNT_ID_SUFFIX' to 'test.near' using regexp: '([,{])ACCOUNT_ID_SUFFIX:[^,]*([,}])'

> print "Replacing variable 'ACCESS_KEY_FUNDING_AMOUNT' to '3000000000000000000000000' using regexp: '([,{])ACCESS_KEY_FUNDING_AMOUNT:[^,]*([,}])'"
Replacing variable 'ACCESS_KEY_FUNDING_AMOUNT' to '3000000000000000000000000' using regexp: '([,{])ACCESS_KEY_FUNDING_AMOUNT:[^,]*([,}])'

> add_service service_id="wallet"
Service 'wallet' added with service GUID 'wallet-1670311807'

> print "Explorer wallet struct(public_url = struct(ip_address = \"127.0.0.1\", path = \"\", port_number = 8334, protocol = \"http\"))"
Explorer wallet struct(public_url = struct(ip_address = "127.0.0.1", path = "", port_number = 8334, protocol = "http"))

Starlark code successfully run. Output was:
{
 "contract_helper_service_url": "http://127.0.0.1:8330",
 "explorer_url": "http://127.0.0.1:8331",
 "near_node_rpc_url": "http://127.0.0.1:8332",
 "network_name": "localnet",
 "root_validator_key": {
  "account_id": "test.near",
  "public_key": "ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW",
  "secret_key": "ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"
 },
 "wallet_url": "http://127.0.0.1:8334"
}
INFO[2022-12-06T13:00:10+05:30] =============================================
INFO[2022-12-06T13:00:10+05:30] ||          Created enclave: near          ||
INFO[2022-12-06T13:00:10+05:30] =============================================
============================================================ SUCCESS ================================================================================
  ACTION Paste the following in your terminal to declare the following variables so you can use them:

         export NEAR_ENV="local"
         export NEAR_CLI_LOCALNET_NETWORK_ID="localnet"
         export NEAR_NODE_URL="http://127.0.0.1:8332"
         export NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-12-06T12.59.04/validator-key.json"
         export NEAR_WALLET_URL="http://127.0.0.1:8334"
         export NEAR_HELPER_URL="http://127.0.0.1:8330"
         export NEAR_HELPER_ACCOUNT="test.near
\"ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW\"})
ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"})
test.near"
         export NEAR_EXPLORER_URL="http://127.0.0.1:8331"

  ACTION Paste the following into your terminal now to use the 'local_near' command as a replacement for the NEAR CLI for connecting to your
         local cluster (e.g. 'local_near login'):

         alias local_near='NEAR_ENV="local" NEAR_CLI_LOCALNET_NETWORK_ID="localnet" NEAR_NODE_URL="http://127.0.0.1:8332" NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-12-06T12.59.04/validator-key.json" NEAR_WALLET_URL="http://127.0.0.1:8334" NEAR_HELPER_URL="http://127.0.0.1:8330" NEAR_HELPER_ACCOUNT="test.near
\"ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW\"})
ed25519:2ykcMLiM7vCmsSECcgfmUzihBtNdBv7v2CxNi94sNt4R8ar4xsrMMYvtsSNGQDfSRhNWXEnZvgx2wzS9ViBiS9jW"})
test.near" NEAR_EXPLORER_URL="http://127.0.0.1:8331" near'

  ACTION If you want the 'local_near' command available in all your new terminal windows, add the above alias into your .bash_profile/.bashrc/.zshrc
         file and open a new terminal window.

  ACTION To stop your cluster, run the following:

         kurtosis enclave stop near

  ACTION To remove your cluster, run:

         kurtosis clean -a

============================================================ SUCCESS ================================================================================
```

:::tip

The URLs and validator key value above will be the same for each run of Kurtosis, so you can safely use these values in your config files.

:::

:::tip

If you're running Kurtosis on a remote machine, you'll also need to:

- Replace the `127.0.0.1` IP addresses in the environment variables with the IP address of your remote machine
- Copy the validator key from where it lives on the machine running Kurtosis (in `NEAR_CLI_LOCALNET_KEY_PATH`) to somewhere on your local machine
- Adjust the value of the `NEAR_CLI_LOCALNET_KEY_PATH` on your local machine to match the location you stored the key at

:::

</details>

If you ever forget the above URLs, you can inspect the cluster:

```
kurtosis enclave inspect near
```

### Setup Environment Variables

After deploying your Kurtosis NEAR Package, you will need to setup some environment variables to make life a lot easier. Notice the **ACTION** sections in your terminal log from the package deployment. You will be using these exact values to setup these variables.

1. Follow the first ACTION item from the deployment log by copying all of the export commands and running them in your terminal.

**Example exports: (DO NOT COPY ~ yours will be slightly different)**

```bash
export NEAR_ENV="local"
export NEAR_CLI_LOCALNET_NETWORK_ID="localnet"
export NEAR_NODE_URL="http://127.0.0.1:8332"
export NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json"
export NEAR_WALLET_URL="http://127.0.0.1:8334"
export NEAR_HELPER_URL="http://127.0.0.1:8330"
export NEAR_HELPER_ACCOUNT="test.near"
export NEAR_EXPLORER_URL="http://127.0.0.1:8331"
```

2. Proceed to the second ACTION item which asks you to create an alias for `local_near`. This is what we will use when running [`near-cli`](/tools/near-cli) commands with our test environment.

**Example alias: (DO NOT COPY ~ yours will be slightly different)**

```bash
alias local_near='NEAR_ENV="local" NEAR_CLI_LOCALNET_NETWORK_ID="localnet" NEAR_NODE_URL="http://127.0.0.1:8332" NEAR_CLI_LOCALNET_KEY_PATH="/Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json" NEAR_WALLET_URL="http://127.0.0.1:8334" NEAR_HELPER_URL="http://127.0.0.1:8330" NEAR_HELPER_ACCOUNT="test.near" NEAR_EXPLORER_URL="http://127.0.0.1:8331" near'
```

Now replacing `near` with `local_near` when running [`near-cli`](/tools/near-cli) commands will perform these actions in your local test environment.

### Testing

Ensure that your alias is working correctly by checking the state of the root account `test.near`.

Run the following in your terminal:

```bash
local_near state test.near
```

This should return something similar to the following output:

```bash
Loaded master account test.near key from /Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json with public key = ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW
Account test.near
{
  amount: '1000000000000000000000000000000000',
  block_hash: 'G8jx4pYgqFSFSCDyM9MvVYj3HAdgRuxhkAHGweNhUNrY',
  block_height: 224,
  code_hash: '11111111111111111111111111111111',
  locked: '50000000000000000000000000000000',
  storage_paid_at: 0,
  storage_usage: 182,
  formattedAmount: '1,000,000,000'
}
```

**Congratulations! Setup is complete and you are ready to start exploring your local NEAR blockchain!** üéâ

:::tip

The Kurtosis Team has created a great [video presentation](https://www.loom.com/share/8a1b8e2138334a81a380f5d523fba27e) that covers the above steps as well as demoing the functionality of this local network setup.

:::

---

## Using Wallet and Explorer

### Local NEAR Wallet

Now that you have [everything setup](#setup), create an account using your local NEAR Wallet at 127.0.0.1:8334.

![Local wallet landing page](/docs/assets/kurtosis/local-wallet-landing-page.png)

The account creation is exactly the same as on mainnet or testnet but **only the passphrase recovery mode** will work here. Also note that the root account is `test.near` instead of `testnet` or `mainnet`. This means that all the accounts you create will be "subaccounts" of `test.near`. (ex. `benji.test.near`) [Read more](/concepts/protocol/account-id#named-address)

:::tip

Because the Wallet will start on the same host and port, and the Wallet stores your account information in your browser's local storage, if you've created an account with a previous Kurtosis network then the Wallet will be storing the old account's information (which won't work with your new network). If this is the case for you, you'll need to clear the Wallet's storage by visiting [your Chrome's local storage](chrome://settings/siteData?searchSubpage=127.0.0.1), removing the `127.0.0.1` entry, and refreshing the Wallet.

:::

Now that you've created an account, try interacting with it using the local CLI. In order to use this account you will need to "login" with it via CLI which will save a full access key locally for that account. [`near login`](/tools/near-cli#import) is the command to perform this action but as you are on `localnet` you will need to replace `near` with `local_near`.

```bash
local_near login
```

This launches the local wallet site and will ask for confirmation for this action. Once you authorize you should see confirmation in your terminal similar to this:

```bash
Logged in as [ kevin.test.near ] with public key [ ed25519:8EaALn... ] successfully
```

- Export your account ID to an environment variable by running the following: (replacing YOUR_ACCOUNT_ID)

```bash
export ACCOUNT_ID=YOUR_ACCOUNT_ID
```

- Now create a test transaction by sending 1 $NEAR to the root account `test.near`:

```bash
local_near send $ACCOUNT_ID test.near 1
```

<details>
<summary>Example response: </summary>

```bash
Sending 1 NEAR to test.near from kevin.test.near
Loaded master account test.near key from /Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json with public key = ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW
Transaction Id 3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
To see the transaction in the transaction explorer, please open this url in your browser
http://127.0.0.1:8331/transactions/3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
```

</details>

### Local NEAR Explorer

Again, now that you have [everything setup](#setup) you can view the transaction details of the command you just performed at the end of [the last section](#local-near-wallet). Notice that the last line of the terminal log displays a link to the transaction details in your local NEAR Explorer.

```bash
Sending 1 NEAR to test.near from kevin.test.near
Loaded master account test.near key from /Users/zerix/.neartosis/2022-06-03T18.04.32/validator-key.json with public key = ed25519:3Kuyi2DUXdoHgoaNEvCxa1m6G8xqc6Xs7WGajaqLhNmW
Transaction Id 3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
To see the transaction in the transaction explorer, please open this url in your browser
http://127.0.0.1:8331/transactions/3e3H5zqj9noKGYTCMqeZ5pb4NWK7tQsjYKak6ybtpgvD
```

- Click on this link or copy/paste it into your browser:

![Local explorer sending 1 NEAR](/docs/assets/kurtosis/local-explorer-send-funds.png)

Here everything behaves exactly like the `testnet` or `mainnet` NEAR Explorer except it is retrieving data from your local NEAR blockchain!

- If you ever need to open your local NEAR Explorer, you can always visit 127.0.0.1:8331 or run:

```bash
echo $NEAR_EXPLORER_URL
```

**Example Response:**

```bash
http://127.0.0.1:8331
```

![Localnet explorer](/docs/assets/kurtosis/localnet-explorer.png)

---

## Deploy a Smart Contract

With everything setup and your `test.near` account created, it's time to deploy a smart contract on `localnet`. For this example you will deploy an NFT use a pre-compiled WASM smart contract from [this NFT example](https://github.com/near-examples/nft-tutorial.git).

- Download the smart contract:

```
curl -o ~/main.wasm https://github.com/near-examples/nft-tutorial/raw/main/out/main.wasm -L
```

- Deploy the smart contract:

```
local_near deploy --wasmFile ~/main.wasm --accountId $ACCOUNT_ID
```

<details>
<summary>Example response: </summary>

```
Loaded master account test.near key from /Users/benjaminkurrek/.neartosis/2021-12-02T13.37.41/validator-key.json with public key = ed25519:AnLHi4ZAxfxFAQSXniycyZS6dpBqxhmVZH3zBCZbqAS6
Starting deployment. Account id: goteam.test.near, node: http://127.0.0.1:62285, helper: http://127.0.0.1:62286, file: /Users/benjaminkurrek/main.wasm
Transaction Id 7atHm2piVehEitYeMF2FxWuRJVd6ZdRQEo3K83P98GuR
To see the transaction in the transaction explorer, please open this url in your browser
http://127.0.0.1:62290/transactions/7atHm2piVehEitYeMF2FxWuRJVd6ZdRQEo3K83P98GuR
Done deploying to goteam.test.near
```

</details>

- Click on the clink to the Explorer and verify that the contract was deployed:

![Local explorer contract deployed](/docs/assets/kurtosis/local-explorer-contract-deployed.png)

Now, let's interact with the deployed contract.

- First, initialize the contract by running the following command:

```bash
local_near call $ACCOUNT_ID new_default_meta '{"owner_id": "'$ACCOUNT_ID'"}' --accountId $ACCOUNT_ID
```

This will initialize the contract with some default metadata and set our account ID as the owner of the contract.

- Now mint your first NFT!

```bash
local_near call $ACCOUNT_ID nft_mint '{"token_id": "team_token", "metadata": { "title": "Go Team!", "description": "Go Team!", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif", "copies": 1}, "receiver_id": "'$ACCOUNT_ID'"}' --accountId $ACCOUNT_ID --amount 0.1
```

Once the NFT has been minted, you can view the token on the local wallet's collectibles tab. If you already had the wallet site open, simply refresh. Otherwise open your local NEAR Wallet instance and view your collectible.

![Local wallet collectibles tab](/docs/assets/kurtosis/local-wallet-collectibles-tab.png)

We won't spoil what the NFT is, but once you switch over to the collectibles tab your beautiful token should be there!

---

## Connecting a dApp to `localnet`

The ability to develop decentralized applications locally is a dream come true for dApp developers and the Kurtosis NEAR Package really simplifies this process. Here you'll integrate `localnet` into one of the examples from [`near-examples`](https://github.com/near-examples/).

### Clone Example dApp

- Clone the [NEAR Guestbook](https://github.com/near-examples/guest-book-examples) repository:

```bash
git clone https://github.com/near-examples/guest-book-examples.git
```

### Configure Network

- Open the `src/config.js` file inside the guestbook repo and scroll down to the `local` config:

```javascript
case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      };
```

Here you will need to update all of the values **except** the `contractName`. Copy the following into your `local` case. This will automatically assign the config to your environment variables if you've specified them. This way, you don't need to change anything when running new enclaves.

```javascript
case 'local':
      return {
            networkId: process.env.NEAR_CLI_LOCALNET_NETWORK_ID || 'local',
            nodeUrl: process.env.NEAR_NODE_URL || 'http://localhost:3030',
            keyPath: process.env.NEAR_CLI_LOCALNET_KEY_PATH || `${process.env.HOME}/.near/validator_key.json`,
            walletUrl: process.env.NEAR_WALLET_URL || 'http://localhost:4000/wallet',
            contractName: CONTRACT_NAME,
        };
```

The last thing you will need to do is set your `NODE_ENV` in your terminal to `local` so your dApp will use the values we configured above.

- Run:

```bash
export NODE_ENV=local
```

**Your dApp is now fully configured to use `localnet`!** üéâ

### Create Contract Account

As mentioned earlier, you do not need to change the `contractName` in the `config.js` file you updated earlier. This is an environment variable you will configure now. Let's quickly create a subaccount from [the account you created earlier](#local-near-wallet) to deploy the guest-book contract to.

- Using the `local_near CLI`, run the following command:

```bash
local_near create-account guest-book.$ACCOUNT_ID --masterAccount $ACCOUNT_ID --initialBalance 5
```

**Example Response:**

```bash
Loaded master account test.near key from /Users/benjaminkurrek/.neartosis/2021-12-02T13.37.41/validator-key.json with public key = ed25519:AnLHi4ZAxfxFAQSXniycyZS6dpBqxhmVZH3zBCZbqAS6
Saving key to 'undefined/localnet/guest-book.goteam.test.near.json'
Account guest-book.goteam.test.near for network "localnet" was created.
```

- Export the `CONTRACT_NAME` environment variable as the account you just created:

```bash
export CONTRACT_NAME=guest-book.$ACCOUNT_ID
```

### Deploy Contract to `localnet`

With the network setup and contract account created you are now ready to launch your dApp!

- Run the following command in the root directory of the guest book repo:

```bash
yarn && yarn start
```

**Example Response:**

![Local dApp build](/docs/assets/kurtosis/local-dapp-build.png)

- Open the dApp by clicking on the server address in the terminal:

```bash
Server running at http://localhost:1234
‚ú®  Built in 1.20s.
```

You should see the Guest Book landing page:

![Local Guest Book Landing Page](/docs/assets/kurtosis/local-guest-book-landing.png)

:::tip

If you run into any problems signing into try clearing your browser's local storage. If you've used the guest-book before your browser might think you're still logged in with your `testnet` account and it will throw an error saying it can't find that account on `localnet`.

:::

Once you've logged in, you can sign a message with an optional donation.

![Local Guest Book Signed Message](/docs/assets/kurtosis/local-guest-book-signed-message.png)

- Sign the Guest Book which will create a transaction on `localnet`.

- Once complete, open your local NEAR explorer and you can view the transaction you just created!

![Local Explorer Signed Transaction](/docs/assets/kurtosis/local-explorer-signed-transaction.png)

**Congratulations! You've successfully deployed and interacted with a dApp on a local NEAR blockchain!** üéâ

---

## Managing NEAR Packages

The Kurtosis NEAR Packages you create will continue to run on your local machine for as long as your Docker engine is running. This package runs inside of a Kurtosis "enclave" which is an environment isolated from both your computer and other enclaves. In practice, this means that you can have multiple independent local NEAR clusters running on your machine simply by rerunning the script we executed from the [setup instructions](#setup).

### View Package Status

- To see the status of your existing enclaves, run:

```bash
kurtosis enclave ls
```

### View Package Details

- To see detailed information about an enclave, copy an enclave ID and run:

```bash
kurtosis enclave inspect near
```

### Terminate Package

- To shut down your NEAR Package and free up resources on your machine, run the following:

```bash
kurtosis enclave stop near
```

:::note

You will not be able to restart the cluster! If this is something you need, please [file an issue here](https://github.com/kurtosis-tech/kurtosis-cli-release-artifacts) so we can prioritize it.

:::

### Delete Package

- Stopping an enclave leaves its resources intact so that you can examine them if need be. To destroy a stopped enclave and free its resources, run:

```
kurtosis clean
```

### Delete All Package

If you would like to destroy _all_ enclaves, regardless of if they're running, pass the `-a` flag to `clean` like so:

```
kurtosis clean -a
```

This can be a handy way to clear all your Kurtosis data.


 This is the content for the doc docs/2.build/2.smart-contracts/testing/unit-test.md 

 ---
id: unit-test
title: Unit Testing
#sidebar_label: üß´ Unit Testing
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Unit tests allow you to test the contract methods individually. They are suitable to check the storage is updated correctly, and that methods return their expected values. They are written in the contract's language and execute locally.

If you used one of our [examples](https://github.com/near-examples/docs-examples) as template, then you simply need to navigate to the contract's folder, and use `yarn test`. In case you didn't, then we recommend you copy the necessary node files (e.g. `package.json`) from one of our templates.

:::tip
You can run `yarn test` from the root folder of each project to run both unit and [integration](integration-test.md) tests.
:::

---

## Snippet I: Testing a Counter

The tests in the [Counter Example](https://github.com/near-examples/counters) rely on basic functions to check that the `increment`, `decrement`, and `reset` methods work properly.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/counters/blob/main/contract-rs/src/lib.rs"
            start="47" end="68" />
    <Github fname="Cargo.toml"
            url="https://github.com/near-examples/counters/blob/main/contract-rs/Cargo.toml"
            start="18" end="19" />
  </Language>
</CodeTabs>

---

## Snippet II: Modifying the Context

While doing unit testing you can modify the [Environment variables](../anatomy/environment.md) through the `VMContextBuilder`. This will enable you to, for example, simulate calls from different users, with specific attached deposit and GAS. Here we present a snippet on how we test the `donate` method from our [Donation Example](https://github.com/near-examples/donation-examples) by manipulating the `predecessor` and `attached_deposit`.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-rs/src/lib.rs"
            start="58" end="105" />
    <Github fname="Cargo.toml"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-rs/Cargo.toml"
            start="18" end="19" />
  </Language>
</CodeTabs>

---

## ‚ö†Ô∏è Limitations

Unit tests are useful to check for code integrity, and detect basic errors on isolated methods. However, since unit tests do not run on a blockchain, there are many things which they cannot detect. Unit tests are not suitable for:

- Testing [gas](../anatomy/environment.md) and [storage](../anatomy/storage.md) usage
- Testing [transfers](../anatomy/actions.md)
- Testing [cross-contract calls](../anatomy/crosscontract.md)
- Testing complex interactions, i.e. multiple users depositing money on the contract

For all these cases it is necessary to **complement** unit tests with [integration tests](integration-test.md).


 This is the content for the doc docs/2.build/2.smart-contracts/what-is.md 

 ---
id: what-is
title: What is a Smart Contract?
sidebar_label: What is a Contract?
---

Smart contracts are pieces of **executable code** that live in a NEAR account. They can **store data**, **perform transactions** in the account‚Äôs name, and **expose methods** so other accounts can interact with them.

![img](/docs/assets/welcome-pages/contracts-landing.png)

Developers can choose between using Javascript or Rust to write smart contracts in NEAR. Indistinctly from the language chosen, the contract will be compiled into WebAssembly, from which point it can be deployed and executed on the NEAR platform.

<details>

<summary> New to Smart Contract Development? </summary>

Do not worry if you don't know how smart-contract blockchains work. As a developer, it is sufficient to understand that NEAR smart-contracts:
1. Have **limited** computational resources.
2. Interact with other contracts in an **asynchronous** way.
3. Deal with **real money**, for which security must be a top concern.

</details>

---

## Where do contracts live?
Smart Contracts are deployed into [**NEAR accounts**](../../1.concepts/protocol/account-model.md). Any NEAR account can hold a contract, needing to pay for the **contract's code** and the **data it stores**. 

Once in an account, anyone can interact with the contract. Thanks to the underlying network structure, executing code from a contract is both **fast** (avg. 1.4s finality) and **cheap**. Moreover, **read-only** operations are **free for everyone**.

:::tip
Storing 100kb costs 1‚ìÉ, so deploying a contract generally costs only a few $NEARs.
:::

---

## What can they do?

Smart contracts have **complete control over the account**, and thus can perform **any action on its behalf**. For example, contracts can:
- Transfer $NEAR Tokens 
- Call methods on other contracts
- Create new accounts and deploy contracts on them
- Update their own code

Besides, smart contracts can store data in the account's storage. This allows contracts to create almost any type of application, from simple games to complex financial systems.

:::danger What contracts cannot do
- Smart contracts cannot **access the internet**, so they cannot make HTTP requests or access external data 
- Smart contracts cannot **execute automatically**, they need to be called by an external account
:::

---

## What are they used for?
Smart contracts are useful to create **decentralized applications**. Some traditional examples include:
- [Decentralized Autonomous Organizations](https://dev.near.org/applications?cat=dao), where users create and vote proposals
- [Marketplaces](https://dev.near.org/applications?cat=marketplaces), where users create and commercialize digital art pieces
- [Decentralized exchanges](https://dev.near.org/applications?cat=exchanges), where users can trade different currencies
- [And many more...](https://dev.near.org/applications)

For instance, you can easily create a crowdfunding contract that accepts $NEAR. If the goal is met in time, the creator can claim the funds. Otherwise, the backers are refunded.

---

## Development flow

Just like any piece of software, smart contracts have a development flow - starting with its creation and ending with monitoring it, all of which we cover in our documentation.

![img](/docs/assets/welcome-pages/contract-lifecycle.png)
 "build/building-smart-contracts/testing/introduction",
The development flow can be summarized as follows:
- [**Scaffold**](./quickstart.md): The simplest way to create a project is by starting from a template.
- [**Build**](./anatomy/anatomy.md): Write a contract using Rust or Javascript.
- [**Test**](./testing/introduction.md): Our Sandbox enables to simulate interactions with one or multiple contracts in a realistic environment.
- [**Deploy**](./release/deploy.md): After making sure the contract is secure, developers can deploy the contract into their accounts.
- [**Use**](https://mynearwallet.com): Any user can interact with the contract through their NEAR Wallet.
- [**Monitor**](../6.data-infrastructure/what-is.md): The contract's activity can be monitored through simple APIs.

#### Supported Languages
During the whole cycle, developers can choose between [JavaScript](https://www.learn-js.org/) and [Rust](https://www.rust-lang.org/), allowing them to use their favorite language at each step of their journey.

<details>

<summary> Other languages </summary>

Theoretically, you can use any language that compiles to Wasm for developing NEAR smart contract. However, in order to have a user-friendly experience we would need to provide a library that wraps around low-level runtime APIs, while also offering other high-level functionalities.

We envision that in the future, more languages will be supported and the support will be done through the effort from the wider community, not just NEAR alone.

</details>

---

## Contract primitives
Contract primitives such as FT, NFT, and DAOs are fundamental building blocks that can be combined to create awesome user experiences such as reward tokens, decision-making tools, and marketplaces. 

:::tip

Check our section on [primitives](../5.primitives/what-is.md) to learn more about them

:::


 This is the content for the doc docs/2.build/4.web3-apps/ai/ai-assistant.md 

 ---
id: ai-assistant
title: AI Assistant
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

Welcome! In this guide, you'll discover an AI chatbot that can interact with the NEAR ecosystem

This AI agent can:

- Explore and explain what happened in a transaction when given a transaction hash
- Request tokens from the testnet faucet
- Mint and send a special NFT though a wallet it controls to a user
- Answer general questions about the NEAR architecture (powered by realtime search results)

:::tip Community Project 

Created by our community member [Reza](https://x.com/RezaRahemtola), this project was one of our AI track winners at the [ETHGlobal Brussels 2024 hackathon](https://ethglobal.com/events/brussels) 

:::

---

## Prerequisites

Let's start by setting up the environment to run the AI assistant locally.

<hr class="subsection" />

### Tools
Before starting, make sure you have the following tools installed:

- [Python >= 3.12](https://www.python.org/downloads/)
- [NodeJS >= 20](https://nodejs.org/en)
- [llama.cpp](https://github.com/ggerganov/llama.cpp)

<Tabs>
  <TabItem value="Mac">
    
    ```sh
    # Install Node.js using nvm (more option in: https://nodejs.org/en/download)
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    nvm install latest

    # Install python using miniconda (includes the package manager pip)
    brew install --cask miniconda
    conda init "$(basename "${SHELL}")"
    pip install poetry

    # Install llama.cpp
    brew install llama.cpp
    ```

  </TabItem>
  <TabItem value="Linux">
    Please help by contributing these steps for Linux!
  </TabItem>

</Tabs>

<hr class="subsection" />

### AI Model
In this tutorial we will be using the [NousResearch/Hermes-2-Pro-Llama-3-8B-GGUF](https://huggingface.co/NousResearch/Hermes-2-Pro-Llama-3-8B-GGUF) model, which is hosted on [Hugging Face](https://huggingface.co/login).

```sh
# Install the Hugging Face library
pip install huggingface_hub

# Login to your Hugging Face account
huggingface-cli login

# get the model from Hugging Face
huggingface-cli download NousResearch/Hermes-2-Pro-Llama-3-8B-GGUF Hermes-2-Pro-Llama-3-8B-Q4_K_M.gguf --local-dir model
```

:::info Q4_K_M Model

We use the small `Q4_K_M` model to reduce the time and resources needed to run the AI agent

:::

<hr class="subsection" />

### Execute the Model
You should now have a folder named `./model` with the [GGUF file](https://huggingface.co/docs/hub/en/gguf) `./model/Hermes-2-Pro-Llama-3-8B-Q4_K_M.gguf`, lets use `llama.cpp` to run it.

```bash
# run the model with llama.cpp
llama-server -m ./model/Hermes-2-Pro-Llama-3-8B-Q4_K_M.gguf
```

Open your browser at `http://localhost:8080`, if you see an interface similar to this one you are ready to go üöÄ
![llama.cpp UI](@site/static/docs/assets/llama-cpp.png)

:::tip

You can use a different model with llama.cpp if you wish! Just make sure it supports [function calling](https://docs.mistral.ai/capabilities/function_calling)

:::

---

### Project Setup

Start by cloning the repository of the project, in which you will find the AI agent and a basic frontend to interact with it:

```sh
git clone git@github.com:RezaRahemtola/near-ai-assistant.git
```

<hr class="subsection" />

### AI

Let's configure the AI agent, first, we install all python dependencies on the project 

```sh
cd ai/

# Important: Create a virtual environment
conda create -n ai-assistant python=3.12
conda activate ai-assistant

# Install the dependencies
pip install poetry
poetry install
```

Then you can create a `.env` file and fill it with values inspired from the `.env.example` file:
- `NEAR_ACCOUNT_ID`: The NEAR account id (i.e. account name) of your bot
- `NEAR_ACCOUNT_PRIVATE_KEY`: The private key to control the account
- `NEAR_RPC_URL`: can also be set in case you want to use a different RPC

Once you've done all this, you are ready to launch the code üöÄ

```sh
python src/main.py
```

<details> 

<summary> Optional: Google Search </summary>

`OXYLABS_USERNAME` and `OXYLABS_PASSWORD` are API credential used to access an SERP API to search information on Google

</details>

<hr class="subsection" />

### Frontend

Now that your AI agent is ready to go, let's quickly launch a basic frontend to interact with it:

```sh
cd front/
# Install the dependencies
yarn
# Start the frontend
yarn dev
```

----

## Usage

You can now head to `http://localhost:5173`, where you'll find an interface like this one to interact with the AI:
![img](@site/static/docs/assets/ai-assistant.png)

Here are a few example questions you can ask it:
- What is NEAR?
- What are the different transaction actions on NEAR?
- Can I please have an ETHGlobal Brussels NFT sent to me at random.testnet? Thanks
- I want to start using NEAR, can you send me some tokens on my testnet address random.testnet?
- I don't understand what this transaction is doing, can you help me? The transaction hash is `hash` and it was send by someone.testnet.

---

## Moving Forward

That's it for the quickstart tutorial. You have now seen an open-source AI agent interacting with NEAR and controlling a wallet to make transactions.

To better understand how it works, check the [`agent.py` file](https://github.com/RezaRahemtola/near-ai-assistant/blob/main/ai/src/agent/agent.py) and the [Function Calling explanation on HuggingFace](https://huggingface.co/NousResearch/Hermes-2-Pro-Llama-3-8B#prompt-format-for-function-calling).

A lot of things could be built by leveraging this PoC, some ideas could be:
- A chatbot integrated to the explorer to summarize transactions directly in the page
- Interactive tutorials in the documentation through a chatbot
  - "How to create an NFT?"
  - Multiple chats with explanations and code to complete given by the AI
  - In the end, the AI publish the smart contract, mint an NFT and send it to you on testnet
- An AI trader reacting to on-chain or off-chain events to buy/sell some tokens with its wallet
- The only limit is your imagination!

<MovingForwardSupportSection />


 This is the content for the doc docs/2.build/4.web3-apps/backend/backend.md 

 ---
id: backend-login
title: Authenticate NEAR Users 
---

import {Github} from "@site/src/components/codetabs"

Recently NEAR has approved a new standard that, among other things, enables users to authenticate into a backend service.

The basic idea is that the user will sign a challenge with their NEAR wallet, and the backend will verify the signature. If the signature is valid, then the user is authenticated.

---

## Backend Auth with a NEAR Wallet
Authenticating users is a common use-case for backends and web applications. This enables services to provide a personalized experience to users, and to protect sensitive data.

To authenticate a user, the backend must verify that the user is who they say they are. To do so, the backend must verify that the user has access to a full-access key that is associated with their account.

For this three basic steps are needed:

1. Create a challenge for the user to sign.
2. Ask the user to sign the challenge with the wallet.
3. Verify the signature corresponds to the user.

### 1.  Create a Challenge
Assume we want to login the user into our application named `application-name`.

We first need to create a challenge that the user will sign with their wallet. For this, it is recommended to use a cryptographically secure random number generator to create the challenge.

```js
import { randomBytes } from 'crypto'
const challenge = randomBytes(32)
const message = 'Login with NEAR'
```

:::note
Here we use [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback) to generate a 32 byte random buffer.
:::

### 2. Ask the User to Sign the Challenge
The `signMessage` method needed to sign the challenge is supported by these wallets:
- Meteor Wallet
- Here Wallet
- Near Snap
- Nightly Wallet
- WELLDONE Wallet
- NearMobileWallet
- MyNearWallet
- Sender


The message that the user needs to sign contains 4 fields:
- Message: The message that the user is signing.
- Recipient: The recipient of the message.
- Nonce: The challenge that the user is signing.
- Callback URL: The URL that the wallet will call with the signature.

```js
// Assuming you setup a wallet selector so far
const signature = wallet.signMessage({ message, recipient, nonce: challenge, callbackUrl: <server-auth-url> })
```

### 3. Verify the Signature
Once the user has signed the challenge, the wallet will call the `callbackUrl` with the signature. The backend can then verify the signature.

<Github fname="authenticate.js" language="javascript"
      url="https://github.com/near-examples/near-api-examples/blob/main/javascript/examples/verify-signature/authentication.js" />


 This is the content for the doc docs/2.build/4.web3-apps/ethereum-wallets.md 

 ---
sidebar_label: "Ethereum Wallets on Near"
id: ethereum-wallets
---

import { Github } from "@site/src/components/codetabs"

# How to integrate Ethereum Wallets to Near DApps?

In this article we will describe how to add EVM wallets support to your Near app, which is already uses the [Near Wallet Selector](https://github.com/near/wallet-selector/).

To integrate Metamask and other EVM wallets you will need to:

1. Update the `Wallet Selector` and add the Web3Modal libraries (`wagmi`, `web3wallet`, `@near-wallet-selector/ethereum-wallets`)
2. Create configurations so the Ethereum wallets can communicate with our Near RPCs
3. Create a Web3Modal and connect it to the Near Wallet Selector
4. Initialize the Ethereum Wallets 

We will show how we added Ethereum Wallets support to our [**Hello Near Examples**](https://github.com/near-examples/hello-near-examples/tree/main/frontend). Let's go step-by-step with it!

:::info
AuroraLabs team has worked on this feature almost for a year now. You can learn more about it from [NEP-518](https://github.com/near/NEPs/issues/518).
:::

:::tip

This article was created by the AuroraLabs team, and appeared originally in the [official Aurora documentation](https://doc.aurora.dev/dev-reference/eth-wallets)

:::

---

## 1. Update Wallet Selector libraries

Lets start by updating the `package.json`, adding all the necessary libraries to support Ethereum wallets.

<hr class="subsection" />

### Wallet Selector Packages


In your `package.json`, add the `@near-wallet-selector/ethereum-wallets` package, and update **all** wallet selector packages to version `8.9.13` or above:

```json title="package.json"
  "dependencies": {
    ...
    "@near-wallet-selector/core": "^8.9.13",
    // highlight-next-line
    "@near-wallet-selector/ethereum-wallets": "^8.9.13",
    "@near-wallet-selector/here-wallet": "^8.9.13",
    "@near-wallet-selector/modal-ui": "^8.9.13",
    "@near-wallet-selector/my-near-wallet": "^8.9.13",
    ...
    }
```

<hr class="subsection" />

### Add Web3Modal libraries

[Web3Modal (also known as AppKit)](https://reown.com/appkit) is a standard way to integrate multiple wallets in Ethereum community.

It is based on [wagmi] hooks library for React. We will describe the React integration here, but if you are on another platform - just go [here](https://docs.reown.com/appkit/overview#get-started), and try using specific instructions suitable for you to install it.

```bash
npm install @web3modal/wagmi wagmi viem @tanstack/react-query
```

---

## 2. Add Near chain config with our RPCs

We updated the config file of our repo to add the chain information necessary for Metamask to communicate with our RPC.

<Github fname="config.js" language="js"
      url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/config.js"
      start="6" end="20" />

---

## 3. Add Web3Modal

First, let's create a new file to handle the Web3Modal (i.e. the modal shown when selecting the `Ethereum Wallets` on the `Wallet Selector`), and all the configs needed to setup the Ethereum Wallets.

<Github fname="web3modal.js" language="js"
      url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/web3modal.js" />

<details>
  <summary> Metadata </summary>

  You can pass a `metadata` object to the `walletConnect` connector. This object will be displayed in the EVM wallets, like MetaMask.

  ```js title="source/wallets/web3modal.js"
  const url = "http://localhost:3000";

  const metadata = {
    name: "Onboard to NEAR Protocol with EVM Wallet",
    description: "Discover NEAR Protocol with Ethereum and NEAR wallets.",
    url: url,
    icons: [`${url}/icon.svg`],
  };
  ```

  This tracks the app requesting the connection on the WalletConnect side. See more [here](https://wagmi.sh/core/api/connectors/walletConnect#metadata).

</details>

:::tip

Make sure to call `reconnect(wagmiConfig)` in your code, to persist the connection between the app and the wallet when the user refreshes the page

:::

<hr class="subsection" />

### Get `projectId`

Notice that the modal uses a `projectId`, which refers to your unique project on `Reown`. Let's get the Web3Modal `projectId` for your project:

1. Go to [Cloud Reown](https://cloud.reown.com/).
2. Register there.
3. Create a project on Cloud Reown.
4. You can copy your `projectId`:

![reown_projectid](https://doc.aurora.dev/assets/images/reown_projectid-dbd1cc5521998d2f16545598ac925a5e.png)

:::tip

You can read more about the `projectId` and how it works [here](https://docs.reown.com/appkit/react/core/installation#cloud-configuration).

:::

---

## 4. Setup Wallet Selector

The last step is to add the Ethereum Wallets selector to your Near Wallet Selector. Let's find your `setupWalletSelector` call and add `setupEthereumWallets` there:

```js showLineNumbers
import { setupWalletSelector } from '@near-wallet-selector/core';
import { wagmiConfig, web3Modal } from '@/wallets/web3modal';
import { setupEthereumWallets } from "@near-wallet-selector/ethereum-wallets";
```

<Github fname="web3modal.js" language="js" start="42" end="53" metastring="{10}"
      url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js" />


---

## 5. Use It!

That is it! Just re-build your project and click on login! You should see Ethereum Wallets option in your Near Selector:

![ethwallets_popup1](https://doc.aurora.dev/assets/images/ethwallets_popup1-b113d70e3578a75f0f996aa3bcdf43e9.png)

And after click to be able to choose the EVM wallet of your taste:

![ethwallets_popup2](https://doc.aurora.dev/assets/images/ethwallets_popup2-8484d037a465af5134f112fba6eef918.png)

---

## Resources

1. [Source code of the project above](https://github.com/near-examples/hello-near-examples/blob/main/frontend/)

2. [Example of the EVM account on the Near Testnet](https://testnet.nearblocks.io/address/0xe5acd26a443d2d62f6b3379c0a5b2c7ac65d9454) to see what happens in reality on-chain during the execution.

3. Details about how does it work are in [NEP-518](https://github.com/near/NEPs/issues/518)

4. [Recording of the Near Devs call](https://drive.google.com/file/d/1xGWN1yRLzFmRn1e29kbSiO2W1JsxuJH-/view?usp=sharing) with the EthWallets presentation.


 This is the content for the doc docs/2.build/4.web3-apps/integrate-contracts.md 

 ---
id: integrate-contracts
title: Integrating Contracts
---
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

To integrate NEAR to your frontend, you will leverage two tools:

1. `Wallet Selector`: Enables the user to select their preferred NEAR wallet in your dApp.
2. `NEAR API JS`: A suite of tools to interact with the NEAR RPC.

Using those tools, you will implement the following flow:

1. **Setup** a wallet selector.
1. Load the wallet selector **on start-up**.
2. Ask the user to **sign-in** using a NEAR wallet.
2. **Call methods** in the contract.


:::warning NEAR BOS

  The project known as NEAR Blockchain Operating System (NEAR BOS) has been deprecated, but you can find its documentation on [this link](https://deprecated-near.github.io/legacy-docs/components/what-is)

:::

<details>

<summary> Alternatives to `near-api-js` </summary>

You can optionally use [Naxios](https://wpdas.gitbook.io/naxios). A promise-based NEAR Contract and NEAR Wallet Client for browser.

Naxios was designed to facilitate the React / Next.js integration with NEAR Blockchain and avoid the boilerplate of setting up a wallet and contract.

</details>


<details markdown="1">

<summary> Decentralized Frontend Solutions </summary>

This option is ideal if you need full decentralization of your entire stack. However, consider possible technical constraints, such as the absence of server-side rendering or meta frameworks like Next.js.

Although the ecosystem for developing decentralized frontends is still maturing, here are some notable projects for you to evaluate and consider:

| Name                                                                                      | <div align="center">Description</div>                                                                                                          |
|-------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|
| [**IPFS**](https://docs.ipfs.tech/how-to/websites-on-ipfs/single-page-website/)           | A peer-to-peer hypermedia protocol designed to preserve and grow humanity's knowledge by making the web upgradeable, resilient, and more open. |
| [**Fleek**](https://docs.fleek.co/tutorials/hosting/)                                     | Hosts websites on IPFS with a user-friendly interface and continuous deployment from popular repositories.                                     |
| [**Arweave**](https://www.arweave.org/build)                                              | Arweave lets you build quickly and simply with permanent storage. You can store anything from files to fully decentralized web applications.   |
| [**Web4**](https://web4.near.page/)                                                       | Web4 is a new way to distribute decentralized apps on NEAR Protocol. Deploy single WASM smart contract to deploy an entire web application.    |
| [**B.O.S. Components**](https://deprecated-near.github.io/legacy-docs/components/what-is) | An experimental platform that allows users to build and deploy multi-chain decentralized UI experiences.                                       |

</details>

---


## Adding NEAR API JS and Wallet Selector
As a popular framework [our examples](https://github.com/near-examples/) are based on **Next.js** so, we will go through the steps to integrate NEAR to a default Next.js project and interact with the `hello-near` example contract.

Apart of `near-api-js` and the `wallet-selector` core package we will also add the optional `modal-ui` and the provided `react-hook` (more info on [wallet-selector repo](https://github.com/near/wallet-selector/)) as well as few of the popular wallet providers.

If you prefer to explore the complete code example, you can check the [hello-near-example](https://github.com/near-examples/hello-near-examples/tree/main/frontend) repository.

```bash
npm install \
  near-api-js \
  @near-wallet-selector/core \
  @near-wallet-selector/modal-ui \
  @near-wallet-selector/react-hook \
  @near-wallet-selector/bitte-wallet \
  @near-wallet-selector/ledger \
  @near-wallet-selector/meteor-wallet \
  @near-wallet-selector/nightly
```
:::tip

The wallet selector supports multiple wallet packages to select from, [see the full list on the Repo](https://github.com/near/wallet-selector#installation-and-usage).
We cover how to support Ethereum wallets in the next section: [Ethereum Wallets on Near](ethereum-wallets.md)
:::

---

## Initialize Wallet Selector

```jsx title="_app.js"
import { setupBitteWallet } from "@near-wallet-selector/bitte-wallet";
import { setupLedger } from "@near-wallet-selector/ledger";
import { setupMeteorWallet } from "@near-wallet-selector/meteor-wallet";
import { setupNightly } from "@near-wallet-selector/nightly";
import { WalletSelectorProvider } from "@near-wallet-selector/react-hook";

const walletSelectorConfig = {
  network: "testnet", // "mainnet"
  // Optional: createAccessKeyFor: "hello.near-examples.testnet",
  modules: [
    setupBitteWallet(),
    setupMeteorWallet(),
    setupLedger(),
    setupNightly()
  ],
}

export default function App({ Component }) {
  return (
    <WalletSelectorProvider config={walletSelectorConfig}>
      <Component {...pageProps} />
    </WalletSelectorProvider>
  );
}
```
<details markdown="1" id="setting-customs-rpc-endpoints">

<summary>Setting custom RPC endpoints</summary>

If you want to use a user-defined RPC endpoint with the Wallet Selector, you can set up a [network options](https://github.com/near/wallet-selector/tree/main/packages/core#options) object with the custom URLs.
For example:


```js
const my_network = {
  networkId: "my-custom-network",
  nodeUrl: "https://rpc.custom-rpc.com",
  helperUrl: "https://helper.custom-helper.com",
  explorerUrl: "https://custom-explorer.com",
  indexerUrl: "https://api.custom-indexer.com",
};
```

:::tip

You can find the entire Wallet Selector [API reference here](https://github.com/near/wallet-selector/blob/main/packages/core/docs/api/selector.md).

:::

</details>

#### Optional: `createAccessKeyFor`

When initializing the wallet-selector, you can choose to **create a [Function-Call Key](/concepts/protocol/access-keys#function-call-keys)** using the `createAccessKeyFor` parameter.

By creating this key, your dApp will be able to **automatically sign non-payable transactions** on behalf of the user for specified contract.

---

## Calling View Methods

Once the wallet-selector is up, we can start calling view methods, i.e., the methods that perform read-only operations.

Because of their read-only nature, view methods are **free** to call, and do **not require** the user to be **logged in**.

  <Language value="js" language="jsx">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/pages/hello-near/index.js" start="19" end="20" />
  </Language>


The snippet above shows how we call view methods in our examples. Under the hood: we are actually making a **direct call to the RPC** using `near-api-js`.

:::tip

View methods have by default 200 TGAS for execution

:::

---

## User Sign-In / Sign-Out

In order to interact with non-view methods it is necessary for the user to first sign in using a NEAR wallet.

We can request the user sign in if `signedAccountId` is not present, the same simplicity applies to signing out.

<CodeTabs>
  <Language value="js" language="jsx">
    <Github fname="navigation.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/components/navigation.js"
            start="9" end="38" />

    <Github fname="_app.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/pages/_app.js"
            start="43" end="46" />

  </Language>
</CodeTabs>

When the user clicks the `login` button, they will be asked to select a wallet and use it to log in.

<hr className="subsection" />

### Function Call Key

If you instantiated the `wallet-selector` passing an account id for the `createAccessKeyFor` parameter, then the wallet will create a [Function-Call Key](/concepts/protocol/access-keys#function-call-keys) and store it in the web's local storage.

```js
const walletSelectorConfig = {
  network: "testnet", // "mainnet"
  createAccessKeyFor: "hello.near-examples.testnet",
  modules: [
  ...
  ],
}
```

By default, such key enables to expend a maximum of `0.25‚ìÉ` on GAS calling methods in **the specified** contract **without prompting** the user to sign them.

If, on the contrary, you do not create an access key, then the user will be asked to sign every single transaction (except calls to `view methods`, since those are always free).

:::tip

Please notice that this only applies to **non-payable** methods, if you attach deposit to any call the user will **always** be redirected to the wallet to confirm the transaction.

:::

---

## Calling Change Methods

Once the user logs in they can start calling `change methods`. Programmatically, calling `change methods` is similar to calling `view methods`, only that now you can attach deposit to the call, and specify how much GAS you want to use.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="index.js"
            url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/pages/hello-near/index.js"
            start="26" end="39" />
</Language>

</CodeTabs>

Under the hood, we are asking the **signedAccountId** to **sign a Function-Call transaction** for us.

:::tip

Remember that you can use the `callFunction` to call methods in **any** contract. If you did not ask for a function call key to be created, the user will simply be prompted to confirm the transaction.

:::

<hr className="subsection" />

## Sending Multiple Transactions

The wallet-selector hook also exposes a method that can be used to send multiple transactions.

<CodeTabs>
  <Language value="js" language="js">
  ```js
  ...
  const { signAndSendTransactions } = useWalletSelector();

  const txs = await signAndSendTransactions({
      transactions: [{
          receiverId: "hello.near-examples.testnet",
          actions: [{
              type: "FunctionCall",
              params: {
                  methodName: "set_greeting",
                  args: {
                      greeting: "Hello World"
                  },
                  gas: THIRTY_TGAS,
                  deposit: NO_DEPOSIT
              }
          }]
      }
      ...
      ]
  });
  ```
  </Language>
</CodeTabs>

Transactions can either be sent as multiple separate transactions simultaneously or as a batch transaction made up of actions where if one of the actions fails, they are all reverted. An example of both can be seen [here](https://docs.near.org/tutorials/examples/frontend-multiple-contracts#dispatching-multiple-transactions)

---
## Signing Messages


<CodeTabs>
  <Language value="js" language="js">
  ```js
  ...
  const { signMessage } = useWalletSelector();

  const sign = await signMessage({ message, recipient, nonce });

  ```
  </Language>
</CodeTabs>

---

## Querying Account Balance

By calling the `getBalance` method the user can get the balance of a given account.

 <Language value="js" language="js">
 ```js
  ...
  const { getBalance } = useWalletSelector();

  const balance = await getBalance("account.testnet");
```
</Language>


---

## Get Access Keys

The final method the the wallet selector hooks exposes is `getAccessKeys` which is used to return an object of all the access keys on the account that is currently logged in.

<Language value="js" language="js">
```js
...
const { getAccessKeys } = useWalletSelector();

const keys = await getAccessKeys("account.testnet");
```
</Language>

---

## Handling Data Types

When calling methods in a contract or receiving results from them, you will need to encode/decode parameters correctly. For this, it is important to know how the contracts encode timestamps (u64) and deposit amounts (u128).

##### Time

The block timestamp in a smart contract is encoded using nanoseconds (i.e. 19 digits: `1655373910837593990`). In contrast, `Date.now()` from javascript returns a timestamp in milliseconds (i.e 13 digits: `1655373910837`). Make sure to convert between milliseconds and nanoseconds to properly handle time variables.

##### Deposits

Smart contracts speak in yocto NEAR, where 1‚ìÉ = 10^24yocto, and the values are always encoded as `strings`.

- Convert from NEAR to yocto before sending it to the contract using `near-api-js.utils.format.parseNearAmount(amount.toString())`.
- Convert a response in yoctoNEAR to NEAR using `near-api-js.utils.format.formatNearAmount(amount)`

:::tip

If the contract returns a `Balance` instead of a `U128`, you will get a "scientific notation" `number` instead of a `string` (e.g. `10^6` instead of `"1000000"`). In this case, you can convert the value to NEAR by doing:

```js
function formatAmount(amount) {
  let formatted = amount.toLocaleString("fullwide", { useGrouping: false })
  formatted = utils.format.formatNearAmount(formatted)

  return Math.floor(formatted * 100) / 100
}
```

:::

---

## Leveraging NEAR API JS

NEAR API JS does not limit itself to simply calling methods in a contract. In fact, you can use it to transform your web-app into a rich user experience. While we will not cover these topics in depth, it is important for you to know that with NEAR API JS you can also:

- **[Sign and verify messages](./backend/backend.md)**: this is very useful for proving that a message was created by the user.
- **[Create batch transactions](https://github.com/near/near-api-js/tree/master/packages/cookbook/transactions/batch-transactions.ts)**: this enables to link multiple [actions](../../1.concepts/protocol/transaction-anatomy.md#actions) (e.g. multiple function calls). If one of the transactions fails, then they are all reverted.
- **[Create accounts](https://github.com/near/near-api-js/tree/master/packages/cookbook/accounts/create-testnet-account.ts)**: deploy accounts for your users!

Check the [NEAR API](../../4.tools/near-api.md) section to learn how to supercharge your web-app.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- next: `15.0.3`
- near-api-js: `^5.0.1`
- wllet-selector/core: `^8.10.0`

:::


 This is the content for the doc docs/2.build/4.web3-apps/quickstart.md 

 ---
id: quickstart
title: Hello WebApp
sidebar_label: Quickstart ‚ú®
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from '@site/src/components/codetabs';
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

In this guide we will show you how to quickly spin up a frontend where users can **login** using their wallets and interact with a **contract**.

:::tip Searching to integrate NEAR in your App?
If you already have an application and want to integrate NEAR into it, we recommend you to first go through this guide and then check our documentation on [integrating NEAR to a frontend](./integrate-contracts.md)
:::

---

## Create NEAR App
If you already have [Node.js](https://nodejs.org/en/download) installed, simply run:

```bash
  npx create-near-app@latest
```

Use the interactive menu to set up:
1. `A Web App`.
2. `NextJs (Classic)`.

<details>
<summary> More boilerplate options from `create-near-app` </summary>

Using `create-near-app` you can also set up:
   - NextJs (App Router)
   - Vite (React)
   - JS/TS Smart Contract
   - Rust Smart Contract

</details>

:::tip Using pnpm
While you can use our app with any package manager, we recommend you to skip the installation step and manually install the dependencies using `pnpm i`.
:::

Once the folder is ready - and all dependencies installed - you can start the development server using `pnpm`.

```bash
pnpm dev
```

Visit `http://localhost:3000` in your browser to view the dApp. Note that since the dApp uses NextJS the app might take longer to load the pages on first visit.

<details>
<summary> The app is not starting? </summary>

Make sure you are using **node >= v18**, you can easily switch versions using `nvm use 18`

</details>

<hr className="subsection" />
:::info Info: Community Starter Templates

  These are some community templates that you can use to start quickstart your project. Reffer to their pages for more information:
 * [Bitte Templates](https://templates.mintbase.xyz) - A `collection` of templates from [Bitte](https://www.bitte.ai/) and [MintBase](https://mintbase.xyz)
 * [NEARBuilders/near-vite-starter](https://github.com/NEARBuilders/near-vite-starter) - `Vite`, `TypeScript`, `Tanstack`, `Tailwind`,`Playwright`

:::
---

## Landing Page

Once the app starts you will see the landing page, rendering a navigation bar that allows users to login using their NEAR wallet. You can then navigate to the docs or the `Near Integration` page (which we will do).

![img](/docs/assets/examples/hello-near-landing-page.png)
*Landing page of Hello NEAR Gateway*

Go ahead and sign in with your NEAR account. If you don't have one, you can create one on the fly.

<hr className="subsection" />

### Under the Hood

[Next.js](https://nextjs.org/) uses a template system, where each page is a React component.

Our app's template is defined at `./src/pages/_app.js`. It does two things:

1. Initializes a [wallet selector](../../4.tools/wallet-selector.md), and stores it in context so other components can access it later.
2. Renders the navigation menu and the page's content.

<Github url="https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/pages/_app.js" language="jsx" start="22" end="48" />

When initializing the wallet-selector you can choose to **create a [Function-Call Key](../../1.concepts/protocol/access-keys.md)** using the `createAccessKeyFor` parameter. This allows the application to sign `non-payable` methods on behalf of the user so they are not required to manually sign each transaction.

```jsx
const walletSelectorConfig = {
  networkId: NetworkId,
  createAccessKeyFor: HelloNearContract,
  modules: [
    ...
  ],
};
```

This example additionally includes the option to login with `Metamask` and other `EVM wallets`. Further information on how to add EVM wallets to your application can be found in the [Ethereum Wallets on NEAR documentation](./ethereum-wallets.md).

<details>
<summary>What is the wallet selector?</summary>

The wallet selector is a modal that allows users to select their preferred Near wallet to login. Our application creates a new instance of the wallet selector then stores it in the apps context so it can be accessed by other components.

</details>

<hr className="subsection" />

### Navigation Bar & Login
The navigation bar implements buttons to `login` and `logout` users with their Near wallet.

The code for the navigation bar can be found at `./src/components/navigation.js`. The login and logout buttons are implemented by using the `signIn` and `signOut` methods from the wallet selector previously initialized:

<Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/components/navigation.js" language="jsx" start="10" end="23" />

---

## Interacting with NEAR

Now that you understand how the landing page works, we can move to the `Near Integration` page, which retrieves a greeting from the [hello.near-examples.testnet](https://testnet.nearblocks.io/address/hello.near-examples.testnet) contract.

![img](/docs/assets/examples/hello-near-gateway.png)
*View of the `Near Integration` page*

Login if you haven't done it yet and you will see a simple form that allows you to store a greeting in the smart contract.

<hr className="subsection" />

### Under the Hood
We retrieve the `wallet` we initialized earlier via the `useContext` hook. The wallet allows us to interact with the smart contract through `viewMethod` and `callMethod`.

- `viewMethod` is used to call functions that are read-only
- `callMethod` is used to call functions that modify the state of the contract

<Github url="https://github.com/near-examples/hello-near-examples/blob/master/frontend/src/pages/hello-near/index.js" language="jsx" start="13" end="36" />

On load, the first `useEffect` hook will call the contract's `get_greeting` method and set the `greeting` state to the result.

If the user is logged in, the user will be able to use the `saveGreeting` function which will call the contract's `set_greeting` method and then update the `greeting`.

---

## Moving Forward

That's it for our quickstart tutorial. You have now seen a fully functional frontend that can talk with NEAR contracts and render Web3 components.

<MovingForwardSupportSection />


 This is the content for the doc docs/2.build/4.web3-apps/what-is.md 

 ---
id: what-is
title: What are Web3 Apps? 
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Web3 Applications - also known as decentralized apps (dApps) - leverage [smart contracts](../2.smart-contracts/what-is.md) and blockchain data to offer **transparency**, **security** and **giving back control** to users over their assets and data.

![img](/docs/assets/welcome-pages/examples.png)

NEAR simplifies building Web3 apps for the general public, making it easy to **interact** with different blockchains, while helping to **onboard users** that are not familiarized with crypto.

---

### Why Integrating NEAR to your App?
Any application can benefit from integrating NEAR, including games, financial services, social platforms, and more.

- **Easy Onboarding**: Users can create accounts using familiar methods such as email login. Furthermore, applications can cover all transactional costs for their users, so they never have to worry about handling crypto.

- **Ownership**: Users have true ownership of digital assets within their accounts. Fungible Tokens can be used as reward systems, Non-Fungible Tokens can denote holdings, and wallets can represent digital identities.

- **Fast, Cheap and Scalable**: Near‚Äôs efficient consensus mechanism and fee model make transactions cost effective for both users and developers.

- **Security & Transparency**: All transactions and data on the blockchain is transparent and auditable, thus ensuring trust in the application‚Äôs behavior.



 This is the content for the doc docs/2.build/5.primitives/dao.md 

 ---
id: dao
title: Decentralized Autonomous Organizations
sidebar_label: Autonomous Organizations (DAO)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetDAOList from "@site/src/components/docs/primitives/dao/bos/get-dao-list.md"
import BOSGetProposalList from "@site/src/components/docs/primitives/dao/bos/get-proposal-list.md"
import BOSCreateDAO from "@site/src/components/docs/primitives/dao/bos/create-dao.md"
import BOSCreateProposal from "@site/src/components/docs/primitives/dao/bos/create-proposal.md"
import BOSVoteForProposal from "@site/src/components/docs/primitives/dao/bos/vote-for-proposal.md"

import WebAppGetDAOList from "@site/src/components/docs/primitives/dao/web-app/get-dao-list.md"
import WebAppGetProposalList from "@site/src/components/docs/primitives/dao/web-app/get-proposal-list.md"
import WebAppCreateDAO from "@site/src/components/docs/primitives/dao/web-app/create-dao.md"
import WebAppCreateProposal from "@site/src/components/docs/primitives/dao/web-app/create-proposal.md"
import WebAppVoteForProposal from "@site/src/components/docs/primitives/dao/web-app/vote-for-proposal.md"

import CLIGetDAOList from "@site/src/components/docs/primitives/dao/near-cli/get-dao-list.md"
import CLIGetProposalList from "@site/src/components/docs/primitives/dao/near-cli/get-proposal-list.md"
import CLICreateDAO from "@site/src/components/docs/primitives/dao/near-cli/create-dao.md"
import CLICreateProposal from "@site/src/components/docs/primitives/dao/near-cli/create-proposal.md"
import CLIVoteForProposal from "@site/src/components/docs/primitives/dao/near-cli/vote-for-proposal.md"

import SmartContractCreateDAO from "@site/src/components/docs/primitives/dao/smart-contract/create-dao.md"
import SmartContractCreateProposal from "@site/src/components/docs/primitives/dao/smart-contract/create-proposal.md"
import SmartContractVoteForProposal from "@site/src/components/docs/primitives/dao/smart-contract/vote-for-proposal.md"

Decentralized Autonomous Organizations (DAOs) are self-organized groups that form around common purposes. Membership, decision-making, and funding are coordinated by publicly voting on proposals through a smart contract.

![dao](/docs/primitives/dao.png)

In contrast with [FT](ft.md) and [NFT](nft.md), DAO contract's are not standardized. Because of this, on this page we will use as
reference the [Astra dao](https://dev.near.org/astraplusplus.ndctools.near/widget/home?page=daos) [contract](https://github.com/near-daos/sputnik-dao-contract). The main concepts covered here should
easily generalizable to other DAO implementations.

---

## Create a DAO
The simplest way to create and interact with a DAO is to go through the [AstraDAO UI](https://dev.near.org/astraplusplus.ndctools.near/widget/home?page=daos).

You can also create a DAO by interacting with the `sputnik-dao` contract.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateDAO />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateDAO />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractCreateDAO />
  </TabItem>
</Tabs>

<hr className="subsection" />

### Voting policy
Currently, DAOs support two different types of [voting policies](https://github.com/near-daos/sputnik-dao-contract#voting-policy): `TokenWeight`, and `RoleWeight`.

When the vote policy is `TokenWeight`, the council votes using [tokens](ft.md). The weigh of a vote is the proportion of tokens used for voting over the token's total supply.

When the vote policy is `RoleWeight(role)`, the vote weigh is computed as "one over the total number of people with the role".

<details>
<summary> Voting Threshold </summary>
Both voting policies further include a `threshold` for passing a proposal, which can be a ratio or a fixed number.

The ratio indicates that you need a proportion of people/tokens to approve the proposal (e.g. half the people need to vote, and to vote positively). A fixed number indicated that you need a specific number of votes/tokens to pass the proposal (e.g. 3 people/tokens are enough to approve the proposal).
</details>

---

## List of DAOs

Query the list of DAOs existing in Sputnik Dao.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetDAOList />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetDAOList />
  </TabItem>
</Tabs>

---

## Query Existing Proposals

These snippets will enable you to query the proposals existing in a particular DAO.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetProposalList />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetProposalList />
  </TabItem>
</Tabs>

---

## Create proposal

Create a proposal so other users can vote in favor or against it.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateProposal />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateProposal />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractCreateProposal />
  </TabItem>
</Tabs>

:::info
By default, only **council members** can create proposals.
:::

---

## Vote for proposal

These snippet will enable your users to cast a vote for proposal of a particular DAO.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppVoteForProposal />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIVoteForProposal />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractVoteForProposal />
  </TabItem>
</Tabs>

---

## Additional Resources

1. [NEAR Treasury](https://neartreasury.com/) - a Treasury management web app built on top of the Sputnik DAO Contract. Allows users to create and manage treasury funds with ease.
2. [List of DAOs as a NEAR component](https://dev.near.org/onboarder.near/widget/DAOSocialSearch)


 This is the content for the doc docs/2.build/5.primitives/dex.md 

 ---
id: dex
title: Decentralized Exchanges (DEX)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetPrice from "@site/src/components/docs/primitives/dex/bos/get-price.md"
import BOSSwap from "@site/src/components/docs/primitives/dex/bos/swap.md"
import BOSGetPools from "@site/src/components/docs/primitives/dex/bos/get-pools.md"
import BOSGetDepositBalances from "@site/src/components/docs/primitives/dex/bos/get-deposit-balances.md"

import WebAppGetPrice from "@site/src/components/docs/primitives/dex/web-app/get-price.md"
import WebAppSwap from "@site/src/components/docs/primitives/dex/web-app/swap.md"
import WebAppGetPools from "@site/src/components/docs/primitives/dex/web-app/get-pools.md"
import WebAppGetDepositBalances from "@site/src/components/docs/primitives/dex/web-app/get-deposit-balances.md"

import CLISwap from "@site/src/components/docs/primitives/dex/near-cli/swap.md"
import CLIGetPools from "@site/src/components/docs/primitives/dex/near-cli/get-pools.md"
import CLIGetDepositBalances from "@site/src/components/docs/primitives/dex/near-cli/get-deposit-balances.md"

import SmartContractSwap from "@site/src/components/docs/primitives/dex/smart-contract/swap.md"
import SmartContractGetPools from "@site/src/components/docs/primitives/dex/smart-contract/get-pools.md"
import SmartContractGetDepositBalances from "@site/src/components/docs/primitives/dex/smart-contract/get-deposit-balances.md"

A Decentralized Exchange (DEX) is an application that allows users to trade tokens (native & fungible tokens) through smart contracts.

![dex](/docs/primitives/dex.png)

In brief, DEXs work by having [pools of token pairs](https://guide.ref.finance/products/overview/pooling) (e.g. NEAR-USDC) that users can deposit tokens into.

The ratio of the tokens in the pool determines the exchange rate for a swap. Indeed, swapping is adding tokens to one side of the pool while removing tokens from the other side of the pool.

:::info

This docs refer to [Ref Finance](https://www.ref.finance/), a community built DEX in NEAR.

Please check their [docs](https://guide.ref.finance/developers-1/cli-trading) for more information.

:::

---

## Query Token Exchange Rate
One can query the exchange rate of a token pair by calling the `get-token-price` method on the DEX contract.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetPrice />
  </TabItem>
</Tabs>

---

## Query Whitelisted Tokens
Anyone list tokens for sale in the DEX. This is why, in order to protect users, the DEX contract has a list of whitelisted tokens that can be traded.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near view v2.ref-finance.near get_whitelisted_tokens
```

</TabItem>

</Tabs>

<details>

<summary> Examples Response </summary>

```bash
  'wrap.near',
  'usdt.tether-token.near',
  'berryclub.ek.near',
  'farm.berryclub.ek.near',
  'token.v2.ref-finance.near',
  'token.paras.near',
  'marmaj.tkn.near',
  'meta-pool.near',
  ...
```

</details>

---

## Register in the DEX
In order to use the contract, make sure to register your account in the DEX by paying for the storage you will use in order to keep track of your balances.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call v2.ref-finance.near storage_deposit '' --accountId <account> --amount 0.1
```

</TabItem>

</Tabs>

---

## Deposit funds

In order to swap tokens, one must first deposit tokens into the DEX. For this, you will need to transfer the FT you want to swap to the DEX contract.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call token.v2.ref-finance.near ft_transfer_call {"receiver_id": "v2.ref-finance.near", "amount": "1000000000000", "msg": ""} --gas 300000000000000 --depositYocto 1 --accountId <account>
```

</TabItem>

</Tabs>

:::danger

Do **NOT** transfer **NEAR** tokens to Ref Finance. Instead, call `near_deposit` in the [`wrap.near`](https://nearblocks.io/address/wrap.near) contract, attaching the amount of NEAR you want to swap.

This will mint `wrap.near` for you, which you can then transfer to Ref Finance.

:::

---

## Get Deposit Balances

Query your deposit balances by calling the `get_deposits` method:

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetDepositBalances />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetDepositBalances />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractGetDepositBalances />
  </TabItem>
</Tabs>

---

### Query Pools

DEXs work by having multiple pools of token pairs (e.g. NEAR-USDC) that users can deposit tokens into.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetPools />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetPools />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractGetPools />
  </TabItem>
</Tabs>

---

## Swap tokens
In order to swap a token for another, you need to [have funds](#deposit-funds), and there needs to [**exist a pool**](#query-pools) that has **both tokens** on it.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppSwap />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLISwap />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractSwap />
  </TabItem>
</Tabs>

---

## Additional Resources

1. [Claim Fungible Tokens from Lockup](https://near.org/near/widget/ComponentDetailsPage?src=whtt.near/widget/Draft-0) - the example how to claim locked tokens from the `lockup.burrow.near` contract.
2. [BSC Dex Collection](https://near.org/near/widget/ComponentDetailsPage?src=bluebiu.near/widget/Bsc.Swap.Dex) - the example of how to build simple swap page for a DEX.


 This is the content for the doc docs/2.build/5.primitives/ft.md 

 ---
id: ft
title: Fungible Tokens (FT)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSGetMetadata from "@site/src/components/docs/primitives/ft/bos/get-metadata.md"
import BOSCheckBalance from "@site/src/components/docs/primitives/ft/bos/check-balance.md"
import BOSSendToken from "@site/src/components/docs/primitives/ft/bos/send.md"
import BOSRegister from "@site/src/components/docs/primitives/ft/bos/register.md"
import BOSAttachTokenToCall from "@site/src/components/docs/primitives/ft/bos/attach-to-call.md"
import BOSCreateToken from "@site/src/components/docs/primitives/ft/bos/create.md"

import WebAppGetMetadata from "@site/src/components/docs/primitives/ft/web-app/get-metadata.md"
import WebAppCheckBalance from "@site/src/components/docs/primitives/ft/web-app/check-balance.md"
import WebAppSendToken from "@site/src/components/docs/primitives/ft/web-app/send.md"
import WebAppRegister from "@site/src/components/docs/primitives/ft/web-app/register.md"
import WebAppAttachTokenToCall from "@site/src/components/docs/primitives/ft/web-app/attach-to-call.md"
import WebAppCreateToken from "@site/src/components/docs/primitives/ft/web-app/create.md"

import CLIGetMetadata from "@site/src/components/docs/primitives/ft/near-cli/get-metadata.md"
import CLICheckBalance from "@site/src/components/docs/primitives/ft/near-cli/check-balance.md"
import CLISendToken from "@site/src/components/docs/primitives/ft/near-cli/send.md"
import CLIRegister from "@site/src/components/docs/primitives/ft/near-cli/register.md"
import CLIAttachTokenToCall from "@site/src/components/docs/primitives/ft/near-cli/attach-to-call.md"
import CLICreateToken from "@site/src/components/docs/primitives/ft/near-cli/create.md"
import CLICreateTokenManually from "@site/src/components/docs/primitives/ft/near-cli/create-manually.md"

import SmartContractSendToken from "@site/src/components/docs/primitives/ft/smart-contract/send.md"
import SmartContractAttachTokenToCall from "@site/src/components/docs/primitives/ft/smart-contract/attach-to-call.md"

import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";

Besides the native NEAR token, NEAR accounts have access to a [multitude of tokens](https://guide.ref.finance/developers-1/cli-trading#query-whitelisted-tokens) to use throughout the ecosystem. Moreover, it is even possible for users to create their own fungible tokens.

In contrast with the NEAR native token, fungible token (FT) are **not stored** in the user's account. In fact, each FT lives in **their own contract** which is in charge of doing **bookkeeping**. This is, the contract keeps track of how many tokens each user has, and handles transfers internally.

![FT](/docs/primitives/ft.png)

In order for a contract to be considered a FT-contract it has to follow the [**NEP-141 and NEP-148 standards**](https://nomicon.io/Standards/FungibleToken/). The **NEP-141** & **NEP-148** standards explain the **minimum interface** required to be implemented, as well as the expected functionality.

---

## Token Factory Tool
You can create an FT using the toolbox on [Dev Portal](https://dev.near.org/tools). The FT Tool is a token factory, you can interact with it through graphical interface, or by making calls to its contract.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCreateToken />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateToken />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/create-ft-via-factory.json" />
  </TabItem>
</Tabs>

The FT you create will live in the account `<your_token_symbol>.tkn.primitives.near` (e.g. `test.tkn.primitives.near`).

---

## Deploying Your Own Contract

You can also create a fungible token by deploying and initializing a [canonical FT contract](https://github.com/near-examples/FT).

On initialization, you will define the token's metadata such as its name (e.g. Ethereum), symbol (e.g. ETH) and total supply (e.g. 10M). You will also define an `owner`, which will own the tokens **total supply**.

To initialize a FT contract you will need to deploy it and then call the `new` method defining the token's metadata.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICreateTokenManually />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/create-ft-manually.json" />
  </TabItem>
</Tabs>


:::tip
Check the [Contract Wizard](https://dev.near.org/contractwizard.near/widget/ContractWizardUI) to create a personalized FT contract!.
:::

---

## Querying Metadata
You can query the FT's metadata by calling the `ft_metadata`.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppGetMetadata />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIGetMetadata />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/query-ft-metadata.json" />
  </TabItem>
</Tabs>

---

## Checking Balance
To know how many coins a user has you will need to query the method `ft_balance_of`.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppCheckBalance />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLICheckBalance />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/check-ft-balance.json" />
  </TabItem>
</Tabs>

---

## Registering a User
In order for an user to own and transfer tokens they need to first **register** in the contract. This is done by calling `storage_deposit` and attaching 0.00125‚ìÉ.

By calling this `storage_deposit` the user can register themselves or **register other users**.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppRegister />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIRegister />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/register-user.json" />
  </TabItem>
</Tabs>

:::info
You can make sure a user is registered by calling `storage_balance_of`.
:::

:::tip
After a user calls the `storage_deposit` the FT will appear in their Wallets.
:::

---

## Transferring Tokens
To send FT to another account you will use the `ft_transfer` method, indicating the receiver and the amount of FT you want to send.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppSendToken />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLISendToken />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/transfer-tokens.json" />
  </TabItem>
  <TabItem value="üìÑ Contract"  label="üìÑ Contract"  default>
    <SmartContractSendToken />
  </TabItem>
</Tabs>

---

## Attaching FTs to a Call
Natively, only NEAR tokens (‚ìÉ) can be attached to a function calls. However, the FT standard enables to attach fungible tokens in a call by using the FT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the FT-contract to do both a transfer and a function call in your name.

Let's assume that you need to deposit FTs on Ref Finance.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppAttachTokenToCall />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIAttachTokenToCall />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/ft/attach-ft-to-call.json" />
  </TabItem>
  <TabItem value="üìÑ Contract"  label="üìÑ Contract"  default>
    <SmartContractAttachTokenToCall />
  </TabItem>
</Tabs>

How it works:

1. You call ft_transfer_call in the FT contract passing: the receiver, a message, and the amount.
2. The FT contract transfers the amount to the receiver.
3. The FT contract calls receiver.ft_on_transfer(sender, msg, amount)
4. The FT contract handles errors in the ft_resolve_transfer callback.
5. The FT contract returns you how much of the attached amount was actually used.

---

## Handling Deposits (Contract Only)

If you want your contract to handle deposit in FTs you have to implement the `ft_on_transfer` method. When executed, such method will know:

- Which FT was transferred, since it is the predecessor account.
- Who is sending the FT, since it is a parameter
- How many FT were transferred, since it is a parameter
- If there are any parameters encoded as a message

The `ft_on_transfer` must return how many FT tokens have to **be refunded**, so the FT contract gives them back to the sender.

```rust
// Implement the contract structure
#[near(contract_state)]
impl Contract {}

#[near]
impl FungibleTokenReceiver for Contract {
  // Callback on receiving tokens by this contract.
  // `msg` format is either "" for deposit or `TokenReceiverMessage`.
  fn ft_on_transfer(
    &mut self,
    sender_id: AccountId,
    amount: U128,
    msg: String,
  ) -> PromiseOrValue<U128> {
    let token_in = env::predecessor_account_id();

    assert!(token_in == self.ft_contract, "{}", "The token is not supported");
    assert!(amount >= self.price, "{}", "The attached amount is not enough");

    env::log_str(format!("Sender id: {:?}", sender_id).as_str());

    if msg.is_empty() {
      // Your internal logic here
      PromiseOrValue::Value(U128(0))
    } else {
      let message =
        serde_json::from_str::<TokenReceiverMessage>(&msg).expect("WRONG_MSG_FORMAT");
      match message {
        TokenReceiverMessage::Action {
          buyer_id,
        } => {
          let buyer_id = buyer_id.map(|x| x.to_string());
          env::log_str(format!("Target buyer id: {:?}", buyer_id).as_str());
          // Your internal business logic
          PromiseOrValue::Value(U128(0))
        }
      }
    }
  }
}
```

---

## Additional Resources

1. [NEP-141 and NEP-148 standards](https://nomicon.io/Standards/Tokens/FungibleToken/)
2. [FT Event Standards](https://nomicon.io/Standards/Tokens/FungibleToken/Event)
3. [FT reference implementation](https://github.com/near-examples/FT)
4. [Fungible Tokens 101](../../3.tutorials/fts/0-intro.md) - a set of tutorials that cover how to create a FT contract using Rust.


 This is the content for the doc docs/2.build/5.primitives/linkdrop.md 

 ---
id: linkdrop
title: Linkdrops
hide_table_of_contents: false
---
import {FeatureList, Column, Feature} from "@site/src/components/featurelist"
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import { Github } from "@site/src/components/codetabs"
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";

Linkdrops allow users to distribute assets and onboard people to Web3 apps through a simple web link.

![Linkdrop](/docs/primitives/linkdrop.png)

They work by storing assets and linking [AccessKeys](../../1.concepts/protocol/access-keys.md) to them. The `AccessKeys` are then distributed to users in the form of web links. These links take users to a website that automatically uses the keys to call the `claim` method in the `linkdrop` contract.

In order for a contract to be considered a Linkdrop-contract it has to follow the [**NEP-452 standard**](https://github.com/near/NEPs/blob/master/neps/nep-0452.md). The **NEP-452** explains the **minimum interface** required to be implemented, as well as the expected functionality.

---

## [Keypom](https://keypom.xyz/)

The simplest way to create Linkdrops is by using [Keypom](https://keypom.xyz/). Keypom is a community project that allows you to create Linkdrops for NEAR tokens and NFTs in a few clicks.

![keypom](/docs/primitives/keypom.png)

---

## AccessKeys

In order to create any kind of drop, you need to first generate key pairs. You will need to create **one key per drop**.

- The `linkdrop` contract will store the **`public`** part of the key.
- You will give the `private` part of the key to the user you want to receive the drop.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

<Tabs className="file-tabs">

<TabItem value="near-api-js" label="near-api-js">

```js
import { KeyPair } from 'near-api-js';

const newKeyPair = KeyPair.fromRandom('ed25519');
newKeyPair.public_key = newKeyPair.publicKey.toString();
```

</TabItem>

<TabItem value="Keypom API" label="Keypom API">

```js
const state = {};

const dropsNumber = "2";
const keysGeneratorUrl = "https://keypom.sctuts.com/keypair/";

fetch(keysGeneratorUrl + dropsNumber + "/rootEntrophy").then((res) => {
  const keyPairs = JSON.parse(res.body);
  const pubKeys = [];
  const privKeys = [];

  keyPairs.forEach((e) => {
    pubKeys.push(e.pub);
    privKeys.push(e.priv);
  });

  state.publicKeys = pubKeys;
  state.privKeys = privKeys;
});
```

</TabItem>

</Tabs>

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

<Tabs className="file-tabs">

<TabItem value="Near CLI" label="Near CLI">

```bash
# This command creates a key pair locally in .near-credentials with an implicit account as the accountId (hash representation of the public key)

near generate-key
```

**Example response:**

```bash
Key pair with ed25519:33Vn9VtNEtWQPPd1f4jf5HzJ5weLcvGHU8oz7o5UnPqy public key for an account "1e5b1346bdb4fc5ccd465f6757a9082a84bcacfd396e7d80b0c726252fe8b3e8"
```

</TabItem>

<TabItem value="Keypom API" label="Keypom API">
```bash
export NUMBER_OF_DROPS=2

curl https://keypom.sctuts.com/keypair/$NUMBER_OF_DROPS/rootEntrophy
```

</TabItem>

</Tabs>
</TabItem>

  <TabItem value="Lantstool" label={<LantstoolLabel/>}>
    <p>Generate a new key on [Lantstool](https://app.lantstool.dev/)</p>
    ![lantstool](/docs/assets/lantstool/lantstool-near_protocol-utils-key_generator.png)
  </TabItem>
</Tabs>

---

## $NEAR Drops

To create a $NEAR drop you will ask the contract to create a drop (`create_drop`), passing the public part of the keys you generated, and how much you want to drop on each key use (`deposit_per_use`).

The contract will create a drop and **return the numerical ID** that identifies it.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const DROP_AMOUNT = "10000000000000000000000"; // 0.1 NEAR

const wallet = new Wallet({ createAccessKeyFor: KEYPOM_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js)_

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000"}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```

  </TabItem>

  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/linkdrop/create-near-drop.json" />
  </TabItem>
</Tabs>

:::info
To claim the drop, you will need to send the user a [link with the private key](#building-drop-links)
:::

---

## NFT Drops

To drop an existing NFT, you will (1) create a drop, and then (2) **transfer the NFT** to keypom.

#### 1. Creating the Drop

To create an NFT drop, you will call the `create_drop` method, now passing a `nft` argument, which will tell the linkdrop contract to wait for an NFT to be transferred.

The contract will then create a drop and **return the numerical ID** that identifies it.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const NFT_CONTRACT_ADDRESS = "nft.primitives.near";
const DROP_AMOUNT = "10000000000000000000000";

const keypomConnectedWallet = new Wallet({ createAccessKeyFor: KEYPOM_CONTRACT_ADDRESS });
const nftConnectedWallet = new Wallet({ createAccessKeyFor: NFT_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
    nft: {
      // Who will be sending the NFTs to the Keypom contract
      sender_id: accountId, // TODO How to get it
      // NFT Contract Id that the tokens will come from
      contract_id: NFT_CONTRACT_ADDRESS,
    },
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js)_

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000", "nft": {"sender_id": "bob.near", "contract_id": "nft.primitives.near"}}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```

  </TabItem>

    <TabItem value="Lantstool" label={<LantstoolLabel />}>
        <TryOutOnLantstool path="docs/2.build/5.primitives/linkdrop/create-nft-drop.json" />
    </TabItem>
</Tabs>

#### 2. Transferring the NFT

Having the Drop ID, you now need to transfer the NFT to the linkdrop contract, specifying to which drop you want to add it.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const NFT_CONTRACT_ADDRESS = "nft.primitives.near";
const NFT_TOKEN_ID = "1";
const DROP_AMOUNT = "10000000000000000000000";

const nftConnectedWallet = new Wallet({ createAccessKeyFor: NFT_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "nft_transfer_call",
  contractId: NFT_CONTRACT_ADDRESS,
  args: {
    receiver_id: keypomContract,
    token_id: nftTokenId,
    msg: dropId.toString()
  },
  deposit: 1,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js)_

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call nft.primitives.near nft_transfer_call '{"receiver_id": "v2.keypom.near", "token_id": <YOUR TOKEN ID>, "msg": <YOUR DROP ID>}' --depositYocto 1 --gas 100000000000000 --accountId bob.near
```

  </TabItem>

  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/linkdrop/transfer-nft-to-v2keypomnear.json" />
  </TabItem>
</Tabs>

:::tip
The `linkdrop` contract will validate that you are transferring the NFT to a drop that belongs to you
:::

---

## FT Drops

The process to drop a Fungible Token is very similar to that of creating an [NFT drop](#nft-drops). You will first create the drop, and then fund it with FTs.

#### 1.Creating a drop

To create a FT drop you will call the `create_drop` method, now passing a `ftData` argument, which will tell the linkdrop contract to wait for a certain amount of FT to be transferred.

The contract will then create a drop and **return the numerical ID** that identifies it.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const FT_CONTRACT_ADDRESS = "ft.primitives.near";
const DROP_AMOUNT = "10000000000000000000000";

const wallet = new Wallet({ createAccessKeyFor: KEYPOM_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
    ftData: {
      contractId: FT_CONTRACT_ADDRESS,
      senderId: accountId, // TODO How to get account id
      // This balance per use is balance of human readable FTs per use.
      amount: "1"
      // Alternatively, you could use absoluteAmount, which is dependant on the decimals value of the FT
      // ex. if decimals of an ft = 8, then 1 FT token would be absoluteAmount = 100000000
    },
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js)_

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000", "ftData": {"contractId": "ft.primitives.near","senderId": "bob.near", "amount": "1"}}}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```

  </TabItem>

  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/linkdrop/create-ft-drop.json" />
  </TabItem>
</Tabs>

#### 2. Transferring FT

Having the Drop ID, you now need to transfer the fungible tokens to the linkdrop contract.

:::note
To transfer FTs to an account, you need to first [register](./ft#registering-a-user) the receiver account (e.g. the keypom contract) on the FT contract.
:::

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const FT_CONTRACT_ADDRESS = "ft.primitives.near";

const wallet = new Wallet({ createAccessKeyFor: FT_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "ft_transfer",
  contractId: FT_CONTRACT_ADDRESS,
  args: {
    receiver_id: KEYPOM_CONTRACT_ADDRESS,
    amount: "1"
  },
  deposit: "1",
  gas: "100000000000000"
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js)_

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call ft.primitives.near ft_transfer '{"receiver_id": "v2.keypom.near", "amount": "1"}' --depositYocto 1 --gas 100000000000000 --accountId bob.near
```

  </TabItem>

  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/linkdrop/transfer-ft-to-v2keypomnear.json" />
  </TabItem>
</Tabs>

---

## Function Call Drop
Linkdrop contracts allow to create `function call` drops. These drops will execute one or more methods on a contract when the user claims the drop.

:::tip
Function call drops can be thought as the abstract version of other drops: you can create a drop that will mint an NFT, register a user in a DAO, or pay for a service.
:::

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">

```js
import { Wallet } from './near-wallet';

const KEYPOM_CONTRACT_ADDRESS = "v2.keypom.near";
const NFT_CONTRACT_ADDRESS = "nft.primitives.near";
const NFT_TOKEN_ID = "1";
const DROP_AMOUNT = "10000000000000000000000";

const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });

await wallet.callMethod({
  method: "create_drop",
  contractId: KEYPOM_CONTRACT_ADDRESS,
  args: {
    public_keys: state.publicKeys,
    deposit_per_use: DROP_AMOUNT,
    fcData: {
      // 2D array of function calls. In this case, there is 1 function call to make for a key use
      // By default, if only one array of methods is present, this array of function calls will be used for all key uses
      methods: [
        // Array of functions for Key use 1.
          [{
            receiverId: NFT_CONTRACT_ADDRESS,
            methodName: "nft_mint",
            args: JSON.stringify({
            // Change this token_id if it already exists -> check explorer transaction
                token_id: NFT_TOKEN_ID,
                metadata: {
                  title: "My NFT drop",
                  description: "",
                  media: "",
                }
            }),
            accountIdField: "receiver_id",
            // Attached deposit for when the receiver makes this function call
            attachedDeposit: "10000000000000000000000"
          }]
      ]
    }
  },
  deposit: "23000000000000000000000" // state.publicKeys.length * dropAmount + 3000000000000000000000,
  gas: "100000000000000",
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/src/wallets/near.js)_

  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call v2.keypom.near create_drop '{"public_keys": <PUBLIC_KEYS>, "deposit_per_use": "10000000000000000000000", "fcData": {"methods": [[{"receiverId": "nft.primitives.near","methodName": "nft_mint","args": {"token_id": "1", "metadata": {"title": "My NFT drop","description": "","media": ""}, "accountIdField": "receiver_id", "attachedDeposit": "10000000000000000000000"}]]}}' --depositYocto 23000000000000000000000 --gas 100000000000000 --accountId bob.near
```

  </TabItem>

  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/2.build/5.primitives/linkdrop/create-function-call-drop.json" />
  </TabItem>
</Tabs>

---

## Building drop links

```js
const getLinks = () => {
  const links = [];

  // It assumes that private keys have been already stored in State by using State.init() and State.update() method
  state.privKeys.map((e, i) => {
    const link =
      "https://app.mynearwallet.com" + "/linkdrop/v2.keypom.near/" + e;
    links.push(link);
  });

  return links;
};
```

<details>
<summary>Example response</summary>
<p>

```js
[
  'https://app.mynearwallet.com/linkdrop/v2.keypom.near/ed25519:2H32THYM8ob336yk81cZUxpidvKi34zLck6a97ypmCY8bbSAuEfrCTu9LWmWGiG9df2C6vkg2FGKGZzY9qE4aEcj',
  'https://app.mynearwallet.com/linkdrop/v2.keypom.near/ed25519:3eoMcqKmmY9Q6qgBy3hZy65HisZ8NXQd9aGGYUGe6RRsmNpGJS5YN64MgZaBVVYJJhbFXhQ2ca3DRRBiKh1rYM48'
]
```

</p>

</details>

:::note
If you didn't save your linkdrop links before closing NEAR App, you can always find them on [Keypom app](https://keypom.xyz/drops).
:::

---

## Additional Resources

1. [Linkdrop plus](https://near.org/near/widget/ComponentDetailsPage?src=cuongdcdev.near/widget/linkdrop_plus) allows to create a Simple Drop. Powered by [Keypom](https://keypom.xyz/)
2. [Keypom Drop Viewer](https://near.org/near/widget/ComponentDetailsPage?src=kiskesis.near/widget/Keypom-Drop-Viewer-fork) shows drops created by current logged in user.


 This is the content for the doc docs/2.build/5.primitives/nft.md 

 ---
id: nft
title: Non-Fungible Tokens (NFT)
hide_table_of_contents: false
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import BOSMintNFT from "@site/src/components/docs/primitives/nft/bos/mint.md"
import BOSBuyNFT from "@site/src/components/docs/primitives/nft/bos/buy.md"
import BOSQueryNFT from "@site/src/components/docs/primitives/nft/bos/query.md"
import BOSTransferNFT from "@site/src/components/docs/primitives/nft/bos/transfer.md"
import BOSListNFTForSale from "@site/src/components/docs/primitives/nft/bos/list-for-sale.md"

import WebAppMintNFT from "@site/src/components/docs/primitives/nft/web-app/mint.md"
import WebAppBuyNFT from "@site/src/components/docs/primitives/nft/web-app/buy.md"
import WebAppQueryNFT from "@site/src/components/docs/primitives/nft/web-app/query.md"
import WebAppTransferNFT from "@site/src/components/docs/primitives/nft/web-app/transfer.md"
import WebAppListNFTForSale from "@site/src/components/docs/primitives/nft/web-app/list-for-sale.md"

import CLIMintNFT from "@site/src/components/docs/primitives/nft/near-cli/mint.md"
import CLIBuyNFT from "@site/src/components/docs/primitives/nft/near-cli/buy.md"
import CLIQueryNFT from "@site/src/components/docs/primitives/nft/near-cli/query.md"
import CLITransferNFT from "@site/src/components/docs/primitives/nft/near-cli/transfer.md"
import CLIListNFTForSale from "@site/src/components/docs/primitives/nft/near-cli/list-for-sale.md"

import SmartContractMintNFT from "@site/src/components/docs/primitives/nft/smart-contract/mint.md"
import SmartContractBuyNFT from "@site/src/components/docs/primitives/nft/smart-contract/buy.md"
import SmartContractQueryNFT from "@site/src/components/docs/primitives/nft/smart-contract/query.md"
import SmartContractTransferNFT from "@site/src/components/docs/primitives/nft/smart-contract/transfer.md"

In contrast with fungible tokens, non-fungible tokens (NFT) are unitary and therefore unique. This makes NFTs ideal to represent ownership of assets such as a piece of digital content, or a ticket for an event.

As with fungible tokens, NFTs are **not stored** in the user's wallet, instead, each NFT lives in a **NFT contract**. The NFT contract works as a bookkeeper, this is: it is in charge of handling the creation, storage and transfers of NFTs.

In order for a contract to be considered a NFT-contract it has to follow the [**NEP-171 and NEP-177 standards**](https://nomicon.io/Standards/Tokens/NonFungibleToken). The **NEP-171** & **NEP-177** standards explain the **minimum interface** required to be implemented, as well as the expected functionality.

:::info NFT & Marketplaces

Be mindful of not confusing an NFT with an NFT-marketplace. NFT simply store information (metadata), while NFT-marketplaces are contracts where NFT can be listed and exchanged for a price.

:::

---

## Community Projects
The easiest way to create and handle NFTs is by using one of the existing community projects.

1. [Paras](https://paras.id/) - a classic NFT marketplace. Just login with your NEAR account, create a collection and share the link with your community.
2. [Mintbase](https://www.mintbase.xyz/) - a marketplace that allows to create NFT collections, and buy NFTs using credit cards or stablecoins.
3. [Enleap](https://enleap.app/) - a no-code launchpad for NFTs. Provides NFT minting, staking, whitelist managing, tracking functionality.

---

## Deploying a NFT Contract
If you want to deploy your own NFT contract, you can create one using our [reference implementation](https://github.com/near-examples/NFT)

Simply personalize it and deploy it to your account.

```bash
near deploy <account-id> --wasmFile contract.wasm --initFunction new
```

:::tip

Check the [Contract Wizard](https://dev.near.org/contractwizard.near/widget/ContractWizardUI) to create a personalized NFT contract!.

:::

---

## Minting a NFT
To create a new NFT (a.k.a. minting it) you will call the `nft_mint` method passing as arguments the metadata that defines the NFT.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppMintNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIMintNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract" default>
    <SmartContractMintNFT />
  </TabItem>
</Tabs>

:::info

See the [metadata standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata) for the full list of `TokenMetadata` parameters.

:::

:::warning

Values of gas and deposit might vary depending on which NFT contract you are calling.

:::

<hr className="subsection" />

### Minting Collections

Many times people want to create multiple 100 copies of an NFT (this is called a collection). In such cases, what you actually need to do is to mint 100 different NFTs with the same metadata (but different `token-id`).

:::tip

Notice that [minting in Mintbase](#minting-a-nft) allows you to pass a `num_to_mint` parameter.

:::

<hr className="subsection" />

### Royalties
You might have noticed that one of the parameters is a structure called royalties. Royalties enable you to create a list of users that should get paid when the token is sell in a marketplace. For example, if `anna` has `5%` of royalties, each time the NFT is sell, `anna` should get a 5% of the selling price.


---

## Querying NFT data
You can query the NFT's information and metadata by calling the `nft_token`.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppQueryNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIQueryNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractQueryNFT />
  </TabItem>
</Tabs>

---

## Transferring a NFT
Transferring an NFT can happen in two scenarios: (1) you ask to transfer an NFT, and (2) an [authorized account](#approving-users) asks to transfer the NFT.

In both cases, it is necessary to invoke the `nft_transfer` method, indicating the token id, the receiver, and an (optionally) an [approval_id](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement).


<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppTransferNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLITransferNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract">
    <SmartContractTransferNFT />
  </TabItem>
</Tabs>

---

## Attaching NFTs to a Call
Natively, only NEAR tokens (‚ìÉ) can be attached to a function calls. However, the NFT standard enables to attach a non-fungible tokens in a call by using the NFT-contract as intermediary. This means that, instead of you attaching tokens directly to the call, you ask the NFT-contract to do both a transfer and a function call in your name.

<Tabs className="language-tabs" groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call <nft-contract> nft_transfer_call '{"receiver_id": "<receiver-contract>", "token_id": "<token_id>", "msg": "<a-string-message>"}' --accountId <your-account> --depositYocto 1
```

</TabItem>

</Tabs>

:::info

Optionally, a [`memo` parameter](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core#nft-interface) can be passed to provide more information to your contract.

:::

<hr className="subsection" />

### How Does it Work?
Assume you want to attach an NFT (üé´) to a call on the receiver contract. The workflow is as follows:
1. You call `nft_transfer_call` in the NFT-contract passing: the receiver, a message, and the token-id of üé´.
2. The NFT contract transfers the NFT üé´ to the receiver.
3. The NFT contract calls **`receiver.nft_on_transfer(sender, token-owner, token-id, msg)`**.
4. The NFT contract handles errors in the `nft_resolve_transfer` callback.
5. The NFT contract returns `true` if it succeeded.

#### The nft_on_transfer method
From the workflow above it follows that the receiver we want to call needs to implement the `nft_on_transfer` method. When executed, such method will know:
- Who is sending the NFT, since it is a parameter
- Who is the current owner, since it is a parameter
- Which NFT was transferred, since it is a parameter.
- If there are any parameters encoded as a message

The `nft_on_transfer` **must return true** if the NFT has to be **returned to the sender**.


---

## Approving Users

You can authorize other users to transfer an NFT you own. This is useful, for example, to enable listing your NFT in a marketplace. In such scenario, you **trust** that the marketplace will only transfer the NFT upon receiving a certain amount of money in exchange.

<Tabs groupId="code-tabs">
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near call <nft-contract> nft_approve '{
"token_id": "<token-unique-id>",
"account_id": "<authorized-account>",
"msg": "<json-structure>"
}' --accountId <your-account> --depositYocto 1
```

</TabItem>

</Tabs>

:::info

If the `msg` parameter is included, then a cross-contract call will be made to `<authorized_account>.nft_on_approve(msg)`. Which in turn will make a callback to `nft_resolve_transfer` in your NFT contract.

:::

---

## List a NFT for sale

Basic NFT contracts following [the NEP-171 and NEP-177 standards](https://nomicon.io/Standards/Tokens/NonFungibleToken) do not implement marketplace functionality.

For this purpose, there are ecosystem apps such as [Paras](https://paras.id/) or [Mintbase](https://www.mintbase.xyz/), that use dedicated marketplace contracts.

In order to put a NFT for a sale on a marketplace you need to do two actions:

1. Cover data storage costs in the marketplace contract.
2. Approve the marketplace to sell the NFT in your NFT contract.

<br />

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppListNFTForSale />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIListNFTForSale />
  </TabItem>
</Tabs>

---

## Buy a NFT

Basic NFT contracts following [the NEP-171 and NEP-177 standards](https://nomicon.io/Standards/Tokens/NonFungibleToken) do not implement marketplace functionality.

For this purpose, there are ecosystem apps such as [Paras](https://paras.id/) or [Mintbase](https://www.mintbase.xyz/), that use dedicated marketplace contracts.

<Tabs groupId="code-tabs">
  <TabItem value="üåê WebApp" label="üåê WebApp">
    <WebAppBuyNFT />
  </TabItem>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">
    <CLIBuyNFT />
  </TabItem>
  <TabItem value="üìÑ Contract" label="üìÑ Contract" default>
    <SmartContractBuyNFT />
  </TabItem>
</Tabs>

---

## Tutorials

- [NFT Tutorial](/tutorials/nfts/js/introduction) _Zero to Hero_ (JavaScript SDK) - a set of tutorials that cover how to create a NFT contract using JavaScript.
- [NFT Tutorial](/tutorials/nfts/introduction) _Zero to Hero_ (Rust SDK) - a set of tutorials that cover how to create a NFT contract using Rust.


## Additional Resources

3. [NFT Tutorial by Keypom](https://github.com/keypom/nft-tutorial-series) (a fork of the NEAR example tutorial).
4. [Paras API documentation](https://parashq.github.io/).
5. [Mintbase API documentation](https://docs.mintbase.xyz/dev/mintbase-graph).
6. [Mintbase JS SDK](https://docs.mintbase.xyz/dev/mintbase-sdk-ref) - a set of methods to get data from blockchain, interact with Mintbase contracts, etc.


 This is the content for the doc docs/2.build/5.primitives/oracles.md 

 ---
id: oracles
title: Oracles
---

import {CodeTabs, Language, Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

[Blockchain Oracles](https://en.wikipedia.org/wiki/Blockchain_oracle) serve as intermediaries that connect smart contracts with external (off-chain) data.

`Example:`

- **Price Feeds:** Real-time pricing for cryptocurrencies, stocks, or commodities.
- **Event Information:** Updates on real-world events like sports results or weather conditions.
- **API Access:** Connections to external web services and systems.

:::info
Oracles, being external third-party services, require careful consideration of their reliability, security, and decentralization to avoid risks such as incorrect data, manipulation, or single points of failure.
:::

---

## Deployed Oracles on NEAR

Here is a directory of third-party oracle services deployed on the NEAR blockchain:

| Name                                                                                                     | Creator                                 | Description                                        |
| -------------------------------------------------------------------------------------------------------- | --------------------------------------- | -------------------------------------------------- |
| [Price Oracle](#price-oracle-by-neardefi)                                                                | [NearDefi](https://github.com/NearDeFi) | Open source oracle for real-time asset pricing     |
| [Pyth Network Oracle](#pyth-network-oracle)                                                              | [Pyth Network](https://pyth.network/)   | High-frequency, low-latency oracle for price feeds |
| **[[Your Project Here]](https://github.com/near/docs/edit/master/docs/2.build/5.primitives/oracles.md)** | -                                       | -                                                  |

---

## Price Oracle by NearDefi

- **Creator:** [NearDefi](https://github.com/NearDeFi)
- **Codebase Repository:** [NearDefi/price-oracle](https://github.com/NearDeFi/price-oracle)
- **Bot for Data Feeds:** [NearDefi/near-price-oracle-bot](https://github.com/NearDeFi/near-price-oracle-bot)
- **Deployed Addresses:**
  - Mainnet: [priceoracle.near](https://nearblocks.io/address/priceoracle.near)
  - Testnet: [priceoracle.testnet](https://testnet.nearblocks.io/address/priceoracle.testnet)

### Query Assets

<Tabs>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near view priceoracle.near get_assets
near contract call-function as-read-only priceoracle.near get_assets json-args {} network-config mainnet now
```

  <details>
  
  <summary>Example Response</summary>

```json
[
  [
    'wrap.near',
    {
      reports: [
        {
          oracle_id: 'thorinoracle.near',
          timestamp: '1669795900809627816',
          price: { multiplier: '17030', decimals: 28 }
        },
        ...
      ]
    }
  ]
]
```

  </details>
</TabItem>
</Tabs>

### Get Assets Price

<Tabs>
  <TabItem value="üñ•Ô∏è CLI" label="üñ•Ô∏è CLI">

```bash
near view priceoracle.near get_price_data
```

</TabItem>

</Tabs>

<details>

<summary>Example response</summary>

```json
{
  timestamp: '1706631861981947371',
  recency_duration_sec: 90,
  prices: [
    {
      asset_id: 'wrap.near',
      price: { multiplier: '30702', decimals: 28 }
    },
    {
      asset_id: 'aurora',
      price: { multiplier: '235662', decimals: 20 }
    },
    {
      asset_id: 'meta-pool.near',
      price: { multiplier: '38770', decimals: 28 }
    },
    {
      asset_id: 'linear-protocol.near',
      price: { multiplier: '36432', decimals: 28 }
    },
```

</details>

:::tip
For USD values, divide the `multiplier` by `10^4`.
:::

---

## Pyth Network Oracle

- **Creator:** [Pyth Network](https://pyth.network)
- **Official Documentation:** [Pyth NEAR Docs](https://docs.pyth.network/price-feeds/use-real-time-data/near)
- **Codebase Repository:** [pyth-network/pyth-crosschain](https://github.com/pyth-network/pyth-crosschain/tree/main/target_chains/near)
- **Deployed Addresses:**
  - **Mainnet:** [pyth-oracle.near](https://nearblocks.io/address/pyth-oracle.near)
  - **Testnet:** [pyth-oracle.testnet](https://testnet.nearblocks.io/address/pyth-oracle.testnet)

---

## Using Pyth Network Oracle

> Pyth Network's NEAR smart contract has two core methods to update & get price feeds of your choice.

1. [`update_price_feeds`](#update_price_feeds)
   _(updates Pyth smart contract with the price feed you provide)_
   - args: `data`
   - type: `object`
   - example: `{ "data": "504e41...' }`
2. [`get_price`](#get_price) (fetches the most recent price stored in the contract)\_
   - args: `price_identifer`
   - type: `object`
   - example: `{ price_identifier: 'f9c0172ba10dfa8...' }`

:::info
For a complete list of endpoints to interact with, see [Pyth's `receiver` contract](https://github.com/pyth-network/pyth-crosschain/blob/main/target_chains/near/receiver/src/ext.rs).
:::

### Getting Started

To get started with Pyth oracle you will need to gather the following information which differ between networks:

- Price ID(s)
- HermesAPI Endpoint
- Smart contract address

| Network   | Price Feed IDs                                                                                   | Hermes API Address         | Contract Address                                                                 |
| --------- | ------------------------------------------------------------------------------------------------ | -------------------------- | -------------------------------------------------------------------------------- |
| `testnet` | [NEAR `testnet` Price Feed IDs](https://www.pyth.network/developers/price-feed-ids#near-testnet) | `hermes-beta.pyth.network` | [pyth-oracle.testnet](https://testnet.nearblocks.io/address/pyth-oracle.testnet) |
| `mainnet` | [NEAR `mainnet` Price Feed IDs](https://www.pyth.network/developers/price-feed-ids#near-mainnet) | `hermes.pyth.network`      | [pyth-oracle.near](https://nearblocks.io/address/pyth-oracle.near)               |

:::info

When using Price Feed IDs, you will need to remove the `0x` prefix.

`Price Feed ID Example (testnet):`

<Github language='typescript' url='https://github.com/near-examples/near-js/blob/main/node-js/oracle-example/pyth-oracle-update.js' start='14' end='15'/>

:::

---

### `update_price_feeds`

> Updates the Pyth Oracle contract data with the price feed you provide.

- args: `data` _(off-chain hex-encoded price feed)_
- type: `object`
- example: `{ "data": "504e41...' }`

Update the Pyth Oracle contract with new price feed data in two main steps:

1. [Fetch off-chain price feed](#1-fetching-off-chain-price-feed)
2. [Update Pyth Oracle contract with off-chain price feed](#2-update-pyth-oracle-contract-price-feed)

#### 1) Fetching off-chain price feed

You can obtain an off-chain price feed using Pyth's [Hermes API](https://hermes-beta.pyth.network/docs/).

To use these endpoints, you will need to provide a Price Feed ID and ensure you are targeting the correct network. See [Getting Started](#getting-started) for more information.

Here is a node.js example of fetching the latest price feed using `/v2/updates/price/latest` endpoint:

<Language value="js" language="js">
  <Github
          url="https://github.com/near-examples/near-js/blob/main/node-js/utils/fetch-hermes-price-data.js"/>
</Language>

#### 2) Update Pyth Oracle Contract Price Feed

After [fetching an off-chain price feed](#1-fetching-off-chain-price-feed), you can now perform a contract call to the Pyth Oracle to update the price feed on-chain.

Call `update_price_feeds` on the Pyth Oracle contract with `data` as your arguments.

`example args:`

```json
{
  "data": "504e41550100000000a00100000000010070b0ee3a00d1a3c07ee440887eb34a5a35860e6f4b9230fd62f0593fe35c8a3561735a6a37d269c5f166b84ead8918f710dc1be2ee6b51db5b22340ea2c173fc01673d544b00000000001ae101faedac5851e32b9b23b5f9411a8c2bac4aae3ed4dd7b811dd1a72ea4aa7100000000061bc18c014155575600000000000ab0f04600002710f41bc8c224ed983c68dbf5dab7dd34c9129fecfa03005500ca80ba6dc32e08d06f1aa886011eed1d77c77be9eb761cc10d72b7d0a2fd57a600000047e2eb4ef0000000000692480ffffffff800000000673d544b00000000673d544b00000048200e66a00000000005e495a60bb9370c458dd50558b34699b5b179f45e56be22f0a1a0feb1db8469adc8c5efeb53988495bac07bf9efed07f5eee43818150c55055882f6872a228e8e9bc78459ed3ea7fe0b86f3048f6bf0aad34befc46063ab7d200beb8bc9fe5839844d2233546f0742bb665f1e610370fcf8ce5be83d0f47e584b685af87cf3ebcb79e714827dcb99dba579e1a03785052ab3c7c7147d3f7bba822b04dbda159670e9a8d29e7ccf68474b2ca85e00224d29bf65b06b09f95e91703313e053b697b48ac1e4d1c57605a71ab77e7ef276bfe8a369c268333b9a37461bf2b7cb7fd4c005500ecf553770d9b10965f8fb64771e93f5690a182edc32be4a3236e0caaa6e0581a0000000e2ba8cd280000000001b40517fffffff800000000673d544b00000000673d544b0000000e3ea44c6800000000016aee120b47b853f55949284cb8ba0b63824ff9b48cd1da8417f45421b79ee3195fc8d107540a0bbb95c2445b66065754f135cb842db09a7e7ab33f79c546a48db872bd7197b04e3d7b52fbb55b3b9f51707c5a55fac3707cb563dbcde4aadeecc3649c237454cecf519dc567c0da03d81808523aa4fa71815eab25ce7da61b48647bac645d403208135002aab5fde2d7ab3c7c7147d3f7bba822b04dbda159670e9a8d29e7ccf68474b2ca85e00224d29bf65b06b09f95e91703313e053b697b48ac1e4d1c57605a71ab77e7ef276bfe8a369c268333b9a37461bf2b7cb7fd4c"
}
```

Example of updating the Pyth Oracle contract's price feed using `near-js/client` and node.js:

<Language value="js" language="js">
  <Github fname="updatePythContract"
          url="https://github.com/near-examples/near-js/blob/main/node-js/oracle-example/pyth-oracle-update.js"/>
  <Github fname="getHermesPriceData"
          url="https://github.com/near-examples/near-js/blob/main/node-js/utils/fetch-hermes-price-data.js"/>
  <Github fname="nearConnect"
          url="https://github.com/near-examples/near-js/blob/main/node-js/utils/connect.js"/>
</Language>

:::info

Although unused deposit will be refunded, you can calculate an estimate by calling the `get_update_fee_estimate` method against the Pyth contract.

:::

---

### `get_price`

> Fetches the most recent price feed stored in the Pyth Oracle contract. Is a view method, so does not require a signature or payment.

- args: `price_identifier` _(unique price feed identifier)_
- type: `object`
- example: `{ price_identifier: 'f9c0172ba10dfa8...' }`

After [updating the price feed](#update_price_feeds), you can view the feed on-chain by calling `get_price` on the Pyth Oracle contract. Note that this is a view method and does not require a signature or deposit.

`Example:`

<Language value="js" language="js">
  <Github
          url="https://github.com/near-examples/near-js/blob/main/node-js/oracle-example/pyth-oracle-view.js"/>
</Language>


 This is the content for the doc docs/2.build/5.primitives/what-is.md 

 ---
id: what-is
title: What are Primitives? 
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Primitives are fundamental building blocks that can be combined to create a fully functional application. Blockchain primitives include [Fungible Tokens (FT)](#fungible-tokens-ft), [Non Fungible Tokens (NFT)](#non-fungible-tokens-nft), [Decentralized Autonomous organizations (DAO)](#decentralized-autonomous-organizations-dao), [Link Drops](#linkdrops) and more.

![img](/docs/assets/welcome-pages/primitives.png)

---

#### Fungible Tokens (FT)
[Fungible tokens](./ft.md) represent an **asset** on a blockchain that is **interchangeable**. Besides the native NEAR token, users can issue their own fungible tokens or use those that are already present in the ecosystem.

:::tip
Fungible Tokens are ideal to create **reward systems**, **fair tickets** and any other type of **token**.
:::

<hr class="subsection" />

#### Non Fungible Tokens (NFT)
In contrast with fungible tokens, each [non-fungible token (NFT)](./nft.md) is **unitary** and therefore **unique**. Users can create their own non-fungible token, transfer to other users, or exchange them in marketplaces.

:::tip
NFTs are ideal to represent **ownership of assets** such as **collectibles**, **event tickets** and other unique assets.
:::

<hr class="subsection" />

#### Decentralized Autonomous organizations (DAO)
[Decentralized Autonomous Organizations (DAOs)](./dao.md) are **self-organized groups** that form around common purposes. Membership, decision making, and funding are **coordinated** by **publicly voting** on proposals through a smart contract.

:::tip
DAOs are ideal to create **decentralized governance**, **funding**, and **decision-making** tools.
:::

<hr class="subsection" />

### LinkDrops
[LinkDrops](./linkdrop.md) are an easy way to **distribute digital assets** (NFTs, FTs) via links. You simply **provide a link** for users and they can **claim** your drop.

:::tip
LinkDrops are ideal to do **drops**, and **onboard new users** into Web3 apps.
:::


 This is the content for the doc docs/2.build/6.data-infrastructure/big-query.md 

 ---
id: big-query
title: BigQuery Public Dataset
sidebar_label: BigQuery
---

Blockchain data indexing in NEAR Public Lakehouse is for anyone wanting to understand blockchain data. This includes:

- **Users**: create queries to track NEAR assets, monitor transactions, or analyze on-chain events at a massive scale.
- **Researchers**: use indexed data for data science tasks, including on-chain activities, identifying trends, or feeding AI/ML pipelines for predictive analysis.
- **Startups**: can use NEAR's indexed data for deep insights on user engagement, smart contract utilization, or insights across tokens and NFT adoption.

Benefits:

- **NEAR instant insights**: Historical on-chain data queried at scale.
- **Cost-effective**: eliminate the need to store and process bulk NEAR protocol data; query as little or as much data as preferred.
- **Easy to use**: no prior experience with blockchain technology is required; bring a general knowledge of SQL to unlock insights.

## Getting started

1. Login into your [Google Cloud Account](https://console.cloud.google.com/).
2. Open the [NEAR Protocol BigQuery Public Dataset](https://console.cloud.google.com/marketplace/product/bigquery-public-data/crypto-near-mainnet).
3. Click in the <kbd>[VIEW DATASET](https://console.cloud.google.com/bigquery?p=bigquery-public-data&d=crypto_near_mainnet_us&page=dataset)</kbd> button.
4. Click in the <kbd>+</kbd> to create a new tab and write your query, click in the <kbd>RUN</kbd> button, and check the `Query results` below the query.
5. Done :)

:::info

The [NEAR Public Lakehouse repository](https://github.com/near/near-public-lakehouse) contains the source code for ingesting NEAR Protocol data stored as JSON files in AWS S3 by [NEAR Lake Indexer](https://github.com/near/near-lake-indexer).

:::

### Example Queries

- _How many unique signers and accounts have interacted with my smart contract per day?_

```sql
SELECT
  ra.block_date collected_for_day,
  COUNT(DISTINCT t.signer_account_id) as total_signers,
  COUNT(DISTINCT ra.receipt_predecessor_account_id) as total_accounts
FROM `bigquery-public-data.crypto_near_mainnet_us.receipt_actions` ra
  JOIN `bigquery-public-data.crypto_near_mainnet_us.receipt_origin_transaction` ro ON ro.receipt_id = ra.receipt_id
  JOIN `bigquery-public-data.crypto_near_mainnet_us.transactions` t ON ro.originated_from_transaction_hash = t.transaction_hash
WHERE ra.action_kind = 'FUNCTION_CALL'
  AND ra.receipt_receiver_account_id = 'social.near' -- change to your contract
GROUP BY 1
ORDER BY 1 DESC;
```

## How much it costs?

- NEAR pays for the storage and doesn't charge you to use the public dataset.
  > To learn more about BigQuery public datasets [check this page](https://cloud.google.com/bigquery/public-data).
- Google GCP charges for the queries that you perform on the data. For example, in today's price "Sep 1st, 2023" the On-demand (per TB) query pricing is $6.25 per TB where the first 1 TB per month is free.
  > Check [Google's pricing page](https://cloud.google.com/bigquery/pricing#analysis_pricing_models) for detailed pricing info, options, and best practices.

:::tip
You can check how much data it will query before running it in the BigQuery console UI. Again, since BigQuery uses a columnar data structure and partitions, it's recommended to select only the columns and partitions (`block_date`) needed to avoid unnecessary query costs.
:::

![Query Costs](/docs/BQ_Query_Cost.png "BQ Query Costs")

## Architecture

The data is loaded in a streaming fashion using [Databricks Autoloader](https://docs.gcp.databricks.com/ingestion/auto-loader/index.html) into raw/bronze tables, and transformed with [Databricks Delta Live Tables](https://www.databricks.com/product/delta-live-tables) streaming jobs into cleaned/enriched/silver tables.

The silver tables are also copied into the [GCP BigQuery Public Dataset](https://cloud.google.com/bigquery/public-data).

![Architecture](/docs/Architecture.png "Architecture")

:::info

[Databricks Medallion Architecture](https://www.databricks.com/glossary/medallion-architecture).

:::

## Available Data

The current data that NEAR is providing was inspired by [NEAR Indexer for Explorer](https://github.com/near/near-indexer-for-explorer/).

:::info
NEAR plans to improve the data available in the NEAR Public Lakehouse making it easier to consume by denormalizing some tables.
:::

The tables available in the NEAR Public Lakehouse are:

- **blocks**: A structure that represents an entire block in the NEAR blockchain. `Block` is the main entity in NEAR Protocol blockchain. Blocks are produced in NEAR Protocol every second.
- **chunks**: A structure that represents a chunk in the NEAR blockchain. `Chunk` of a `Block` is a part of a `Block` from a `Shard`. The collection of `Chunks` of the `Block` forms the NEAR Protocol Block. `Chunk` contains all the structures that make the `Block`: `Transactions`, [`Receipts`](https://nomicon.io/RuntimeSpec/Receipts), and `Chunk Header`.
- **transactions**: [`Transaction`](../../2.build/6.data-infrastructure/lake-data-structures/transaction.mdx#definition) is the main way of interaction between a user and a blockchain. Transaction contains: Signer account ID, Receiver account ID, and Actions.
- **execution_outcomes**: Execution outcome is the result of execution of `Transaction` or `Receipt`. In the result of the Transaction execution will always be a Receipt.
- **receipt_details**: All cross-contract (we assume that each account lives in its own shard) communication in Near happens through Receipts. Receipts are stateful in a sense that they serve not only as messages between accounts but also can be stored in the account storage to await `DataReceipts`. Each receipt has a `predecessor_id` (who sent it) and `receiver_id` the current account.
- **receipt_origin**: Tracks the transaction that originated the receipt.
- **receipt_actions**: Action Receipt represents a request to apply actions on the `receiver_id` side. It could be derived as a result of a `Transaction` execution or another `ACTION` Receipt processing. Action kind can be: `ADD_KEY`, `CREATE_ACCOUNT`, `DELEGATE_ACTION`, `DELETE_ACCOUNT`, `DELETE_KEY`, `DEPLOY_CONTRACT`, `FUNCTION_CALL`, `STAKE`, `TRANSFER`.
- **receipts (view)**: It's recommended to select only the columns and partitions (`block_date`) needed to avoid unnecessary query costs. This view join the receipt details, the transaction that originated the receipt and the receipt execution outcome.
- **account_changes**: Each account has an associated state where it stores its metadata and all the contract-related data (contract's code + storage).

:::info Additional information about the data

- Skipped Blocks: NEAR Blockchain can contain skipped blocks, e.g. block `57730443`. For these cases we can find the block for the chunk data using the `prev_block_hash` column, e.g. `SELECT * FROM chunks c JOIN blocks b ON c.chunk.header.prev_block_hash = b.header.prev_hash`.

:::

:::note References

- [Protocol documentation](../../1.concepts/basics/protocol.md)
- [Near Data flow](../../1.concepts/data-flow/near-data-flow.md)
- [Lake Data structures](./lake-data-structures/toc.mdx)
- [Protocol specification](https://nomicon.io/)

:::


 This is the content for the doc docs/2.build/6.data-infrastructure/data-api.md 

 ---
id: data-apis
title: Data APIs
---

Members of the NEAR community have built a set of APIs to access and monitor on-chain data. These APIs are designed to be easy to use and can be accessed from any application through a simple API call.

- [NearBlocks API](#nearblocks-api): Query actions that happened on a NEAR account
- [FastNear API](#fastnear-api): Exposes low-latency APIs for wallets and explorers
- [The Graph](https://thegraph.com/docs/en/cookbook/near/): The Graph gives developers tools to process blockchain events and make the resulting data easily available via a GraphQL API, known individually as a subgraph. [Graph Node](https://github.com/graphprotocol/graph-node) is now able to process NEAR events, which means that NEAR developers can now build subgraphs to index their smart contracts.
- [PIKESPEAK API](https://pikespeak.ai): an enterprise-grade API where you can fetch blockchain events and aggregated analytics on wallets, validators, delegators, money transfers, dapps activity and more. [Documentation](https://doc.pikespeak.ai/)
- [Mintbase Indexer](https://mintbase.xyz/) A highly efficient and adaptable indexing solution developed to capture, process, and store NFT events throughout the NEAR ecosystem. This indexer provides developers with a streamlined and well-structured data stream, making it an optimal choice for constructing data-centric applications in the NFT space. By systematically monitoring and indexing a wide array of NFT-related events across various platforms and projects on NEAR, the Mintbase Indexer offers developers the necessary tools and data access to build innovative and practical applications. Furthermore, the indexed data can be conveniently queried using GraphQL, allowing for flexible and efficient data retrieval tailored to specific developer needs. [Documentation](https://docs.mintbase.xyz/dev/mintbase-graph)
- [SubQuery](https://academy.subquery.network/quickstart/quickstart_chains/near.html): SubQuery is a fast, flexible, and reliable open-source data indexer that provides you with custom APIs for your web3 project across NEAR and many other chains. NEAR developers will benefit from the superior SubQuery experience, including the open-source SDK, tools, [documentation](https://academy.subquery.network), and developer support that the SubQuery ecosystem provides. Additionally, NEAR is accommodated by [SubQuery‚Äôs Managed Service](http://managedservice.subquery.network/), which provides enterprise-level infrastructure hosting.

:::tip

We only include some examples on how to use these APIs. For more information, check each project's documentation

:::

---

## [NearBlocks API](https://api.nearblocks.io/api-docs/)

The NearBlocks API provides a simple way to query actions that happened on a NEAR account, such as function calls, token transfers, etc

```bash
# All the times **anyone** called "create_drop" on Keypom
https://api.nearblocks.io/v1/account/v2.keypom.near/txns?method=create_drop

# All the times that gagdiez.near called "create_drop" on Keypom
https://api.nearblocks.io/v1/account/v2.keypom.near/txns?method=create_drop&from=gagdiez.near
```


<details>
  <summary> Response </summary>

```json
{
  "txns": [
    {
      "predecessor_account_id": "gagdiez.near",
      "receiver_account_id": "v2.keypom.near",
      "receipt_kind": "ACTION",
      "receipt_outcome": {
        "status": true,
        ...
      },
      ...
    }
  ]
}
```

</details>

:::info More info

Find more information about the NearBlocks API in their [api page](https://api.nearblocks.io/api-docs/)

:::

---

## [FastNear API](https://fastnear.com/)

FastNear exposes low-latency APIs for wallets and explorers. Their API allows you to easily query the NEAR blockchain to get an account's assets, map keys into account IDs, explore a block's transactions, etc.

#### [Blockchain Data](https://github.com/fastnear/neardata-server/)

```bash
# Query last block produced
curl https://mainnet.neardata.xyz/v0/last_block/final
```

<details>
  <summary> Response </summary>

```json
  {
    "block": {
      "author": "aurora.pool.near",
      "header": {
        "height": 129311487,
        "prev_height": 129311486,
        ...
      }
    }
  }
```

</details>

#### [User Queries](https://github.com/fastnear/fastnear-api-server-rs)

```bash
# Query user's FTs
curl https://api.fastnear.com/v1/account/root.near/ft

# Query user's NFTs
curl https://api.fastnear.com/v1/account/root.near/ft

# Query all user's assets
curl https://api.fastnear.com/v1/account/root.near/full
```

<details>
  <summary> Response </summary>

```json
  {
    "account_id": "root.near",
    "tokens": [
      { "balance": "199462092", "contract_id": "the-token.near" },
      ...
    ]
  }
```

</details>

:::info More info

Find more information about the FastNear API on their [documentation page](https://docs.fastnear.com/)

:::


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/block.mdx 

 ---
sidebar_position: 2
sidebar_label: Block
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `Block` Structure

## Definition

`Block` is the main entity in NEAR Protocol blockchain. `Blocks` are produced in NEAR Protocol every second.

It contains the info:
- about the `Block` producer (`AccountId` of the validator responsible for particular `Block` production)
- Block Header
- List of Chunk Headers

## Representation

### `Block`

<Tabs>
  <TabItem value="rust" label="Rust" default>

```rust links=1
pub struct BlockView {
    pub author: AccountId,
    pub header: BlockHeaderView,
    pub chunks: Vec<ChunkHeaderView>,
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export interface Block {
  author: string;
  header: BlockHeader;
  chunks: ChunkHeader[];
};
```

  </TabItem>
</Tabs>


### `BlockHeaderView`

`BlockHeaderView` contains main info about the block.

<Tabs>
  <TabItem value="rust" label="Rust">

```rust
pub struct BlockHeaderView {
    pub height: BlockHeight,
    pub prev_height: Option<BlockHeight>,
    pub epoch_id: CryptoHash,
    pub next_epoch_id: CryptoHash,
    pub hash: CryptoHash,
    pub prev_hash: CryptoHash,
    pub prev_state_root: CryptoHash,
    pub chunk_receipts_root: CryptoHash,
    pub chunk_headers_root: CryptoHash,
    pub chunk_tx_root: CryptoHash,
    pub outcome_root: CryptoHash,
    pub chunks_included: u64,
    pub challenges_root: CryptoHash,
    /// Legacy json number. Should not be used.
    pub timestamp: u64,
    pub timestamp_nanosec: u64,
    pub random_value: CryptoHash,
    pub validator_proposals: Vec<ValidatorStakeView>,
    pub chunk_mask: Vec<bool>,
    pub gas_price: Balance,
    pub block_ordinal: Option<NumBlocks>,
    /// TODO(2271): deprecated.
    pub rent_paid: Balance,
    /// TODO(2271): deprecated.
    pub validator_reward: Balance,
    pub total_supply: Balance,
    pub challenges_result: ChallengesResult,
    pub last_final_block: CryptoHash,
    pub last_ds_final_block: CryptoHash,
    pub next_bp_hash: CryptoHash,
    pub block_merkle_root: CryptoHash,
    pub epoch_sync_data_hash: Option<CryptoHash>,
    pub approvals: Vec<Option<Signature>>,
    pub signature: Signature,
    pub latest_protocol_version: ProtocolVersion,
}
```

  </TabItem>

  <TabItem value="typescript" label="TypeScript">

```ts links=1
export interface BlockHeader {
  approvals: (string | null)[];
  blockMerkleRoot: string;
  blockOrdinal: number;
  challengesResult: ChallengeResult[];
  challengesRoot: string;
  chunkHeadersRoot: string;
  chunkMask: boolean[];
  chunkReceiptsRoot: string;
  chunkTxRoot: string;
  chunksIncluded: number;
  epochId: string;
  epochSyncDataHash: string | null;
  gasPrice: string;
  hash: string;
  height: number;
  lastDsFinalBlock: string;
  lastFinalBlock: string;
  latestProtocolVersion: number;
  nextBpHash: string;
  nextEpochId: string;
  outcomeRoot: string;
  prevHash: string;
  prevHeight: number;
  prevStateRoot: string;
  randomValue: string;
  rentPaid: string;
  signature: string;
  timestamp: number;
  timestampNanosec: string;
  totalSupply: string;
  validatorProposals: [];
  validatorReward: string;
};
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/chunk.mdx 

 ---
sidebar_position: 3
sidebar_label: Chunk
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `Chunk` Structure

## Definition

`Chunk` of a [`Block`](block.mdx) is a part of a [`Block`](block.mdx) from a [Shard](shard.mdx). The collection of Chunks of the Block forms the NEAR Protocol [`Block`](block.mdx)

Chunk contains all the structures that make the Block:
- [Transactions](transaction.mdx)
- [Receipts](receipt.mdx)
- [ChunkHeader](#chunkheaderview)

## `IndexerChunkView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct ChunkView {
    pub author: AccountId,
    pub header: ChunkHeaderView,
    pub transactions: Vec<IndexerTransactionWithOutcome>,
    pub receipts: Vec<ReceiptView>,
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export interface Chunk {
  author: string;
  header: ChunkHeader;
  transactions: IndexerTransactionWithOutcome[];
  receipts: Receipt[],
}
```

  </TabItem>
</Tabs>

## `ChunkHeaderView`

<Tabs>
  <TabItem value="rust" label="value">

```rust links=1
pub struct ChunkHeaderView {
    pub chunk_hash: CryptoHash,
    pub prev_block_hash: CryptoHash,
    pub outcome_root: CryptoHash,
    pub prev_state_root: StateRoot,
    pub encoded_merkle_root: CryptoHash,
    pub encoded_length: u64,
    pub height_created: BlockHeight,
    pub height_included: BlockHeight,
    pub shard_id: ShardId,
    pub gas_used: Gas,
    pub gas_limit: Gas,
    /// TODO(2271): deprecated.
    #[serde(with = "u128_dec_format")]
    pub rent_paid: Balance,
    /// TODO(2271): deprecated.
    #[serde(with = "u128_dec_format")]
    pub validator_reward: Balance,
    #[serde(with = "u128_dec_format")]
    pub balance_burnt: Balance,
    pub outgoing_receipts_root: CryptoHash,
    pub tx_root: CryptoHash,
    pub validator_proposals: Vec<ValidatorStakeView>,
    pub signature: Signature,
}
```

  </TabItem>
  <TabItem value="typescript" value="TypeScript">

```ts links=1
export interface ChunkHeader {
  balanceBurnt: number;
  chunkHash: string;
  encodedLength: number;
  encodedMerkleRoot: string;
  gasLimit: number;
  gasUsed: number;
  heightCreated: number;
  heightIncluded: number;
  outcomeRoot: string;
  outgoingReceiptsRoot: string;
  prevBlockHash: string;
  prevStateRoot: string;
  rentPaid: string;
  shardId: number;
  signature: string;
  txRoot: string;
  validatorProposals: ValidatorProposal[];
  validatorReward: string;
};
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/execution_outcome.mdx 

 ---
id: execution-outcome
sidebar_position: 6
sidebar_label: ExecutionOutcome
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `ExecutionOutcome` Structure

## Definition

ExecutionOutcome is the result of execution of [Transaction](transaction.mdx) or [Receipt](receipt.mdx)

:::info Transaction's ExecutionOutcome

In the result of the Transaction execution will always be a Receipt.

:::

## `ExecutionOutcomeWithIdView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct ExecutionOutcomeWithIdView {
    pub proof: MerklePath,
    pub block_hash: CryptoHash,
    pub id: CryptoHash,
    pub outcome: ExecutionOutcomeView,
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type ExecutionOutcomeWithReceipt = {
  executionOutcome: {
    blockHash: string;
    id: string;
    outcome: {
      executorId: string,
      gasBurnt: number,
      logs: string[],
      metadata: {
        gasProfile: string | null;
        version: number;
      };
      receiptIds: string[],
      status: ExecutionStatus,
      tokensBurnt: string
    };
    proof: ExecutionProof[];
  };
  receipt: Receipt | null;
};
```

  </TabItem>
</Tabs>

## `ExecutionOutcomeView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct ExecutionOutcomeView {
    /// Logs from this transaction or receipt.
    pub logs: Vec<String>,
    /// Receipt IDs generated by this transaction or receipt.
    pub receipt_ids: Vec<CryptoHash>,
    /// The amount of the gas burnt by the given transaction or receipt.
    pub gas_burnt: Gas,
    /// The amount of tokens burnt corresponding to the burnt gas amount.
    /// This value doesn't always equal to the `gas_burnt` multiplied by the gas price, because
    /// the prepaid gas price might be lower than the actual gas price and it creates a deficit.
    #[serde(with = "u128_dec_format")]
    pub tokens_burnt: Balance,
    /// The id of the account on which the execution happens. For transaction this is signer_id,
    /// for receipt this is receiver_id.
    pub executor_id: AccountId,
    /// Execution status. Contains the result in case of successful execution.
    pub status: ExecutionStatusView,
    /// Execution metadata, versioned
    #[serde(default)]
    pub metadata: ExecutionMetadataView,
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

  [ExecutionOutcomeWithIdView TypeScript](#executionoutcomewithidview) defines this structure already an nested

  </TabItem>
</Tabs>


## `ExecutionStatusView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub enum ExecutionStatusView {
    /// The execution is pending or unknown.
    Unknown,
    /// The execution has failed.
    Failure(TxExecutionError),
    /// The final action succeeded and returned some value or an empty vec encoded in base64.
    SuccessValue(String),
    /// The final action of the receipt returned a promise or the signed transaction was converted
    /// to a receipt. Contains the receipt_id of the generated receipt.
    SuccessReceiptId(CryptoHash),
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type ExecutionStatus =
  | { Unknown: unknown }
  | { Failure: unknown }
  | { SuccessValue: string }
  | { SuccessReceiptId: string };
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/receipt.mdx 

 ---
sidebar_position: 7
sidebar_label: Receipt
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `Receipt` Structure

## Definition

Receipt is an internal transaction in NEAR Protocol.

## `ReceiptView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct ReceiptView {
    pub predecessor_id: AccountId,
    pub receiver_id: AccountId,
    pub receipt_id: CryptoHash,

    pub receipt: ReceiptEnumView,
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type Receipt = {
  predecessorId: string;
  receipt: ReceiptEnum;
  receiptId: string;
  receiverId: string;
}
```

  </TabItem>
</Tabs>

## `ReceiptEnumView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub enum ReceiptEnumView {
    Action {
        signer_id: AccountId,
        signer_public_key: PublicKey,
        #[serde(with = "u128_dec_format")]
        gas_price: Balance,
        output_data_receivers: Vec<DataReceiverView>,
        input_data_ids: Vec<CryptoHash>,
        actions: Vec<ActionView>,
    },
    Data {
        data_id: CryptoHash,
        #[serde(with = "option_base64_format")]
        data: Option<Vec<u8>>,
    },
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type ReceiptEnum =
  | {
      Action: {
        actions: Action[];
        gasPrice: string;
        inputDataIds: string[];
        outputDataReceivers: string[];
        signerId: string;
        signerPublicKey: string;
      };
    }
    | {
      Data: {
        data: string;
        dataId: string;
      };
    };
```

  </TabItem>
</Tabs>

## ActionReceipt

ActionReceipts hold info about what actions to perform. In the cross-contract calls some actions might happen only when specific data is available, such data is in the [DataReceipts](#datareceipt).

## DataReceipt

DataReceipts hold the data that is produced by `Promise` during the cross-contract calls.


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/shard.mdx 

 ---
sidebar_position: 4
sidebar_label: Shard
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `Shard` structure

## Definition

`IndexerShard` struct is ephemeral structure, there is no such entity in `nearcore`. We've introduces it as a container in [`near-indexer-primitives`](https://crates.io/crates/near-indexer-primitives). This container includes:

- shard ID
- [Chunk](chunk.mdx) that might be absent
- [ExecutionOutcomes](execution_outcome.mdx) for [Receipts](receipt.mdx) (these belong to a Shard not to a [Chunk](chunk.mdx) or a [Block](block.mdx))
- [StateChanges](state_change.mdx) for a Shard

## `IndexerShard`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct IndexerShard {
    pub shard_id: types::ShardId,
    pub chunk: Option<IndexerChunkView>,
    pub receipt_execution_outcomes: Vec<IndexerExecutionOutcomeWithReceipt>,
    pub state_changes: views::StateChangesView,
}
```

  </TabItem>
  <TabItem value="typescript" value="TypeScript">

```ts links=1
export interface Shard {
  shard_id: number;
  chunk?: Chunk;
  receiptExecutionOutcomes: ExecutionOutcomeWithReceipt[];
  stateChanges: StateChange[];
};
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/state_change.mdx 

 ---
id: state-change
sidebar_position: 9
sidebar_label: StateChange
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `StateChange` Structure

## Definition

This entity from `nearcore` describes how account's state has changed and the reason

## `StateChangeWithCauseView`

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct StateChangeWithCauseView {
    pub cause: StateChangeCauseView,
    #[serde(flatten)]
    pub value: StateChangeValueView,
}

pub enum StateChangeCauseView {
    NotWritableToDisk,
    InitialState,
    TransactionProcessing { tx_hash: CryptoHash },
    ActionReceiptProcessingStarted { receipt_hash: CryptoHash },
    ActionReceiptGasReward { receipt_hash: CryptoHash },
    ReceiptProcessing { receipt_hash: CryptoHash },
    PostponedReceipt { receipt_hash: CryptoHash },
    UpdatedDelayedReceipts,
    ValidatorAccountsUpdate,
    Migration,
    Resharding,
}

pub enum StateChangeValueView {
    AccountUpdate {
        account_id: AccountId,
        #[serde(flatten)]
        account: AccountView,
    },
    AccountDeletion {
        account_id: AccountId,
    },
    AccessKeyUpdate {
        account_id: AccountId,
        public_key: PublicKey,
        access_key: AccessKeyView,
    },
    AccessKeyDeletion {
        account_id: AccountId,
        public_key: PublicKey,
    },
    DataUpdate {
        account_id: AccountId,
        #[serde(rename = "key_base64", with = "base64_format")]
        key: StoreKey,
        #[serde(rename = "value_base64", with = "base64_format")]
        value: StoreValue,
    },
    DataDeletion {
        account_id: AccountId,
        #[serde(rename = "key_base64", with = "base64_format")]
        key: StoreKey,
    },
    ContractCodeUpdate {
        account_id: AccountId,
        #[serde(rename = "code_base64", with = "base64_format")]
        code: Vec<u8>,
    },
    ContractCodeDeletion {
        account_id: AccountId,
    },
}
```

  </TabItem>

  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type StateChange = {
  cause: {
    receiptHash: string;
    type: string;
  };
  change: {
    accountId: string;
    keyBase64: string;
    valueBase64: string;
  },
  type: string;
};
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/toc.mdx 

 ---
sidebar_position: 1
sidebar_label: Table of contents
---

# Structures. Table of Contents

The structures described in this section of the docs are indexer-related more than `nearcore` related. Some of the are artificial and are not a part of `nearcore`

:::note How data flows in NEAR Protocol

Don't skip the article about the [NEAR Data Flow](https://docs.near.org/concepts/data-flow/near-data-flow)

:::

**The main goal of this section is to describe `StreamerMessage` structure from [`near-indexer-primitives`](https://crates.io/crates/near-indexer-primitives)**

- `StreamerMessage`
  - [Block](./block.mdx)
    - [BlockHeader](./block.mdx#blockheaderview)
  - [Shards](./shard.mdx)
    - [Chunk](./chunk.mdx)
      - [ChunkHeader](./chunk.mdx#chunkheaderview)
      - [Transactions](./transaction.mdx)
      - [Receipts](./receipt.mdx)
    - [ExecutionOutcomes](./execution_outcome.mdx) for [Receipts](./receipt.mdx)
    - [StateChanges](./state_change.mdx)


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-data-structures/transaction.mdx 

 ---
sidebar_position: 5
sidebar_label: Transaction
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# `Transaction` Structure

## Definition

Transaction is the main way of interaction between a user and a blockchain. Transaction contains:
- Signer account ID
- Receiver account ID
- Actions

## `SignedTransactionView`

Transaction might be unsigned but from the indexer perspective when we think about Transaction we think about signed one

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub struct SignedTransactionView {
    pub signer_id: AccountId,
    pub public_key: PublicKey,
    pub nonce: Nonce,
    pub receiver_id: AccountId,
    pub actions: Vec<ActionView>,
    pub signature: Signature,
    pub hash: CryptoHash,
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type Transaction = {
  signerId: string;
  publicKey: string;
  nonce: number;
  receiverId: string;
  actions: Action[];
  signature: string;
  hash: string;
};
```

  </TabItem>
</Tabs>


## `ActionView`

`ActionView` is an Enum with possible actions along with parameters. This structure is used in Transactions and in [Receipts](receipt.mdx)

<Tabs>
  <TabItem value="rust" label="Rust">

```rust links=1
pub enum ActionView {
    CreateAccount,
    DeployContract {
        code: String,
    },
    FunctionCall {
        method_name: String,
        args: String,
        gas: Gas,
        #[serde(with = "u128_dec_format")]
        deposit: Balance,
    },
    Transfer {
        #[serde(with = "u128_dec_format")]
        deposit: Balance,
    },
    Stake {
        #[serde(with = "u128_dec_format")]
        stake: Balance,
        public_key: PublicKey,
    },
    AddKey {
        public_key: PublicKey,
        access_key: AccessKeyView,
    },
    DeleteKey {
        public_key: PublicKey,
    },
    DeleteAccount {
        beneficiary_id: AccountId,
    },
}
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts links=1
export type Action =
  | "CreateAccount"
  | DeployContractAction
  | FunctionCallAction
  | TransferAction
  | StakeAction
  | AddKeyAction
  | DeleteKeyAction
  | DeleteAccountAction;

export type DeployContractAction = {
  DeployContract: {
    code: string;
  };
};

export type FunctionCallAction= {
  FunctionCall: {
    methodName: string;
    args: string;
    gas: number;
    deposit: string;
  };
};

export type TransferAction = {
  Transfer: {
    deposit: string;
  };
};

export type StakeAction = {
  Stake: {
    stake: number;
    publicKey: string;
  };
};

export type AddKeyAction = {
  AddKey: {
    publicKey: string;
    accessKey: AccessKey;
  };
};

export type DeleteKeyAction = {
  DeleteKey: {
    publicKey: string;
  };
};

export type DeleteAccountAction = {
  DeleteAccount: {
    beneficiaryId: string;
  };
};
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/building-indexers/js-lake-indexer.md 

 ---
id: js-lake-indexer
title: JS basic tutorial
sidebar_label: JS basic tutorial
---

# NEAR Lake indexer basic tutorial


:::info Source code for the tutorial

[`near-examples/near-lake-raw-printer-js`](https://github.com/near-examples/near-lake-raw-printer-js): source code for the tutorial on how to create an indexer that prints block height and number of shards

:::

Recently we have [published a JavaScript version of the NEAR Lake Framework](https://www.npmjs.com/package/near-lake-framework) on npmjs.org

We want to empower you with a basic tutorial on how to use the JavaScript Library. Let's get started!


## Requirements

Before we get started, please, ensure you have:

- [nodejs](https://nodejs.org/en/download/) installed

## Create a project

Create an indexer project:

```bash
mkdir near-lake-raw-printer-js && cd near-lake-raw-printer-js
```

Now we're going to call `npm init`, we can continue with the default values pressing Enter on every question in the interactive mode:
```bash
npm init
```

```
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to /Users/near/projects/near-lake-raw-printer-js/package.json:

{
  "name": "near-lake-raw-printer-js",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC"
}


Is this OK? (yes)
```

`package.json` is ready. Let's install `near-lake-framework`

## Install dependencies

Install `near-lake-framework`

```bash
npm install near-lake-framework --save
```

Install `typescript` as dev dependency

```bash
npm install typescript --save-dev
```

## Setup TypeScript

Now we can create `tsconfig.json` for TypeScript settings:

```bash
touch tsconfig.json
```

Paste the content to the file:

```json title=tsconfig.json
{
  "compilerOptions": {
    "lib": [
      "ES2018",
      "dom"
    ]
  }
}
```

Now let's add the `scripts` section to the `package.json`

```json
"scripts": {
  "start": "tsc && node index.js"
}
```

After that your `package.json` should look similar to:

```json title=package.json
{
  "name": "near-lake-raw-printer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsc && node index.js"
  },
  "dependencies": {
    "near-lake-framework": "^1.0.1"
  },
  "devDependencies": {
    "typescript": "^4.6.4"
  }
}
```

Now let's create `index.ts`

```bash
touch index.ts
```

Open `index.ts` in your favorite editor to start coding.

## Import `near-lake-framework`

In the `index.ts` file let's import the necessary dependencies:

```ts
import { startStream, types } from 'near-lake-framework';
```

We've imported the main function `startStream`, which will be called to actually run the indexer, and `types`, which hold the `LakeConfig` type we need to construct.

## Create a config

To get indexer running we need to start it with a config. We need to create an instance of `LakeConfig`

```ts
const lakeConfig: types.LakeConfig = {
    s3BucketName: "near-lake-data-mainnet",
    s3RegionName: "eu-central-1",
    startBlockHeight: 63804051,
};
```

## Create indexer handler

Indexer will be streaming the [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc) instances we need to handle according to our needs.

In `near-lake-framework` JS library the handler have to be presented as a callback function. This function have to:
- be asynchronous
- accept an argument of type [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc)
- return nothing (`void`)

Creating the callback:

```ts
async function handleStreamerMessage(streamerMessage: types.StreamerMessage): Promise<void> {
    //
}
```

For this tutorial our requirement is to log the block height and the numer of shards. That's simple:

```ts
async function handleStreamerMessage(streamerMessage: types.StreamerMessage): Promise<void> {
    console.log(`
        Block #${streamerMessage.block.header.height}
        Shards: ${streamerMessage.shards.length}
    `);
}
```

## Starting the stream

And the last thing to write is the call to `startStream` with the config and pass the callback function.

```ts
(async () => {
    await startStream(lakeConfig, handleStreamerMessage);
})();
```

That's it. Now we can compile the code and run it

## Compile and run

:::danger Credentials

To be able to access the data from [NEAR Lake](/build/data-infrastructure/lake-framework/near-lake) you need to provide credentials. Please, see the [Credentials](../running-near-lake/credentials.md) article

:::

We've added the `start` command to the `scripts`, so the compilation and run should as easy as

```bash
npm run start
```

You should see something like the following:

```bash
Block #63804051 Shards: 4
Block #63804052 Shards: 4
Block #63804053 Shards: 4
Block #63804054 Shards: 4
Block #63804055 Shards: 4
Block #63804056 Shards: 4
Block #63804057 Shards: 4
Block #63804058 Shards: 4
Block #63804059 Shards: 4
Block #63804060 Shards: 4
```

You can stop the indexer by pressing CTRL+C

## What's next?

You can play around and change the content of the callback function [`handleStreamerMessage`](#create-indexer-handler) to handle the data differently.

You can find the [source code for this tutorial on the GitHub](https://github.com/near-examples/near-lake-raw-printer-js).


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/building-indexers/nft-indexer.md 

 ---
sidebar_label: NFT Indexer
---

# Building an NFT indexer


:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::

## The End

This tutorial ends with a working NFT indexer built on top [NEAR Lake Framework JS](/build/data-infrastructure/lake-framework/near-lake-framework). The indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and prints some relevant data:
- `receiptId` of the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) where the mint has happened
- Marketplace
- NFT owner account name
- Links to the NFTs on the marketplaces

The final source code is available on the GitHub [`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer)

## Motivation

NEAR Protocol had introduced a nice feature [Events](https://nomicon.io/Standards/EventsFormat). The Events allow a contract developer to add standardized logs to the [`ExecutionOutcomes`](/build/data-infrastructure/lake-data-structures/execution-outcome) thus allowing themselves or other developers to read those logs in more convenient manner via API or indexers.

The Events have a field `standard` which aligns with NEPs. In this tutorial we'll be talking about [NEP-171 Non-Fungible Token standard](https://github.com/near/NEPs/discussions/171).

In this tutorial our goal is to show you how you can "listen" to the Events contracts emit and how you can benefit from them.

As the example we will be building an indexer that watches all the NFTs minted following the [NEP-171 Events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) standard, assuming we're collectors who don't want to miss a thing. Our indexer should notice every single NFT minted and give us a basic set of data like: in what Receipt it was minted, and show us the link to a marketplace (we'll cover [Paras](https://paras.id) and [Mintbase](https://mintbase.io) in our example).

We will use JS version of [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) in this tutorial. Though the concept is the same for Rust, but we want to show more people that it's not that complex to build your own indexer.

## Preparation

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](../running-near-lake/credentials.md) page. Otherwise you won't be able to get the code working.

:::

You will need:

- `node` [installed and configured](https://nodejs.org/en/download/)

Let's create our project folder

```bash
mkdir lake-nft-indexer && cd lake-nft-indexer
```

Let's add the `package.json`

```json title=package.json
{
  "name": "lake-nft-indexer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "tsc && node index.js"
  },
  "dependencies": {
    "near-lake-framework": "^1.0.2"
  },
  "devDependencies": {
    "typescript": "^4.6.4"
  }
}
```

You may have noticed we've added `typescript` as a dev dependency. Let's configure the TypeScript. We'll need to create `tsconfig.json` file for that

```json title=tsconfig.json
{
  "compilerOptions": {
    "lib": [
      "ES2019",
      "dom"
    ]
  }
}
```

:::warning ES2019 edition

Please, note the `ES2019` edition used. We require it because we are going to use `.flatMap()` and `.flat()` in our code. These methods were introduces in `ES2019`. Though you can use even more recent

:::

Let's create empty `index.ts` in the project root and thus finish the preparations.

```bash
npm install
```

Now we can start a real work.


## Set up NEAR Lake Framework

In the `index.ts` let's import `startStream` function and `types` from `near-lake-framework`:

```ts title=index.ts
import { startStream, types } from 'near-lake-framework';
```

Add the instantiation of `LakeConfig` below:

```ts title=index.js
const lakeConfig: types.LakeConfig = {
  s3BucketName: "near-lake-data-mainnet",
  s3RegionName: "eu-central-1",
  startBlockHeight: 66264389,
};
```

Just a few words on the config, we have set `s3BucketName` for mainnet, default `s3RegionName` and a fresh-ish block height for `startBlockHeight`. You can go to [NEAR Explorer](https://nearblocks.io) and get **the freshest** block height for your setup. Though you can use the same as we do.

Now we need to create a callback function that we'll be called to handle [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc) our indexer receives.

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {

}
```

:::info Callback function requirements

In `near-lake-framework` JS library the handler have to be presented as a callback function. This function have to:
- be asynchronous
- accept an argument of type [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc)
- return nothing (`void`)

:::

And an actual start of our indexer in the end of the `index.ts`

```ts title=index.ts
(async () => {
  await startStream(lakeConfig, handleStreamerMessage);
})();
```

The final `index.ts` at this moment should look like the following:

```ts title=index.ts
import { startStream, types } from 'near-lake-framework';

const lakeConfig: types.LakeConfig = {
  s3BucketName: "near-lake-data-mainnet",
  s3RegionName: "eu-central-1",
  startBlockHeight: 66264389,
};

async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {

}

(async () => {
  await startStream(lakeConfig, handleStreamerMessage);
})();
```


## Events and where to catch them

First of all let's find out where we can catch the Events. We hope you are familiar with how the [Data Flow in NEAR Blockchain](/concepts/data-flow/near-data-flow), but let's revise our knowledge:
- Mint an NFT is an action in an NFT contract (doesn't matter which one)
- Actions are located in a [Receipt](/build/data-infrastructure/lake-data-structures/receipt)
- A result of the Receipt execution is [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome)
- `ExecutionOutcome` in turn, catches the logs a contract "prints"
- [Events](https://nomicon.io/Standards/EventsFormat) built on top of the logs

This leads us to the realization that we can watch only for ExecutionOutcomes and ignore everything else `StreamerMessage` brings us.

Also, we need to define an interface to catch the Events. Let's copy the interface definition from the [Events Nomicon page](https://nomicon.io/Standards/EventsFormat#events) and paste it before the `handleStreamerMessage` function.

```ts title=index.ts
interface EventLogData {
  standard: string,
  version: string,
  event: string,
  data?: unknown,
};
```

## Catching only the data we need

Inside the callback function `handleStreamerMessage` we've prepared in the [Preparation](#preparation) section let's start filtering the data we need:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)

}
```

We have iterated through all the [Shards](/build/data-infrastructure/lake-data-structures/shard) and collected the lists of all ExecutionOutcomes into a single list (in our case we don't care on which Shard did the mint happen)

Now we want to deal only with those ExecutionOutcomes that contain logs of Events format. Such logs start with `EVENT_JSON:` according to the [Events docs](https://nomicon.io/Standards/EventsFormat#events).

Also, we don't require all the data from ExecutionOutcome, let's handle it:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
      },
      events: outcome.executionOutcome.outcome.logs.map(
        (log: string): EventLogData => {
          const [_, probablyEvent] = log.match(/^EVENT_JSON:(.*)$/) ?? []
          try {
            return JSON.parse(probablyEvent)
          } catch (e) {
            return
          }
        }
      )
      .filter(event => event !== undefined)
    }))

}
```

Let us explain what we are doing here:

1. We are walking through the ExecutionOutcomes
2. We are constructing a list of objects containing `receipt` (it's id and the receiver) and `events` containing the Events
3. In order to collect the Events we are iterating through the ExecutionOutcome's logs trying to parse Event using regular expression. We're returning `undefined` if we fail to parse `EventLogData`
4. Finally once `events` list is collected we're filtering it dropping the `undefined`

Fine, so now we have only a list of our objects that contain some Receipt data and the list of successfully parsed `EventLogData`.

The goal for our indexer is to return the useful data about a minted NFT that follows NEP-171 standard. We need to drop irrelevant standard Events:

```ts title=index.ts
    .filter(relevantOutcome =>
      relevantOutcome.events.some(
        event => event.standard === "nep171" && event.event === "nft_mint"
      )
    )
```

## Almost done

So far we have collected everything we need corresponding to our requirements.

We can print everything in the end of the `handleStreamerMessage`:

```ts title=index.ts
  relevantOutcomes.length && console.dir(relevantOutcomes, { depth: 10 })
```

The final look of the `handleStreamerMessage` function:

```ts title=index.ts
async function handleStreamerMessage(
  streamerMessage: types.StreamerMessage
): Promise<void> {
  const relevantOutcomes = streamerMessage
    .shards
    .flatMap(shard => shard.receiptExecutionOutcomes)
    .map(outcome => ({
      receipt: {
        id: outcome.receipt.receiptId,
        receiverId: outcome.receipt.receiverId,
      },
      events: outcome.executionOutcome.outcome.logs.map(
        (log: string): EventLogData => {
          const [_, probablyEvent] = log.match(/^EVENT_JSON:(.*)$/) ?? []
          try {
            return JSON.parse(probablyEvent)
          } catch (e) {
            return
          }
        }
      )
      .filter(event => event !== undefined)
    }))
    .filter(relevantOutcome =>
      relevantOutcome.events.some(
        event => event.standard === "nep171" && event.event === "nft_mint"
      )
    )

  relevantOutcomes.length && console.dir(relevantOutcomes, { depth: 10 })
}

```

And if we run our indexer we will be catching `nft_mint` event and print the data in the terminal.

```bash
npm run start
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Not so fast! Remember we were talking about having the links to the marketplaces to see the minted tokens? We're gonna extend our data with links whenever possible. At least we're gonna show you how to deal with the NFTs minted on [Paras](https://paras.id) and [Mintbase](https://mintbase.io).

## Crafting links to Paras and Mintbase for NFTs minted there

At this moment we have an array of objects we've crafted on the fly that exposes receipt, execution status and event logs. We definitely know that all the data we have at this moment are relevant for us, and we want to extend it with the links to that minted NFTs at least for those marketplaces we know.

We know and love Paras and Mintbase.

### Paras token URL

We did the research for you and here's how the URL to token on Paras is crafting:

```
https://paras.id/token/[1]::[2]/[3]
```

Where:

- [1] - Paras contract address (`x.paras.near`)
- [2] - First part of the `token_id` (`EventLogData.data` for Paras is an array of objects with `token_ids` key in it. Those IDs represented by numbers with column `:` between them)
- [3] - `token_id` itself

Example:

```
https://paras.id/token/x.paras.near::387427/387427:373
```

Let's add the interface for later use somewhere after `interface EventLogData`:

```ts
interface ParasEventLogData {
  owner_id: string,
  token_ids: string[],
};
```

### Mintbase token URL

And again we did the research for you:

```
https://www.mintbase.io/thing/[1]:[2]
```

Where:

- [1] - `meta_id` (`EventLogData.data` for Mintbase is an array of stringified JSON that contains `meta_id`)
- [2] - Store contract account address (basically Receipt's receiver ID)

Example:

```
https://www.mintbase.io/thing/70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus:vnartistsdao.mintbase1.near
```

Let's add the interface for later use somewhere after `interface EventLogData`:

```ts
interface MintbaseEventLogData {
  owner_id: string,
  memo: string,
}
```

Now it's a perfect time to add another `.map()`, but it might be too much. So let's proceed with a forloop to craft the output data we want to print.

```ts title=index.ts
let output = []
for (let relevantOutcome of relevantOutcomes) {
  let marketplace = "Unknown"
  let nfts = []


}
```

We're going to print the marketplace name, Receipt id so you would be able to search for it on [NEAR Explorer](https://nearblocks.io) and the list of links to the NFTs along with the owner account name.

Let's start crafting the links. Time to say "Hi!" to [Riqi](https://twitter.com/hdriqi) (just because we can):

```ts title=index.ts
let output = []
  for (let relevantOutcome of relevantOutcomes) {
    let marketplace = "Unknown"
    let nfts = []
    if (relevantOutcome.receipt.receiverId.endsWith(".paras.near")) {
      marketplace = "Paras"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as ParasEventLogData[])
          .map(eventData => ({
            owner: eventData.owner_id,
            links: eventData.token_ids.map(
              tokenId => `https://paras.id/token/${relevantOutcome.receipt.receiverId}::${tokenId.split(":")[0]}/${tokenId}`
            )
           })
        )
      })
    }
```

A few words about what is going on here. If the Receipt's receiver account name ends with `.paras.near` (e.g. `x.paras.near`) we assume it's from Paras marketplace, so we are changing the corresponding variable.

After that we iterate over the Events and its `data` using the `ParasEventLogData` we've defined earlier. Collecting a list of objects with the NFTs owner and NFTs links.

Mintbase turn, we hope [Nate](https://twitter.com/nategeier) and his team have [migrated to NEAR Lake Framework](../../lake-framework/migrating-to-near-lake-framework.md) already, saying "Hi!" and crafting the link:

```ts title=index.ts
  } else if (relevantOutcome.receipt.receiverId.match(/\.mintbase\d+\.near$/)) {
      marketplace = "Mintbase"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as MintbaseEventLogData[])
          .map(eventData => {
          const memo = JSON.parse(eventData.memo)
          return {
            owner: eventData.owner_id,
            links: [`https://mintbase.io/thing/${memo["meta_id"]}:${relevantOutcome.receipt.receiverId}`]
          }
        })
      })
    }
```

Almost the same story as with Paras, but a little bit more complex. The nature of Mintbase marketplace is that it's not a single marketplace! Every Mintbase user has their own store and a separate contract. And it looks like those contract addresses follow the same principle they end with `.mintbaseN.near` where `N` is number (e.g. `nate.mintbase1.near`).

After we have defined that the ExecutionOutcome receiver is from Mintbase we are doing the same stuff as with Paras:

1. Changing the `marketplace` variable
2. Collecting the list of NFTs with owner and crafted links

And if we can't determine the marketplace, we still want to return something, so let's return Events data as is:

```ts title=index.ts
  } else {
    nfts = relevantOutcome.events.flatMap(event => event.data)
  }
```

It's time to push the collected data to the `output`

```ts title=index.ts
  output.push({
    receiptId: relevantOutcome.receipt.id,
    marketplace,
    nfts,
  })
```

And make it print the output to the terminal:

```ts title=index.ts
if (output.length) {
  console.log(`We caught freshly minted NFTs!`)
  console.dir(output, { depth: 5 })
}
```

All together:

```ts title=index.ts
  let output = []
  for (let relevantOutcome of relevantOutcomes) {
    let marketplace = "Unknown"
    let nfts = []
    if (relevantOutcome.receipt.receiverId.endsWith(".paras.near")) {
      marketplace = "Paras"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as ParasEventLogData[])
          .map(eventData => ({
            owner: eventData.owner_id,
            links: eventData.token_ids.map(
              tokenId => `https://paras.id/token/${relevantOutcome.receipt.receiverId}::${tokenId.split(":")[0]}/${tokenId}`
            )
           })
        )
      })
    } else if (relevantOutcome.receipt.receiverId.match(/\.mintbase\d+\.near$/)) {
      marketplace = "Mintbase"
      nfts = relevantOutcome.events.flatMap(event => {
        return (event.data as MintbaseEventLogData[])
          .map(eventData => {
          const memo = JSON.parse(eventData.memo)
          return {
            owner: eventData.owner_id,
            links: [`https://mintbase.io/thing/${memo["meta_id"]}:${relevantOutcome.receipt.receiverId}`]
          }
        })
      })
    } else {
      nfts = relevantOutcome.events.flatMap(event => event.data)
    }
    output.push({
      receiptId: relevantOutcome.receipt.id,
      marketplace,
      createdOn,
      nfts,
    })
  }
  if (output.length) {
    console.log(`We caught freshly minted NFTs!`)
    console.dir(output, { depth: 5 })
  }
```

OK, how about the date and time of the NFT mint? Let's add to the beginning of the `handleStreamerMessage` function

```ts title=index.ts
const createdOn = new Date(streamerMessage.block.header.timestamp / 1000000)
```

Update the `output.push()` expression:

```ts title=index.ts
output.push({
  receiptId: relevantOutcome.receipt.id,
  marketplace,
  createdOn,
  nfts,
})
```

And not that's it. Run the indexer to watch for NFT minting and never miss a thing.

```bash
npm run start
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Example output:

```
We caught freshly minted NFTs!
[
  {
    receiptId: '2y5XzzL1EEAxgq8EW3es2r1dLLkcecC6pDFHR12osCGk',
    marketplace: 'Paras',
    createdOn: 2022-05-24T09:35:57.831Z,
    nfts: [
      {
        owner: 'dccc.near',
        links: [ 'https://paras.id/token/x.paras.near::398089/398089:17' ]
      }
    ]
  }
]
We caught freshly minted NFTs!
[
  {
    receiptId: 'BAVZ92XdbkAPX4DkqW5gjCvrhLX6kGq8nD8HkhQFVt5q',
    marketplace: 'Mintbase',
    createdOn: 2022-05-24T09:36:00.411Z,
    nfts: [
      {
        owner: 'chiming.near',
        links: [
          'https://mintbase.io/thing/HOTcn6LTo3qTq8bUbB7VwA1GfSDYx2fYOqvP0L_N5Es:vnartistsdao.mintbase1.near'
        ]
      }
    ]
  }
]
```

## Conclusion

What a ride, yeah? Let's sum up what we have done:

- You've learnt about [Events](https://nomicon.io/Standards/EventsFormat)
- Now you understand how to follow for the Events
- Knowing the fact that as a contract developer you can use Events and emit your own events, now you know how to create an indexer that follows those Events
- We've had a closer look at NFT minting process, you can experiment further and find out how to follow `nft_transfer` Events

The material from this tutorial can be extrapolated for literally any event that follows the [Events format](https://nomicon.io/Standards/EventsFormat)

Not mentioning you have a dedicated indexer to find out about the newest NFTs minted out there and to be the earliest bird to collect them.

Let's go hunt doo, doo, doo ü¶à

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/building-indexers/primitives.md 

 ---
id: primitives
title: NEAR Lake Primitive Types
sidebar_label: Lake Primitive Types
---

# NEAR Lake Primitive Types

This article contains the primitive types used by the [NEAR Lake Framework package](https://www.npmjs.com/package/@near-lake/framework). These types are used to define the data structures used by the framework as well as provide some popular helper functions.

## `Block`

:::info Important Notes on `Block`

- All the entities located on different shards were merged into one single list without differentiation.
- `Block` is not the fairest name for this structure either. NEAR Protocol is a sharded blockchain, so its block is actually an ephemeral structure that represents a collection of real blocks called chunks in NEAR Protocol.

:::

### `Block` Structure Definition

The `Block` type is used to represent a block in the NEAR Lake Framework. It is comprised by the following structure:

```ts
export class Block {
    constructor(
        readonly streamerMessage: StreamerMessage,
        private executedReceipts: Receipt[],
        readonly postponedReceipts: Receipt[],
        readonly transactions: Transaction[],
        private _actions: Map<string, Action>,
        private _events: Map<string, Event[]>,
        private _stateChanges: StateChange[]) { 

        }
    ... // helper methods and getters omitted for brevity
}
```

#### `streamerMessage`

Low-level structure for backward compatibility. As implemented in previous versions of [`near-lake-framework`](https://www.npmjs.com/package/near-lake-framework). 

#### `postponedReceipts`

Receipts included on the chain but not executed yet marked as ‚Äúpostponed‚Äù: they are represented by the same structure `Receipt` (see the corresponding section in this doc for more details).

#### `transactions`

List of included `Transactions`, converted into `Receipts`.

:::info Heads up!

**Note:**  You might want to know about `Transactions` to know where the action chain has begun. Unlike Ethereum, where a Transaction contains everything you may want to know about a particular interaction on  the Ethereum blockchain, Near Protocol because of its asynchronous nature converts a `Transaction` into a `Receipt` before executing it. Thus, On NEAR, `Receipts` are more important for figuring out what happened on-chain as a result of a Transaction signed by a user. Read more about [Transactions on Near](https://nomicon.io/RuntimeSpec/Transactions) here.

:::

### `Block` Helper Methods

```ts
export class Block {
    ... // constructor omitted for brevity
    get blockHash(): string {}
    get prevBlockHash(): string {}
    get blockHeight(): number {}

    header(): BlockHeader {}
    receipts(): Receipt[] {}
    actions(): Action[] {}
    events(): Event[] {}
    stateChanges(): StateChange[] {}

    actionByReceiptId(receipt_id: string): Action | undefined {}
    eventsByReceiptId(receipt_id: string): Event[] {}
    eventsByAccountId(account_id: string): Event[] {}

    private buildActionsHashmap() {}
    private buildEventsHashmap(): Map<string, Event[]> {}

    static fromStreamerMessage(streamerMessage: StreamerMessage): Block {}
}
```

#### `blockHash`

Returns the block hash. A shortcut to get the data from the block header.

#### `prevBlockHash`

Returns the previous block hash. A shortcut to get the data from the block header.

#### `blockHeight`

Returns the block height. A shortcut to get the data from the block header.

#### `header(): BlockHeader`

Returns a `BlockHeader` structure of the block

See `BlockHeader` structure sections for details.

#### `receipts(): Receipt[]`

Returns a slice of `Receipts` executed in the block.

Basically is a getter for the `executedReceipts` field.

#### `actions(): Action[]`

Returns an Array of `Actions` executed in the block.

#### `events(): Event[]`

Returns `Events` emitted in the block.

#### `stateChanges(): StateChange[]`

Returns an Array of `StateChange` occurred in the block.

#### `actionByReceiptId(receipt_id: string): Action | undefined`

Returns `Action`s of the provided `receipt_id` from the block if any. Returns `undefined` if there is no corresponding `Action`.

This method uses the internal `Block` `action` field which is empty by default and will be filled with the block‚Äôs actions on the first call to optimize memory usage.

The result is either `Action | undefined` since there might be a request for an `Action` by `receipt_id` from another block, in which case this method will be unable to find the `Action` in the current block. In the other case, the request might be for an `Action` for a `receipt_id` that belongs to a `DataReceipt` where an action does not exist.

#### `eventsByReceiptId(receipt_id: string): Event[]`

Returns an Array of Events emitted by `ExecutionOutcome` for the given `receipt_id`. There might be more than one `Event` for the `Receipt` or there might be none of them. In the latter case, this method returns an empty Array.

#### `eventsByAccountId(account_id: string): Event[]`

Returns an Array of Events emitted by `ExecutionOutcome` for the given `account_id`. There might be more than one `Event` for the `Receipt` or there might be none of them. In the latter case, this method returns an empty Array.

---

## `BlockHeader`

Replacement for `BlockHeaderView` from `near-primitives`. Shrunken and simplified. 

:::note
The original `BlockHeaderView` is still accessible via the `.streamerMessage` attribute.
:::

### `BlockHeader` Structure Definition

```ts
export class BlockHeader {
    constructor(
        readonly height: number,
        readonly hash: string,
        readonly prevHash: string,
        readonly author: string,
        readonly timestampNanosec: string,
        readonly epochId: string,
        readonly nextEpochId: string,
        readonly gasPrice: string,
        readonly totalSupply: string,
        readonly latestProtocolVersion: number,
        readonly randomValue: string,
        readonly chunksIncluded: number,
        readonly validatorProposals: ValidatorStakeView[]) { 
        }
    ... // helper method omitted for brevity
}
```

---

## `Receipt`

This field is a simplified representation of the `ReceiptView` structure from `near-primitives`.

### `Receipt` Structure Definition

```ts
export class Receipt implements Events {
  constructor(
    readonly receiptKind: ReceiptKind, 
    readonly receiptId: string, 
    readonly receiverId: string, 
    readonly predecessorId: string, 
    readonly status: ExecutionStatus, 
    readonly executionOutcomeId?: string | undefined, 
    readonly logs: string[] = []) {
    }
  ... // helper methods omitted for brevity
}
```

### `Receipt` Fields

#### `receiptKind`

Defined the type of the `Receipt`: `Action` or `Data` representing the `ActionReceipt` and `DataReceipt`.

#### `receiptId`

The ID of the `Receipt` of the `CryptoHash` type.

#### `receiverId`

The receiver account id of the `Receipt`.

#### `predecessorId`

The predecessor account id of the `Receipt`.

#### `status`

Represents the status of `ExecutionOutcome` of the `Receipt`.

See the `ExecutionStatus` enum section for the details.

#### `executionOutcomeId`

The id of the `ExecutionOutcome` for the `Receipt`. Returns `null` if the `Receipt` isn‚Äôt executed yet and has a postponed status.

#### `logs`

The original logs of the corresponding `ExecutionOutcome` of the `Receipt`.

Note: not all of the logs might be parsed as JSON Events (`Events`).

### `Receipt` Helper Methods

```ts
export class Receipt {
    ... // constructor omitted for brevity
    get events(): Event[] {}

    static fromOutcomeWithReceipt(outcomeWithReceipt: OutcomeWithReceipt): Receipt {}
}
```

#### `Receipt.events(): Events[]`

Returns an Array of `Events` for the `Receipt`, if any. This might be empty if the `logs` field is empty or doesn‚Äôt contain JSON Events compatible log records.

---

## `Event`

This structure is an ephemeral entity to provide access to the [Events Standard](https://github.com/near/NEPs/blob/master/neps/nep-0297.md) structure and keep data about the related `Receipt` for convenience.

### Interface for Capturing Data About an Event in `handleStreamerMessage()`

The interface to capture data about an event has the following arguments:

- `standard`: name of standard, e.g. nep171
- `version`: e.g. 1.0.0
- `event`: type of the event, e.g. nft_mint
- `data`: associate event data. Strictly typed for each set `{standard, version, event}` inside corresponding NEP

### `Event` Structure Definition

```ts
export class Event {
    constructor(
      readonly relatedReceiptId: string, 
      readonly rawEvent: RawEvent) {
      }
    ... // helper methods omitted for brevity
}
```

### `Event` Methods

```ts
export class Event {
    ... // constructor omitted for brevity
    static fromLog(log: string): Event {}
}
```

---

## `Transaction`

A representation of the `IndexerTransactionWithOutcome` from `near-indexer-primitives` which is an ephemeral structure combining `SignedTransactionView` from `near-primitives` and `IndexerExecutionOutcomeWithOptionalReceipt` from `near-indexer-primitives`.

This structure is very similar to `Receipt`. Unlike `Receipt`, a `Transaction` has a few additional fields like `signerId`, `signature`, and `operations`.

### `Transaction` Structure Definition

```ts
export class Transaction {
    constructor(
      readonly transactionHash: string, 
      readonly signerId: string, 
      readonly signerPublicKey: string, 
      readonly signature: string, 
      readonly receiverId: string, 
      readonly status: ExecutionStatus, 
      readonly executionOutcomeId: string, 
      readonly operations: Operation[]) { 
      }
}
```

#### `Transaction.transactionHash`

Returns the hash of the `Transaction` in `CryptoHash`.

#### `Transaction.signerId`

Returns the signer account id of the `Transaction`.

#### `Transaction.signerPublicKey`

Returns the `PublicKey` of the signer of the `Transaction`.

#### `Transaction.signature`

Returns the `Signature` the `Transaction` was signed with.

#### `Transaction.receiverId`

Returns the receiver account id of the `Transaction`.

#### `Transaction.status`

Returns the status of the `Transaction` as `ExecutionStatus`.

#### `Transaction.executionOutcomeId`

Returns the id of the `ExecutionOutcome` for the `Transaction`.

#### `Transaction.operations`

Returns an Array of `Operation` for the `Transaction`.

---

## `StateChange`

This structure is almost an identical copy of the `StateChangeWithCauseView` from `near-primitives` with a propagated additional field `affectedAccountId`.

### `StateChange` Structure Definition

```ts
export class StateChange {
    constructor(
      readonly cause: StateChangeCause, 
      readonly value: StateChangeValue
    ) {}
    
    get affectedAccountId(): string {}

    static fromStateChangeView(stateChangeView: StateChangeWithCauseView) {}
}
```

#### `StateChange.cause`

Returns the `cause` of the `StateChange`.

#### `StateChange.value`

Returns the `value` of the `StateChange`.

#### `StateChange.affectedAccountId(): string`

Returns the account id of the `StateChange`.

#### `StateChange.fromStateChangeView(stateChangeView: StateChangeWithCauseView): StateChange`

Returns the `StateChange` from the `StateChangeWithCauseView`. Created for backward compatibility.


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/building-indexers/python-lake-indexer.md 

 ---
sidebar_label: "Python tutorial"
---

# NEAR Lake indexer basic tutorial


:::info Source code for the tutorial

[`frolvanya/near-lake-raw-printer`](https://github.com/frolvanya/near-lake-raw-printer): source code for the tutorial on how to create an indexer that prints block height and number of shards

:::

Recently we have [published a Python version of the NEAR Lake Framework](https://pypi.org/project/near-lake-framework/) on pypi.org

We want to empower you with a basic tutorial on how to use the Python Package. Let's get started!


## Create a project

Create an indexer project:

```bash
mkdir near-lake-raw-printer && cd near-lake-raw-printer
touch main.py
```

## Install dependencies

Install `near-lake-framework`

```bash
pip3 install near-lake-framework
```

## Import `near-lake-framework`

In the `main.py` file let's import the necessary dependencies:

```python title=main.py
from near_lake_framework import near_primitives, LakeConfig, streamer
```

We've imported the main function `streamer`, which will be called to actually run the indexer, `near_primitives`, and `LakeConfig` type we need to construct.

## Create a config

Add the instantiation of `LakeConfig` below:

```python title=main.py
config = LakeConfig.mainnet()
config.start_block_height = 69030747
config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
```

Just a few words on the config, function `mainnet()` has set `s3_bucket_name`, `s3_region_name` for mainnet.
You can go to [NEAR Explorer](https://nearblocks.io) and get **the most recent** block height to set `config.start_block_height`.

## Starting the stream

Let's call `streamer` function with the `config`:

```python title=main.py
stream_handle, streamer_messages_queue = streamer(config)
while True:
    streamer_message = await streamer_messages_queue.get()
    print(f"Block #{streamer_message.block.header.height} Shards: {len(streamer_message.shards)}")
```

And an actual start of our indexer in the end of the `main.py`

```python title=main.py
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

## All together

```python title=main.py
import asyncio
import os

from near_lake_framework import LakeConfig, streamer, near_primitives

async def main():    
    config = LakeConfig.mainnet()
    config.start_block_height = 69030747
    config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
    config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")

    stream_handle, streamer_messages_queue = streamer(config)
    while True:
        streamer_message = await streamer_messages_queue.get()
        print(f"Block #{streamer_message.block.header.height} Shards: {len(streamer_message.shards)}")

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

That's it. Now we run `main.py`

```bash
python3 main.py
```

You should see something like the following:

```bash
Received 400 blocks from S3
Block #69030747 Shards: 4
Block #69030748 Shards: 4
Block #69030749 Shards: 4
Block #69030750 Shards: 4
Block #69030751 Shards: 4
Block #69030752 Shards: 4
Block #69030753 Shards: 4
Block #69030754 Shards: 4
```

You can stop the indexer by pressing CTRL+C

:::danger Credentials

To be able to access the data from [NEAR Lake](/build/data-infrastructure/lake-framework/near-lake) you need to provide credentials. Please, see the [Credentials](../../lake-framework/running-near-lake/credentials.md) article

:::

You can find the [source code for this tutorial on the GitHub](https://github.com/frolvanya/near-lake-raw-printer).


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/building-indexers/python-nft-indexer.md 

 ---
sidebar_label: "NFT indexer for Python"
---

# Building an NFT indexer for Python


:::note Source code for the tutorial

[`frolvanya/near-lake-nft-indexer`](https://github.com/frolvanya/near-lake-nft-indexer): source code for this tutorial

:::

## The Goal

This tutorial ends with a working NFT indexer built on top [NEAR Lake Framework for Python](/build/data-infrastructure/lake-framework/near-lake-framework/). The indexer is watching for `nft_mint` [Events](https://nomicon.io/Standards/EventsFormat) and prints some relevant data:
- `receipt_id` of the [Receipt](/build/data-infrastructure/lake-data-structures/receipt) where the mint has happened
- Marketplace
- NFT owner account name
- Links to the NFTs on the marketplaces

The final source code is available on the GitHub [`frolvanya/near-lake-nft-indexer`](https://github.com/frolvanya/near-lake-nft-indexer)

## Motivation

NEAR Protocol had introduced a nice feature [Events](https://nomicon.io/Standards/EventsFormat). The Events allow a contract developer to add standardized logs to the [`ExecutionOutcomes`](/build/data-infrastructure/lake-data-structures/execution-outcome) thus allowing themselves or other developers to read those logs in more convenient manner via API or indexers.

The Events have a field `standard` which aligns with NEPs. In this tutorial we'll be talking about [NEP-171 Non-Fungible Token standard](https://github.com/near/NEPs/discussions/171).

In this tutorial our goal is to show you how you can "listen" to the Events contracts emit and how you can benefit from them.

As the example we will be building an indexer that watches all the NFTs minted following the [NEP-171 Events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) standard, assuming we're collectors who don't want to miss a thing. Our indexer should notice every single NFT minted and give us a basic set of data like: in what Receipt it was minted, and show us the link to a marketplace (we'll cover [Paras](https://paras.id) and [Mintbase](https://mintbase.io) in our example).

We will use Python version of [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) in this tutorial. Though the concept is the same for Rust, but we want to show more people that it's not that complex to build your own indexer.

## Preparation

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](../running-near-lake/credentials.md) page. Otherwise you won't be able to get the code working.

:::

Let's create our project folder

```bash
mkdir lake-nft-indexer && cd lake-nft-indexer
touch main.py
```

## Set up NEAR Lake Framework

In the `main.py` let's import `stream` function and `near_primitives` from `near-lake-framework`:

```python title=main.py
from near_lake_framework import near_primitives, LakeConfig, streamer
```

Add the main function

```python title=main.py
async def main():
    print("Starting NFT indexer")
```

Add the instantiation of `LakeConfig` below:

```python title=main.py
config = LakeConfig.mainnet()
config.start_block_height = 69030747
config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")
```

Just a few words on the config, function `mainnet()` has set `s3_bucket_name`, `s3_region_name` for mainnet.
You can go to [NEAR Explorer](https://nearblocks.io) and get **the most recent** block height to set `config.start_block_height`.

Let's call `streamer` function with the `config`

```python title=main.py
stream_handle, streamer_messages_queue = streamer(config)
while True:
    streamer_message = await streamer_messages_queue.get()
```


And an actual start of our indexer in the end of the `main.py`

```python title=main.py
loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

The final `main.py` at this moment should look like the following:

```python title=main.py
from near_lake_framework import LakeConfig, streamer, near_primitives
async def main():
    print("Starting NFT indexer")
    
    config = LakeConfig.mainnet()
    config.start_block_height = 69030747
    config.aws_access_key_id = os.getenv("AWS_ACCESS_KEY_ID")
    config.aws_secret_key = os.getenv("AWS_SECRET_ACCESS_KEY")

    stream_handle, streamer_messages_queue = streamer(config)
    while True:
        streamer_message = await streamer_messages_queue.get()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
```

Now we need to create a callback function that we'll be called to handle [`StreamerMessage`](/build/data-infrastructure/lake-data-structures/toc) our indexer receives.

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    pass
```

## Events and where to catch them

First of all let's find out where we can catch the Events. We hope you are familiar with how the [Data Flow in NEAR Blockchain](/concepts/data-flow/near-data-flow), but let's revise our knowledge:
- Mint an NFT is an action in an NFT contract (doesn't matter which one)
- Actions are located in a [Receipt](/build/data-infrastructure/lake-data-structures/receipt)
- A result of the Receipt execution is [ExecutionOutcome](/build/data-infrastructure/lake-data-structures/execution-outcome)
- `ExecutionOutcome` in turn, catches the logs a contract "prints"
- [Events](https://nomicon.io/Standards/EventsFormat) built on top of the logs

This leads us to the realization that we can watch only for ExecutionOutcomes and ignore everything else `StreamerMessage` brings us.


## Catching only the data we need

Inside the callback function `handle_streamer_message` we've prepared in the [Preparation](#preparation) section let's start filtering the data we need:

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                pass
```

We have iterated through the logs of all ExecutionOutcomes of [Shards](/build/data-infrastructure/lake-data-structures/shard) (in our case we don't care on which Shard did the mint happen)

Now we want to deal only with those ExecutionOutcomes that contain logs of Events format. Such logs start with `EVENT_JSON:` according to the [Events docs](https://nomicon.io/Standards/EventsFormat#events).

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                if not log.startswith("EVENT_JSON:"):
                    continue
                try:
                    parsed_log = json.loads(log[len("EVENT_JSON:") :])
                except json.JSONDecodeError:
                    print(
                        f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nError during parsing logs from JSON string to dict"
                    )
                    continue
```

Let us explain what we are doing here:

1. We are walking through the logs in ExecutionOutcomes
2. We are filtering ExecutionOutcomes that contain logs of Events format
3. In order to collect the Events we are iterating through the ExecutionOutcome's logs trying to parse Event using `json.loads`

The goal for our indexer is to return the useful data about a minted NFT that follows NEP-171 standard. We need to drop irrelevant standard Events:

```python title=main.py
    if (
        parsed_log.get("standard") != "nep171"
        or parsed_log.get("event") != "nft_mint"
    ):
        continue
```

## Almost done

So far we have collected everything we need corresponding to our requirements.

The final look of the `handle_streamer_message` function:

```python title=main.py
async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                if not log.startswith("EVENT_JSON:"):
                    continue
                try:
                    parsed_log = json.loads(log[len("EVENT_JSON:") :])
                except json.JSONDecodeError:
                    print(
                        f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nError during parsing logs from JSON string to dict"
                    )
                    continue

                if (
                    parsed_log.get("standard") != "nep171"
                    or parsed_log.get("event") != "nft_mint"
                ):
                    continue

                print(parsed_log)
```

Now let's call `handle_streamer_message` inside the loop in `main` function

```python title=main.py
await handle_streamer_message(streamer_message)
```

And if we run our indexer we will be catching `nft_mint` event and print logs in the terminal.

```bash
python3 main.py
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Not so fast! Remember we were talking about having the links to the marketplaces to see the minted tokens? We're gonna extend our data with links whenever possible. At least we're gonna show you how to deal with the NFTs minted on [Paras](https://paras.id) and [Mintbase](https://mintbase.io).

## Crafting links to Paras and Mintbase for NFTs minted there

At this moment we have an access to logs that follows NEP-171 standard. We definitely know that all the data we have at this moment are relevant for us, and we want to extend it with the links to that minted NFTs at least for those marketplaces we know.

We know and love Paras and Mintbase.

### Paras token URL

We did the research for you and here's how the URL to token on Paras is crafting:

```
https://paras.id/token/[1]::[2]/[3]
```

Where:

- [1] - Paras contract address (`x.paras.near`)
- [2] - First part of the `token_id` (`parsed_log["data"]` for Paras is an array of objects with `token_ids` key in it. Those IDs represented by numbers with column `:` between them)
- [3] - `token_id` itself

Example:

```
https://paras.id/token/x.paras.near::387427/387427:373
```

### Mintbase token URL

And again we did the research for you:

```
https://www.mintbase.io/thing/[1]:[2]
```

Where:

- [1] - `meta_id` (`parsed_log["data"]` for Mintbase is an array of stringified JSON that contains `meta_id`)
- [2] - Store contract account address (basically Receipt's receiver ID)

Example:

```
https://www.mintbase.io/thing/70eES-icwSw9iPIkUluMHOV055pKTTgQgTiXtwy3Xus:vnartistsdao.mintbase1.near
```

Let's start crafting the links:

```python title=main.py
def format_paras_nfts(data, receipt_execution_outcome):
    links = []

    for data_element in data:
        for token_id in data_element.get("token_ids", []):
            first_part_of_token_id = token_id.split(":")[0]
            links.append(
                f"https://paras.id/token/{receipt_execution_outcome.receipt.receiver_id}::{first_part_of_token_id}/{token_id}"
            )

    return {"owner": data[0].get("owner_id"), "links": links}

def format_mintbase_nfts(data, receipt_execution_outcome):
    links = []
    for data_block in data:
        try:
            memo = json.loads(data_block.get("memo"))
        except json.JSONDecodeError:
            print(
                f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nMemo: `{memo}`\nError during parsing Mintbase memo from JSON string to dict"
            )
            return

        meta_id = memo.get("meta_id")
        links.append(
            f"https://www.mintbase.io/thing/{meta_id}:{receipt_execution_outcome.receipt.receiver_id}"
        )

    return {"owner": data[0].get("owner_id"), "links": links}
```

We're going to print the receipt_id, so you would be able to search for it on [NEAR Explorer](https://nearblocks.io), marketplace name and the list of links to the NFTs along with the owner account name.

```python title=main.py
if receipt_execution_outcome.receipt.receiver_id.endswith(
    ".paras.near"
):
    output = {
        "receipt_id": receipt_execution_outcome.receipt.receipt_id,
        "marketplace": "Paras",
        "nfts": format_paras_nfts(
            parsed_log["data"], receipt_execution_outcome
        ),
    }
```

A few words about what is going on here. If the Receipt's receiver account name ends with `.paras.near` (e.g. `x.paras.near`) we assume it's from Paras marketplace, so we are changing the corresponding variable.

Mintbase turn, we hope [Nate](https://twitter.com/nategeier) and his team have [migrated to NEAR Lake Framework](../migrating-to-near-lake-framework.md) already, saying "Hi!" and crafting the link:

```python title=main.py
    elif re.search(
        ".mintbase\d+.near", receipt_execution_outcome.receipt.receiver_id
    ):
        output = {
            "receipt_id": receipt_execution_outcome.receipt.receipt_id,
            "marketplace": "Mintbase",
            "nfts": format_mintbase_nfts(
                parsed_log["data"], receipt_execution_outcome
            ),
        }
    else:
        continue
```

Almost the same story as with Paras, but a little bit more complex. The nature of Mintbase marketplace is that it's not a single marketplace! Every Mintbase user has their own store and a separate contract. And it looks like those contract addresses follow the same principle they end with `.mintbaseN.near` where `N` is number (e.g. `nate.mintbase1.near`).

After we have defined that the ExecutionOutcome receiver is from Mintbase we are doing the same stuff as with Paras:

1. Setting the `marketplace` variable to Mintbase
2. Collecting the list of NFTs with owner and crafted links

And make it print the output to the terminal:

```python title=main.py
print(json.dumps(output, indent=4))
```

All together:

```python title=main.py
def format_paras_nfts(data, receipt_execution_outcome):
    links = []

    for data_element in data:
        for token_id in data_element.get("token_ids", []):
            first_part_of_token_id = token_id.split(":")[0]
            links.append(
                f"https://paras.id/token/{receipt_execution_outcome.receipt.receiver_id}::{first_part_of_token_id}/{token_id}"
            )

    return {"owner": data[0].get("owner_id"), "links": links}


def format_mintbase_nfts(data, receipt_execution_outcome):
    links = []
    for data_block in data:
        try:
            memo = json.loads(data_block.get("memo"))
        except json.JSONDecodeError:
            print(
                f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nMemo: `{memo}`\nError during parsing Mintbase memo from JSON string to dict"
            )
            return

        meta_id = memo.get("meta_id")
        links.append(
            f"https://www.mintbase.io/thing/{meta_id}:{receipt_execution_outcome.receipt.receiver_id}"
        )

    return {"owner": data[0].get("owner_id"), "links": links}


async def handle_streamer_message(streamer_message: near_primitives.StreamerMessage):
    for shard in streamer_message.shards:
        for receipt_execution_outcome in shard.receipt_execution_outcomes:
            for log in receipt_execution_outcome.execution_outcome.outcome.logs:
                if not log.startswith("EVENT_JSON:"):
                    continue
                try:
                    parsed_log = json.loads(log[len("EVENT_JSON:") :])
                except json.JSONDecodeError:
                    print(
                        f"Receipt ID: `{receipt_execution_outcome.receipt.receipt_id}`\nError during parsing logs from JSON string to dict"
                    )
                    continue

                if (
                    parsed_log.get("standard") != "nep171"
                    or parsed_log.get("event") != "nft_mint"
                ):
                    continue

                if receipt_execution_outcome.receipt.receiver_id.endswith(
                    ".paras.near"
                ):
                    output = {
                        "receipt_id": receipt_execution_outcome.receipt.receipt_id,
                        "marketplace": "Paras",
                        "nfts": format_paras_nfts(
                            parsed_log["data"], receipt_execution_outcome
                        ),
                    }
                elif re.search(
                    ".mintbase\d+.near", receipt_execution_outcome.receipt.receiver_id
                ):
                    output = {
                        "receipt_id": receipt_execution_outcome.receipt.receipt_id,
                        "marketplace": "Mintbase",
                        "nfts": format_mintbase_nfts(
                            parsed_log["data"], receipt_execution_outcome
                        ),
                    }
                else:
                    continue

                print(json.dumps(output, indent=4))
```

And not that's it. Run the indexer to watch for NFT minting and never miss a thing.

```bash
python3 main.py
```

:::note

Having troubles running the indexer? Please, check you haven't skipped the [Credentials](../running-near-lake/credentials.md) part :)

:::

Example output:

```
{
    "receipt_id": "8rMK8rxb3WmFcSfM3ahFoeeoBF92pad3tpsqKoSWurr2",
    "marketplace": "Mintbase",
    "nfts": {
        "owner": "vn-artists-dao.near",
        "links": [
            "https://www.mintbase.io/thing/aqdCBHB9_2XZY7pwXRRu5rGDeLQl7Q8KgNud1wKgnGo:vnartistsdao.mintbase1.near"
        ]
    }
}
{
    "receipt_id": "ArRh94Fe1LKF9yPrAdzrMozWoxMVQbEW2Z2Zf4fsSsce",
    "marketplace": "Paras",
    "nfts": {
        "owner": "eeaeb516e0945893ac01eaf547f499abdbd344831c5fcbefa1a5c0a9f303cc5c",
        "links": [
            "https://paras.id/token/x.paras.near::432714/432714:1"
        ]
    }
}
```

## Conclusion

What a ride, yeah? Let's sum up what we have done:

- You've learnt about [Events](https://nomicon.io/Standards/EventsFormat)
- Now you understand how to follow for the Events
- Knowing the fact that as a contract developer you can use Events and emit your own events, now you know how to create an indexer that follows those Events
- We've had a closer look at NFT minting process, you can experiment further and find out how to follow `nft_transfer` Events

The material from this tutorial can be extrapolated for literally any event that follows the [Events format](https://nomicon.io/Standards/EventsFormat)

Not mentioning you have a dedicated indexer to find out about the newest NFTs minted out there and to be the earliest bird to collect them.

Let's go hunt doo, doo, doo ü¶à

:::note Source code for the tutorial

[`near-examples/near-lake-nft-indexer`](https://github.com/near-examples/near-lake-nft-indexer): source code for this tutorial

:::



 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/migrating-to-near-lake-framework.md 

 ---
sidebar_label: Migrating to NEAR Lake framework
id: migrating-to-near-lake-framework
---

# Migrating to NEAR Lake Framework


We encourage everyone who don't have a hard requirement to use [NEAR Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer) consider the migration to [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework).

In this tutorial we'll show you how to migrate the project using [indexer-tx-watcher-example](https://github.com/near-examples/indexer-tx-watcher-example) as a showcase.

:::info Source code

The source code for the migrated indexer can be found on GitHub https://github.com/near-examples/indexer-tx-watcher-example-lake/tree/0.4.0

:::

:::info Diffs

We've [posted the diffs for the reference in the end](#diffs) of the article, you can scroll down to them if diffs are all you need in order to migrate your indexer

:::

## Changing the dependencies

First of all we'll start from the dependencies in `Cargo.toml`

```toml title=src/Cargo.toml

[package]
name = "indexer-tx-watcher-example"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[dependencies]
actix = "=0.11.0-beta.2"
actix-rt = "=2.2.0"  # remove it once actix is upgraded to 0.11+
base64 = "0.11"
clap = "3.0.0-beta.1"
openssl-probe = { version = "0.1.2" }
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
tokio = { version = "1.1", features = ["sync"] }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"

near-indexer = { git = "https://github.com/near/nearcore", rev = "25b000ae4dd9fe784695d07a3f2e99d82a6f10bd" }
```

- Update `edition` to `2021`
- Drop `actix` crates
- Drop `openssl-probe` crate
- Add `futures` and `itertools`
- Add features to `tokio` as we will be using tokio runtime
- Add `tokio-stream` crate
- Replace `near-indexer` with `near-lake-framework`

So in the end we'll have this after all:

```toml title=src/Cargo.toml
[package]
name = "indexer-tx-watcher-example"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[dependencies]
base64 = "0.11"
clap = { version = "3.1.6", features = ["derive"] }
futures = "0.3.5"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"
itertools = "0.9.0"
tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"

near-lake-framework = "0.4.0"

```

## Change the clap configs

Currently we have structure `Opts` that has a subcommand with `Run` and `Init` command. Since [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) doesn't need `data` and config files we don't need `Init` at all. So we need to combine some structures into `Opts` itself.

```rust title=src/config.rs
...
/// NEAR Indexer Example
/// Watches for stream of blocks from the chain
#[derive(Clap, Debug)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
pub(crate) struct Opts {
    /// Sets a custom config dir. Defaults to ~/.near/
    #[clap(short, long)]
    pub home_dir: Option<std::path::PathBuf>,
    #[clap(subcommand)]
    pub subcmd: SubCommand,
}

#[derive(Clap, Debug)]
pub(crate) enum SubCommand {
    /// Run NEAR Indexer Example. Start observe the network
    Run(RunArgs),
    /// Initialize necessary configs
    Init(InitConfigArgs),
}

#[derive(Clap, Debug)]
pub(crate) struct RunArgs {
    /// account ids to watch for
    #[clap(long)]
    pub accounts: String,
}

#[derive(Clap, Debug)]
pub(crate) struct InitConfigArgs {
    ...
}
...
```

We are going:

- Drop `InitConfigArgs` completely
- Move the content from `RunArgs` to `Opts` and then drop `RunArgs`
- Drop `home_dir` from `Opts`
- Add `block_height` to `Opts` to know from which block height to start indexing
- Refactor `SubCommand` to have to variants: mainnet and testnet to define what chain to index
- And add `Clone` detive to the structs for later

```rust title=src/config.rs
/// NEAR Indexer Example
/// Watches for stream of blocks from the chain
#[derive(Clap, Debug, Clone)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
pub(crate) struct Opts {
    /// block height to start indexing from
    #[clap(long)]
    pub block_height: u64,
    /// account ids to watch for
    #[clap(long)]
    pub accounts: String,
    #[clap(subcommand)]
    pub subcmd: SubCommand,
}

#[derive(Clap, Debug, Clone)]
pub(crate) enum SubCommand {
    Mainnet,
    Testnet,
}
```

In the end of the file we have one implementation we need to replace.

```rust title=src/config.rs
...
impl From<InitConfigArgs> for near_indexer::InitConfigArgs {
    ...
}
```

We want to be able to cast `Opts` to `near_lake_framework::LakeConfig`. So we're going to create a new implementation.

```rust title=src/config.rs
impl From<Opts> for near_lake_framework::LakeConfig {
    fn from(opts: Opts) -> Self {
        let mut lake_config =
            near_lake_framework::LakeConfigBuilder::default().start_block_height(opts.block_height);

        match &opts.subcmd {
            SubCommand::Mainnet => {
                lake_config = lake_config.mainnet();
            }
            SubCommand::Testnet => {
                lake_config = lake_config.testnet();
            }
        };

        lake_config.build().expect("Failed to build LakeConfig")
    }
}
```

And the final move is to change `init_logging` function to remove redundant log subscriptions:

```rust title=src/config.rs

...
pub(crate) fn init_logging() {
    let env_filter = EnvFilter::new(
        "tokio_reactor=info,near=info,stats=info,telemetry=info,indexer_example=info,indexer=info,near-performance-metrics=info",
    );
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}
...
```

Replace it with

```rust title=src/config.rs
...
pub(crate) fn init_logging() {
    let env_filter = EnvFilter::new("near_lake_framework=info");
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}
...
```

Finally we're done with `src/config.rs` and now we can move on to `src/main.rs`

## Replacing the indexer instantiation

Since we can use `tokio` runtime and make our `main` function asynchronous it's shorted to show the recreating of the `main` function than the process of refactoring.

Let's start from import section

### Imports before

```rust title=src/main.rs
use std::str::FromStr;

use std::collections::{HashMap, HashSet};

use clap::Clap;
use tokio::sync::mpsc;
use tracing::info;

use configs::{init_logging, Opts, SubCommand};

mod configs;
```

### Imports after

We're adding `near_lake_framework` imports and remove redundant import from `configs`.

```rust title=src/main.rs
use std::str::FromStr;

use std::collections::{HashMap, HashSet};

use clap::Clap;
use tokio::sync::mpsc;
use tracing::info;

use near_lake_framework::near_indexer_primitives;
use near_lake_framework::LakeConfig;

use configs::{init_logging, Opts};
```

### Creating `main()`

Let's create an async `main()` function, call `init_logging` and read the `Opts`.

```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

```

Let's cast `LakeConfig` from `Opts` and instantiate [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework)'s `stream`

```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

```

Copy/paste the code of reading `accounts` arg to `Vec<AccountId`> from the old `main()`

```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

    let watching_list = opts
        .accounts
        .split(',')
        .map(|elem| {
            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
        })
        .collect();
```

Now we can call `listen_blocks` function we have used before in our indexer while it was built on top of [NEAR Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer). And return `Ok(())` so our `main()` would be happy.


### Final async main with NEAR Lake Framework stream
```rust title=src/main.rs
#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_logging();

    let opts: Opts = Opts::parse();

    let config: LakeConfig = opts.clone().into();

    let (_, stream) = near_lake_framework::streamer(config);

    let watching_list = opts
        .accounts
        .split(',')
        .map(|elem| {
            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
        })
        .collect();

    listen_blocks(stream, watching_list).await;

    Ok(())
}
```

We're done. That's pretty much entire `main()` function. Drop the old one if you haven't yet.

## Changes in other function related to data types

Along with [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) release we have extracted the structures created for indexers into a separate crate. This was done in order to avoid dependency on `nearcore` as now you can depend on a separate crate that is already [published on crates.io](https://crates.io/crates/near-indexer-primitives) or on NEAR Lake Framework that exposes that crate.

### `listen_blocks`

A function signature needs to be changed to point to new place for data types

```rust title=src/main.rs
async fn listen_blocks(
    mut stream: mpsc::Receiver<near_indexer::StreamerMessage>,
    watching_list: Vec<near_indexer::near_primitives::types::AccountId>,
 ) {
```

```rust title=src/main.rs
async fn listen_blocks(
    mut stream: mpsc::Receiver<near_indexer_primitives::StreamerMessage>,
    watching_list: Vec<near_indexer_primitives::types::AccountId>,
 ) {
```

And another 3 places where `near_indexer::near_primitives` needs to be replaced with `near_indexer_primitives`

```rust title=src/main.rs

if let near_indexer_primitives::views::ReceiptEnumView::Action {
```

```rust title=src/main.rs
if let near_indexer_primitives::views::ReceiptEnumView::Action {
```

```rust title=src/main.rs
if let near_indexer_primitives::views::ActionView::FunctionCall {
```

## `is_tx_receiver_watched()`

And final change for data types in the function `is_tx_receiver_watched()`

```rust title=src/main.rs
fn is_tx_receiver_watched(
    tx: &near_indexer_primitives::IndexerTransactionWithOutcome,
    watching_list: &[near_indexer_primitives::types::AccountId],
) -> bool {
    watching_list.contains(&tx.transaction.receiver_id)
}
```

## Credentials
[Configure the Credentials](./running-near-lake/credentials.md) in order to access the data from NEAR Lake Framework

## Conclusion

And now we have a completely migrated to [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) indexer.

We are posting the complete diffs for the reference

## Diffs

```diff title=Cargo.toml
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -2,18 +2,18 @@
 name = "indexer-tx-watcher-example"
 version = "0.1.0"
 authors = ["Near Inc <hello@nearprotocol.com>"]
-edition = "2018"
+edition = "2021"

 [dependencies]
-actix = "=0.11.0-beta.2"
-actix-rt = "=2.2.0"  # remove it once actix is upgraded to 0.11+
 base64 = "0.11"
-clap = "3.0.0-beta.1"
-openssl-probe = { version = "0.1.2" }
+clap = { version = "3.1.6", features = ["derive"] }
+futures = "0.3.5"
 serde = { version = "1", features = ["derive"] }
 serde_json = "1.0.55"
-tokio = { version = "1.1", features = ["sync"] }
+itertools = "0.9.0"
+tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
+tokio-stream = { version = "0.1" }
 tracing = "0.1.13"
 tracing-subscriber = "0.2.4"

-near-indexer = { git = "https://github.com/near/nearcore", rev = "25b000ae4dd9fe784695d07a3f2e99d82a6f10bd" }
+near-lake-framework = "0.4.0"
```

```diff title=src/configs.rs
--- a/src/configs.rs
+++ b/src/configs.rs
@@ -1,99 +1,50 @@
-use clap::Clap;
+use clap::Parser;

 use tracing_subscriber::EnvFilter;

 /// NEAR Indexer Example
 /// Watches for stream of blocks from the chain
-#[derive(Clap, Debug)]
+#[derive(Parser, Debug, Clone)]
 #[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
 pub(crate) struct Opts {
-    /// Sets a custom config dir. Defaults to ~/.near/
-    #[clap(short, long)]
-    pub home_dir: Option<std::path::PathBuf>,
-    #[clap(subcommand)]
-    pub subcmd: SubCommand,
-}
-
-#[derive(Clap, Debug)]
-pub(crate) enum SubCommand {
-    /// Run NEAR Indexer Example. Start observe the network
-    Run(RunArgs),
-    /// Initialize necessary configs
-    Init(InitConfigArgs),
-}
-
-#[derive(Clap, Debug)]
-pub(crate) struct RunArgs {
+    /// block height to start indexing from
+    #[clap(long)]
+    pub block_height: u64,
     /// account ids to watch for
     #[clap(long)]
     pub accounts: String,
+    #[clap(subcommand)]
+    pub subcmd: SubCommand,
 }

-#[derive(Clap, Debug)]
-pub(crate) struct InitConfigArgs {
-    /// chain/network id (localnet, testnet, devnet, betanet)
-    #[clap(short, long)]
-    pub chain_id: Option<String>,
-    /// Account ID for the validator key
-    #[clap(long)]
-    pub account_id: Option<String>,
-    /// Specify private key generated from seed (TESTING ONLY)
-    #[clap(long)]
-    pub test_seed: Option<String>,
-    /// Number of shards to initialize the chain with
-    #[clap(short, long, default_value = "1")]
-    pub num_shards: u64,
-    /// Makes block production fast (TESTING ONLY)
-    #[clap(short, long)]
-    pub fast: bool,
-    /// Genesis file to use when initialize testnet (including downloading)
-    #[clap(short, long)]
-    pub genesis: Option<String>,
-    /// Download the verified NEAR genesis file automatically.
-    #[clap(long)]
-    pub download_genesis: bool,
-    /// Specify a custom download URL for the genesis file.
-    #[clap(long)]
-    pub download_genesis_url: Option<String>,
-    /// Download the verified NEAR config file automatically.
-    #[clap(long)]
-    pub download_config: bool,
-    /// Specify a custom download URL for the config file.
-    #[clap(long)]
-    pub download_config_url: Option<String>,
-    /// Specify the boot nodes to bootstrap the network
-    #[clap(long)]
-    pub boot_nodes: Option<String>,
-    /// Specify a custom max_gas_burnt_view limit.
-    #[clap(long)]
-    pub max_gas_burnt_view: Option<u64>,
+#[derive(Parser, Debug, Clone)]
+pub(crate) enum SubCommand {
+    Mainnet,
+    Testnet,
 }

 pub(crate) fn init_logging() {
-    let env_filter = EnvFilter::new(
-        "tokio_reactor=info,near=info,stats=info,telemetry=info,indexer_example=info,indexer=info,near-performance-metrics=info",
-    );
+    let env_filter = EnvFilter::new("near_lake_framework=info");
     tracing_subscriber::fmt::Subscriber::builder()
         .with_env_filter(env_filter)
         .with_writer(std::io::stderr)
         .init();
 }

-impl From<InitConfigArgs> for near_indexer::InitConfigArgs {
-    fn from(config_args: InitConfigArgs) -> Self {
-        Self {
-            chain_id: config_args.chain_id,
-            account_id: config_args.account_id,
-            test_seed: config_args.test_seed,
-            num_shards: config_args.num_shards,
-            fast: config_args.fast,
-            genesis: config_args.genesis,
-            download_genesis: config_args.download_genesis,
-            download_genesis_url: config_args.download_genesis_url,
-            download_config: config_args.download_config,
-            download_config_url: config_args.download_config_url,
-            boot_nodes: config_args.boot_nodes,
-            max_gas_burnt_view: config_args.max_gas_burnt_view,
-        }
+impl From<Opts> for near_lake_framework::LakeConfig {
+    fn from(opts: Opts) -> Self {
+        let mut lake_config =
+            near_lake_framework::LakeConfigBuilder::default().start_block_height(opts.block_height);
+
+        match &opts.subcmd {
+            SubCommand::Mainnet => {
+                lake_config = lake_config.mainnet();
+            }
+            SubCommand::Testnet => {
+                lake_config = lake_config.testnet();
+            }
+        };
+
+        lake_config.build().expect("Failed to build LakeConfig")
     }
 }
```

```diff title=src/main.rs
--- a/src/main.rs
+++ b/src/main.rs
@@ -2,11 +2,14 @@

 use std::collections::{HashMap, HashSet};

-use clap::Clap;
+use clap::Parser;
 use tokio::sync::mpsc;
 use tracing::info;

-use configs::{init_logging, Opts, SubCommand};
+use near_lake_framework::near_indexer_primitives;
+use near_lake_framework::LakeConfig;
+
+use configs::{init_logging, Opts};

 mod configs;

@@ -15,60 +18,34 @@
 /// We want to catch all *successful* transactions sent to one of the accounts from the list.
 /// In the demo we'll just look for them and log them but it might and probably should be extended based on your needs.

-fn main() {
-    // We use it to automatically search the for root certificates to perform HTTPS calls
-    // (sending telemetry and downloading genesis)
-    openssl_probe::init_ssl_cert_env_vars();
+#[tokio::main]
+async fn main() -> Result<(), tokio::io::Error> {
     init_logging();

     let opts: Opts = Opts::parse();

-    let home_dir = opts.home_dir.unwrap_or_else(near_indexer::get_default_home);
+    let config: LakeConfig = opts.clone().into();

-    match opts.subcmd {
-        SubCommand::Run(args) => {
-            // Create the Vec of AccountId from the provided ``--accounts`` to pass it to `listen_blocks`
-            let watching_list = args
-                .accounts
-                .split(',')
-                .map(|elem| {
-                    near_indexer::near_primitives::types::AccountId::from_str(elem)
-                        .expect("AccountId is invalid")
-                })
-                .collect();
-
-            // Inform about indexer is being started and what accounts we're watching for
-            eprintln!(
-                "Starting indexer transaction watcher for accounts: \n {:#?}",
-                &args.accounts
-            );
-
-            // Instantiate IndexerConfig with hardcoded parameters
-            let indexer_config = near_indexer::IndexerConfig {
-                home_dir,
-                sync_mode: near_indexer::SyncModeEnum::FromInterruption,
-                await_for_node_synced: near_indexer::AwaitForNodeSyncedEnum::WaitForFullSync,
-            };
+    let (_, stream) = near_lake_framework::streamer(config);

-            // Boilerplate code to start the indexer itself
-            let sys = actix::System::new();
-            sys.block_on(async move {
-                eprintln!("Actix");
-                let indexer = near_indexer::Indexer::new(indexer_config);
-                let stream = indexer.streamer();
-                actix::spawn(listen_blocks(stream, watching_list));
-            });
-            sys.run().unwrap();
-        }
-        SubCommand::Init(config) => near_indexer::indexer_init_configs(&home_dir, config.into()),
-    }
+    let watching_list = opts
+        .accounts
+        .split(',')
+        .map(|elem| {
+            near_indexer_primitives::types::AccountId::from_str(elem).expect("AccountId is invalid")
+        })
+        .collect();
+
+    listen_blocks(stream, watching_list).await;
+
+    Ok(())
 }

 /// The main listener function the will be reading the stream of blocks `StreamerMessage`
 /// and perform necessary checks
 async fn listen_blocks(
-    mut stream: mpsc::Receiver<near_indexer::StreamerMessage>,
-    watching_list: Vec<near_indexer::near_primitives::types::AccountId>,
+    mut stream: mpsc::Receiver<near_indexer_primitives::StreamerMessage>,
+    watching_list: Vec<near_indexer_primitives::types::AccountId>,
 ) {
     eprintln!("listen_blocks");
     // This will be a map of correspondence between transactions and receipts
@@ -120,7 +97,7 @@
                         &execution_outcome.receipt.receiver_id,
                         execution_outcome.execution_outcome.outcome.status
                     );
-                    if let near_indexer::near_primitives::views::ReceiptEnumView::Action {
+                    if let near_indexer_primitives::views::ReceiptEnumView::Action {
                         signer_id,
                         ..
                     } = &execution_outcome.receipt.receipt
@@ -128,19 +105,20 @@
                         eprintln!("{}", signer_id);
                     }

-                    if let near_indexer::near_primitives::views::ReceiptEnumView::Action {
-                        actions,
-                        ..
+                    if let near_indexer_primitives::views::ReceiptEnumView::Action {
+                        actions, ..
                     } = execution_outcome.receipt.receipt
                     {
                         for action in actions.iter() {
-                            if let near_indexer::near_primitives::views::ActionView::FunctionCall {
+                            if let near_indexer_primitives::views::ActionView::FunctionCall {
                                 args,
                                 ..
                             } = action
                             {
                                 if let Ok(decoded_args) = base64::decode(args) {
-                                    if let Ok(args_json) = serde_json::from_slice::<serde_json::Value>(&decoded_args) {
+                                    if let Ok(args_json) =
+                                        serde_json::from_slice::<serde_json::Value>(&decoded_args)
+                                    {
                                         eprintln!("{:#?}", args_json);
                                     }
                                 }
@@ -156,8 +134,8 @@
 }

 fn is_tx_receiver_watched(
-    tx: &near_indexer::IndexerTransactionWithOutcome,
-    watching_list: &[near_indexer::near_primitives::types::AccountId],
+    tx: &near_indexer_primitives::IndexerTransactionWithOutcome,
+    watching_list: &[near_indexer_primitives::types::AccountId],
 ) -> bool {
     watching_list.contains(&tx.transaction.receiver_id)
 }
```


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/near-lake-framework.md 

 ---
id: near-lake-framework
sidebar_label: "NEAR Lake Framework"
---

NEAR Lake Framework is an ecosystem of library companions to [NEAR Lake](/build/data-infrastructure/lake-framework/near-lake). They allow you to build your own indexer that subscribes to the stream of blocks from the [NEAR Lake](/build/data-infrastructure/lake-framework/near-lake) data source and create your own logic to process the NEAR Protocol data in the programming languages of your choice (at the moment, there are implementations in [Python](http://pypi.org/project/near-lake-framework), [JavaScript](https://www.npmjs.com/package/near-lake-framework), and [Rust](https://crates.io/crates/near-lake-framework)).

:::tip NEAR Lake Framework announcement

We have announced the release of NEAR Lake Framework on NEAR Governance Forum.

Please, read the post [here](https://gov.near.org/t/announcement-near-lake-framework-brand-new-word-in-indexer-building-approach/17668).

:::

:::note GitHub repo

https://github.com/near/near-lake-framework/

:::


## How does it compare to [NEAR Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer)?

Feature | Indexer Framework | Lake Framework
------- | ----------------- | --------------
Allows to follow the blocks and transactions in the NEAR Protocol | **Yes** | **Yes**<br />(but only mainnet and testnet networks)
Decentralized | **Yes** | No<br />(Pagoda Inc dumps the blocks to AWS S3)
Reaction time (end-to-end) | minimum 3.8s (estimated average 5-7s) | [minimum 3.9s (estimated average 6-8s)](#limitations)
Reaction time (framework overhead only) | 0.1s | 0.2-2.2s
Estimated cost of infrastructure | [$500+/mo](https://near-nodes.io/rpc/hardware-rpc) | [**$20/mo**](#what-is-the-cost-of-running-a-custom-indexer-based-on-near-lake)
Ease of maintenance | Advanced<br />(need to follow every nearcore upgrade, and sync state) | **Easy**<br />(deploy once and forget)
How long will it take to start? | days (on mainnet/testnet) | **seconds**
Ease of local development | Advanced<br />(localnet is a good option, but testing on testnet/mainnet is too heavy) | **Easy**<br />(see [tutorials](/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer))
Programming languages that a custom indexer can be implemented with | Rust only | **Any**<br />(currently, helper packages are released in [Python](http://pypi.org/project/near-lake-framework), [JavaScript](https://www.npmjs.com/package/near-lake-framework), and [Rust](https://crates.io/crates/near-lake-framework))


## Limitations

Lake Framework relies on the data being dumped to AWS S3 from [NEAR Lake Indexer](https://github.com/near/near-lake-indexer) which is based on [NEAR Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer). Thus, Lake Framework is centralized around AWS S3 storage and also around maintainers of NEAR Lake Indexer nodes (Pagoda Inc). This is the tradeoff you might still want to take given all the other benefits mentioned above.

Indexers based on the Lake Framework inherit [the latency characteristics of Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer) and extra latency of dumping to and reading from AWS S3, which is estimated to add at least 50ms delay while writing to S3, and 50ms on polling and reading from S3 (to make the polling cost-efficient, we default to polling only every 2s, so in the worst case you may observe an additional 2-second latency). Thus, Lake Framework adds 0.1-2.1s latency on top of Indexer Framework. Yet, again, most of the latency is there due to the finalization delay and both Indexer Framework and Lake Framework add quite a minimum overhead.

## What is the cost of running a custom indexer based on NEAR Lake?

Indexers based on NEAR Lake consume 100-500MB of RAM depending on the size of the preloading queue, it does not require any storage, and it can potentially run even on Raspberry PI.

Getting the blockchain data from S3 will cost around $18.15 per month as NEAR Lake configured S3 buckets in such a way that the reader is paying the costs.

### AWS S3 cost breakdown

Assuming NEAR Protocol produces exactly 1 block per second (which is really not, the average block production time is 1.3s). A full day consists of 86400 seconds, that's the max number of blocks that can be produced.

According to the [Amazon S3 prices](https://aws.amazon.com/s3/pricing/?nc1=h_ls) `list` requests are charged for $0.005 per 1000 requests and `get` is charged for $0.0004 per 1000 requests.

Calculations (assuming we are following the tip of the network all the time):

```
86400 blocks per day * 5 requests for each block / 1000 requests * $0.0004 per 1k requests = $0.173 * 30 days = $5.19
```
**Note:** 5 requests for each block means we have 4 shards (1 file for common block data and 4 separate files for each shard)

And a number of `list` requests we need to perform for 30 days:

```
86400 blocks per day / 1000 requests * $0.005 per 1k list requests = $0.432 * 30 days = $12.96

$5.19 + $12.96 = $18.15
```

Note, the price depends on the number of shards.

## Examples & Tutorials

- [`near-examples/near-lake-raw-printer`](https://github.com/near-examples/near-lake-raw-printer): simple example of a data printer built on top of NEAR Lake Framework
- [`near-examples/near-lake-accounts-watcher`](https://github.com/near-examples/near-lake-accounts-watcher): source code for a video tutorial on how to use the NEAR Lake Framework
- [`near-examples/indexer-tx-watcher-example-lake`](https://github.com/near-examples/indexer-tx-watcher-example-lake) indexer example that watches for transaction for specified accounts/contracts build on top of NEAR Lake Framework

:::note Tutorials

See [Tutorials page](/build/data-infrastructure/lake-framework/near-lake-state-changes-indexer)

:::


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/near-lake-state-changes-indexer.md 

 ---
id: near-lake-state-changes-indexer
title: NEAR Lake Indexer Tutorial
---

:::note Source code for the tutorial

[`near-examples/near-lake-accounts-watcher`](https://github.com/near-examples/near-lake-accounts-watcher/tree/0.2.0): source code for a video tutorial on how to use the NEAR Lake Framework

:::

:::info Version 0.2.0

The video is based on the [`near-lake-framework`](/build/data-infrastructure/lake-framework/near-lake-framework) version 0.2.0

At the same time we're keeping the source code up to date with the latest version of the published crate.

:::

We've created a video tutorial to empower the release announcement of [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework).

In this tutorial you will build an indexer application to watch for any `StateChange`s affecting the account or a list of account provided.

<iframe
 width="560"
 height="315"
 src="https://www.youtube.com/embed/GsF7I93K-EQ"
 title="YouTube video player"
 frameborder="0"
 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
 allowfullscreen>
</iframe>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/near-lake.md 

 ---
id: near-lake
sidebar_label: Lake Overview
title: NEAR Lake Indexer
---

NEAR Lake is an indexer built on top of [NEAR Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer) to watch the network and store all the event logs such as [FT Events](https://nomicon.io/Standards/Tokens/FungibleToken/Event) and [NFT Events](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) as JSON files on AWS S3.

:::info GitHub repo

You can find the Lake Indexer source code in [this GitHub repository](https://github.com/near/near-lake-indexer/).

:::

### How it works

:::tip

[Pagoda Inc.](https://www.pagoda.co) runs NEAR Lake nodes to store the data in JSON format on AWS S3.
There is no need to run your own NEAR Lake unless you have specific reasons to do that.

:::

There are AWS S3 buckets created:

- `near-lake-data-testnet` (`eu-central-1` region)
- `near-lake-data-mainnet` (`eu-central-1` region)

All the buckets are set up the way the requester pays for the access. Anyone can read from these buckets by connecting to them with their own AWS credentials to be charged by Amazon.

### Data structure

The data structure used by Lake Indexer is the following:

```
    <block_height>/
      block.json
      shard_0.json
      shard_1.json
      ...
      shard_N.json
```

`<block_height>` is a 12-character-long [`u64`](https://doc.rust-lang.org/std/primitive.u64.html) string with leading zeros (e.g "000042839521"). See [this issue for reasoning](https://github.com/near/near-lake/issues/23).

`block_json` contains JSON-serialized `BlockView` struct. **NB!** this struct might change in the future, we will announce it

`shard_N.json` where N is [`u64`](https://doc.rust-lang.org/std/primitive.u64.html) starting from `0`. Represents the index number of the shard. In order to find out the expected number of shards in the block you can look in `block.json` at `.header.chunks_included`


### How to use it

We have created the [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) to have a simple straightforward way to create an indexer on top of the data stored by NEAR Lake itself.

:::info NEAR Lake Framework

You can check the NEAR Lake Framework release announcement on the [NEAR Governance Forum](https://gov.near.org/t/announcement-near-lake-framework-brand-new-word-in-indexer-building-approach/17668).

:::

We have prepared this video tutorial with a simple example to give you an overview and some practical ideas.

<iframe
 width="560"
 height="315"
 src="https://www.youtube.com/embed/GsF7I93K-EQ"
 title="NEAR Lake Indexer"
 frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
 allowfullscreen>
</iframe>


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/running-near-lake/credentials.md 

 ---
sidebar_label: "Credentials"
id: credentials
---

# Credentials

To access the data provided by [NEAR Lake](../near-lake.md) you need to provide valid AWS credentials in order to be charged by the AWS for the S3 usage.

:::info AWS credentials

Please note that using your own AWS Credentials is the only way to access the data provided by [NEAR Lake](../near-lake.md) ecosystem.

:::

### AWS S3 Credentials

To be able to get objects from the AWS S3 bucket you need to provide your AWS credentials.

AWS default profile configuration with aws configure looks similar to the following:

```
~/.aws/credentials
```

```
[default]
aws_access_key_id=<YOUR_AWS_ACCESS_KEY_ID>
aws_secret_access_key=<YOUR_AWS_ACCESS_KEY>
```

[AWS docs: Configuration and credential file settings](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)

#### Environment variables

Alternatively, you can provide your AWS credentials via environment variables with constant names:

```
$ export AWS_ACCESS_KEY_ID=<YOUR_AWS_ACCESS_KEY_ID>
$ AWS_SECRET_ACCESS_KEY=<YOUR_AWS_ACCESS_KEY>
$ AWS_DEFAULT_REGION=eu-central-1
```


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/running-near-lake/lake-start-options.md 

 ---
sidebar_label: "Start options"
id: lake-start-options
---

# Extending Lake indexer with start options


## The End

This tutorial ends with the example code of the simple indexer built on top of [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) that can start:
- from specified block height (out of the box)
  ```bash
  ./target/release/indexer mainnet from-block 65359506
  ```
- from the latest final block from the network
  ```bash
  ./target/release/indexer mainnet from-latest
  ```
- from the block indexer has indexed the last before it was interrupted
  ```bash
  ./target/release/indexer mainnet from-interruption
  ```

## Motivation

To find out whether you need an indexer for you project and to create one means you're covering only one side of things - the development.

There is another important side - the maintenance. This involves:
- indexer needs to be upgraded with a newer version of dependencies
- indexer needs to be updates with a new features you've made
- your server needs some maintenance
- incident had happened
- etc.

Almost in all of the above cases you might want to start or restart your indexer not only from the specific block you need to provide, but from the block it was stopped, or from the latest final block in the network.

[NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) doesn't provide such options. Actually, we didn't empower the library with these options to start indexer intentionally.

:::info Intent

We want to keep [NEAR Lake Framework](/build/data-infrastructure/lake-framework/near-lake-framework) crate in the narrowest possible way. The goal for the library is to do a single job and allow it to be empowered with any features but outside of the crate itself

:::

Though, the possibility to start indexer from the latest block or from the block after the one it has indexed the last, might be very useful.

Also, during [the April Data Platform Community Meeting](https://github.com/near/indexers-docs/blob/main/blog/2022-05-11-community-meeting-record.mdx) we had a question whether we plan to add this feature to the library. We've promised to create a tutorial showing how to do it by your own. So here it is.

## Preparation

In this tutorial we're not going to focus our attention on the indexer itself, but on the start options instead.

:::note

To simplify the code samples in the tutorial, we're writing entire application in a single file `src/main.rs`.

**Please, do not take it as a design advice. We do it only for the simplicity**

:::

Let's prepare a project with a base dependencies, so we can focus on the main goal of this tutorial.

Create a new Rust project

```bash
cargo new --bin indexer && cd indexer
```

Replace the content of the `Cargo.toml` file with this:

```toml title=Cargo.toml
[package]
name = "indexer"
version = "0.1.0"
edition = "2021"
rust-version = "1.60.0"

[dependencies]
clap = { version = "3.1.6", features = ["derive"] }
futures = "0.3.5"
itertools = "0.9.0"
tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"

near-lake-framework = "0.3.0"

```

Replace the content of `src/main.rs` with this:

```rust
use clap::{Parser, Subcommand};
use futures::StreamExt;
use tracing_subscriber::EnvFilter;

// TODO: StartOptions

#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_tracing();

    let opts = Opts::parse();

    // TODO: Config

    let stream = near_lake_framework::streamer(config);

    let mut handlers = tokio_stream::wrappers::ReceiverStream::new(stream)
        .map(handle_streamer_message)
        .buffer_unordered(1usize);

    while let Some(_handle_message) = handlers.next().await {}

    Ok(())
}

async fn handle_streamer_message(
    streamer_message: near_lake_framework::near_indexer_primitives::StreamerMessage,
) {
    eprintln!(
        "{} / shards {}",
        streamer_message.block.header.height,
        streamer_message.shards.len()
    );
    std::fs::write("last_indexed_block", streamer_message.block.header.height.to_string().as_bytes()).unwrap();
}

fn init_tracing() {
    let mut env_filter = EnvFilter::new("near_lake_framework=info");

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    eprintln!("Ignoring directive `{}`: {}", s, err);
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}
```

This code is not going to build yet. Meanwhile let's have a quick look of what we've copy/pasted for now:

- We have imported [`clap`](https://docs.rs/clap/latest/clap/) to set up what command line arguments we're going to accept
- Also, we've important necessary stuff like `futures` and `tracing_subscriber`
- `init_tracing` in the end of the file is a helper function that subscribes our application to the logs from `near-lake-framework`
- An asynchronous `main` function with the indexer boilerplate code, but missing the `LakeConfig` creation part we're going to cover in the tutorial.
- You can find a few `// TODO: ...` sections we've marked for you to find places to write the code from this tutorial.

OK, all the preparations are done. Let's move on.

## Design the `StartOptions`

So we want to be able to pass a command that defines the way our indexer should start. In this tutorial we'll be using `clap`.

We need a structure that receives the chain id. This will allow us to use command:

```bash
./target/release/indexer mainnet ...
```

OR

```bash
./target/release/indexer testnet ...
```

Let's replace the `// TODO: StartOptions` in the `src/main.rs` with:

```rust title=src/main.rs
#[derive(Parser, Debug, Clone)]
#[clap(version = "0.1", author = "Near Inc. <hello@nearprotocol.com>")]
struct Opts {
    #[clap(subcommand)]
    pub chain_id: ChainId,
}

#[derive(Subcommand, Debug, Clone)]
enum ChainId {
    #[clap(subcommand)]
    Mainnet(StartOptions),
    #[clap(subcommand)]
    Testnet(StartOptions),
}

```

Now we want to create a `StartOptions` structure that will allow us to tell our indexer where to start indexing from. The command should look like:

```bash
./target/release mainnet from-latest
```

Our variants are:

- `from-block N`, where `N` is the block height to start from
- `from-latest` to start from latest final block in the network
- `from-interruption` to start from the block indexer was previously interrupted

Let's replace the comment `// TODO: StartOptions` with the enum:

```rust title=src/main.rs
#[derive(Subcommand, Debug, Clone)]
pub(crate) enum StartOptions {
    FromBlock { height: u64 },
    FromLatest,
    FromInterruption,
}
```

Pretty simple and straightforward, agree?

## Creating a `LakeConfig`

In order to create `LakeConfig` we're going to use a config builder [`LakeConfigBuilder`](https://docs.rs/near-lake-framework/0.3.0/near_lake_framework/struct.LakeConfigBuilder.html). Fotunately, we've imported it already.

Let's instantiate a builder in place of `// TODO: Config` comment:

```rust title=src/main.src
    let mut lake_config_builder = near_lake_framework::LakeConfigBuilder::default();
```

Notice that `lake_config_builder` is defined as mutable.

Now we need to set the chain we are going to index by matching `ChainId` provided:

```rust title=src/main.src
    let mut lake_config_builder = near_lake_framework::LakeConfigBuilder::default();

    match &opts.chain_id {
        ChainId::Mainnet(start_options) => {
            lake_config_builder = lake_config_builder
                .mainnet();
        }
        ChainId::Testnet(start_options) => {
            lake_config_builder = lake_config_builder
                .testnet();
        }
    }
```

As you can see, depending on the variant of the `ChainId` enum we modify the `lake_config_builder` with one of the shortcuts `mainnet()` or `testnet()`.

The only parameter left to set is the most important for us in this tutorial `start_block_height`

Normally, we just pass the block height number `u64` but we're implementing the start options here.

## Start options logic

Let's create a separate function that will hold the logic of identification the `start_block_height` and call it `get_start_block_height`.

**Just read the code, don't copy, it's not final approach yet**

### `FromBlock { height: u64 }`

Let's start from implementation `from-block N` as the simplest one:

```rust title=src/main.rs
async fn get_start_block_height(start_options: &StartOptions) -> u64 {
    match start_options {
        StartOptions::FromBlock { height } => height,

    }
}
```

OK, it's simple enough, what's about other match arms for `StartOptions`:

```rust title=src/main.rs
async fn get_start_block_height(start_options: &StartOptions) -> u64 {
    match start_options {
        StartOptions::FromBlock { height } => height,
        StartOptions::FromLatest =>
    }
}
```

Er, how should we get the latest block from the network? We should query the JSON RPC and get the final block, extract its height and call it a day.

### `FromLatest`

In order to query the JSON RPC from within Rust code we need to use [`near-jsonrpc-client-rs` crate](https://github.com/near/near-jsonrpc-client-rs)

You can find a [bunch of useful examples](https://github.com/near/near-jsonrpc-client-rs/tree/master/examples) in the corresponding folder of the project's repository on GitHub.

Add it to `Cargo.toml` in the end:

```toml title=Cargo.toml
near-jsonrpc-client = "0.3.0"
```

The code for getting the final block height would look like the following:

```rust
use near_jsonrpc_client::{methods, JsonRpcClient};
use near_lake_framework::near_indexer_primitives::types::{BlockReference, Finality};

async fn final_block_height() -> u64 {
    let client = JsonRpcClient::connect("https://rpc.mainnet.near.org");
    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let latest_block = client.call(request).await.unwrap();

    latest_block.header.height
}
```

Nice and easy. Though, a hardcoded value of `"https://rpc.mainnet.near.org"` looks not so great. Especially when we want to support both networks.

But we can handle it by passing the JSON RPC URL to the `get_start_block_function` like this:

```rust title=src/main.rs

async fn get_start_block_height(
    start_options: &StartOptions,
    rpc_url: &str,
) -> u64 {
    ...
}

    ...
    match &opts.chain_id {
        ChainId::Mainnet(start_options) => {
            lake_config_builder = lake_config_builder
                .mainnet()
                .start_block_height(
                    get_start_block_height(
                        start_options,
                        "https://rpc.mainnet.near.org",
                    ).await
                );
        }
        ChainId::Testnet(start_options) => {
            lake_config_builder = lake_config_builder
                .testnet()
                .start_block_height(
                    get_start_block_height(
                        start_options,
                        "https://rpc.testnet.near.org",
                    ).await
                )
        }
    }

```

Meh. It's ugly and why should we pass it everytime if it is required in only one case from three possible?

Instead we can pass to the `get_start_block_height` function the entire `Opts`.

```rust title=src/main.rs
async fn get_start_block_height(opts: &Opts) -> u64 {
    match opts.chain_id {
        ChainId::Mainnet(start_options) => {
            match start_options {
                StartOptions::FromBlock { height } => height,
                StartOptions::FromLatest =>
            }
        }
    }
}
```

At least we have everything we need. Though, it still looks ugly and will definitely involve code duplication.

What we propose instead to is create `impl Opts` with a few useful methods to get JSON RPC URL and to get `StartOptions` instance.

**Now you may proceed copying the code safely**

Somewhere under the `StartOptions` definition add the following:

```rust title=src/main.rs
impl Opts {
    pub fn rpc_url(&self) -> &str {
        match self.chain_id {
            ChainId::Mainnet(_) => "https://rpc.mainnet.near.org",
            ChainId::Testnet(_) => "https://rpc.testnet.near.org",
        }
    }

    pub fn start_options(&self) -> &StartOptions {
        match &self.chain_id {
            ChainId::Mainnet(args) | ChainId::Testnet(args) => args
        }
    }
}
```

And now we can create our `get_start_block_height` function with the helper function that will query the final block `final_block_height` (we're going to reuse it, watch for the hands):

```rust title=src/main.rs
async fn get_start_block_height(opts: &Opts) -> u64 {
    match opts.start_options() {
        StartOptions::FromBlock { height } => *height,
        StartOptions::FromLatest => final_block_height(opts.rpc_url()).await,
        // a placeholder
        StartOptions::FromInterruption => 0,
    }
}

async fn final_block_height(rpc_url: &str) -> u64 {
    let client = JsonRpcClient::connect(rpc_url);
    let request = methods::block::RpcBlockRequest {
        block_reference: BlockReference::Finality(Finality::Final),
    };

    let latest_block = client.call(request).await.unwrap();

    latest_block.header.height
}
```

You may have noticed the `FromInterruption` and a comment about the placeholder. The reason we've made is to be able to build the application right now to test out that `FromLatest` works as expected.

### Testing `FromLatest`

:::danger Credentials

Please, ensure you've the credentials set up as described on the [Credentials](credentials.md) page. Otherwise you won't be able to get the code working.

:::

Let's try to build and run our code

```bash
cargo build --release

./target/release/indexer mainnet from-latest
```

Once the code is built you should see something like that in your terminal:

```
65364116 / shards 4
65364117 / shards 4
65364118 / shards 4
65364119 / shards 4
65364120 / shards 4
```

You can stop it by pressing `CTRL+C`

And now we can move on to `FromInterruption`

### `FromInterruption`

In order to let an indexer know at what block it was interrupted, the indexer needs to store the block height somewhere. And it should do it in the and of the `handle_message` function.

In the boilerplate code you've copy/pasted in the beginning of this tutorial you can notice a line of code:

```rust
    std::fs::write("last_indexed_block", streamer_message.block.header.height.to_string().as_bytes()).unwrap();
```

It saves the last indexed block height into a file `last_indexed_block` right near the indexer binary.

In the real world indexer you'd probably go with some other storage, depending on the toolset you're using.

But to show you the concept, we've decided to go with the easiest approach by saving it to the file.

Now we need to implement the reading the value from the file.

:::note

If it is a first start of your indexer and you ask it to start from interruption it wouldn't be able to find `last_indexed_block` and would just fail.

It's not the behavior we expect. That's why we assume you want it to start from interruption (if possible) or from the latest.

:::

Let's finish up our `get_start_block_height`

```rust title=src/main.rs
async fn get_start_block_height(opts: &Opts) -> u64 {
    match opts.start_options() {
        StartOptions::FromBlock { height } => *height,
        StartOptions::FromLatest => final_block_height(opts.rpc_url()).await,
        // a placeholder
        StartOptions::FromInterruption => {
            match &std::fs::read("last_indexed_block") {
                Ok(contents) => {
                    String::from_utf8_lossy(contents).parse().unwrap()
                }
                Err(e) => {
                    eprintln!("Cannot read last_indexed_block.\n{}\nStart indexer from latest final", e);
                    latest_block_height(opts.rpc_url()).await
                }
            }
        },
    }
}
```

What we are doing here:

- Trying to read the file `last_indexed_block`
- If the `Result` is `Ok`, we are reading the `contents` and parsing it
- If the `Result` is `Err` we print a message about the error and call `last_block_height` to get the final block from the network (the fallback we were talking earlier)

### Testing `FromInterruption`

In order to ensure everything works as expected we will start index from the genesis to store the last indexed block. And then we will start it from interruption to ensure we're not starting from latest.

Let's build and run from genesis.

:::info Genesis Trick

To start NEAR Lake Framework based indexer from the genesis block, you need to just specify the `start_block_height` as `0`.

:::

```bash
cargo build --release
./target/release/indexer mainnet from-block 0
```

You will see something like:

```
9820210 / shards 1
9820214 / shards 1
9820216 / shards 1
9820219 / shards 1
9820221 / shards 1
9820226 / shards 1
9820228 / shards 1
9820230 / shards 1
9820231 / shards 1
9820232 / shards 1
9820233 / shards 1
9820235 / shards 1
9820236 / shards 1
9820237 / shards 1
9820238 / shards 1
```

Stop it by pressing `CTRL+C`

Memorize the last block height you see. In our example it is `9820238`

Restart the indexer from interruption

```bash
./target/release/indexer mainnet from-interruption
```

You should see the indexer logs beginning from the block you've memorized.

Perfect! It's all done. Now you can adjust the code you got in the result to your needs and use it in your indexers.

## Summary

You've seen the way how you can empower your indexer with the starting options. As you can see there is nothing complex here.


You can find the source code in the [`near-examples/lake-indexer-start-options`](https://github.com/near-examples/lake-indexer-start-options)


 This is the content for the doc docs/2.build/6.data-infrastructure/lake-framework/running-near-lake/run-near-lake.md 

 ---
id: run-lake-indexer
sidebar_label: Running Lake Indexer
---

# Running NEAR Lake Indexer

:::info

NEAR Lake is a blockchain indexer built on top of [NEAR Indexer microframework](https://github.com/nearprotocol/nearcore/tree/master/chain/indexer)
to watch the network and store all the events as JSON files on AWS S3.

:::

## How to start

The Lake Indexer setup consists of the following components:

- AWS S3 Bucket as a storage
- NEAR Lake binary that operates as a regular NEAR Protocol peer-to-peer node, so you will operate it as
  any other [Regular/RPC Node in NEAR](https://near-nodes.io/rpc/hardware-rpc)

### Prepare Development Environment

Before you proceed, make sure you have the following software installed:

- [Rust compiler](https://rustup.rs/) of the version that is mentioned in `rust-toolchain` file in the root of
  [nearcore](https://github.com/nearprotocol/nearcore) project.
- Ensure you have [AWS Credentials configured](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)
  From AWS Docs:

  > For example, the files generated by the AWS CLI for a default profile configured with aws configure looks similar to the following.
  >
  > ~/.aws/credentials
  >
  > ```
  > [default]
  > aws_access_key_id=AKIAIOSFODNN7EXAMPLE
  > aws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
  > ```

### Compile NEAR Lake

```bash
$ cargo build --release
```

### Configure NEAR Lake

To connect NEAR Lake to the specific chain you need to have necessary configs, you can generate it as follows:

```bash
$ ./target/release/near-lake --home ~/.near/testnet init --chain-id testnet --download-config --download-genesis
```

The above code will download the official genesis config and generate necessary configs. You can replace `testnet` in the command above to different network ID (`betanet`, `mainnet`).

Configs for the specified network are in the `--home` provided folder. We need to ensure that NEAR Lake follows
all the necessary shards, so `"tracked_shards"` parameters in `~/.near/testnet/config.json` needs to be configured properly.
Currently, `nearcore` treats empty value for `"tracked_shards"` as "do not track any shard" and **any value** as "track all shards".
For example, in order to track all shards, you just add the shard #0 to the list:

```
...
"tracked_shards": [0],
...
```

### Run NEAR Lake

Commands to run NEAR Lake, after `./target/release/near-lake`

| Command | Key/Subcommand                | Required/Default                                                       | Responsible for                                                                                                                                                                                                                                                                                                                                                               |
| ------- | ----------------------------- | ---------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|         | `--home`                      | Default <br />`~/.near`                                                | Tells the node where too look for necessary files: <br />`config.json`<br />, <br />`genesis.json`<br />, <br />`node_key.json`<br />, and <br />`data`<br /> folder                                                                                                                                                                                                          |
| `init`  |                               |                                                                        | Tells the node to generate config files in `--home-dir`                                                                                                                                                                                                                                                                                                                       |
|         | `--chain-id`                  | Required<br /><br /> _ `localnet`<br /> _ `testnet`<br /> \* `mainnet` | Defines the chain to generate config files for                                                                                                                                                                                                                                                                                                                                |
|         | `--download-config`           | Optional                                                               | If provided tells the node to download `config.json` from the public URL. You can download them manually<br /><br /> - [testnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/rpc/config.json)<br /> - [mainnet config.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/rpc/config.json)      |
|         | `--download-genesis`          | Optional                                                               | If provided tells the node to download `genesis.json` from the public URL. You can download them manually<br /><br /> - [testnet genesis.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/testnet/genesis.json)<br /> - [mainnet genesis.json](https://s3-us-west-1.amazonaws.com/build.nearprotocol.com/nearcore-deploy/mainnet/genesis.json) |
|         | TODO:<br />Other `neard` keys |                                                                        |                                                                                                                                                                                                                                                                                                                                                                               |
| `run`   |                               |                                                                        | Runs the node                                                                                                                                                                                                                                                                                                                                                                 |
|         | `--bucket`                    | Required                                                               | AWS S3 Bucket name                                                                                                                                                                                                                                                                                                                                                            |
|         | `--region`                    | Required                                                               | AWS S3 Bucket region                                                                                                                                                                                                                                                                                                                                                          |
|         | `--fallback-region`           | Default eu-central-1                                                   | AWS S3 Fallback region                                                                                                                                                                                                                                                                                                                                                        |
|         | `--endpoint`                  | Optional                                                               | AWS S3 compatible API endpoint                                                                                                                                                                                                                                                                                                                                                |
|         | `--stream-while-syncing`      | Optional                                                               | If provided Indexer streams blocks while they appear on the node instead of waiting the node to be fully synced                                                                                                                                                                                                                                                               |
|         | `--concurrency`               | Default 1                                                              | Defines the concurrency for the process of saving block data to AWS S3                                                                                                                                                                                                                                                                                                        |
|         | `sync-from-latest`            | One of the `sync-` subcommands is required                             | Tells the node to start indexing from the latest block in the network                                                                                                                                                                                                                                                                                                         |
|         | `sync-from-interruption`      | One of the `sync-` subcommands is required                             | Tells the node to start indexing from the block the node was interrupted on (if it is a first start it will fallback to `sync-from-latest`)                                                                                                                                                                                                                                   |
|         | `sync-from-block --height N`  | One of the <br />`sync-`<br /> subcommands is required                 | Tells the node to start indexing from the specified block height `N` (**Ensure** you node data has the block you want to start from)                                                                                                                                                                                                                                          |

```bash
$ ./target/release/near-lake --home ~/.near/testnet run --stream-while-syncing --concurrency 50 sync-from-latest
```

After the network is synced, you should see logs of every block height currently received by NEAR Lake.

## Syncing

Whenever you run NEAR Lake for any network except localnet you'll need to sync with the network.
This is required because it's a natural behavior of `nearcore` node and NEAR Lake is a wrapper
for the regular `nearcore` node. In order to work and index the data your node must be synced
with the network. This process can take a while, so we suggest to download a fresh backup of
the `data` folder and put it in you `--home-dir` of your choice (by default it is `~/.near`)

:::tip
Running your NEAR Lake node on top of a backup data will reduce the time of syncing process
because your node will download only the data after the backup was cut and it takes reasonable amount time.
:::

All the backups can be downloaded from the public S3 bucket which contains latest daily snapshots:

You will need [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-welcome.html) to be installed in order to download the backups.

### Mainnet

```
$ aws s3 --no-sign-request cp s3://near-protocol-public/backups/mainnet/rpc/latest .
$ LATEST=$(cat latest)
$ aws s3 --no-sign-request cp --no-sign-request --recursive s3://near-protocol-public/backups/mainnet/rpc/$LATEST ~/.near/data
```

### Testnet

```
$ aws s3 --no-sign-request cp s3://near-protocol-public/backups/testnet/rpc/latest .
$ LATEST=$(cat latest)
$ aws s3 --no-sign-request cp --no-sign-request --recursive s3://near-protocol-public/backups/testnet/rpc/$LATEST ~/.near/data
```

## Running NEAR Lake as an archival node

It's not necessary but in order to index everything in the network it is better to do it from the genesis.
`nearcore` node is running in non-archival mode by default. That means that the node keeps data only
for [5 last epochs](https://docs.near.org/concepts/basics/epoch). In order to index data from the genesis
you need to turn the node in archival mode.

To do it you need to update `config.json` located in `--home-dir` (by default it is `~/.near`).

Find next keys in the config and update them as following:

```json
{
  ...
  "archive": true,
  "tracked_shards": [0],
  ...
}
```

The syncing process in archival mode can take a lot of time, so it's better to download a backup provided by NEAR
and put it in your `data` folder. After that your node will download only the data after the backup was cut and it
takes reasonable amount time.

All the backups can be downloaded from the public [S3 bucket](https://near-nodes.io/intro/node-data-snapshots) which contains the latest daily snapshots.

See [this link](https://near-nodes.io/archival/run-archival-node-with-nearup) for reference

## Using the data

We write all the data to AWS S3 buckets:

- `near-lake-data-testnet` (`eu-central-1` region) for testnet
- `near-lake-data-mainnet` (`eu-central-1` region) for mainnet

## Custom S3 storage

In case you want to run you own `near-lake` instance and store data in some S3 compatible storage ([Minio](https://min.io/) or [Localstack](https://localstack.cloud/) as example)
You can override default S3 API endpoint by using `--endpoint` option

- run `minio`

```bash
$ mkdir -p /data/near-lake-custom && minio server /data
```

- run `near-lake`

```bash
$ ./target/release/near-lake --home ~/.near/testnet run --endpoint http://127.0.0.1:9000 --bucket near-lake-custom sync-from-latest
```

### Data structure

The data structure we use is the following:

```
<block_height>/
  block.json
  shard_0.json
  shard_1.json
  ...
  shard_N.json
```

- `<block_height>` is a 12-character-long `u64` string with leading zeros (e.g `000042839521`). [See this issue for a reasoning](https://github.com/near/near-lake/issues/23)
- `block_json` contains JSON-serialized [`BlockView`](https://github.com/near/nearcore/blob/e9a28c46c2bea505b817abf484e6015a61ea7d01/core/primitives/src/views.rs#L711-L716) struct. **Note:** this struct might change in the future, we will announce it
- `shard_N.json` where `N` is `u64` starting from `0`. Represents the index number of the shard. In order to find out the expected number of shards in the block you can look in `block.json` at `.header.chunks_included`

### Access the data

All NEAR Lake AWS S3 buckets have [Request Payer](https://docs.aws.amazon.com/AmazonS3/latest/userguide/RequesterPaysBuckets.html) enabled. It means that anyone with their own AWS credentials can List and Read the bucket's content and **be charged for it by AWS**. Connections to the bucket have to be done with AWS credentials provided. See [NEAR Lake Framework](https://github.com/near/near-lake-framework) for a reference.

### NEAR Lake Framework

Once we [set up the public access to the buckets](https://github.com/near/near-lake/issues/22) anyone will be able to build their own code to read it through.

For our own needs we are working on [NEAR Lake Framework](https://github.com/near/near-lake-framework) to have a simple way to create an indexer on top of the data stored by NEAR Lake itself.

:::note
See the official NEAR Lake Framework [announcement on the NEAR Gov Forum](https://gov.near.org/t/announcement-near-lake-framework-brand-new-word-in-indexer-building-approach/17668).
:::


 This is the content for the doc docs/2.build/6.data-infrastructure/what-is.md 

 ---
id: what-is
title: What is Data Infrastructure?
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

NEAR offers ready-to-use solutions to access and monitor on-chain data easily. This is very useful to automate actions based on specific **events**, cache data to **reduce latency**, gather **usage data** of the blockchain, and even **study user preferences**.

![img](/docs/assets/welcome-pages/data-lake.png)

In NEAR you will find three main solutions to access and monitor on-chain data: [**Data APIs**](#data-apis), [**BigQuery Public Dataset**](#bigquery-public-dataset) and [**NEAR Lake**](#near-lake). Each of these solutions is designed to fit different needs and use cases, and can be used in combination to create a complete data infrastructure for your application.

---

## [Data APIs](./data-api.md)

Members of the NEAR community have built a set of APIs to access and monitor on-chain data. These APIs are designed to be easy to use and can be accessed from any application through a simple API call.

- User assets: Easily track all the assets that a user or a contract holds
- Monitor transactions: Get all the transactions of a user, a contract or a specific token
- Track on-chain events: Get all the events emitted by a contract, or a specific event type

<hr subclass="subsection" />

## [BigQuery: Public Dataset](./big-query.md)
A large dataset with on-chain data publicly available on Google Cloud Platform. Obtain near real-time blockchain data using simple SQL queries. **All the data, zero setup**.

- Instant insights: Historic on-chain data queried at scale. No need to run your own infrastructure.
- Cost-effective: Eliminate the need to store and process bulk NEAR Protocol data. Query as little or as much data as you like.
- As easy as SQL: No prior experience with blockchain technology is required. Just bring a general knowledge of SQL to unlock insights.

<hr subclass="subsection" />

## [NEAR Lake](./lake-framework/near-lake.md)
A solution that watches over the NEAR network and stores all the events for your easy access.

- Cost-efficient solution: Cost-efficient solution for building self-hosted indexers in Rust, JavaScript, Python, Go and other languages
- Streamlined data management: Use NEAR Lake Framework to stream blocks to your server directly from NEAR Lake

---

## Conclusion

Data infrastructure is a key component of any blockchain application. It allows developers to access and monitor on-chain data easily, which is essential for building applications that interact with the blockchain.

NEAR offers a range of solutions to help developers build robust data infrastructure for their applications, including Data APIs, BigQuery Public Dataset, and NEAR Lake. By using these solutions in combination, developers can create a complete data infrastructure that meets their specific needs and use cases.


 This is the content for the doc docs/2.build/welcome.md 

 ---
id: welcome
title: Welcome to NEAR
sidebar_label: Home
hide_table_of_contents: true
slug: /
---

import Home from '../welcome.md';

<Home />

 This is the content for the doc docs/3.tutorials/auction/0-intro.md 

 ---
id: introduction
title: A Step-by-Step Guide to Mastering NEAR
sidebar_label: Introduction
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Welcome! In this guide we will help you navigate NEAR tech stack, so you can build Web3 applications from start to finish in no-time.

We'll start from a simple auction contract and slowly build on top of it to create a full Web3 application to carry out on-chain auctions.

By the time you finish this tutorial, you will have learned several concepts and how to use many key primitives along the way:

- [Creating a simple smart contract](./1.1-basic.md#the-contracts-state)
- [Writing tests for a contract](./1.2-testing.md)
- [Deploying a contract to testnet](./1.3-deploy.md)
- [Locking a contract](./1.3-deploy.md#locking-the-contract)
- [Creating a frontend to interact with the contract](./2.1-frontend.md)
- [Using an indexing API to view historical bids](./2.2-indexing.md)
- [Making cross-contract calls](./3.1-nft.md#transferring-the-nft-to-the-winner)
- [Using Non-Fungible Tokens](./3.1-nft.md)
- [Using Fungible Tokens](./3.2-ft.md) 
- [Modifying a factory contract to deploy your own contracts](./4-factory.md)

---

## Prerequisites

Before starting, make sure to set up your development environment! 

<details>
<summary>Working on Windows?</summary>

  See our blog post [getting started on NEAR using Windows](/blog/getting-started-on-windows) for a step-by-step guide on how to setup WSL and your environment

</details>

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

    ```bash
    # Install Node.js using nvm (more option in: https://nodejs.org/en/download)
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    nvm install latest

    # Install the NEAR CLI to deploy and interact with the contract
    curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/latest/download/near-cli-rs-installer.sh | sh
    ```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    ```bash
    # Install Rust: https://www.rust-lang.org/tools/install
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

    # Contracts will be compiled to wasm, so we need to add the wasm target
    rustup target add wasm32-unknown-unknown

    # Install the NEAR CLI to deploy and interact with the contract
    curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/latest/download/near-cli-rs-installer.sh | sh

    # Install cargo near to help building the contract
    curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/cargo-near/releases/latest/download/cargo-near-installer.sh | sh
    ```

  </TabItem>

</Tabs>

We will be using [NEAR CLI](../../4.tools/cli.md) to interact with the blockchain through the terminal, and you can choose between JavaScript and Rust to write the contract.

---

## Overview

This series will touch on different level of the NEAR tech stack. Each section will be independent of the previous one, so feel free to jump into the section that interests you the most.

#### 1. Smart contracts 101
1. [The Auction Contract](./1.1-basic.md): We cover a simple auction smart contract                      
2. [Testing the Contract](./1.2-testing.md): Learn how to test your contract in a realistic environment
3. [Deploying the Contract](./1.3-deploy.md): Deploy your contract to the NEAR blockchain

#### 2. Frontends 101

1. [Creating the frontend](./2.1-frontend.md): Lets learn how to connect a frontend with your smart contract
2. [indexing historical data](./2.2-indexing.md): Use APIs to keep track of historical bids

#### 3. Using Primitives
1. [Giving an NFT to the Winner](./3.1-nft.md): Give the highest bidder an NFT to signal their win            
2. [Integrating Fungible Tokens](./3.2-ft.md): Allow people to use fungible tokens to bid (e.g. stable coins)
3. [Updating the frontend](./3.3-new-frontend.md): Update the frontend to use the extended functionality of the contract.

#### 3. Auction Factory
1. [Creating a factory](./4-factory.md): Allow users to easily deploy and initialize their own auction contracts

---

## Next steps

Ready to start? Let's jump to the [The Auction Contract](./1.1-basic.md) and begin your learning journey!

---

:::note Versioning for this article

- near-cli: `0.12.0`
- rustc: `1.78.0`
- cargo: `1.80.1`
- cargo-near: `0.13.2`
- rustc: `1.78.0`
- node: `21.6.1`
        
:::


 This is the content for the doc docs/3.tutorials/auction/1.1-basic.md 

 ---
id: basic-auction
title: Basic Auction
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

In this section, we will analyze a simple auction contract, which allows users to place bids, track the highest bidder and claim tokens at the end of the auction. After, we will cover how to test the contract, as well as how to deploy it on `testnet`.

:::info Documentation

During this tutorial, we will be relying on the [Smart Contract Documentation](../../2.build/2.smart-contracts/quickstart.md) and its different sections

:::

:::tip Prerequisites

Make sure to read the [Prerequisites](./0-intro.md) section and install the necessary tools before starting this tutorial

:::

---

## Cloning the contract

To get started we'll clone the [tutorial's repository](https://github.com/near-examples/auctions-tutorial) from GitHub. The repository contains the same smart contracts written in JavaScript (`./contract-ts`) and Rust (`./contract-rs`).

Navigate to the folder of the language you prefer, and then to the `01-basic-auction` folder.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

  ```bash
  git clone git@github.com:near-examples/auctions-tutorial.git

  cd contract-ts/01-basic-auction
  ```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

  ```bash
  git clone git@github.com:near-examples/auctions-tutorial.git

  cd contract-rs/01-basic-auction
  ```

  </TabItem>

</Tabs>


:::info Frontend

The repository also contains a frontend application that interacts with the contract. You can find it in the `frontends` folder. We will cover the frontend in a future section

:::

---

## The Contract's State

The contract allows users to place bids using $NEAR tokens and keeps track of the highest bidder. Lets start by looking at how we define the contract's state, this is, the data that the contract will store.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    <Github fname="contract.ts" language="javascript"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts#L4-L14"
      start="4" end="14" />

    #### Decorator
    The first thing to notice is that the main class of the contract is marked using the `@NearBindgen` decorator, which allows also to further specify that the contract **must be initialized** before being used.

    #### Storage (aka State)
    Another important information revealed by the code is that a contract can store different types of data, in this case:

    - `highest_bid` is an instance of a `Bid` which stores:
        - `bid`: a `BigInt` representing an amount of $NEAR tokens in `yoctonear` (`1‚ìÉ = 10^24 y‚ìÉ`)
        - `bidder`: an `AccountId` that represents which account placed the bid
    - `auction_end_time` a `BigInt` representing a `unix timestamp` in **nanoseconds**
    - `auctioneer` an `AccountId` that states who can withdraw the funds at the end of the auction
    - `claimed` a `boolean` that tracks if the auctioneer has claimed the funds

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="lib.rs" language="rust"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs#L5-L19"
        start="5" end="19" />

    #### Macros
    A first thing to notice is the use of the `#[near(contract_state)]` macro to denote the main structure and derive the `PanicOnDefault` to specify that the contract **must be initialized** before being used.

    We also use the `#[near(serializers = [json, borsh])]` macro to enable both `borsh` and `JSON` (de)serialization of the `Bid` structure. As a rule of thumb: use the `json` serializer for structs that will be used as input / output of functions, and `borsh` for those that will be saved to state.

    #### Storage (aka State)
    Another important information revealed by the code is that the contract can store different types of data.

    - `highest_bid` is an instance of a `Bid` which stores:
        - `bid`: a `NearToken` which simplifies handling $NEAR token amounts
        - `bidder`: the `AccountId` that placed the bid
    - `auction_end_time` is a `U64` representing a `unix timestamp` in **nanoseconds**
    - `auctioneer` an `AccountId` that states who can withdraw the funds at the end of the auction
    - `claimed` a `boolean` that tracks if the auctioneer has claimed the funds

  </TabItem>

</Tabs>


:::tip Learn More

You can read more about the contract's structure and the type of data it can store in the following documentation pages:
- [Basic Contract's Anatomy](../../2.build/2.smart-contracts/anatomy/anatomy.md)
- [Contract's State](../../2.build/2.smart-contracts/anatomy/storage.md)
- [Data Types](../../2.build/2.smart-contracts/anatomy/types.md)

:::

---

## Initialization Function

Lets now take a look at the initialization function, which we need to call to determine the time at which the auction will end.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    <Github fname="contract.ts" language="javascript"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts#L16-#L21"
      start="16" end="21" />

    #### Decorator
    We denote the initialization function using the `@initialize({ privateFunction: true })` decorator. The `privateFunction:true` denotes that the function can only be called by the account on which the contract is deployed.

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="lib.rs" language="rust"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs#L23-L35"
      start="23" end="35" />

    #### Macros
    We denote the initialization function using the `#[init]` macro. Notice that the initialization function needs to return an instance of `Self`, i.e. the contract's structure.

    Meanwhile, the `#[private]` denotes that the function can only be called by the account on which the contract is deployed.

  </TabItem>

</Tabs>

#### End Time
The end time is represented using a `unix timestamp` in **nano seconds**, and needs to be given as a `String` when calling the initialization function. This is because smart contracts cannot receive numbers larger than `52 bits` and `unix timestamps` are represented in `64 bits`.

#### Initial Bid
Notice that we initialize the contract with a `1 yoctonear` bid, made from the `current account id`. This means that, after the contract is initialized, the first bid will be placed by the contract at 10^-24 NEAR.

#### Claimed
The `claimed` field is initialized as `false`, as the auctioneer has not claimed the funds yet.

#### Auctioneer
The auctioneer is set by the deployer on initialization and is the account that will be able to claim the funds at the end of the auction.

:::tip Learn More

You can read more about the contract's interface in our [contract functions documentation](../../2.build/2.smart-contracts/anatomy/functions.md), and learn about data types on the [data types documentation](../../2.build/2.smart-contracts/anatomy/types.md).

:::

---

## Read-only Functions

The contract implements four functions to give access to its stored data, i.e. the highest bid so far (the amount and by whom), the time at which the auction ends, the auctioneer, and whether the auction has been claimed.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    <Github fname="contract.ts" language="javascript"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts#L53-L71"
      start="53" end="71" />

    Functions that do not change the contract's state (i.e. that only read from it) are called `view` functions, and are decorated using the `@view` decorator.

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="lib.rs" language="rust"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs#L78-L92"
      start="78" end="92" />

    Functions that do not change the contract's state (i.e. that only read from it) are called `view` functions and take a non-mutable reference to `self` (`&self`).

  </TabItem>

</Tabs>

View functions are **free to call**, and do **not require** a NEAR account to sign a transaction in order to call them.

:::tip Learn More

You can read more about the contract's interface in our [contract functions documentation](../../2.build/2.smart-contracts/anatomy/functions.md), and learn about data types on the [data types documentation](../../2.build/2.smart-contracts/anatomy/types.md).

:::


---

## Bidding Function

An auction is not an auction if you can't place a bid! For this, the contract includes a `bid` function, which users will call attaching some $NEAR tokens.

The function is quite simple: it verifies if the auction is still active and compares the attached deposit with the current highest bid. If the bid is higher, it updates the `highest_bid` and refunds the previous bidder.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    <Github fname="contract.ts" language="javascript"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts#L23-L43"
      start="23" end="43" />

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="lib.rs" language="rust"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs#L37-L63"
      start="37" end="63" />

  </TabItem>

</Tabs>

#### Payable Functions
The first thing to notice is that the function changes the state, and thus is marked with a `@call` decorator in JS, while taking as input a mutable reference to self (`&mut self`) on Rust. To call this function, a NEAR account needs to sign a transaction and expend GAS.

Second, the function is marked as `payable`, this is because by default **functions do not accept $NEAR tokens**! If a user attaches tokens while calling a function that is not marked as `payable`, the transaction will fail.

#### The Environment
Notice that the function can access information about the environment in which it is running, such as who called the function (`predecessor account`), how many tokens they attached as deposit (`attached deposit`), and the approximate `unix timestamp` at which the function is executing (`block timestamp`).

#### Token Transfer
The function finishes by creating a `Promise` to transfer tokens to the previous bidder. This token amount will be deducted immediately and transferred in the next block after the current function has finished executing.

Note that on the first bid, the contract will send 1 yoctonear to itself, this is fine as we can safely assume that the contract will have the lowest denomination of $NEAR available to send to itself.

<details>

<summary> Handling Funds </summary>

When a user attaches tokens to a call, the tokens are deposited to the contract's account before the function is executed. However, if the function raises an error during its execution, the tokens are immediately refunded to the user.

</details>

:::tip Learn More

You can read more about the environment variables, payable functions and which actions the contract can perform here:
- [Environment Variables](../../2.build/2.smart-contracts/anatomy/environment.md)
- [Payable Functions](../../2.build/2.smart-contracts/anatomy/functions.md)
- [Transfers and Actions](../../2.build/2.smart-contracts/anatomy/actions.md)

:::

---

## Claim function

You'll notice that the contract has a final function called `claim`, this allows the auctioneer to claim the funds from the contract at the end of the auction. Since, on NEAR, a smart contract account and user account are the same, contracts can still have keys when they are deployed, thus a user could just claim the funds from the contract via a wallet. However, this presents a security issue since by having a key the key holder can take the funds from the contract at any point, maliciously change the contract's state or just delete the contract as a whole. By implementing a `claim` function we can later lock the contract by removing all access keys and have the auctioneer claim the funds via preset conditions via code.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    <Github fname="contract.ts" language="javascript"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/src/contract.ts#L45-L51"
      start="45" end="51" />

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    <Github fname="lib.rs" language="rust"
      url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/src/lib.rs#L65-L76"
      start="65" end="76" />

  </TabItem>

</Tabs>

This function is quite simple it does four things:
1) Checks that the auction has ended (the current timestamp is past the auction end time).
2) Checks that the auction has not yet been claimed.
3) Sets the auction as now claimed.
4) And if these conditions hold true it transfers $NEAR equal to the highest bid to the auctioneer.

:::tip Learn More

You can read more about locking contracts in this section of the documentation: [locked accounts](../../1.concepts/protocol/access-keys.md#locked-accounts)

:::

---

## Conclusion

In this part of the tutorial, we've seen how a smart contract stores data, mutates the stored data, and views the data. In the [next part](./1.2-testing.md), we will cover how to test the contract, so we can ensure it works as expected before deploying it to `testnet`.

 This is the content for the doc docs/3.tutorials/auction/1.2-testing.md 

 ---
id: sandbox-testing
title: Sandbox Testing
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

In the previous section, we went through the contract's code, analyzing how it worked. Now, we need to test it and make sure it works as expected! For contracts, there are two types of testing you can do: unit testing and sandbox testing.

Here, we will focus on sandbox testing, as it enables one to deploy the contract in a realistic environment, allowing us to create multiple accounts and interact with the contract as if it was deployed on the blockchain.

:::info unit testing

Unit tests are built into the language and are used to test the contract functions individually. These tests work well when little context is required. However, they cannot test chain interactions - like sending accounts $NEAR tokens - since they need to be processed by the network.

:::

---

## Account Creation

The first thing our test does is to create multiple accounts with 10 $NEAR tokens each and deploy the contract to one of them.

<Tabs groupId="code-tabs">
    <TabItem value="js" label="üåê JavaScript">
        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L12-L23"
                start="12" end="23" />
        
        To deploy the contract, we pass the path to the compiled WASM contract as an argument to the test in `package.json`. Indeed, when executing `npm run test`, the command will first compile the contract and then run the tests.

    </TabItem>
    <TabItem value="rust" label="ü¶Ä Rust">
        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs#L17-l29"
                start="17" end="29" />

        Notice that the sandbox compiles the code itself, so we do not need to pre-compile the contract before running the tests.
    </TabItem>
</Tabs>

---

## Contract Initialization

To initialize, the contract's account calls itself, invoking the `init` function with an `end_time` set to 60 seconds in the future.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L26-L29"
                start="26" end="29" />

:::warning Time Units

The contract measures time in **nanoseconds**, for which we need to multiply the result of `Date.now()` (expressed in milliseconds) by `10^6`

:::

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs#L31-L38"
                start="31" end="38" />

:::warning Time Units

The contract measures time in **nanoseconds**, for which we need to multiply the result of `Utc::now().timestamp()` (expressed in seconds) by `10^9`

:::

    </TabItem>
</Tabs>

:::info Time is a String

Notice that the time is passed as a `String` to the contract, this is because smart contracts cannot receive numbers larger than `52 bits` and we want to pass a `unix timestamp` in **nanoseconds**

:::

---

## Bidding

Now that the contract is deployed and initialized, we can start bidding and checking if the contract behaves as expected.

We first make `alice` place a bid of 1 NEAR, and check that the contract correctly registers the bid. Then, we have `bob` place a bid of 2 NEAR, and check that the highest bid is updated, and that `alice` gets her NEAR refunded.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L46-L61"
                start="46" end="61" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs"
                start="42" end="74" />

    </TabItem>

</Tabs>

#### Checking the balance
It is important to notice how we check if `alice` was refunded. We query her balance after her first bid, and then check if it has increased by 1 NEAR after `bob` makes his bid. 

You might be tempted to check if `alice`'s balance is exactly 10 NEAR after she gets refunded, but `alice` balance cannot be 10 NEAR anymore, because some $NEAR was **consumed as `gas` fees** when `alice` called `bid`.

#### Testing invalid calls

When testing we should also check that the contract does not allow invalid calls. The next part checks that the contract doesn't allow for bids with fewer $NEAR tokens than the previous to be made.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L64"
                start="64" end="64" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs#L77-L83"
                start="77" end="83" />

    </TabItem>

</Tabs>

---

## Fast Forwarding Time
The sandbox allows us to fast-forward time, which is useful for testing the contract when the auction is over. The test advances 200 blocks in order to pass a minute, and thus allowing the auction to be claimed. 

After which the auction can now be claimed. Once claimed the test checks that the auctioneer has received the correct amount of $NEAR tokens.

<Tabs groupId="code-tabs">
    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/01-basic-auction/sandbox-test/main.ava.js#L69-L81"
                start="69" end="81" />

    </TabItem>
    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/01-basic-auction/tests/test_basics.rs#L95-L112"
                start="95" end="112" />

    </TabItem>
</Tabs>

If you review the tests in full you'll see that we also test other invalid calls such as the auctioneer trying to claim the auction before it is over and a user attempting to bid once the auction is over.

---

## Executing the tests 

Now that we understand what we are testing, let's go ahead and run the tests!


<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        ```bash
        # if you haven't already, install the dependencies
        npm install

        # run the tests
        npm run test 
        ```

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        ```bash
        cargo test
        ```

    </TabItem>

</Tabs>

All tests should pass, and you should see the output of the tests in the console. If you see any errors, please contact us in the [NEAR Discord](https://near.chat) or through [Telegram](https://t.me/neardev) and we'll help you out!

---

## Conclusion 

In this part of the tutorial, we've seen how to use our sandbox testing environment to test the contract. We've tested the contract's initialization, bidding, and time advancement.

You are now ready to move to the [next section](./1.3-deploy.md), where we will deploy the contract to `testnet` and interact with it through the CLI.

 This is the content for the doc docs/3.tutorials/auction/1.3-deploy.md 

 ---
id: deploy
title: Deploying to Testnet
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

In the previous sections, we saw how a simple auction smart contract is implemented, and checked its correctness using sandbox testing.

The time has come to release it on the actual blockchain and interact with it! In this section, we will show you how to create a simple testnet account, deploy the contract, and interact with it from the CLI.

:::info Networks

NEAR has two main networks for you to use: `testnet` and `mainnet`. The `testnet` network behaves exactly as the main network but uses test tokens with no real value

:::

---

## Testnet Account

To deploy a contract, you need a testnet account. If you don't have one, you can create one using the following command:

```bash
# create-account using near-cli (contractId has end with .testnet)
near create <contractId> --useFaucet
```

Replace `<contractId>` with the name you want to give to your account, and make sure it ends with `.testnet`.

The account will be created with **10 NEAR** (these are test tokens).

:::info Testnet Faucet

Notice that we are using the `--useFaucet` flag to automatically request test tokens from the NEAR faucet. 

The faucet is only available on the testnet network - which is the default network for the CLI

:::

---

## Deploying the Contract

To deploy the contract, you need to compile the contract code into WebAssembly (WASM) and then deploy it to the network

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

    ```bash
    # compile the contract
    npm run build

    # deploy the contract
    near deploy <contractId> ./build/auction-contract.wasm

    # initialize the contract, it finishes in 2 minutes
    TWO_MINUTES_FROM_NOW=$(date -v+2M +%s000000000)
    near call <contractId> init '{"end_time": "'$TWO_MINUTES_FROM_NOW'", "auctioneer": "<auctioneerId>"}' --accountId <contractId>
    ```

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

    ```bash
    # compile the contract using cargo-near
    cargo near build

    # deploy the contract
    near deploy <contractId> ./target/near/auction-contract.wasm

    # initialize the contract, it finishes in 2 minutes
    TWO_MINUTES_FROM_NOW=$(date -v+2M +%s000000000)
    near call <contractId> init '{"end_time": "'$TWO_MINUTES_FROM_NOW'", "auctioneer": "<auctioneerId>"}' --accountId <contractId>
    ```

    </TabItem>

</Tabs>

Replace `<auctioneerId>` with the name of another account, this should not be the same as the contract account as we intend on removing its keys.

---

## Locking the contract

As mentioned previously we should lock the account by removing the keys. This allows our users to interact with the contract without having to trust the account owner.

```bash
near account delete-keys 
```

Next, specify the contract account and click the right arrow ‚Üí to delete all the keys. Make sure you select testnet. 

:::caution
Be extra careful to delete the keys from the correct account as you'll never be able to access the account again!
:::


Now that the contract is deployed, initialized, and locked we can send transactions to it using the CLI. 

:::tip Interactive CLI
NEAR's CLI is interactive meaning you can type `near` and click through all the possible options without having to remember certain commands
:::

---

## Interacting with the Contract
We are now ready to start bidding by calling the `bid` function on the contract. We recommend that you create **two new accounts** to simulate different bidders.

```bash
# call the contract to bid 
near call <contractId> bid --accountId <bidderId> --deposit 1 

# get the highest bid
near view <contractId> get_highest_bid
```

Notice that we call the `bid` function without arguments, but attach 1 NEAR to the transaction. This is the amount we are bidding.

For the `get_highest_bid` function, we don't need to specify which user is calling it, as it is a view function and does not require gas to be executed.

---

## Conclusion 

We have now seen how to deploy a contract to `testnet` and interact with it using the NEAR CLI.

A word of advice before moving forward. When people learn how to use the CLI, they get lazy and start testing new contract features directly on the testnet. While this is tempting, it is not recommended.

Do not use testnet as your **only way** to test contracts. Always test your contracts on the **sandbox environment first**, and only deploy to the testnet when you are confident that everything is working as expected.

:::tip Frontend

Generally, you will use the CLI only to deploy and initialize the contract. Afterward, all interactions will be made from a frontend. This is why in the [next section](./2.1-frontend.md) we'll move on to creating a frontend to interact with the contract.

:::


 This is the content for the doc docs/3.tutorials/auction/2.1-frontend.md 

 ---
id: creating-a-frontend
title: Creating a Frontend
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

Now that we have successfully created a contract, it's time to build a frontend to provide a user-friendly interface for interacting with it. Up until now, we have been using the CLI to send transactions and view the contract's state. However, frontends offer a more intuitive way for end users to interact with the contract. They can display all the relevant information in one place, allow users to make calls with a simple button click, and only require a wallet as a prerequisite.

---

## Frontend structure

Navigate to the auction frontend.

```bash
cd frotends/01-frontend
```

Here we have a simple Next.js frontend that we'll walk through to understand the basics of creating a frontend for a NEAR smart contract.

For starters, let's take a look at how the code in the frontend is structured by doing a quick overview of the important files.

| File                             | Description                                                                     |
|----------------------------------|---------------------------------------------------------------------------------|
| **_app.js**           | Responsible for rending the page, initiates the wallet object and adds it to global context  |
| **index.js**          | The main page where the project's components are loaded into and contains most of the logic for the application like viewing the state of the contract and logic for placing a bid |
| **near.js**           | Contains the wallet class that has methods to interact with the wallet and blockchain |
| **context.js**        | Holds the global context - the wallet object and the signed-in account ID - that can be accessed anywhere |
| **config.js**         | Specifies the account ID of the auction contract |
| **Navigation.jsx**    | A component that contains a button to sign users in and out of wallets |
| **Bid.jsx**           | A component allowing a user to make a bid |
| **LastBid.jsx**       | A component that displays the highest bid and when the highest bid will next refresh |
| **Timer.jsx**         | A component that shows how long till the auction is over, or, if over, displays a button to claim the auction and then states the auction is over 

---

## Specifying the contract

We have a config file that specifies the contract name of the auction that the frontend will interact with. There has been an example auction contract deployed and specified already but feel free to change the contract to your own auction contract you deployed.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="config.js"
            url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/config.js"
            />
</Language>

---

## Setting up wallets

To be able to fully interact with the contract - send bids and claim the auction - you'll need a `wallet` to sign transactions. Wallets securely store your private keys and allow you to sign transactions without exposing your private key to the frontend. The wallet selector allows users to choose between a selection of wallets.

We abstract the wallet selector in our `near.js` file by exposing methods to complete various tasks. Feel free to [explore the file](https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/wallets/near.js) to understand fully how the wallet selector is implemented. 

The wallet object is initiated in the `app.js` file and its added to the global context along with the account that is signed in to make it easier to access anywhere in the application.

<Language value="javascript" language="javascript">
    <Github fname="_app.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/_app.js#L13-L27"
        start="13" end="27" />
    <Github fname="context.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/context.js"
        />
</Language>

:::tip Access keys

On NEAR, in additional to normal full access keys, we have `function-call access keys` that are given to applications to allow them to sign `non-payable` transactions on behalf of the user. This is so the wallet doesn't have to pop up for each non-critical transaction, improving the user experience. When creating the wallet object you can decide to create an access key for the application to use. However, in this example we opt out since the main function - `bid` - we'll be calling is `payable`.

You can read further about NEAR's key model [here](../../1.concepts/protocol/access-keys.md).

:::

We add a sign-in and sign-out button in the `navigation` component to call the respective methods in the `near.js` file.

<Language value="javascript" language="javascript">
    <Github fname="Navigation.jsx" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/components/Navigation.jsx"
        />
    <Github fname="near.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/wallets/near.js#L58-L72"
        start="58" end="72" />
</Language>

---

## Displaying the highest bid

To get the highest bid from the auction and who made it we call `get_highest_bid`. Since this function returns the highest bid in `yoctoNEAR` we divide by `10^24` to get the amount in NEAR. 

<Language value="javascript" language="javascript">
    <Github fname="index.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/index.js#L24-L29"
        start="24" end="29" />
    <Github fname="near.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/wallets/near.js#L82-L94"
        start="82" end="94" />
</Language>

In the wallet file, you'll see that we make a query to the RPC provider, since we are not signing a transaction the wallet isn't required here. Here we are using https://rpc.testnet.near.org but note there are [many different providers available](../../5.api/rpc/providers.md). We are querying the RPC with optimistic finality, which queries the latest block recorded on the node. Alternatively, one could use final finality where the block has been validated by at least 66% of the validators on the network but this will provide slightly delayed information (only by a couple of seconds).

We then pass the information about the highest bidder into the `LastBid` component to display the bid amount and the bidder's account Id.

<Language value="javascript" language="javascript">
    <Github fname="index.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/index.js#L101"
        start="101" end="101" />
    <Github fname="LastBid.jsx" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/components/LastBid.jsx"
        />
</Language>

---

## Updating the highest bid

We want to know the highest bid at all times, someone else could have placed a higher bid since the page was loaded. To solve this we fetch the contract information every 20 seconds using `setInterval` and update the highest bid if it has changed. In reality you would want to refresh the bid amount more requently but for the sake of saving on RPC calls we are doing it every 20 seconds.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="index.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/index.js#L47-L60"
        start="47" end="60" />
</Language>

---

## Auction end time

The contract stores the end time of the auction in the number of nanoseconds since the Unix epoch (1 January 1970 00:00:00 UTC). In our frontend we will display the time left in days, hours, minutes, and seconds.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="Timer.jsx" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/components/Timer.jsx#L11-L35"
        start="11" end="35" />
</Language>

---

## Making a bid

To make a bid we make a call to the contract using the `bid` function. We specify the deposit amount in `yoctoNEAR` which will be the bid amount. The input box will take the bid amount in NEAR so we multiply by `10^24` to get the correct amount to send. We also specify the amount of gas to attach to the transaction, here we are attaching 30Tgas which is more than enough for the transaction to go through, we are refunded any unused gas anyway.

Here, since the user is changing the state of the contract, not just viewing it, the user needs to sign the transaction. Thus the wallet will pop up displaying the transaction details.

<Language value="javascript" language="javascript">
    <Github fname="index.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/index.js#L95-L105"
        start="95" end="105" />
    <Github fname="near.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/wallets/near.js#L107-L126"
        start="107" end="126"/>
</Language>

---

## Claiming the auction

Once the auction is over (the current time is greater than the end time) the auction can be claimed. At this point, the timer will be hidden and a button to claim the auction will be displayed. Once clicked the `claim` function will be called on the auction contract to send the highest bidder the NFT and the auctioneer the FTs.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="index.js" 
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/index.js#L75-L82"
        start="75" end="82" />
</Language>

---

## Conclusion

In this part of the tutorial, we have implemented a simple frontend for a NEAR contract. Along the way, you have learned how to use the wallet selector to sign the user in and out, how to view the contract‚Äôs state, how to sign and send transactions.

While we can see the highest bid, we may want to see the auction's bidding history. Since the contract only stores the most recent bid (to reduce storage costs), we need to use an indexer to pull historical data. In the [next part](./2.2-indexing.md) of the tutorial, we'll look at querying historical data using an API endpoint.


 This is the content for the doc docs/3.tutorials/auction/2.2-indexing.md 

 ---
id: indexing-historical-data
title: Indexing Historical Data
---

import {Github, Language} from "@site/src/components/codetabs"

In our frontend, we can easily display the previous bid since it's stored in the contract's state. However, we're unable to see previous bids to the auction. An indexer is used to fetch historical data from the blockchain and store it in a database. Since indexers can take a while to set up and can be expensive to run, we will use a pre-defined API endpoint provided by NEAR Blocks to query an indexer they run that will fetch us the data we need.

---

## NEAR Blocks API key

NEAR Blocks provides a free tier that allows you to make 6 calls per minute, which will be plenty for our use case. To get an API key, head over to https://dash.nearblocks.io/user/overview and sign up. Once signed go to `API Keys` then click `Add key` and give it whatever name you like.

We'll create a new file named `.env.local` to store our API key.

```env
API_KEY=YOUR_API_KEY_GOES_HERE
```

We put the API key in a `.env.local` file so the user cannot access it in the browser and use our key elsewhere. We should also add `.env.local` to our `.gitignore` file so it is not pushed to GitHub.

---

## Calling the API endpoint

NextJS allows us to easily create server-side functions with API routes. We need to make this API call on the server-side rather than the client side so as to not expose our API key. We'll create a new file in src/pages/api named `getBidHistory.js`. Here we'll define our function to get the bid history.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="getBidHistory.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/api/getBidHistory.js#L1-L13"
        start="3" end="13" />
</Language>

Here we are retrieving the auction contract ID from the API route call and then calling the NEAR Blocks API. This specific API endpoint allows us to retrieve transactions made to a specific contract calling a specific function. Some details are worth discussing here:

- We pass the account ID of the auction contract, which is `basic-auction-example.testnet` in the example repo.
- We specify the function name on the auction contract that we want the transactions for, in our case it will be `bid`
- We'll receive a JSON object of up to 25 transactions, ordered by the most recent first.
- We pass our API key to authenticate the request.

---

## Retrieving the bids from the API result

From our API call, we receive a JSON object containing up to 25 transactions made to the bid function on the auction contract.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="getBidHistory.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/api/getBidHistory.js#L15-L37"
        start="15" end="37" />
</Language>

We want to display the 5 most recent valid bids. To do this we loop through each transaction and check whether the transaction was successful by checking `receipt_outcome.status` is `true`. If so we check the first action (since there should only be one function call action in this case) and store the `deposit`, which is equal to the bid amount, and store the `predecessor account ID`, which is the account ID of the bidder.

Once we have 5 valid bids we can stop looping through the transactions.

Note that in our example if the previous 25 bids were invalid the API will return an empty array. The function could be set up such that it calls the API again to get the new page of transactions if this is the case.


:::tip Learn More

You can read more about transaction actions in this section of the documentation: [Actions](/concepts/protocol/transaction-anatomy#actions)

:::

---

## Using the API Route

In our main page, we'll define a function to call the API route we just created. This function will be called each time the page timer reaches zero.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="getBidHistory.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/01-frontend/src/pages/index.js#L84-L92"
        start="84" end="92" />
</Language>

The `pastBids` will then be passed into the `Bid` component to be displayed.

---

You may like to explore NEAR Blocks APIs further to see what other data you can retrieve from the blockchain. You can find the documentation at https://api.nearblocks.io/api-docs/

---

## Using the frontend

Now we have implemented the frontend and indexer you can go ahead and actually use the frontend. From the root of the frontend directory run the following commands:

```bash
# install dependencies
npm install

# run the frontend locally
npm run dev
```

---

## Conclusion

In this short part of the tutorial, we've added the ability to display the previous 5 valid bids made to the auction contract. In doing this we learned how to interact with the NEAR Blocks APIs to retrieve historical data from the blockchain and how to make server-side calls in NextJS to not expose our API key. Now we have a pretty good frontend that displays all the information we need about the auction contract.

In the [next section of the tutorial](./3.1-nft.md) we're going to improve our contract by adding primitives to the auction contract starting with adding NFTs as a prize.


 This is the content for the doc docs/3.tutorials/auction/3.1-nft.md 

 ---
id: winning-an-nft
title: Winning an NFT
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

No one will enter an auction if there's nothing to win, so let's add a prize. Why not an [NFT](../../2.build/5.primitives/nft.md)? NFTs are uniquely identifiable, easily swappable and their logic comes from an external contract so the prize will exist without the auction contract. Let's get to work!

---

## Listing the NFT

When we create an auction we need to list the NFT. To specify which NFT is being auctioned off we need the account ID of the NFT contract and the token ID of the NFT. We will specify these when the contract is initialized; amend `init` to add `nft_contract` and `token_id` as such:  

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/02-winner-gets-nft/src/contract.ts#L22-L28"
                start="22" end="28" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/src/lib.rs#L32-L49"
                start="32" end="49" />

        Note that `token_id` is of type `TokenId` which is a String type alias that the NFT standards use for future-proofing.

    </TabItem>

</Tabs>

---

## Transferring the NFT to the winner

When the method `claim` is called the NFT needs to be transferred to the highest bidder. Operations regarding NFTs live on the NFT contract, so we make a cross-contract call to the NFT contract telling it to swap the owner of the NFT to the highest bidder. The method on the NFT contract to do this is `nft_transfer`.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="contract.ts" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/02-winner-gets-nft/src/contract.ts#L58-L60"
                start="58" end="60" />

        In near-sdk-js we cannot transfer the NFT and send the $NEAR independently so we will chain the promises.

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        We will create a new file in our source folder named `ext.rs`; here we are going to define the interface for the `nft_transfer` method. We define this interface as a `trait` and use the `ext_contract` macro to convert the NFT trait into a module with the method `nft_transfer`. Defining external methods in a separate file helps improve the readability of our code. 
        
        We then use this method in our `lib.rs` file to transfer the NFT.

        <Language value="rust" language="rust">
            <Github fname="lib.rs" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/src/lib.rs#L93-L96"
                start="93" end="96" />
            <Github fname="ext.rs" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/src/ext.rs"
                start="2" end="10" />
        </Language>

    </TabItem>

</Tabs>

When calling this method we specify the NFT contract name, that we are attaching 30 Tgas to the call, that we are attaching a deposit of 1 YoctoNEAR to the call, and give the arguments `receiver_id` and `token_id`. The NFT requires that we attach 1 YoctoNEAR for [security reasons](../../2.build/2.smart-contracts/security/one_yocto.md).

---

## NFT ownership problems

In our contract, we perform no checks to verify whether the contract actually owns the specified NFT. A bad actor could set up an auction where the NFT being auctioned doesn't belong to the auction contract, causing `nft_transfer` to fail and the winning bidder to lose their bid funds with nothing in return. We could make a cross-contract call to the NFT contract to verify ownership on initialization but this would become quite complex. Instead, we will do this check off-chain and validate the auction in the frontend. 

---

## Displaying the contract object

Since we are now dealing with more information in our contract, instead of implementing a function to display each field we'll create a function to display the entire contract object. Since the contract doesn't include large complex data structures like a map displaying the contract state in its entirety is easily done.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/02-winner-gets-nft/src/contract.ts#L73-L76"
                start="73" end="76" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/src/lib.rs#L17-L26"
                start="17" end="26" />

        We add the `serilizers` macro to enable json serialization so the object as a whole can easily be displayed to the frontend without having to output each field individually.

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/src/lib.rs#L107-L109"
                start="107" end="109" />


    </TabItem>

</Tabs>


## Testing with multiple contracts

In our tests, we're now going to be using two contracts; the auction contract and an NFT contract. Sandbox testing is great as it allows us to test multiple contracts in a realistic environment.

In our tests folder, we need the WASM for an NFT contract. For this tutorial, we compiled an example NFT contract from [this repo](https://github.com/near-examples/NFT/tree/master).

To deploy the NFT contract, this time we're going to use `dev deploy` which creates an account with a random ID and deploys the contract to it by specifying the path to the WASM file. After deploying we will initialize the contract with default metadata and specify an account ID which will be the owner of the NFT contract (though the owner of the NFT contract is irrelevant in this example). Default metadata sets information such as the name and symbol of the NFT contract to default values.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/02-winner-gets-nft/sandbox-test/main.ava.js#L24-L25"
                start="24" end="25" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/tests/test_basics.rs#L30-L39"
                start="30" end="39" />

    </TabItem>

</Tabs>

---

## Minting an NFT

To start a proper auction the auction contract should own an NFT. To do this the auction account calls the NFT contract to mint a new NFT providing information such as the image for the NFT.  

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/02-winner-gets-nft/sandbox-test/main.ava.js#L28-L39"
                start="28" end="39" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/tests/test_basics.rs#L42-L60"
                start="42" end="60" />

    </TabItem>

</Tabs>

---

## Verifying ownership of an NFT

After `claim` is called, the test should verify that the auction winner now owns the NFT. This is done by calling `nft_token` on the NFT contract and specifying the token ID which will return the account ID that the token belongs to.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/02-winner-gets-nft/sandbox-test/main.ava.js#L105-L106"
                start="105" end="106" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/02-winner-gets-nft/tests/test_basics.rs#L151-L164"
                start="151" end="164" />

    </TabItem>

</Tabs>

---

## Getting an NFT

If you would like to interact with the new contract via the CLI you can mint an NFT from a pre-deployed NFT contract 

```bash
near call nft.examples.testnet nft_mint '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "<accountId>", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' --accountId <accountId> --deposit 0.1 
```

You can also just buy an NFT with testnet $NEAR on a testnet marketplace like [Mintbase](https://testnet.mintbase.xyz/explore/new/0).

---

## Conclusion 

In this part of the tutorial we have added NFTs as a reward which has taught us how to interact with NFT standards, make cross-contract calls and test multiple contracts that interact with each other in workspaces. In the [next part](./3.2-ft.md) we'll learn how to interact with fungible token standards by adapting the auction to receive bids in FTs. This will allow users to launch auctions in different tokens, including stablecoins. 

 This is the content for the doc docs/3.tutorials/auction/3.2-ft.md 

 ---
id: bidding-with-fts
title: Bidding with FTs
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

To further develop this contract we will introduce another primitive: [fungible tokens](../../2.build/5.primitives/ft.md). Instead of placing bids in $NEAR tokens, they will be placed in FTs. This may be useful if, for example, an auctioneer wants to keep the bid amounts constant in terms of dollars as an auction is carried out, so bids can be placed in stablecoins such as $USDC. Another use case is if a project like Ref Finance was holding its own auction and wanted the auction to happen in its project's token $REF.

---

## Specifying the FT contract 

We want to only accept bids in one type of fungible token; accepting many different FTs would make the value of each bid difficult to compare. We're also going to adjust the contract so that the auctioneer can specify a starting bid amount for the auction.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="contract.ts" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L23-L30"
                start="23" end="30" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L33-L53"
                start="33" end="53" />

    </TabItem>

</Tabs>

---

## Accepting bids in FTs

When we were making bids in $NEAR tokens we would call the auction contract directly and attach $NEAR tokens to the call. With fungible tokens, since an account's balance lives on a separate contract, we call the FT contract which then calls the auction contract and transfers tokens. The method on the FT contract to do this is named `ft_transfer_call` and it will always call a method in the target contract named `ft_on_transfer`. Take a look [here](../../2.build/5.primitives/ft.md#attaching-fts-to-a-call) for more information. 

![ft_transfer_call-flow](/docs/assets/auction/auction-ft-transfer.png)

The `ft_on_transfer` method always has the same interface; the FT contract will pass it the `sender`, the `amount` of FTs being sent and a `msg` which can be empty (which it will be here) or it can contain some information needed by the method (if you want to send multiple arguments in msg it is best practice to deliver this in JSON then parse it in the contract). The method returns the number of tokens to refund the user, in our case we will use all the tokens attached to the call for the bid unless the contract panics in which case the user will automatically be refunded their FTs in full.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="contract.ts" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L33"
                start="33" end="33" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L56"
                start="56" end="56" />

    </TabItem>

</Tabs>


We need to confirm that the user is attaching fungible tokens when calling the method and that they are using the right FT, this is done by checking the predecessor's account ID. Since it's the FT contract that directly calls the auction contract, the `predecessor` is now the account ID of the FT contract.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="contract.ts" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L38"
                start="38" end="38" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L62-L63"
                start="62" end="63" />

    </TabItem>

</Tabs>

The bidder's account ID is now given by the argument `sender_id` and the bid amount is passed as an argument named `amount`.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="contract.ts" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L40-L43"
                start="40" end="43" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L75-L78"
                start="75" end="78" />

    </TabItem>

</Tabs>

When we want to return the funds to the previous bidder we now make a cross-contract call to the FT contract. 

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Language value="javascript" language="javascript">
            <Github fname="call" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L45-L51"
                start="45" end="51" />
            <Github fname="callback" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L78-L81"
                start="68" end="71" />
        </Language>

        In JavaScript, we have to return the Promise to transfer the FTs but we also need to return how much to refund the user. So after transferring the FTs, we make a `callback` to our own contract to resume the contract flow. Note that the callback is private so it can only be called by the contract. We return 0 because the method uses all the FTs in the call.

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Language value="rust" language="rust">
            <Github fname="lib.rs" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L81-L84"
                start="81" end="84" />
            <Github fname="ext.rs" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/ext.rs#L8-L11"
                start="8" end="11" />
        </Language>

         We then return 0 because the method uses all the FTs in the call.

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L86"
                start="86" end="86" />

    </TabItem>

</Tabs>

    If the call was to fail the FT contract will automatically refund the user their FTs.

<details> 
        
    <summary> What happens if the cross-contract call fails? </summary>

    The first time this method is called the contract will try to send itself FTs. Most fungible token contracts don't allow one to send themselves FTs so the cross-contract call will fail. However, since cross-contract calls are asynchronous and independent and we are not checking the result of the call then the auction contract does not care that the call failed and ft_on_transfer will complete successfully.

    In the other cases, the call to the fungible token contract could only fail if the receiver does not exist, the FT contract does not exist, the auction contract doesn't have enough fungible tokens to cover the amount being sent, or the receiver is not registered in the FT contract. Our contract is set up such that these errors cannot occur, the receiver must exist since they placed the previous bid, the FT contract exists since it was used to place the bid, the auction contract has enough FTs to cover the amount since it was sent that amount by the previous bid, and the receiver must be registered in the FT contract since they needed to have held the token in the first place to make a bid.

</details>  

---

## Claiming the FTs

When the auction is complete we need to send the fungible tokens to the auctioneer when we send the NFT to the highest bidder, we implement a similar call as when we were returning the funds just changing the arguments.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="contract.ts" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/src/contract.ts#L61-L65"
                start="61" end="65" />

        In JavaScript, since we need to return each cross-contract call we chain the NFT and FT transfer.

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="lib.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/src/lib.rs#L99-L109"
                start="99" end="109" />

    </TabItem>

</Tabs>

---

## Creating a new FT

Just as with the NFT contract, we will deploy an FT contract in the sandbox tests using a WASM file compiled from [this repo](https://github.com/near-examples/FT).

When the contract is deployed it is initialized with `new_default_meta` which sets the token's metadata, including things like its name and symbol, to default values while requiring the owner (where the token supply will sent), and the total supply of the token.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/sandbox-test/main.ava.js#L28-L29"
                start="28" end="29" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L33-L46"
                start="33" end="46" />

    </TabItem>

</Tabs>

---

## Registering users in the FT contract

For one to receive fungible tokens, first their account ID must be [registered](../../2.build/5.primitives/ft.md#registering-a-user) in the FT contract. A user has to register in an FT contract to pay for the storage used to track their amount of tokens. By default, a contract pays for its own storage, but not requiring a user to register and pay for storage would drain the contract of $NEAR tokens. When the contract is live we don't need to register the accounts that we transfer tokens back to since to make a bid in the first place they would have needed to be registered, but we do need to register the auction contract in the FT contract to receive bids and the auctioneer to receive the funds at the end of the auction. It is most convenient to register users from the frontend rather than the contract.

In our tests, since we are creating a new fungible token and new accounts we will actually have to register every account that will interact with FTs.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/sandbox-test/main.ava.js#L50-L53"
                start="50" end="53" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L81-L97"
                start="81" end="97" />

    </TabItem>

</Tabs>

---

## Simple FT transfer to bidders

Then we will transfer the bidders FTs so they can use them to bid. A simple transfer of FTs is done using the method `ft_transfer` on the FT contract.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/sandbox-test/main.ava.js#L56-L57"
                start="56" end="57" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Language value="rust" language="rust">
            <Github fname="Call ft_transfer" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L100-L107"
                start="100" end="107" />
            <Github fname="ft_transfer definition" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L291-L307"
                start="291" end="307" />
        </Language>

    </TabItem>

</Tabs>

---

## FT transfer call

As stated previously, to bid on the auction the bidder now calls `ft_transfer_call` on the FT contract which subsequently calls the auction contract's `ft_on_transfer` method with fungible tokens attached.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/sandbox-test/main.ava.js#L101-L104"
                start="101" end="104" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Language value="rust" language="rust">
            <Github fname="Call ft_transfer_call" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L149-L161"
                start="149" end="161" />
            <Github fname="ft_transfer_call definition" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L322-L337"
                start="322" end="337" />
        </Language>

    </TabItem>

</Tabs>

---

## Checking users' FT balance

Previously, to check a user's $NEAR balance, we pulled the details from their account. Now we are using FTs we query the balance on the FT contract using `ft_balance_of`, let's check that the contract's balance increased by the bid amount and the user's balance decreased by the bid amount.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/sandbox-test/main.ava.js#L106-L109"
                start="106" end="109" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Language value="rust" language="rust">
            <Github fname="Call ft_balance_of" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L163-L166"
                start="163" end="166" />
            <Github fname="ft_balance_of definition" 
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L309-L320"
                start="309" end="320" />
        </Language>

    </TabItem>

</Tabs>

---

## Invalid FT transfer call

If we make a lower bid than the previous this will cause the auction contract to panic. One might expect that `ft_transfer_call` will fail, but it does not. `ft_on_transfer` will fail and the FT contract will recognize this and reverse the transfer of tokens. So after making an invalid bid, we should check that the call was successful but the parties involved in the transaction (the bidder and the contract) have the same balance of fungible tokens as they did before the call.

Previous to this, Bob made a bid of 60,000 and Alice was returned her bid bringing her balance back up to 150,000. Now when Alice makes an invalid of 50,000 Alice's balance should remain at 150,000 and the contract should remain at a balance of 60,000.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        <Github fname="main.ava.js" language="javascript"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-ts/03-bid-with-fts/sandbox-test/main.ava.js#L122-L130"
                start="122" end="130" />

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        <Github fname="test_basics.rs" language="rust"
                url="https://github.com/near-examples/auctions-tutorial/blob/main/contract-rs/03-bid-with-fts/tests/test_basics.rs#L190-L207"
                start="190" end="207" />

    </TabItem>

</Tabs>

---

## Using FTs with the CLI

If you want to interact with the auction contract you're going to need FTs. For this example, we'll use $DAI where the contract address is `dai.fakes.testnet`. One can easily acquire FTs through the [testnet faucet](https://near-faucet.io/). Select DAI and withdraw to the account you will use to place a bid. If you take a look at the transaction details you can see that the faucet registers your account in the FT contract and then sends you DAI from the faucet account.

When deploying the contract make sure to specify the FT contract `dai.fakes.testnet`.

The auction contract will need to be registered as well, you could do this by sending it an arbitrary amount of $DAI from the faucet or you can just register it since it doesn't need any FTs. You should also register the auctioneer,

```bash
near call dai.fakes.testnet storage_deposit '{"account_id": "<auctionContractId>"}' --accountId <accountId> --deposit 0.1
```

Now you can go ahead and place a bid. DAI has 18 decimals meaning that 1 $DAI is made up of 10^24 smallest units. To make a bid of 2 $DAI you can use the command:

```bash
near call dai.fakes.testnet ft_transfer_call '{"receiver_id": "<auctionContractId>", "amount": "2000000000000000000", "msg": ""}' --accountId <bidderId> --depositYocto 1
```

## Auction architecture 

When creating an application there are numerous ways to structure it. Here, we have one contract per auction meaning we have to deploy a new contract each time we want to host an auction. To make this easier we will leverage a factory contract to deploy auction contracts for an auctioneer. Deploying code for each auction gets expensive, with 100kb of storage costing 1 $NEAR, since each auction stores all the same type of information and implements the same methods one could instead decide to have multiple auctions per contract. 

In such case, the Contract struct would be a map of auctions. We would implement a method to create a new auction by adding an entry to the map with the specific details of that individual auction.

<Tabs groupId="code-tabs">

    <TabItem value="js" label="üåê JavaScript">

        ```javascript
        class Contract {
            auctions: UnorderedMap<string, Auction>
        ```

    </TabItem>

    <TabItem value="rust" label="ü¶Ä Rust">

        ```rust 
        pub struct Contract {
            auctions: IterableMap<String, Auction>
        ```

    </TabItem>

</Tabs>

However, this architecture could be deemed less secure since if a bad actor were to gain access to the contract they would have access to every auction instead of just one.

--- 

## Conclusion

In this section, you learned a lot about fungible tokens: how to send and receive FTs in a smart contract, and then in sandbox tests how to deploy and initialize an FT contract, how to register a user in an FT contract, and send them some tokens, how to attach FTs to a smart contract call and finally how to view the FT balance of a user. With that, we now have our completed auction smart contract!  

Taking a further step back we've taken a very simple auction contract and transformed it into a more production contract with thorough testing. To improve the auction we learned how to add a prize by introducing NFTs, and enabled auctioneers to host auctions with FTs.

In the [next part of the tutorial](./3.3-new-frontend.md), we're going to update the frontend to interact with the new features of the contract.

 This is the content for the doc docs/3.tutorials/auction/3.3-new-frontend.md 

 ---
id: updating-the-frontend
title: Updating the Frontend
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

Now we've updated the contract to include an NFT as a reward and changed the contract such that it accepts bids in fungible tokens, we need to update the frontend accordingly.

## Getting the data from the contract

Now we have a function to output the whole contract state we will call this function in our frontend 

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="index.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/pages/index.js#L28-L35"
        start="28" end="35" />
</Language>

This call will deliver us the contract Ids of the FT and NFT contracts along with the token Id of the NFT. We will then use this information to call the `ft_metadata` and `nft_token` methods on the FT and NFT contracts respectively to get information about the FT and NFT.

---

## Displaying the NFT

We want to show what NFT is being auctioned. To do this we will call `nft_token` on the NFT contract to get the NFT metadata. To call this method we need to specify the NFT `contractId` and the `token_id`, which can be found in the auction information. `nft_token` also returns the owner of the NFT, so we'll check this against the contract account to verify that the auction is valid.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="index.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/pages/index.js#L57-L73"
        start="57" end="73" />
</Language>

Note that this effect will only run once the `auctionInfo` updates because we first need the NFT contract ID and token ID from `auctionInfo` to make a valid call to `nft_token`.

In a new component named `AuctionItem` we display the NFT image, name, and description.

<Language value="javascript" language="javascript" showSingleFName={true}>
<Github fname="AuctionItem.jsx"
    url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/components/AuctionItem.jsx"
    />
</Language>

Note that an image caching service is used to display the NFT image for better performance.

---

## Fetching FT information

Using the FT contract ID from the auction information, we can call the `ft_metadata` method on the FT contract to get information about the fungible token that is being used for the auction.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="index.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/pages/index.js#L75-L93"
        start="75" end="93" />
</Language>

We set the FT image, symbol, icon, and decimals in state. We use the decimals to format the amount of tokens being bid. In the case of DAI it divides the amount by 10^18. The reverse process is used when making a bid, the bid amount is multiplied by 10^18 before being sent to the contract.

---

## Bidding with FTs

Instead of calling the function `bid` on the contract we now call the `ft_transfer_call` function on the FT contract. This function transfers the FTs to the auction contract and calls the `ft_on_transfer` on the auction contract. 

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="index.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/pages/index.js#L95-L105"
        start="95" end="105" />
</Language>

---

## Updating the indexing API call

We need to update the API call that fetches historical bids to now index each time `ft_on_transfer` is called on the auction contract from the FT contract. 

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="getBidHistory.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/pages/api/getBidHistory.js#L1-L13"
        start="1" end="13" />
</Language>

And now instead of getting the bid amount from the deposit, it is now retrieved from the calls argument, from `amount`. The case is the same for the account Id of the bidder, from `sender_id`.

<Language value="javascript" language="javascript" showSingleFName={true}>
    <Github fname="getBidHistory.js"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/frontends/03-frontend/src/pages/api/getBidHistory.js#L24-L28"
        start="24" end="28" />
</Language>

---

## Conclusion

Ok nice, that didn't take too long. To look back, we updated the frontend to now display the NFT being auctioned, to display bid amounts - both the current and historical bids - in terms of the FT being used, and changed the bidding process to now use FTs. 

In the [final section](./4-factory.md) of this mega tutorial we'll create an auction factory contract that is used to deploy and initialize new auction contracts.


 This is the content for the doc docs/3.tutorials/auction/4-factory.md 

 ---
id: auction-factory
title: Auction factory
sidebar_label: Auction Factory
---

import {Github, Language} from "@site/src/components/codetabs"

Since an auction contract hosts a single auction, each time you would like to host a new auction you will need to deploy a new contract. Rather than finding the compiled WASM file, creating a new account, deploying the contract, and then initializing it each time, you can use a factory contract to do this for you.

Luckily for us, there is already a [factory contract example](https://github.com/near-examples/factory-rust)! We will fork this example and slightly modify it to suit our use case. If you would like to learn more about how the factory contract works, you can take a look at the [associated documentation](https://docs.near.org/tutorials/examples/factory#generic-factory).

The factory example only comes in rust since, currently, the JavaScript SDK does not allow you to embed the WASM file in the contract. This is a limitation of the SDK and not the blockchain itself.

---

## Changing the default contract

In the current example, the factory contract deploys the donation contract example. We will change this to deploy our auction contract instead. 

Firstly, we'll need the compiled auction contract WASM file. You can get this by running the following command in [03-bid-with-fts](https://github.com/near-examples/auctions-tutorial/tree/reorg-auction/contract-rs/03-bid-with-fts) of `contract-rs`

```bash
cargo near build 
```

You will find the resulting WASM file in `target/near`; copy this file and use it to replace the WASM of the donation contract in the factory contract's source folder. Now edit the auction contract changing the path to the auction contract.

<Language value="rust" language="rust">
    <Github fname="Default init" 
            url="https://github.com/near-examples/auctions-tutorial/blob/main/factory/src/lib.rs#L25-L31"
            start="25" end="31" />
    <Github fname="Contract path" 
            url="https://github.com/near-examples/auctions-tutorial/blob/main/factory/src/lib.rs#L9"
            start="9" end="9" />
</Language>

On initialization, the factory will add the auction contracts WASM, as bytes, to the factory's state. It is more efficient to not store the WASM in the factory's state, however, we may want to update the auction contract if we find a bug or want to add new features. The factory implements a method to update the auction contract - we'll change the name to `update_auction_contract` as this factory will only deploy auction contracts.

<Github fname="Contract path" language="rust"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/factory/src/manager.rs#L8-L13"
        start="8" end="13" />

---

## Modifying deploy method

The method to deploy a new contract is specific to the contract being deployed (in the case the contract has custom initialization parameters). We will modify the method to take in the auction contract's initialization parameters.

<Github fname="Contract path" language="rust"
        url="https://github.com/near-examples/auctions-tutorial/blob/main/factory/src/deploy.rs#L9-L82"
        start="9" end="82" />

In this fork, we have also removed the option to add an access key to the contract account since, as discussed [earlier](./1.3-deploy.md#locking-the-contract), we want auctions to be locked.

---

## Using the factory 

Build and deploy the factory like you would any other contract, this time without any initialization parameters. 

```bash
# compile the contract using cargo-near
cargo near build

# deploy the contract
near deploy <contractId> ./target/near/contract.wasm
```

You can now use the factory to deploy new auction contracts, here is an example command. 

```bash
near call auction-factory.testnet deploy_new_auction '{"name": "new-auction", "end_time": "3000000000000000000", "auctioneer": "pivortex.testnet", "ft_contract": "dai.fakes.testnet", "nft_contract": "nft.examples.testnet", "token_id": "7777", "starting_price": "1000000000000000000"}' --accountId pivortex.testnet --deposit 1.6 --gas 100000000000000
```

:::info Deposit and storage costs
Note that we attach 1.6 $NEAR to the call to cover the storage costs of deploying the new auction. The storage cost on NEAR is 1 $NEAR per 100 kb, and our auction contract is around 140 kb, but we'll add a little to cover the storage used on initialization.
:::

The command results in a fresh auction contract being deployed and initialized at `new-auction.auction-factory.testnet`.

---

## Conclusion

In this part of the tutorial, you have learned how to fork and modify the factory contract example to deploy our auction contracts. You have also learned how to use the factory to deploy new auction contracts. If you're feeling adventurous you could create a frontend to interact with the factory contract to make it even easier to deploy new auctions. If you do so feel free to share it in our developer [Telegram](https://t.me/neardev) or [Discord](https://discord.gg/vMGH5QywTH) channels!

And with that, this tutorial series is over, congratulations! Through this tutorial, we've built an auction contract and iterated on it adding improvements and extending its functionality, created a frontend to interact with the auction, used an API to index previous bids, and deployed a factory contract to make deploying new auctions easier. Along the way we've learned a great deal about NEAR, we learned about the anatomy of smart contracts, how to lock a contract to make it more secure, how to use primitives such as NFTs and FTs, how to perform cross-contract calls, how to use wallets from a frontend to interact with the blockchain and display data about a smart contract, how to pull historical data from the blockchain using an API, how to deploy contracts from other contracts and a lot of other little bits that will help you in the future. 

That's a lot, so once again congratulations!


 This is the content for the doc docs/3.tutorials/crosswords/01-basics/00-overview.md 

 ---
id: overview
sidebar_position: 1
sidebar_label: "Crossword Game Overview"
title: "Basics overview laying out what will be accomplished in this first section."
---

import basicCrossword from '/docs/assets/crosswords/basics-crossword.jpg';
import rustScary from '/docs/assets/crosswords/rust-scary--ksart.near.png';
import rustGood from '/docs/assets/crosswords/rust-good--ksart.near.png';

# Basics overview

This first chapter of the crossword puzzle tutorial will introduce fundamental concepts to smart contract development in a beginner-friendly way. By the end of this chapter you'll have a proof-of-concept contract that can be interacted with via [NEAR CLI](https://docs.near.org/tools/near-cli) and a simple frontend that uses the [`near-api-js` library](https://www.npmjs.com/package/near-api-js).

## It's not as bad as you think

Rust is a serious systems programming language. There are pointers, lifetimes, macros, and other things that may look foreign. Don't worry if this is how you feel:

<figure>
    <img src={rustScary} alt="Programmer looking at Rust code and looking worried. Art created by ksart.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/ksartworks" target="_blank" rel="noopener noreferrer">ksart.near</a></figcaption>
</figure>
<br/>

The good news is the Rust SDK takes care of a lot of the heavy lifting.

We'll also have the compiler on our side, often telling us exactly what went wrong and offering suggestions. As we go through this tutorial, you'll begin to see patterns that we'll use over and over again.

So don't worry, writing smart contracts in Rust on NEAR doesn't require a heavy engineering background.

<img src={rustGood} alt="Programmer looking quite relieved at the Rust code from the NEAR SDK. Art created by ksart.near" width="600"/>

## Assumptions for this first chapter

- There will be only one crossword puzzle with one solution.
- The user solving the crossword puzzle will not be able to know the solution.
- Only the author of the crossword puzzle smart contract can set the solution.

## Completed project

Here's the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-1

## How it works

<img src={basicCrossword} alt="Basic crossword puzzle" width="600" />

We'll have a rule about how to get the words in the proper order. We collect words in ascending order by number, and if there's and across and a down for a number, the across goes first.

So in the image above, the solution will be **near nomicon ref finance**. 

Let's begin!


 This is the content for the doc docs/3.tutorials/crosswords/01-basics/01-set-up-skeleton.md 

 ---
sidebar_position: 2
sidebar_label: "Set up Rust and a contract skeleton"
title: "Set up Rust, get a NEAR testnet account, NEAR CLI, and get a basic smart contract skeleton ready"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Getting started

In this tutorial we'll get a `testnet` account, use [NEAR CLI RS](../../../4.tools/cli.md) to add a key to our computer's file system, and set up the basic skeleton of a Rust smart contract.

## Setting up Rust

You may have found the [online Rust Book](https://doc.rust-lang.org/stable/book), which is a great resource for getting started with Rust. However, there are key items that are different when it comes to blockchain development. Namely, that smart contracts are [technically libraries and not binaries](https://learning-rust.github.io/docs/cargo-crates-and-basic-project-structure/#crate), but for now just know that we won't be using some commands commonly found in the Rust Book.

:::caution
We won't be using `cargo run` during smart contract development.
:::

Instead, we'll be iterating on our smart contract by building it and running tests.

### Install Rust using `rustup`

Please see the directions from the [Rustup site](https://rustup.rs/#). For OS X or Unix, you may use:

```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

(Taken from the [Rust installation guide](https://www.rust-lang.org/tools/install))

### Add Wasm toolchain

Smart contracts compile to WebAssembly (Wasm) so we'll add the toolchain for Rust.

```bash
rustup target add wasm32-unknown-unknown
```

(More info on [targets and this toolchain here](https://doc.rust-lang.org/edition-guide/rust-2018/platform-and-target-support/webassembly-support.html).)

## Getting a testnet account

Visit [NEAR Wallet for testnet](https://testnet.mynearwallet.com/) and register for a free account. For the purposes of this tutorial, you may skip the option to add two-factor authentication if you wish.

:::note What just happened?
When you created your NEAR `testnet` account, a private key was created and placed into your browser's local storage. You may inspect this using developer tools and see it.
:::

## Creating a new key on your computer

We'll want to use a command-line interface (CLI) tool to deploy a contract, but at the moment the private key only exists in the browser. Next we'll _add a new key_ to the testnet account and have this stored locally on our computer as a JSON file. (Yes, you can have multiple keys on your NEAR account, which is quite powerful!)

Let's install [NEAR CLI RS](../../../4.tools/cli.md) using `cargo`. You can also download the pre-compiled version of `near-cli-rs` for your OS from [GitHub's Releases page](https://github.com/near/near-cli-rs/releases/).

```bash
cargo install near-cli-rs
```

You may now run:

```bash
near
```

to see various commands, which are covered [in detail here](https://github.com/near/near-cli-rs/blob/main/docs/GUIDE.en.md).

We'll start by "logging in" with this command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near login
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account import-account using-web-wallet network-config testnet
  ```
  </TabItem>
</Tabs>

This will bring you to NEAR Wallet again where you can confirm the creation of a **full-access** key. We'll get to full-access and function-call access keys later, just know that for powerful actions like "deploy" we'll need a full-access key. Follow the instructions from the login command to create a key on your hard drive. This will be located in your operating system's home directory in a folder called `.near-credentials`.

:::note How was a key added?
When you typed `near login`, NEAR CLI generated a key pair: a private and public key. It kept the private key tucked away in a JSON file and sent the public key as a URL parameter to NEAR Wallet. The URL is long and contains other info instructing NEAR Wallet to "add a full access key" to the account. Our browser's local storage had a key (created when the account was made) that is able to do several things, including adding another key. It took the public key from the URL parameter, used it as an argument, and voil√†: the `testnet` account has an additional key!
:::

You can see the keys associated with your account by running the following command, replacing `friend.testnet` with your account name:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near list-keys friend.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account list-keys friend.testnet network-config testnet now
  ```
  </TabItem>
</Tabs>

## Start writing Rust!

There's a basic repository that's helpful to clone or download [located here](https://github.com/near/boilerplate-template-rs).

The first thing we'll do is modify the manifest file at `Cargo.toml`:

```diff
[package]
-  name = "rust-template"
+  name = "my-crossword"
version = "0.1.0"
- authors = ["Near Inc <hello@near.org>"]
+ authors = ["NEAR Friend <friend@example.com>"]
edition = "2018"
```

By changing the `name` here, we'll be changing the compiled Wasm file's name after running the build script. (`build.sh` for OS X and Linux, `build.bat` for Windows.) After running the build script, we can expect to find our compiled Wasm smart contract in `res/my_crossword.wasm`.

Now let's look at our main file, in `src/lib.rs`:

<Github language="rust" start="9" end="44" url="https://github.com/near/boilerplate-template-rs/blob/f1edeead98a9ec12c3f6db311f62025305f57874/contract/src/lib.rs" />

As you can see, this is a stub that's ready to be filled in. Let's pause and point out a few items:

- Note the **near** macro is above the struct and the impl
- Here the main struct is called `Contract`, while in other examples it might be `Counter` or something else. This is purely stylistic, but you may learn more from the link in the previous bullet.
- You may notice the word "Borsh" and wonder what that means. This is a binary serializer. Eventually, we'll want to save data as ones and zeroes to validators' hard drives, and do it efficiently. We use Borsh for this, as is explained [on this website](https://borsh.io).

Next, let's modify this contract little by little‚Ä¶


 This is the content for the doc docs/3.tutorials/crosswords/01-basics/02-add-functions-call.md 

 ---
sidebar_position: 3
sidebar_label: "Add basic code, create a subaccount, and call methods"
title: "Alter the smart contract, learning about basics of development"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import teachingDeployment from '/docs/assets/crosswords/teaching--jeheycell.near--artcultureac.jpeg';
import createAccount from '/docs/assets/crosswords/creating account with text--seanpineda.near--_seanpineda.png';
import chalkboardErase from '/docs/assets/crosswords/erasing-subaccount-chalkboard--iambon.near--JohnreyBona.mp4';

# Modifying the contract

This section will modify the smart contract skeleton from the previous section. This tutorial will start by writing a contract in a somewhat useless way in order to learn the basics. Once we've got a solid understanding, we'll iterate until we have a crossword puzzle.

## Add a const, a field, and functions

Let's modify the contract to be:

<Github language="rust" start="1" end="28" url="https://github.com/near-examples/crossword-snippets/blob/master/src/lib.rs" />

We've done a few things here:
1. Set a constant for the puzzle number.
2. Added the field `crossword_solution` to our main struct.
3. Implemented three functions: one that's view-only and two that are mutable, meaning they have the ability to change state.
4. Used logging, which required the import of `env` from our `near_sdk` crate.

Before moving on, let's talk about these changes and how to think about them, beginning with the constant:

```rust
const PUZZLE_NUMBER: u8 = 1;
```

This is an in-memory value, meaning that when the smart contract is spun up and executed in the virtual machine, the value `1` is contained in the contract code. This differs from the next change, where a field is added to the struct containing the `#[near]` macro. The field `crossword_solution` has the type of `String` and, like any other fields added to this struct, the value will live in **persistent storage**. With NEAR, storage is "paid for" via the native NEAR token (‚ìÉ). It is not "state rent" but storage staking, paid once, and returned when storage is deleted. This helps incentivize users to keep their state clean, allowing for a more healthy chain. Read more about [storage staking here](https://docs.near.org/concepts/storage/storage-staking).

Let's now look at the three new functions:

```rust
pub fn get_puzzle_number(&self) -> u8 {
    PUZZLE_NUMBER
}
```

As is covered in the [function section of these docs](../../../2.build/2.smart-contracts/anatomy/functions.md), a "view-only" function will have open parenthesis around `&self` while "change methods" or mutable functions will have `&mut self`. In the function above, the `PUZZLE_NUMBER` is returned. A user may call this method using the proper RPC endpoint without signing any transaction, since it's read-only. Think of it like a GET request, but using RPC endpoints that are [documented here](https://docs.near.org/api/rpc/contracts#call-a-contract-function).

Mutable functions, on the other hand, require a signed transaction. The first example is a typical approach where the user supplies a parameter that's assigned to a field:

```rust
pub fn set_solution(&mut self, solution: String) {
    self.crossword_solution = solution;
}
```

The next time the smart contract is called, the contract's field `crossword_solution` will have changed.

The second example is provided for demonstration purposes:

```rust
pub fn guess_solution(&mut self, solution: String) {
    if solution == self.crossword_solution {
        env::log_str("You guessed right!")
    } else {
        env::log_str("Try again.")
    }
}
```

Notice how we're not saving anything to state and only logging? Why does this need to be mutable?

Well, logging is ultimately captured inside blocks added to the blockchain. (More accurately, transactions are contained in chunks and chunks are contained in blocks. More info in the [Nomicon spec](https://nomicon.io/Architecture.html?highlight=chunk#blockchain-layer-concepts).) So while it is not changing the data in the fields of the struct, it does cost some amount of gas to log, requiring a signed transaction by an account that pays for this gas.

---

## Building and deploying

Here's what we'll want to do:

<figure>
    <img src={teachingDeployment} alt="Teacher shows chalkboard with instructions on how to properly deploy a smart contract. 1. Build smart contract. 2. Create a subaccount (or delete and recreate if it exists) 3. Deploy to subaccount. 4. Interact. Art created by jeheycell.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/artcultureac" target="_blank" rel="noopener noreferrer">jeheycell.near</a></figcaption>
</figure>

### Build the contract

To build the contract, we'll be using [`cargo-near`](https://github.com/near/cargo-near).

Install `cargo-near` first:

```bash
cargo install cargo-near
```

Run the following commands and expect to see the compiled Wasm file copied to the `target/near` folder.

```bash
cd contract
cargo near build
```

### Create a subaccount

If you've followed from the previous section, you have NEAR CLI installed and a full-access key on your machine. While developing, it's a best practice to create a subaccount and deploy the contract to it. This makes it easy to quickly delete and recreate the subaccount, which wipes the state swiftly and starts from scratch. Let's use NEAR CLI to create a subaccount and fund with 1 NEAR:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you look again in your home directory's `.near-credentials`, you'll see a new key for the subaccount with its own key pair. This new account is, for all intents and purposes, completely distinct from the account that created it. It might as well be `alice.testnet`, as it has, by default, no special relationship with the parent account. To be clear, `friend.testnet` cannot delete or deploy to `crossword.friend.testnet` unless it's done in a single transaction using Batch Actions, which we'll cover later.

:::info Subaccount nesting
It's possible to have the account `another.crossword.friend.testnet`, but this account must be created by `crossword.friend.testnet`.

`friend.testnet` **cannot** create `another.crossword.friend.testnet` because accounts may only create a subaccount that's "one level deeper."

See this visualization where two keys belonging to `mike.near` are able to create `new.mike.near`. We'll get into concepts around access keys later.

<figure>
    <img src={createAccount} alt="Depiction of create account where two figures put together a subaccount. Art created by seanpineda.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/_seanpineda" target="_blank" rel="noopener noreferrer">seanpineda.near</a></figcaption>
</figure>

:::

We won't get into top-level accounts or implicit accounts, but you may read more [about that here](https://docs.near.org/docs/concepts/account).

Now that we have a key pair for our subaccount, we can deploy the contract to `testnet` and interact with it!

#### What's a codehash?

We're almost ready to deploy the smart contract to the account, but first let's take a look at the account we're going to deploy to. Remember, this is the subaccount we created earlier. To view the state easily with NEAR CLI, you may run this command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near state crossword.friend.testnet --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account view-account-summary crossword.friend.testnet network-config testnet now
  ```
  </TabItem>
</Tabs>

What you'll see is something like this:

```bash
------------------------------------------------------------------------------------------
 crossword.friend.testnet         At block #167331831
                                  (Evjnf29LuqFE7FUf97VQZzNfnUgPFLNyyiUk9qr4Wjri)
------------------------------------------------------------------------------------------
 Native account balance           10.01 NEAR
------------------------------------------------------------------------------------------
 Validator stake                  0 NEAR
------------------------------------------------------------------------------------------
 Storage used by the account      182 B
------------------------------------------------------------------------------------------
 Contract (SHA-256 checksum hex)  No contract code
------------------------------------------------------------------------------------------
 Access keys                      1 full access keys and 0 function-call-only access keys
------------------------------------------------------------------------------------------
```

Note the `Contract` SHA-256 checksum is missing. This indicates that there is no contract deployed to this account.

Let's deploy the contract (to the subaccount we created) and then check this again.

### Deploy the contract

Ensure that in your command line application, you're in the directory that contains the `Cargo.toml` file, then run:

```bash
cargo near deploy build-non-reproducible-wasm crossword.friend.testnet without-init-call network-config testnet sign-with-keychain send
```

Congratulations, you've deployed the smart contract! Note that NEAR CLI will output a link to [NEAR Explorer](https://nearblocks.io/) where you can inspect details of the transaction.

Lastly, let's run this command again and notice that the `Contract` has a SHA-256 checksum. This is the hash of the smart contract deployed to the account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near state crossword.friend.testnet --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account view-account-summary crossword.friend.testnet network-config testnet now
  ```
  </TabItem>
</Tabs>

:::note

Deploying a contract is often done on the command line. While it may be _technically_ possible to deploy via a frontend, the CLI is likely the best approach. If you're aiming to use a factory model, (where a smart contract deploys contract code to a subaccount) this isn't covered in the tutorial, but you may reference the [contracts in SputnikDAO](https://github.com/near-daos/sputnik-dao-contract).

:::

### Call the contract methods (interact!)

Let's first call the method that's view-only:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view crossword.friend.testnet get_puzzle_number '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only crossword.friend.testnet get_puzzle_number json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

Your command prompt will show the result is `1`. Since this method doesn't take any arguments, we don't pass any.

Next, we'll add a crossword solution as a string (later we'll do this in a better way) argument:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call crossword.friend.testnet set_solution '{"solution": "near nomicon ref finance"}' --gas 100000000000000 --accountId friend.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction crossword.friend.testnet set_solution json-args '{"solution": "near nomicon ref finance"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as friend.testnet network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Note that we used NEAR CLI's [`view` command](https://docs.near.org/docs/tools/near-cli#call), and didn't include an `--accountId` flag. As mentioned earlier, this is because we are not signing a transaction. This second method uses the NEAR CLI [`call` command](https://docs.near.org/docs/tools/near-cli#call) which does sign a transaction and requires the user to specify a NEAR account that will sign it, using the credentials files we looked at.

The last method we have will check the argument against what is stored in state and write a log about whether the crossword solution is correct or incorrect.

Correct:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call crossword.friend.testnet guess_solution '{"solution": "near nomicon ref finance"}' --gas 100000000000000 --accountId friend.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction crossword.friend.testnet guess_solution json-args '{"solution": "near nomicon ref finance"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as friend.testnet network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You'll see something like this:

![Command line shows log for successful solution guess](/docs/assets/crosswords/cli-guess-solution.png)

Notice the log we wrote is output as well as a link to NEAR Explorer.

Incorrect:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call crossword.friend.testnet guess_solution '{"solution": "wrong answers here"}' --gas 100000000000000 --accountId friend.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction crossword.friend.testnet guess_solution json-args '{"solution": "wrong answers here"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as friend.testnet network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

As you can imagine, the above command will show something similar, except the logs will indicate that you've given the wrong solution.

## Reset the account's contract and state

We'll be iterating on this smart contract during this tutorial, and in some cases it's best to start fresh with the NEAR subaccount we created. The pattern to follow is to **delete** the account (sending all remaining testnet ‚ìÉ to a recipient) and then **create the account** again.

<video autoPlay controls loop>
    <source src={chalkboardErase} type="video/mp4" />
    Sorry, your browser doesn't support embedded videos.
</video>

<figure>
    <figcaption>Deleting a recreating a subaccount will clear the state and give us a fresh start.<br/>Animation by <a href="https://twitter.com/JohnreyBona" target="_blank" rel="noopener noreferrer">iambon.near</a></figcaption>
</figure>

Using NEAR CLI, the commands will look like this:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # deleting an account
  near delete-account crossword.friend.testnet friend.testnet --networkId testnet

  # creating an account
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # deleting an account
  near account delete-account crossword.friend.testnet beneficiary friend.testnet network-config testnet sign-with-keychain send

  # creating an account
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

The first command deletes `crossword.friend.testnet` and sends the rest of its NEAR to `friend.testnet`.

## Wrapping up

So far, we're writing a simplified version of smart contract and approaching the crossword puzzle in a novice way. Remember that blockchain is an open ledger, meaning everyone can see the state of smart contracts and transactions taking place.

:::info How would you do that?
You may hit an RPC endpoint corresponding to `view_state` and see for yourself. Note: this quick example serves as demonstration purposes, but note that the string being returned is Borsh-serialized and contains more info than just the letters.

```bash
    curl -d '{"jsonrpc": "2.0", "method": "query", "id": "see-state", "params": {"request_type": "view_state", "finality": "final", "account_id": "crossword.friend.testnet", "prefix_base64": ""}}' -H 'Content-Type: application/json' https://rpc.testnet.near.org
```

![Screenshot of a terminal screen showing a curl request to an RPC endpoint that returns state of a smart contract](/docs/assets/crosswords/rpc-api-view-state.png)

More on this RPC endpoint in the [NEAR docs](https://docs.near.org/docs/api/rpc/contracts#view-contract-state).
:::

In this section, we saved the crossword solution as plain text, which is likely not a great idea if we want to hide the solution to players of this crossword puzzle. Even though we don't have a function called `show_solution` that returns the struct's `crossword_solution` field, the value is stored transparently in state. We won't get into viewing contract state at this moment, but know it's rather easy [and documented here](https://docs.near.org/docs/api/rpc/contracts#view-contract-state).

The next section will explore hiding the answer from end users playing the crossword puzzle.


 This is the content for the doc docs/3.tutorials/crosswords/01-basics/03-hashing-and-unit-tests.md 

 ---
sidebar_position: 4
sidebar_label: "Hash the solution, unit tests, and an init method"
title: "Introduction to basic hashing and adding unit tests"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import batchCookieTray from '/docs/assets/crosswords/batch-of-actions--dobulyo.near--w_artsu.jpg';

# Hash the solution, add basic unit tests

In the previous section, we stored the crossword solution as plain text as a `String` type on the smart contract. If we're trying to hide the solution from the users, this isn't a great approach as it'll be public to anyone looking at the state. Let's instead hash our crossword solution and store that instead. There are different ways to hash data, but let's use `sha256` which is one of the hashing algorithms available in [the Rust SDK](https://docs.rs/near-sdk/latest/near_sdk/env/fn.sha256.html).

:::info Remind me about hashing
Without getting into much detail, hashing is a "one-way" function that will output a result from a given input. If you have input (in our case, the crossword puzzle solution) you can get a hash, but if you have a hash you cannot get the input. This basic idea is foundational to information theory and security.

Later on in this tutorial, we'll switch from using `sha256` to using cryptographic key pairs to illustrate additional NEAR concepts.

Learn more about hashing from [Evgeny Kapun](https://github.com/abacabadabacaba)'s presentation on the subject. You may find other NEAR-related videos from the channel linked in the screenshot below.

[![Evgeny Kapun presents details on hashing](/docs/assets/crosswords/kapun-hashing.png)](https://youtu.be/PfabikgnD08)
:::

## Helper unit test during rapid iteration

As mentioned in the first section of this **Basics** chapter, our smart contract is technically a library as defined in the manifest file. For our purposes, a consequence of writing a library in Rust is not having a "main" function that runs. You may find many online tutorials where the command `cargo run` is used during development. We don't have this luxury, but we can use unit tests to interact with our smart contract. This is likely more convenient than building the contract, deploying to a blockchain network, and calling a method.

We'll add a dependency to the [hex crate](https://crates.io/crates/hex) to make things easier. As you may remember, dependencies live in the manifest file.

<Github language="rust" start="10" end="12" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/master/contract/Cargo.toml" />

Let's write a unit test that acts as a helper during development. This unit test will sha256 hash the input **"near nomicon ref finance"** and print it in a human-readable, hex format. (We'll typically put unit tests at the bottom of the `lib.rs` file.)

<Github language="rust" start="43" end="60" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/master/contract/src/lib.rs" />

:::info What is that `{:?}` thing?
Take a look at different formatting traits that are covered in the [`std` Rust docs](https://doc.rust-lang.org/std/fmt/index.html#formatting-traits) regarding this. This is a `Debug` formatting trait and can prove to be useful during development.
:::

Run the unit tests with the command:

```
cargo test -- --nocapture
```

You'll see this output:

```
‚Ä¶
running 1 test
Let's debug: "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"
test tests::debug_get_hash ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
```

This means when you sha256 the input **"near nomicon ref finance"** it produces the hash:
`69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f`

:::tip Note on the test flags
You may also run tests using:

```
cargo test
```

Note that the test command we ran had additional flags. Those flags told Rust **not to hide the output** from the tests. You can read more about this in [the cargo docs](https://doc.rust-lang.org/cargo/commands/cargo-test.html#display-options). Go ahead and try running the tests using the command above, without the additional flags, and note that we won't see the debug message.
:::

The unit test above is meant for debugging and quickly running snippets of code. Some may find this a useful technique when getting familiar with Rust and writing smart contracts. Next we'll write a real unit test that applies to this early version of our crossword puzzle contract.

## Write a regular unit test

Let's add this unit test (inside the `mod tests {}` block, under our previous unit test) and analyze it:

<Github language="rust" start="62" end="92" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/master/contract/src/lib.rs" />

The first few lines of code will be used commonly when writing unit tests. It uses the `VMContextBuilder` to create some basic context for a transaction, then sets up the testing environment.

Next, an object is created representing the contract and the `set_solution` function is called. After that, the `guess_solution` function is called twice: first with the incorrect solution and then the correct one. We can check the logs to determine that the function is acting as expected.

:::info Note on assertions
This unit test uses the [`assert_eq!`](https://doc.rust-lang.org/std/macro.assert_eq.html) macro. Similar macros like [`assert!`](https://doc.rust-lang.org/std/macro.assert.html) and [`assert_ne!`](https://doc.rust-lang.org/std/macro.assert_ne.html) are commonly used in Rust. These are great to use in unit tests. However, these will add unnecessary overhead when added to contract logic, and it's recommended to use the [`require!` macro](https://docs.rs/near-sdk/4.0.0-pre.2/near_sdk/macro.require.html). See more information on this and [other efficiency tips here](../../../2.build/2.smart-contracts/anatomy/reduce-size.md).
:::

Again, we can run all the unit tests with:

```
cargo test -- --nocapture
```

:::tip Run only one test
To only run this latest test, use the command:

```
cargo test check_guess_solution -- --nocapture
```

:::

## Modifying `set_solution`

The [overview section](00-overview.md) of this chapter tells us we want to have a single crossword puzzle and the user solving the puzzle should not be able to know the solution. Using a hash addresses this, and we can keep `crossword_solution`'s field type, as `String` will work just fine. The overview also indicates we only want the author of the crossword puzzle to be able to set the solution. As it stands, our function `set_solution` can be called by anyone with a full-access key. It's trivial for someone to create a NEAR account and call this function, changing the solution. Let's fix that.

Let's have the solution be set once, right after deploying the smart contract.

Here we'll use the [`#[near]` macro](https://docs.rs/near-sdk/latest/near_sdk/attr.near.html) on a function called `new`, which is a common pattern.

<Github language="rust" start="9" end="17" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/master/contract/src/lib.rs" />

Let's call this method on a fresh contract.

Go into the directory containing the Rust smart contract and build it:

```bash
cd contract

# Build
cargo near build
```

Create fresh account if you wish, which is good practice:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # Delete an account
  near delete-account crossword.friend.testnet friend.testnet --networkId testnet
  
  # Create an account again
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # Delete an account
  near account delete-account crossword.friend.testnet beneficiary friend.testnet network-config testnet sign-with-keychain send

  # Create an account again
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Deploy the contract:

```bash
cargo near deploy build-non-reproducible-wasm crossword.friend.testnet without-init-call network-config testnet sign-with-keychain send
```

Call the "new" method:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near call crossword.friend.testnet new '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}' --gas 100000000000000 --accountId crossword.friend.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-transaction crossword.friend.testnet new json-args '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as crossword.friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Now the crossword solution, as a hash, is stored instead. If you try calling the last command again, you'll get the error message, thanks to the `#[init]` macro:
`The contract has already been initialized`

## First use of Batch Actions

This is close to what we want, but what if a person deploys their smart contract and **someone else** quickly calls the `new` function before them? We want to make sure the same person who deployed the contract sets the solution, and we can do this using Batch Actions. Besides, why send two transactions when we can do it in one? (Technical details covered in the spec for a [batch transaction here](https://nomicon.io/RuntimeSpec/Transactions.html?highlight=batch#batched-transaction).)

<figure>
    <img src={batchCookieTray} alt="Cookie sheet representing a transaction, where cookies are Deploy and FunctionCall Actions. Art created by dobulyo.near."/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/w_artsu" target="_blank" rel="noopener noreferrer">dobulyo.near</a></figcaption>
</figure><br/>

:::info Batch Actions in use
Batch Actions are common in this instance, where we want to deploy and call an initialization function. They're also common when using a factory pattern, where a subaccount is created, a smart contract is deployed to it, a key is added, and a function is called.

Here's a truncated snippet from a useful (though somewhat advanced) repository with a wealth of useful code:
<Github language="rust" start="172" end="177" url="https://github.com/near/core-contracts/blob/1720c0cfee238974ebeae8ad43076abeb951504f/staking-pool-factory/src/lib.rs" />

We'll get into Actions later in this tutorial, but in the meantime here's a handy [reference from the spec](https://nomicon.io/RuntimeSpec/Actions.html).
:::

As you can from the info bubble above, we can batch [Deploy](https://docs.rs/near-sdk/3.1.0/near_sdk/struct.Promise.html#method.deploy_contract) and [FunctionCall](https://docs.rs/near-sdk/3.1.0/near_sdk/struct.Promise.html#method.function_call) Actions. This is exactly what we want to do for our crossword puzzle, and luckily, NEAR CLI has a [flag especially for this](https://docs.near.org/tools/near-cli#near-deploy).

Let's run this again with the handy `--initFunction` and `--initArgs` flags:

Create fresh account if you wish, which is good practice:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # Delete an account
  near delete-account crossword.friend.testnet friend.testnet --networkId testnet
  
  # Create an account again
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # Delete an account
  near account delete-account crossword.friend.testnet beneficiary friend.testnet network-config testnet sign-with-keychain send

  # Create an account again
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Deploy the contract and call the initialization method:

```bash
cargo near deploy build-non-reproducible-wasm crossword.friend.testnet with-init-call new json-args '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

Now that we're using Batch Actions, no one can call this `new` method before us.

:::note Batch action failures
If one Action in a set of Batch Actions fails, the entire transaction is reverted. This is good to note because sharded, proof-of-stake systems do not work like proof-of-work where a complex transaction with multiple cross-contract calls reverts if one call fails. With NEAR, cross-contract calls use callbacks to ensure expected behavior, but we'll get to that later.
:::

## Get ready for our frontend

In the previous section we showed that we could use a `curl` command to view the state of the contract without explicitly having a function that returns a value from state. Now that we've demonstrated that and hashed the solution, let's add a short view-only function `get_solution`.

In the next section we'll add a simple frontend for our single, hardcoded crossword puzzle. We'll want to easily call a function to get the final solution hash. We can use this opportunity to remove the function `get_puzzle_number` and the constant it returns, as these were use for informative purposes.

We'll also modify our `guess_solution` to return a boolean value, which will also make things easier for our frontend.

<Github language="rust" start="19" end="34" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/94f42e75cf70ed2aafb9c29a1faa1e21f079a49e/contract/src/lib.rs" />

The `get_solution` method can be called with:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view crossword.friend.testnet get_solution '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only crossword.friend.testnet get_solution json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

In the next section we'll add a simple frontend. Following chapters will illustrate more NEAR concepts built on top of this idea.


 This is the content for the doc docs/3.tutorials/crosswords/01-basics/04-simple-frontend.md 

 ---
sidebar_position: 5
sidebar_label: "Add simple frontend"
title: "Add a simple frontend to the crossword puzzle that checks the solution's hash"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import nearReactFriends from '/docs/assets/crosswords/near-and-react--dakila.near--rodolf_dtbbx.png';

# Add a simple frontend

This will be the final section in this chapter, where we'll add a simple frontend using React and [`near-api-js`](../../../4.tools/near-api.md) to communicate with the smart contract.

<figure>
    <img src={nearReactFriends} alt="Two characters hanging out, NEAR and React. Art created by dakila.near" width="600"/>
    <figcaption>Dynamic duo of NEAR as the backend and React as a frontend.<br/>Art by <a href="https://twitter.com/rodolf_dtbbx" target="_blank" rel="noopener noreferrer">dakila.near</a></figcaption>
</figure>
<br/>

There will be three main files we'll be working with:
1. `src/index.js` will be the entry point, where NEAR network configuration will be set up, and the view-only call to `get_solution` will happen.
2. `src/App.js` is then called and sets up the crossword table and checks to see if a solution has been found.
3. `src/utils.js` is used to make a view-only call to the blockchain to get the solution, and other helper functions.

## Entry point

We'll go over a pattern that may look familiar to folks who have surveyed the [NEAR examples site](https://github.com/near-examples). We'll start with an asynchronous JavaScript function that sets up desired logic, then pass that to the React app.

<Github language="js" start="3" end="22" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/index.js" />

Let's talk through the code above, starting with the imports.

We import from:

- `config.js` which, at the moment, is a common pattern. This file contains details on the different networks. (Which RPC endpoint to hit, which NEAR Wallet site to redirect to, which NEAR Explorer as well‚Ä¶)
- `utils.js` for that view-only function call that will call `get_solution` to retrieve the correct solution hash when a person has completed the crossword puzzle correctly.
- `hardcoded-data.js` is a file containing info on the crossword puzzle clues. This chapter has covered the crossword puzzle where the solution is **near nomicon ref finance**, and according to the chapter overview we've committed to serving *one* puzzle. We'll improve our smart contract later, allowing for multiple crossword puzzles, but for now it's hardcoded here.

Next, we define an asynchronous function called `initCrossword` that will be called before passing data to the React app. It's often useful to set up a connection with the blockchain here, but in our case all we need to do is retrieve the crossword puzzle solution as a hash. Note that we're attempting to pass this environment variable `NEAR_ENV` into our configuration file. `NEAR_ENV` is used to designate the blockchain network (testnet, betanet, mainnet) and is also [used in NEAR CLI](../../../2.build/2.smart-contracts/release/deploy.md).

Lastly, we'll call `initCrossword` and, when everything is complete, pass data to the React app contained in `App.js`.

## React app

Here's a large portion of the `App.js` file, which will make use of a fork of a React crossword library by Jared Reisinger.

<Github language="js" start="3" end="54" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/App.js" />

We'll discuss a few key points in the code above, but seeing as we're here to focus on a frontend connection to the blockchain, will brush over other parts that are library-specific.

The two imports worth highlighting are:

- `parseSolutionSeedPhrase` from the utility file we'll cover shortly. This will take the solution entered by the user and put it in the correct order according to the rules discussed in [the chapter overview](00-overview.md#how-it-works).
- `sha256` will take the ordered solution from above and hash it. Then we'll compare that hash with the one retrieved from the smart contract.

```js
const [solutionFound, setSolutionFound] = useState(false);
```

We're using [React Hooks](https://reactjs.org/docs/hooks-state.html) here, setting up the variable `solutionFound` that will be changed when the player of the crossword puzzle enters the final letter of the crossword puzzle, having entries for all the letters on the board.

The `onCrosswordComplete` and `checkSolution` blocks of code fire events to check the final solution entered by the user, hash it, and compare it to the `solutionHash` that was passed in from the view-only call in `index.js` earlier.

Finally, we return the [JSX](https://reactjs.org/docs/introducing-jsx.html) for our app and render the crossword puzzle! In this basic case we'll change this heading to indicate when the user has completed the puzzle successfully:

```html
<h3>Status: { solutionFound }</h3>
```

## Utility functions

We'll be using two utility functions here:

- `parseSolutionSeedPhrase` which will take a completed crossword puzzle and place the answers in the proper order. (Ascending by number, across answers come before down ones.)
- `viewMethodOnContract` makes the view-only call to the smart contract to retrieve the solution hash.

We'll only focus on the second method:

<Github language="js" start="8" end="12" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/utils.js" />

This API doesn't look warm and friendly yet. You caught us! We'd love some help to improve our API as [detailed in this issue](https://github.com/near/near-api-js/issues/612), but for now, this is a concise way to get data from a view-only method.

We haven't had the frontend call a mutable method for our project yet. We'll get into that in the coming chapters when we'll want to have a prize sent to the first person to solve the puzzle.

## Run the React app

Let's run our frontend on testnet! We won't add any new concepts at this point in the chapter, but note that the [near examples](https://github.com/near-examples) typically create an account for you automatically with a NodeJS command. We covered the important pattern of creating a subaccount and deploying the smart contract to it, so let's stick with that pattern as we start up our frontend.

Go into the directory containing the Rust smart contract and build it:

```bash
cd contract

# Build
cargo near build
```

Create fresh account if you wish, which is good practice:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # Delete an account
  near delete-account crossword.friend.testnet friend.testnet --networkId testnet
  
  # Create an account again
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # Delete an account
  near account delete-account crossword.friend.testnet beneficiary friend.testnet network-config testnet sign-with-keychain send

  # Create an account again
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Deploy the contract:

```bash
cargo near deploy build-non-reproducible-wasm crossword.friend.testnet with-init-call new json-args '{"solution": "69c2feb084439956193f4c21936025f14a5a5a78979d67ae34762e18a7206a0f"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

Return to the project root and start the React app:

```bash
cd ..
env CONTRACT_NAME=crossword.friend.testnet npm run start
```

The last line sends the environment variable `CONTRACT_NAME` into the NodeJS script. This is picked up in the `config.js` file that's used to set up the contract account and network configuration:

<Github language="js" start="1" end="2" url="https://github.com/near-examples/crossword-tutorial-chapter-1/blob/3e497b4815600b8382614f76c7812520710f704d/src/config.js" />

After running the last command to start the React app, you'll be given a link to a local website, like `https://localhost:1234`. When you visit the site you'll see the simple frontend that interacts with our smart contract:

![Crossword puzzle frontend showing a filled out puzzle with clues on the right sidebar](/docs/assets/crosswords/basics-final-frontend.png)

Again, the full code for this chapter is [available here](https://github.com/near-examples/crossword-tutorial-chapter-1).


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/00-overview.md 

 ---
sidebar_position: 1
sidebar_label: "Overview"
title: "Highlights of some beginner topics covered."
---

import chapter2Correct from '/docs/assets/crosswords/chapter-2-solve.gif';
import multipleCrosswords from '/docs/assets/crosswords/puzzle-piggy-bank--r3v.near--rev_rodrigueza.png';

# Diving deeper

In the last chapter we installed Rust and got up and running with a simple smart contract. The contract has a few issues, however, and isn't as powerful as we'd like it to be. For instance, we can only store one crossword puzzle in the smart contract, the frontend is  hardcoded, and we don't offer any incentives to the person who wins.

Let's give the smart contract the ability to store multiple crosswords and offer the winner a prize, paid in NEAR.

<figure>
    <img src={multipleCrosswords} alt="Man holding a book full of crossword puzzles, in his other hand he's holding a piggy bank. Art created by r3v.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/rev_rodrigueza" target="_blank" rel="noopener noreferrer">r3v.near</a></figcaption>
</figure>
<br/>

In this chapter we'll:

- Allow the contract to store multiple crossword puzzles
- Store the positions of the clues in the contract
- Allow users to log in with a NEAR account
- Give a prize (in NEAR tokens) to the first person to solve the puzzle
- Explore using Rust structs and enums
- more‚Ä¶

<figure>
    <img src={chapter2Correct} width="600" alt="A user fills in the last clue in a crossword puzzle and an overlay appears saying that a transaction is pending" />
    <figcaption>A user solves the crossword puzzle, interacts with the blockchain, and gets a prize</figcaption>
</figure>

As we implement the list above, we'll learn key concepts about NEAR:

- [Actions](https://nomicon.io/RuntimeSpec/Actions.html)
- Full and function-call [access keys](https://docs.near.org/concepts/basics/account#access-keys)
- NEAR's specialized [Collections](../../../2.build/2.smart-contracts/anatomy/collections.md) that are generally preferable to, say, Rust's standard HashMap 
- The flow of logging in to a decentralized app (dApp)
- more‚Ä¶

Let's jump right in!

## Completed project

Here's the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-2


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/01-collections.md 

 ---
sidebar_position: 2
sidebar_label: "Store multiple puzzles"
title: "Store multiple crossword puzzles using a specialized collection in NEAR called a LookupMap"
---
import {Github} from "@site/src/components/codetabs"

import bookPagination from '/docs/assets/crosswords/paging-through-hashes-swing--pierced_staggg.near--pierced_stag.jpg';
import guardsAroundContract from '/docs/assets/crosswords/guards-contract-permissions--connoisseur_dane.near--connoisseurdane.png';

# Using collections

As mentioned in the previous chapter, the [online Rust Book](https://doc.rust-lang.org/stable/book) is a great reference for folks getting started with Rust, but there are concepts that differ when we're dealing with the blockchain. One of these differences is the use of collections.

The reference-level documentation of the Rust SDK explains this concept well:

:::note  Motivation for specialized collections
>Collections that offer an alternative to standard containers from [Rust's] std::collections::* by **utilizing the underlying blockchain trie storage more efficiently**.<br/>
>For example, the following smart contract does not work with state efficiently, because **it will load the entire HashMap at the beginning of the contract call**, and will save it entirely at the end, in cases when there is state modification. **This is fine for small number of elements, but very inefficient for large numbers**.

‚Äî [NEAR SDK reference documentation](https://docs.rs/near-sdk/latest/near_sdk/collections/index.html)
:::

In chapter 1, we set the crossword puzzle solution hash when we first deployed the contract and called the initialization method `new`, passing it. This would only allow us to have only one puzzle, but let's allow for many.

At a high level, let's discuss what we'll want to add if our contract is to store multiple crossword puzzles. First, we'll have the concept of many puzzles where some of them will have different states (unfinished and finished) and we'll want to know which ones are unsolved in quick way. Another thing, which is a general rule of thumb when writing smart contracts, is to anticipate what might happen if it gets a lot of usage. What if we end up with 10,000 crossword puzzles? How might that affect how many data structures we use and which ones?

## LookupMap and UnorderedSet

Let's try having two specialized NEAR collections:

1. A [LookupMap](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.LookupMap.html) which will store key-value pairs. (Solution hash ¬ª Puzzle object)
2. An [UnorderedSet](https://docs.rs/near-sdk/latest/near_sdk/collections/struct.UnorderedSet.html) containing a set (list with no duplicates) of the solution hashes for puzzles which have not been solved yet.

As you look at the list of specialized collections in the Rust SDK, you might notice some begin with `Lookup` while others have `Unordered`. As is written in the reference documentation, the `Lookup` is non-iterable while the `Unordered` collections are iterable. This means if you will need to loop through the list of contents of this data structure, you'll likely use an iterable data structure. If you'll only ever be adding and retrieving data by the key, and the key will always be known, it's more efficient to use a non-iterable collection.

So why would we have two data structures here? Again, if we end up with a large number of puzzles, we might not be able to loop through all the puzzles, looking for ones that are unsolved. Because of the limit of gas execution per transaction, we must be conscious that there can be operations which will eventually exceed this limit. I suppose we could assume  that our `UnorderedSet` of unsolved puzzles wouldn't contain tens of thousands of puzzles. That's one way to avoid running into limits, but we could also learn how to utilize **pagination** through an iterable collection like an `UnorderedSet` which we'll get to later.

<figure>
    <img src={bookPagination} alt="Book showing pagination of hashes. Art created by pierced_staggg.near" width="600"/>
    <figcaption>Think of our collection as having multiple pages of puzzle hashes.<br/>Art by <a href="https://twitter.com/pierced_stag" target="_blank" rel="noopener noreferrer">pierced_staggg.near</a></figcaption>
</figure>
<br/>

As we remember from the previous chapter, every smart contract has a primary struct containing the `#[near(contract_state)]` macro.

:::note Naming the primary struct
Note in the [previous chapter](../01-basics/01-set-up-skeleton.md#start-writing-rust) we named our primary struct `Contract`, but in this chapter we'll call it `Crossword.`

The name of the struct doesn't matter and there's nothing special about naming it `Contract`, though you might see that convention used in several smart contracts on NEAR. We've named it something different simply to illustrate that there's no magic behind the scenes. This *does* mean, however, that our `impl` block will also be `Crossword`.
:::

Here's how our struct will look with the iterable and non-iterable NEAR collections:

<Github language="rust" start="62" end="72" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/master/contract/src/lib.rs" />

Above, we have the `puzzles` and `unsolved_puzzles` fields which are collections.

We also have an `owner_id` so we can exercise a common pattern in smart contract development: implementing a rudimentary permission system which can restrict access to certain functions. We'll expand on this thought in a moment.

The snippet below shows the first method in the implementation of the `Crossword` struct, where the `new` function sets up these two specialized collections.

<Github language="rust" start="74" end="83" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/master/contract/src/lib.rs" />

So during the initialization function (`new`) we're setting the `owner_id`. For our purposes the owner will likely be the contract itself, but there can be several reasons to have it be a DAO or another user. Next, let's look at the `b"c"` and `b"u"` bits for the collection fields.

## Collections have prefixes

Above, the `new` function is initializing the struct's fields by giving them a unique prefix. You can learn more about [the prefixes here](../../../2.build/2.smart-contracts/anatomy/collections.md), but know that these prefixes (`c` and `u`) should be short and different.

Let's take a peek at how we'll add a new crossword puzzle. Note that there will be a new struct here, `Answer`, which we haven't defined yet. We'll also be introducing the concept of enums, like `PuzzleStatus::Solved` and `PuzzleStatus::Unsolved`. We'll be covering these in the next section.

Unlike the previous chapter where there was only one crossword puzzle, we'll be inserting into our new collections, so let's create a `new_puzzle` method.

<Github language="rust" start="140" end="157" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/master/contract/src/lib.rs" />

Now we're set up to store multiple puzzles!

## Permissions or permissionless?

<figure>
    <img src={guardsAroundContract} alt="Guards or bouncers in front of a futuristic club with the label of a NEAR smart contract. Art created by connoisseur_dane.near" width="600"/>
    <figcaption>Guarding which accounts can enter the smart contract logic.<br/>Art by <a href="https://twitter.com/connoisseurdane" target="_blank" rel="noopener noreferrer">connoisseur_dane.near</a></figcaption>
</figure>
<br/>

**Is NEAR permissionless?**

Yes.

**What did you mean by a permission system earlier, and what are the ways you can control permissions?**

There are two ways that permissions can be controlled:

1. In the smart contract code itself
2. When using function-call access keys

We'll get to the second topic in later in this chapter, but will focus on the first item.

As you can see in the previous snippet, the first thing that happens in the `new_puzzle` method is a check. It looks to see if the predecessor (the person who most recently called this method, sometimes the same as the signer) is the same as the `owner_id` that we set during the contract's initialization.

If someone else is trying to call `new_puzzle`, this check will fail and the smart contract will panic, going no further. This example is the simplest form of a permission. Much more complex system can exist for users. The SputnikDAO smart contracts, for instance, implement custom policies. It's up the smart contract developer to write their roles/policies and apply them to users. Sometimes an allow-list (or whitelist) is used.

In short, **any account with a full-access key can call any method on a smart contract**, but that doesn't mean the smart contract will let them continue execution. It's up to the developer to protect their functions with guards like the one in `new_puzzle`.

---

Let's dive into structs and enums next.


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/02-structs-enums.md 

 ---
sidebar_position: 3
sidebar_label: "Using structs and enums"
title: "How to think about structs and enums when writing a Rust smart contract on NEAR"
---

import basicCrossword from '/docs/assets/crosswords/basics-crossword.jpg';
import enumBox from '/docs/assets/crosswords/enum-a-d-block--eizaconiendo.near--eiza_coniendo.png';

# Structs and enums

## Overview

### Structs

If you're not familiar with Rust, it may be confusing that there are no classes or inheritance like other programming languages. We'll be exploring how to [use structs](https://doc.rust-lang.org/book/ch05-01-defining-structs.html), which are someone similar to classes, but perhaps simpler.

Remember that there will be only one struct that gets the [`#[near]` macro](../../../2.build/2.smart-contracts/anatomy/anatomy.md) placed on it; our primary struct or singleton if you wish. Oftentimes the primary struct will contain additional structs that may, in turn, contain more structs in a neat and orderly way. You may also have structs that are used to return data to an end user, like a frontend. We'll be covering both of these cases in this chapter.

### Enums

Enums are short for enumerations, and can be particularly useful if you have entities in your smart contract that transition to different states. For example, say you have a series of blockchain games where players can join, battle, and win. There might be an enumeration for  `AcceptingPlayers`, `GameInProgress`, and `GameCompleted`. Enums are also used to define discrete types of concept, like months in a year.

For our crossword puzzle, one example of an enum is the direction of the clue: either across (A) or down (D) as illustrated below. These are the only two options.

<figure>
    <img src={enumBox} alt="Children's toy of a box that has blocks that only fit certain shapes, resembling the letters A and D. Art created by eizaconiendo.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/eiza_coniendo" target="_blank" rel="noopener noreferrer">eizaconiendo.near</a></figcaption>
</figure>
<br/>

Rust has an interesting feature where enums can contain additional data. You can see [examples of that here](https://doc.rust-lang.org/rust-by-example/custom_types/enum.html).

## Using structs

### Storing contract state

We're going to introduce several structs all at once. These structs are addressing a need from the previous chapter, where the puzzle itself was hardcoded and looked like this:

<img src={basicCrossword} alt="Basic crossword puzzle from chapter 1" width="600" />

In this chapter, we want the ability to add multiple, custom crossword puzzles. This means we'll be storing information about the clues in the contract state. Think of a grid where there are x and y coordinates for where a clue starts. We'll also want to specify:

1. Clue number
2. Whether it's **across** or **down**
3. The length, or number of letters in the answer

Let's dive right in, starting with our primary struct:

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Crossword {
    puzzles: LookupMap<String, Puzzle>,  // ‚üµ Puzzle is a struct we're defining
    unsolved_puzzles: UnorderedSet<String>,
}
```

:::note Let's ignore a couple of things‚Ä¶
For now, let's ignore the macros about the structs that begin with `derive` and `near`.
:::

Look at the fields inside the `Crossword` struct above, and you'll see a couple types. `String` is a part of Rust's standard library, but `Puzzle` is something we've created:

```rust
#[near(serializers = [borsh])]
#[derive(Debug)]
pub struct Puzzle {
    status: PuzzleStatus,  // ‚üµ An enum we'll get to soon
    /// Use the CoordinatePair assuming the origin is (0, 0) in the top left side of the puzzle.
    answer: Vec<Answer>,  // ‚üµ Another struct we've defined
}
```

Let's focus on the `answer` field here, which is a vector of `Answer`s. (A vector is nothing fancy, just a bunch of items or a "growable array" as described in the [standard Rust documentation](https://doc.rust-lang.org/std/vec/struct.Vec.html).

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub struct Answer {
    num: u8,
    start: CoordinatePair,  // ‚üµ Another struct we've defined
    direction: AnswerDirection,  // ‚üµ An enum we'll get to soon
    length: u8,
    clue: String,
}
```

Now let's take a look at the last struct we'e defined, that has cascaded down from fields on our primary struct: the `CoordinatePair`.

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub struct CoordinatePair {
    x: u8,
    y: u8,
}
```

:::info Summary of the structs shown
There are a handful of structs here, and this will be a typical pattern when we use structs to store contract state.

```
Crossword ‚üµ primary struct with #[near(contract_state)]
‚îî‚îÄ‚îÄ Puzzle
   ‚îî‚îÄ‚îÄ Answer
      ‚îî‚îÄ‚îÄ CoordinatePair
```
:::

### Returning data

Since we're going to have multiple crossword puzzles that have their own, unique clues and positions in a grid, we'll want to return puzzle objects to a frontend.

:::tip Quick note on return values
By default, return values are serialized in JSON unless explicitly directed to use Borsh for binary serialization.

For example, if we call this function:

```rust
pub fn return_some_words() -> Vec<String> {
    vec!["crossword".to_string(), "puzzle".to_string()]
}
```

The return value would be a JSON array:

`["crossword", "puzzle"]`

While somewhat advanced, you can learn more about [changing the serialization here](../../../2.build/2.smart-contracts/anatomy/serialization-interface.md).
:::

We have a struct called `JsonPuzzle` that differs from the `Puzzle` struct we've shown. It has one difference: the addition of the `solution_hash` field.

```rust
#[near(serializers = [json])]
pub struct JsonPuzzle {
    /// The human-readable (not in bytes) hash of the solution
    solution_hash: String,  // ‚üµ this field is not contained in the Puzzle struct
    status: PuzzleStatus,
    answer: Vec<Answer>,
}
```

This is handy because our primary struct has a key-value pair where the key is the solution hash (as a `String`) and the value is the `Puzzle` struct.

```rust
pub struct Crossword {
    puzzles: LookupMap<String, Puzzle>,
    //               key ‚Üó        ‚Üñ value
    ‚Ä¶
```

Our `JsonPuzzle` struct returns the information from both the key and the value.

We can move on from this topic, but suffice it to say, sometimes it's helpful to have structs where the intended use is to return data in a more meaningful way than might exist from the structs used to store contract data.

### Using returned objects in a callback

Don't be alarmed if this section feels confusing at this point, but know we'll cover Promises and callbacks later.

Without getting into detail, a contract may want to make a cross-contract call and "do something" with the return value. Sometimes this return value is an object we're expecting, so we can define a struct with the expected fields to capture the value. In other programming languages this may be referred to as "casting" or "marshaling" the value.

A real-world example of this might be the [Storage Management standard](https://nomicon.io/Standards/StorageManagement.html), as used in a [fungible token](https://github.com/near-examples/FT).

Let's say a smart contract wants to determine if `alice.near` is "registered" on the `nDAI` token. More technically, does `alice.near` have a key-value pair for herself in the fungible token contract.

```rust
#[near(serializers = [json])]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// ‚Ä¶
// Logic that calls the nDAI token contract, asking for alice.near's storage balance.
// ‚Ä¶

#[private]
pub fn my_callback(&mut self, #[callback] storage_balance: StorageBalance) {
    // ‚Ä¶
}
```

The crossword puzzle will eventually use a cross-contract call and callback, so we can look forward to that. For now just know that if your contract expects to receive a return value that's not a primitive (unsigned integer, string, etc.) and is more complex, you may use a struct to give it the proper type.

## Using enums

In the section above, we saw two fields in the structs that had an enum type:

1.`AnswerDirection` ‚Äî this is the simplest type of enum, and will look familiar from other programming languages. It provides the only two options for how a clue in oriented in a crossword puzzle: across and down.

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub enum AnswerDirection {
    Across,
    Down,
}
```

2. `PuzzleStatus` ‚Äî this enum can actually store a string inside the `Solved` structure. (Note that we could have simply stored a string instead of having a structure, but a structure might make this easier to read.)

As we improve our crossword puzzle, the idea is to give the winner of the crossword puzzle (the first person to solve it) the ability to write a memo. (For example: "Took me forever to get clue six!", "Alice rules!" or whatever.)

```rust
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub enum PuzzleStatus {
    Unsolved,
    Solved { memo: String },
}
```


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/03-actions.md 

 ---
sidebar_position: 4
sidebar_label: "Actions and sending NEAR"
title: "There are several Actions an account can do, including sending the winner of the crossword puzzle NEAR using the Transfer Action"
---
import {Github} from "@site/src/components/codetabs"

import allActions from '/docs/assets/crosswords/crossword-actions.png';
import transferNEAR from '/docs/assets/crosswords/transfer-brand-blue--qiqi04.near--blankworl.png';
import yoctoNEAR from '/docs/assets/crosswords/yoctoNEAR-magnifying--jrbemint.near--JrbeMad.jpg';
import signerPredecessorCurrent from '/docs/assets/crosswords/predecessor-signer-current--yasuoarts.near--YasuoArt69.png';

# Actions (including sending NEAR)

We're going to introduce a new Action: `Transfer`. In this chapter, we'd like the first person to solve the crossword puzzle to earn some prize money, sent in NEAR.

<figure>
    <img src={transferNEAR} alt="Two hands exchanging a coin emblazoned with the NEAR Protocol logo. Art created by qiqi04.near" width="400"/>
    <figcaption className="small">Art by <a href="https://twitter.com/blankworl" target="_blank" rel="noopener noreferrer">qiqi04.near</a></figcaption>
</figure>
<br/>

We've already used Actions in the [previous chapter](/tutorials/crosswords/basics/hashing-and-unit-tests#first-use-of-batch-actions), when we deployed and initialized the contract, which used the `DeployContract` and `FunctionCall` Action, respectively.

The full list of Actions are available at the [NEAR specification site](https://nomicon.io/RuntimeSpec/Actions.html).

By the end of this entire tutorial we'll have used all the Actions highlighted below:

<img src={allActions} alt="All Actions that will be used when the entire crossword puzzle tutorial is complete" width="600"/>

## Actions from within a contract

When we deployed and initialized the contract, we used NEAR CLI in our Terminal or Command Prompt app. At a high level, this might feel like we're lobbing a transaction into the blockchain, instructing it to do a couple actions.

It's important to note that you can also execute Actions inside a smart contract, which is what we'll be doing. In the sidebar on the left, you'll see a section called [**Promises**](../../../2.build/2.smart-contracts/anatomy/actions.md), which provides examples of this. Perhaps it's worth mentioning that for the Rust SDK, Promises and Actions are somewhat synonymous.

:::note Actions only effect the current contract
A contract cannot use the `AddKey` Action on another account, including the account that just called it. It can only add a key to *itself*, if that makes sense.

The same idea applies for the other actions as well. You cannot deploy a contract to someone else's account, or delete a different account. (Thankfully üòÖ)

Similarly, when we use the `Transfer` Action to send the crossword puzzle winner their prize, the amount is being subtracted from the account balance of the account where the crossword contract is deployed.

The only interesting wrinkle (and what may *seem like* an exception) is when a subaccount is created using the `CreateAccount` Action. During that transaction, you may use Batch Actions to do several things like deploy a contract, transfer NEAR, add a key, call a function, etc. This is common in smart contracts that use a factory pattern, and we'll get to this in future chapters of this tutorial.
:::

## Define the prize amount

Let's make it simple and hardcode the prize amount. This is how much NEAR will be given to the first person who solves the crossword puzzle, and will apply to all the crossword puzzles we add. We'll make this amount adjustable in future chapters.

At the top of the `lib.rs` file we'll add this constant:

<Github language="rust" start="10" end="11" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/master/contract/src/lib.rs" />

As the code comment mentions, this is 5 NEAR, but look at all those zeroes in the code!

That's the value in yoctoNEAR. This concept is similar to other blockchains. Bitcoin's smallest unit is a satoshi and Ethereum's is a wei.

<figure>
    <img src={yoctoNEAR} alt="Depiction of bills of NEAR, coins for partial NEAR, and then a magnifying glass showing a tiny yoctoNEAR next to an ant. Art created by jrbemint.near"/>
    <figcaption className="full-width">Art by <a href="https://twitter.com/JrbeMad" target="_blank" rel="noopener noreferrer">jrbemint.near</a></figcaption>
</figure>

## Adding `Transfer`

In the last chapter we had a simple function called `guess_solution` that returned `true` if the solution was correct, and `false` otherwise. We'll be replacing that function with `submit_solution` as shown below:

<Github language="rust" start="85" end="118" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/master/contract/src/lib.rs" />

Note the last line in this function, which sends NEAR to the predecessor.

:::info Returning a Promise
The last line of the function above ends with a semicolon. If the semicolon were removed, that would tell Rust that we'd like to return this Promise object.

It would be perfectly fine to write the function like this:

```rust
pub fn submit_solution(&mut self, solution: String, memo: String) -> Promise {
    // ‚Ä¶
    // Transfer the prize money to the winner
    Promise::new(env::predecessor_account_id()).transfer(PRIZE_AMOUNT)
}
```
:::

## Predecessor, signer, and current account

When writing a smart contract you'll commonly want to use `env` and the details it provides. We used this in the last chapter for:

- logging (ex: `env::log_str("hello friend")`)
- hashing using sha256 (ex: `env::sha256(solution.as_bytes())`)

There are more functions detailed in the [SDK reference docs](https://docs.rs/near-sdk/latest/near_sdk/env/index.html).

Let's cover three commonly-used functions regarding accounts: predecessor, signer, and current account.

<figure>
    <img src={signerPredecessorCurrent} alt="Illustration of Alice sending a transaction to a smart contract named Banana, which does a cross-contract call to the smart contract Cucumber. Art created by yasuoarts.near"/>
    <figcaption className="full-width">Alice sends a transaction to the contract on banana.near, which does a cross-contract call to cucumber.near.<br/>From the perspective of a contract on cucumber.near, we see a list of the predecessor, signer, and current account.<br/>Art by <a href="https://twitter.com/YasuoArt69" target="_blank" rel="noopener noreferrer">yasuoarts.near</a></figcaption>
</figure><br/><br/>

1. [predecessor account](https://docs.rs/near-sdk/latest/near_sdk/env/fn.predecessor_account_id.html) ‚Äî `env::predecessor_account_id()`

    This is the account that was the immediate caller to the smart contract. If this is a simple transaction (no cross-contract calls) from **alice.near** to **banana.near**, the smart contract at **banana.near** considers Alice the predecessor. In this case, Alice would *also* be the signer.

    :::tip When in doubt, use predecessor
    As we explore the differences between predecessor and signer, know that it's a more common **best practice to choose the predecessor**.

    Using the predecessor guards against a potentially malicious contract trying to "fool" another contract that only checks the signer.
    :::

2. [signer account](https://docs.rs/near-sdk/latest/near_sdk/env/fn.signer_account_id.html) ‚Äî `env::signer_account_id()`

    The signer is the account that originally *signed* the transaction that began the blockchain activity, which may or may not include cross-contract calls. If a function calls results in several cross-contract calls, think of the signer as the account that pushed over the first domino in that chain reaction.

    :::caution Beware of middlemen
    If your smart contract is checking the ownership over some assets (fungible token, NFTs, etc.) it's probably a bad idea to use the signer account.

    A confused or malicious contract might act as a middleman and cause unexpected behavior. If **alice.near** accidentally calls **evil.near**, the contract at that account might do a cross-contract call to **vulnerable-nft.near**, instructing it to transfer an NFT.

    If **vulnerable-nft.near** only checks the signer account to determine ownership of the NFT, it might unwittingly give away Alice's property. Checking the predecessor account eliminates this problem.
    :::

3. [current account](https://docs.rs/near-sdk/latest/near_sdk/env/fn.current_account_id.html) ‚Äî `env::current_account_id()`

    The current account is "me" from the perspective of a smart contract.

    :::tip Why would I use that?
    There might be various reasons to use the current account, but a common use case is checking ownership or handling callbacks to cross-contract calls.

    Many smart contracts will want to implement some sort of permission system. A common, rudimentary permission allows certain functions to only be called by the contract owner, AKA the person who owns a private key to the account for this contract.

    The contract can check that the predecessor and current account are the same, and trust offer more permissions like changing contract settings, upgrading the contract, or other privileged modifications.
    :::


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/04-adding-a-puzzle.md 

 ---
sidebar_position: 4
sidebar_label: "Add a puzzle"
title: "Adding a new puzzle now that we're using a collection that can contain multiple crossword puzzles"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import blankCrossword from '/docs/assets/crosswords/chapter-2-crossword-blank.png';
import teachingDeployment from '/docs/assets/crosswords/teaching-just-teacher--herogranada.near--GranadaHero.jpeg';
import recreatingSubaccount from '/docs/assets/crosswords/erase-recreate-subaccount--3one9.near--3one92.gif';

# Adding a puzzle

We're going to make a new puzzle, which means we need to provide the smart contract with a set of clues and info about the answers.

Of course, we'll not be sending the *answers* to the smart contract, otherwise everyone could see. We will, however, send details about each clue, including:

- The clue number
- Whether it's a down or across clue
- The coordinates (x and y position)
- The length of the clue. (How many letters)

Essentially, we're going to tell the smart contract enough information for an empty puzzle like this:

<img src={blankCrossword} alt="Blank crossword for chapter 2 of the crossword puzzle smart contract tutorial" width="600"/>
<br/>

(Note that we aren't showing the human-readable clues in the above screenshot, but we will provide that as well.)

## Building and deploying

Let's use the same steps we learned from the first chapter:

<figure>
    <img src={teachingDeployment} alt="Teacher shows chalkboard with instructions on how to properly deploy a smart contract. 1. Build smart contract. 2. Create a subaccount (or delete and recreate if it exists) 3. Deploy to subaccount. 4. Interact. Art created by herogranada.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/GranadaHero" target="_blank" rel="noopener noreferrer">herogranada.near</a></figcaption>
</figure>
<br/>

Navigate to the `contract` directory, then run:

```bash
cargo near build
```

If following from the previous chapter, you'll likely have a subaccount already created. For the purpose of demonstration, we're calling the subaccount (where we deploy the contract) `crossword.friend.testnet` and the parent account is thus `friend.testnet`.

Let's delete the subaccount and recreate it, to start from a blank slate.

<figure>
    <img src={recreatingSubaccount} alt="Animation of an alien in space with a computer deleting and re-writing the account crossword.friend.testnet Art by 3one9.near" width="600"/>
    <figcaption>Art by <a href="https://twitter.com/3one92" target="_blank" rel="noopener noreferrer">3one9.near</a></figcaption>
</figure>
<br/>

Here's how to delete and recreate the subaccount using NEAR CLI:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # Delete the subaccount and send remaining balance to friend.testnet
  near delete-account crossword.friend.testnet friend.testnet --networkId testnet
  
  # Create the subaccount again
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # Delete the subaccount and send remaining balance to friend.testnet
  near account delete-account crossword.friend.testnet beneficiary friend.testnet network-config testnet sign-with-keychain send

  # Create the subaccount again
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Deploy, calling the "new" method with the parameter for owner_id:
```bash
cargo near deploy build-non-reproducible-wasm crossword.friend.testnet with-init-call new json-args '{"owner_id": "crossword.friend.testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

Now we're ready to construct our new crossword puzzle and add it via the `new_puzzle` method. Let's start with the clues for this new puzzle.

## The clues

We're going to use these clues below for our improved puzzle. The **Answer** column will not get sent to the smart contract when we call `new_puzzle`.

| Number | Answer    | Clue | (x, y) coords | length |
| ----------- | ----------- | ----------- | ----------- | ----------- |
| 1 | paras | NFT market on NEAR that specializes in cards and comics. | (1, 1) | 5 |
| 2 | rainbowbridge | You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app | (0, 2) | 13 |
| 3 | mintbase | NFT market on NEAR with art, physical items, tickets, and more. | (9, 1) | 8 |
| 4 | yoctonear | The smallest denomination of the native token on NEAR. | (3, 8) | 9 |
| 5 | cli | You typically deploy a smart contract with the NEAR ___ tool. | (5, 8) | 3 |

The x and y coordinates have their origin in the upper-left side of the puzzle grid, and each row and column start at 0.

## Solution hash

Let's derive the sha256 hash using an [easy online tool](https://www.wolframalpha.com/input/?i=sha256+%22paras+rainbowbridge+mintbase+yoctonear+cli%22) (there are many other offline methods as well) to discover the solution hash:

```
    d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010
```

## Add the puzzle

Add a new puzzle using NEAR CLI with this long command, replacing `crossword.friend.testnet` with your subaccount:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call crossword.friend.testnet new_puzzle '{
      "solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010",
      "answers": [
      {
        "num": 1,
        "start": {
          "x": 1,
          "y": 1
        },
        "direction": "Down",
        "length": 5,
        "clue": "NFT market on NEAR that specializes in cards and comics."
      },
      {
        "num": 2,
        "start": {
          "x": 0,
          "y": 2
        },
        "direction": "Across",
        "length": 13,
        "clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"
      },
      {
        "num": 3,
        "start": {
          "x": 9,
          "y": 1
        },
        "direction": "Down",
        "length": 8,
        "clue": "NFT market on NEAR with art, physical items, tickets, and more."
      },
      {
        "num": 4,
        "start": {
          "x": 3,
          "y": 8
        },
        "direction": "Across",
        "length": 9,
        "clue": "The smallest denomination of the native token on NEAR."
      },
      {
        "num": 5,
        "start": {
          "x": 5,
          "y": 8
        },
        "direction": "Down",
        "length": 3,
        "clue": "You typically deploy a smart contract with the NEAR ___ tool."
      }
      ]
    }' --gas 100000000000000 --accountId crossword.friend.testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction crossword.friend.testnet new_puzzle json-args '{
      "solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010",
      "answers": [
      {
        "num": 1,
        "start": {
          "x": 1,
          "y": 1
        },
        "direction": "Down",
        "length": 5,
        "clue": "NFT market on NEAR that specializes in cards and comics."
      },
      {
        "num": 2,
        "start": {
          "x": 0,
          "y": 2
        },
        "direction": "Across",
        "length": 13,
        "clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"
      },
      {
        "num": 3,
        "start": {
          "x": 9,
          "y": 1
        },
        "direction": "Down",
        "length": 8,
        "clue": "NFT market on NEAR with art, physical items, tickets, and more."
      },
      {
        "num": 4,
        "start": {
          "x": 3,
          "y": 8
        },
        "direction": "Across",
        "length": 9,
        "clue": "The smallest denomination of the native token on NEAR."
      },
      {
        "num": 5,
        "start": {
          "x": 5,
          "y": 8
        },
        "direction": "Down",
        "length": 3,
        "clue": "You typically deploy a smart contract with the NEAR ___ tool."
      }
      ]
    }' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as crossword.friend.testnet network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Note that our contract name and the account we're calling this from are both `crossword.friend.testnet`. That's because we added a check at the top of `new_puzzle` to make sure the predecessor is the `owner_id`.

Now our smart contract has information about this second crossword puzzle.

Let's explore how to make our frontend have a login button and truly turn this into a decentralized app (dApp)!


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/05-logging-in.md 

 ---
sidebar_position: 5
sidebar_label: "Access keys and login 1/2"
title: "Covering access keys and login"
---

import chapter1Correct from '/docs/assets/crosswords/chapter-1-crossword-correct.gif';
import accessKeys from '/docs/assets/crosswords/keys-cartoon-good--alcantara_gabriel.near--Bagriel_5_10.png';
import functionCallAction from '/docs/assets/crosswords/function-call-action.png';
import tutorialAccessKeys from '/docs/assets/crosswords/access-keys.png';

# Logging in with NEAR

## Previously‚Ä¶

In the previous chapter we simply displayed whether the crossword puzzle was solved or not, by checking the solution hash against the user's answers.

<img src={chapter1Correct} width="600"/><br/><br/>

## Updates to transfer prize money

In this chapter, our smart contract will send 5 ‚ìÉ to the first person who solves the puzzle. For this, we're going to require the user to have a NEAR account and log in.

:::note Better onboarding to come
Later in this tutorial we won't require the user to have a NEAR account.

Since logging in is important for many decentralized apps, we'll show how this is done in NEAR and how it's incredibly unique compared to other blockchains.
:::

This transfer will occur when the first user to solve the puzzle calls the `submit_solution` method with the solution. During the execution of that function it will check that the user submitted the correct answer, then transfer the prize.

We'll be able to see this transfer (and other steps that occurred) in [NearBlocks Explorer](https://testnet.nearblocks.io).

But first let's talk about one of the most interesting superpowers of NEAR: access keys.

## Access keys

You might be familiar with other blockchains where your account name is a long string of numbers and letters. NEAR has an account system where your name is human-readable, like `friend.testnet` for testnet or `friend.near` for mainnet.

You can add (and remove) keys to your account on NEAR. There are two types of keys: full and function-call access keys.

The illustration below shows a keychain with a full-access key (the large, gold one) and two function-call access keys.

<figure>
    <img src={accessKeys} width="600" alt="A keychain with three keys. A large, gold key represents the full-access keys on NEAR. The two other keys are gray and smaller, and have detachable latches on them. They represent function-call access key. Art created by alcantara_gabriel.near" />
    <figcaption>Art by <a href="https://twitter.com/Bagriel_5_10" target="_blank" rel="noopener noreferrer">alcantara_gabriel.near</a></figcaption>
</figure>

### Full-access keys

Full-access keys are the ones you want to protect the most. They can transfer all the funds from your account, delete the account, or perform any of the other [Actions on NEAR](03-actions.md).

When we used the `near login` command in the [previous chapter](../01-basics/01-set-up-skeleton.md#creating-a-new-key-on-your-computer), that command asked the full-access key in the NEAR Wallet to use the `AddKey` Action to create another full-access key: the one we created locally on our computer. NEAR CLI uses that new key to deploy, make function calls, etc.

### Function-call access keys

Function-call access keys will specify:

- What contract it's allowed to call
- What method name(s) it's allowed to call (you can also specify all functions)
- How much allowance it's allowed to use on these function calls

It's only allowed to perform the `FunctionCall` Action.

<img src={functionCallAction} alt="List of NEAR Actions with a highlight on the FunctionCall Action" width="600"/>

### Example account with keys

Let's look at this `testnet` account that has one full-access key and two function-call access keys. As you can see, we use the [NEAR CLI](../../../4.tools/cli.md) to print this info.

```bash
near account list-keys friend.testnet network-config testnet now
```

```
+----+------------------------------------------------------+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| #  | Public Key                                           | Nonce           | Permissions                                                                                                                                                                                        |
+----+------------------------------------------------------+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| 1  | ed25519:QqggnQNPRh5rqxL5PCPSS8qbZyrm6KHBbjne3U9TDGN  | 72772126000000  | do any function calls on puzzle.testnet with an allowance of 777 NEAR                                                                                                        |
| 2  | ed25519:FgsZoPqnSkuvoR6BZzXUY48tb5UfaCrRfg8kf4vyRg4F | 72777733000000  | only do ["foo", "bar"] function calls on puzzle.testnet with an allowance of 0.250 NEAR                                                                                  |
| 3  | ed25519:Hht8gURhPpDB2muhZhkEgxbdy4c2CPiQdUDMVuK7zDLd | 72770704000019  | full access                                                                                                                                                                                        |
+----+------------------------------------------------------+-----------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```

Let's look deeper into each key.

#### First key

```sh
| 1  | ed25519:QqggnQNPRh5rqxL5PCPSS8qbZyrm6KHBbjne3U9TDGN  | 72772126000000  | do any function calls on puzzle.testnet with an allowance of 777 NEAR                                                                                                        |
```

The first key in the image above is a function-call access key that can call the smart contract `puzzle.testnet` on **any method**. If you don't specify which methods it's allowed to call, it is allowed to call them all. Note the empty array (`[]`) next to `method_names`, which indicates this.

We won't discuss the nonce too much, but know that in order to prevent the possibility of [replay attacks](https://en.wikipedia.org/wiki/Replay_attack), the nonce for a newly-created key is large and includes info on the block height as well as a random number.

The allowance is the amount, in yoctoNEAR, that this key is allowed to use during function calls. This **cannot** be used to transfer NEAR. It can only be used in gas for function calls.

The allowance on this key is intentionally large for demonstration purposes. `777000000000000000000000000` yoctoNEAR is `777` NEAR, which is unreasonably high for an access key. So high, in fact, that it exceeded the amount of NEAR on the contract itself when created. This shows that you can create an access key that exceeds the account balance, and that it doesn't subtract the allowance at the time of creation.

So the key is simply allowed to use the allowance in NEAR on gas, deducting from the account for each function call.

#### Second key

```sh
| 2  | ed25519:FgsZoPqnSkuvoR6BZzXUY48tb5UfaCrRfg8kf4vyRg4F | 72777733000000  | only do ["foo", "bar"] function calls on puzzle.testnet with an allowance of 0.250 NEAR                                                                                  |
```

This second key specifies which methods can be called, and has a lower allowance.

Note that the allowance for this key (a quarter of a NEAR) is the default allowance when a person "logs in" in with the NEAR Wallet.

In NEAR, "logging in" typically means adding a key like this to your account. We'll cover this more in a moment.

#### Third key

```sh
| 3  | ed25519:Hht8gURhPpDB2muhZhkEgxbdy4c2CPiQdUDMVuK7zDLd | 72770704000019  | full access                                                                                                                                                                                        |
```

The third key is a full-access key.

Since this key can perform all the Actions, there aren't additional details or restrictions like the function-call access keys we saw.

## What does "log in" mean in a blockchain context?

Let's take a step back from NEAR and talk about how login works broadly using web3 wallets.

A web3 wallet (like Ethereum's MetaMask, Cosmos's Keplr, or the NEAR Wallet) stores a private key for an account. When interacting with decentralized apps, a user will typically use the wallet to sign transactions and send them to the blockchain for processing.

However, web3 wallets can also be used to sign any kind of message, and it doesn't need to send anything to the blockchain. This is sometimes called "offline signing" and protocols will sometimes create standards around how to sign data.

In other ecosystems, the idea of "logging in" with a web3 wallet uses this offline signing. A user is asked to sign a structured message and a backend can confirm that the message was signed by a given account.

NEAR keys can also sign and verify messages in this manner. In fact, there are a couple simple examples of how to achieve this in the [`near-api-js` cookbook](https://github.com/near/near-api-js/blob/master/packages/cookbook/utils/verify-signature.js).

There are potential drawbacks to this offline signing technique, particularly if a signed message gets intercepted by a malicious party. They might be able to send this signature to a backend and log in on your behalf. Because this all takes place offline, there's no mechanism on-chain to revoke your login or otherwise control access. We quickly see that using a web3 wallet for signed typed data runs into limitations.

So signing a message is fine, but what if we could do better?

With NEAR, we can leverage access keys to improve a user's login experience and give the power back to the user.

If I log into the [Guest Book example site](https://github.com/near-examples/guest-book-examples/tree/main/frontend), I create a unique key just for that dApp, adding it to my account. When I'm done I can remove the key myself. If I suspect someone has control of my key (if a laptop is stolen, for example) I can remove the key as long as I have a full-access key in my control.

Logging in with NEAR truly gives the end user control of their account and how they interact with dApps, and does so on the protocol level.

---

The concept of access keys is so important that we've spent longer than usual on the topic without actually implementing code for our improved crossword puzzle.

Let's move to the next section and actually add the login button.


 This is the content for the doc docs/3.tutorials/crosswords/02-beginner/06-logging-in-implementation.md 

 ---
sidebar_position: 6
sidebar_label: "Access keys and login 2/2"
title: "Implementing the login button"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import loggingIn from '/docs/assets/crosswords/logging-in.png';
import explorerTransfer from '/docs/assets/crosswords/chapter-2-explorer-transfer.jpg';

# Add the login functionality

## Plan

We're going to add a login button that uses `near-api-js` to login with NEAR.

Below is the workflow of logging in:

<img src={loggingIn} alt="Three steps to logging in. 1. click the login button we will build. 2. It creates a private key in the browser local storage. 3. Redirected to NEAR Wallet where you sign, creating a new key"/><br/><br/>

1. User clicks the login button
2. `near-api-js` creates a private key in the browser
3. A redirect to NEAR Wallet occurs, passing the public key. NEAR Wallet (often) has a full-access key capable of the `AddKey` action. The user follows a wizard, ultimately authorizing the creation of a new key.

## Adding the button

In the `src` directory we'll look at:

- `index.js`
- `App.js`

We won't go over every change, but instead point to the new logic.

First we set up a `WalletConnection` object from our JavaScript library:

<Github language="js" start="12" end="20" url="https://github.com/near-examples/crossword-tutorial-chapter-2/blob/1d64bf29c3376a18c71e5c5a075e29824d7a55f5/src/index.js" />

It's then used in React:

```js
const signIn = () => {
  walletConnection.requestSignIn(
    nearConfig.contractName,
    '', // title. Optional, by the way
    '', // successUrl. Optional, by the way
    '', // failureUrl. Optional, by the way
  );
};

const signOut = () => {
  walletConnection.signOut();
  ‚Ä¶
};

‚Ä¶

return (
  <div id="page">
    <h1>NEAR Crossword Puzzle</h1>
    <div id="crossword-wrapper">
      <div id="login">
        { currentUser
          ? <button onClick={signOut}>Log out</button>
          : <button onClick={signIn}>Log in</button>
        }
      </div>
      ‚Ä¶
    </div>
  </div>
);
```

Once logged in, that `WalletConnection` object will be tied to the logged-in user, and they'll use that key to sign transactions and interact with the contract.

:::info Transactions that redirect to NEAR Wallet
In our improved crossword puzzle, the function-call access key for the logged-in user will be signing a transaction to submit their solution.

You may notice, however, that sometimes you'll be redirected to NEAR Wallet, and other times you aren't.

This goes back to an earlier rule we mentioned: function-call access keys cannot send NEAR. They cannot perform the `Transfer` Action.

If a function call requires even 1 yoctoNEAR, NEAR Wallet (or any other wallet containing a full-access key) is required to sign the transaction.
:::

## Call the contract function from JavaScript

The frontend code contains a check to see if the user has completed the crossword puzzle successfully. In there we'll add logic to call the `submit_solution` function on the smart contract.

```js
// Send the 5 NEAR prize to the logged-in winner
let functionCallResult = await walletConnection.account().functionCall({
  contractId: nearConfig.contractName,
  methodName: 'submit_solution',
  args: {solution: seedPhrase, memo: "Yay I won!"},
  gas: DEFAULT_FUNCTION_CALL_GAS, // optional param, by the way
  attachedDeposit: 0,
  walletMeta: '', // optional param, by the way
  walletCallbackUrl: '' // optional param, by the way
});

if (functionCallResult && functionCallResult.transaction && functionCallResult.transaction.hash) {
  // Display a link the NEAR Explorer
  console.log('Transaction hash for explorer', functionCallResult.transaction.hash)
}
```

:::tip try‚Ä¶catch blocks
It's not a bad idea to wrap these type of calls in try‚Ä¶catch blocks to properly handle any errors that come from the blockchain.

These errors can be quite helpful to the developer and the end user.
:::

## Fetch the puzzle, finish up

In the previous chapter, the frontend had a hardcoded file containing information about the clues for a simple crossword puzzle. In this chapter, we've given the coordinates and details about the clues, but the frontend needs to fetch this information.

We're going to modify the logic surrounding our view-only call to `get_unsolved_puzzles` on the contract. This method now returns the clue information, so we've implemented a function that puts it in the proper format for React to construct the crossword puzzle.

This is a tutorial about Rust smart contract development, so we won't focus on the details of this, but know we've added the function `mungeBlockchainCrossword`. This allows us to keep adding custom crossword puzzles and have the frontend be dynamic.

We'll also make other minor changes like adding a page for when there are no puzzles available, and adding a loading screen.

## Run the React app

If you've been following this guide closely, you'll likely just need to start the React app with:

```bash
env CONTRACT_NAME=crossword.friend.testnet npm run start
```

As a helpful reminder, below has the steps necessary to recreate the subaccount, build the contract, deploy the subaccount, and call methods on the contract.

Go into the directory containing the Rust smart contract and build it:

```bash
cd contract

# Build
cargo near build
```

Create fresh account if you wish, which is good practice:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # Delete an account
  near delete-account crossword.friend.testnet friend.testnet --networkId testnet
  
  # Create an account again
  near create-account crossword.friend.testnet --use-account friend.testnet --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # Delete an account
  near account delete-account crossword.friend.testnet beneficiary friend.testnet network-config testnet sign-with-keychain send

  # Create an account again
  near account create-account fund-myself crossword.friend.testnet '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Deploy the contract:

```bash
cargo near deploy build-non-reproducible-wasm crossword.friend.testnet with-init-call new json-args '{"owner_id": "crossword.friend.testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

Add the crossword puzzle:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near call crossword.friend.testnet new_puzzle '{"solution_hash":"d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010","answers":[{"num": 1,"start": {"x": 1,"y": 1},"direction": "Down","length": 5,"clue": "NFT market on NEAR that specializes in cards and comics."},{"num": 2,"start": {"x": 0,"y": 2},"direction": "Across","length": 13,"clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"},{"num": 3,"start": {"x": 9,"y": 1},"direction": "Down","length": 8,"clue": "NFT market on NEAR with art, physical items, tickets, and more."},{"num": 4,"start": {"x": 3,"y": 8},"direction": "Across","length": 9,"clue": "The smallest denomination of the native token on NEAR."},{"num": 5,"start": {"x": 5,"y": 8},"direction": "Down","length": 3,"clue": "You typically deploy a smart contract with the NEAR ___ tool."}]}' --gas 100000000000000 --accountId crossword.friend.testnet --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-transaction crossword.friend.testnet new_puzzle json-args '{"solution_hash":"d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010","answers":[{"num": 1,"start": {"x": 1,"y": 1},"direction": "Down","length": 5,"clue": "NFT market on NEAR that specializes in cards and comics."},{"num": 2,"start": {"x": 0,"y": 2},"direction": "Across","length": 13,"clue": "You can move assets between NEAR and different chains, including Ethereum, by visiting ______.app"},{"num": 3,"start": {"x": 9,"y": 1},"direction": "Down","length": 8,"clue": "NFT market on NEAR with art, physical items, tickets, and more."},{"num": 4,"start": {"x": 3,"y": 8},"direction": "Across","length": 9,"clue": "The smallest denomination of the native token on NEAR."},{"num": 5,"start": {"x": 5,"y": 8},"direction": "Down","length": 3,"clue": "You typically deploy a smart contract with the NEAR ___ tool."}]}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as crossword.friend.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Return to the project root and start the React app:

```bash
cd ..
env CONTRACT_NAME=crossword.friend.testnet npm run start
```

## For kicks

For fun, try interacting with the smart contract using the React frontend and the CLI. We can check the status of the puzzle using the CLI, solve the puzzle with the frontend, and check the status again.

Before and after solving the puzzle, run this command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view crossword.friend.testnet get_puzzle_status '{"solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only crossword.friend.testnet get_puzzle_status json-args '{"solution_hash": "d1a5cf9ad1adefe0528f7d31866cf901e665745ff172b96892693769ad284010"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This will return our enum `PuzzleStatus`. Before solving the puzzle it should print:

```json
    'Unsolved'
```

and after:

```json
    { Solved: { memo: 'Yay I won!' } }
```

After you solve the crossword puzzle you'll see a screen with a link to NEAR Explorer to look at the details of the transaction. Notice we have our `Transfer` Action in there:

<figure>
    <img src={explorerTransfer} alt="Screenshot from the NEAR Explorer highlighting a place in the transaction where 5 NEAR is sent to mike.testnet"/>
</figure>
<br/>

---

That's it for this chapter! As a reminder the full code is available at:

https://github.com/near-examples/crossword-tutorial-chapter-2


 This is the content for the doc docs/3.tutorials/crosswords/03-intermediate/00-overview.md 

 ---
sidebar_position: 1
sidebar_label: "Overview"
title: "Intermediate concepts (cross-contract calls and more)"
---

import accessKeys from '/docs/assets/crosswords/keys-cartoon-good--alcantara_gabriel.near--Bagriel_5_10.png';

# Intermediate concepts

This chapter will go a bit faster than the previous ones.

We're going to be covering an important part of smart contract development: cross-contract calls.

## Cross-contract calls

A cross-contract call is when a smart contract calls another smart contract. For instance, if `alice.near` calls contract A, and contract A makes a call to contract B.

NEAR has asynchronous transactions, and some cross-contract calls will have callbacks in order to determine the result of the call. This works a bit different from other blockchains, as we'll explain more in this chapter.

## Access keys

Last chapter covered access keys, and we implemented a login system where a user "logs in" by adding a function-call access key to their account which is tied to the crossword puzzle dApp.

Login is a common use case for access keys, but let's think bigger!

Remember the two (smaller, gray) function-call access keys from the keychain illustration?

<figure>
    <img src={accessKeys} width="600" alt="A keychain with three keys. A large, gold key represents the full-access keys on NEAR. The two other keys are gray and smaller, and have detachable latches on them. They represent function-call access key. Art created by alcantara_gabriel.near" />
    <figcaption>Art by <a href="https://twitter.com/Bagriel_5_10" target="_blank" rel="noopener noreferrer">alcantara_gabriel.near</a></figcaption>
</figure><br/>

Notice that they have a clasp to make them removable.

While it's unlikely you'll want to give another person a full-access key, there are times when you could give a function-call access key to another person or make it public. Why? This can help enable a smooth onboarding experience, as we'll do soon.

## Completed project

Here's the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-3


 This is the content for the doc docs/3.tutorials/crosswords/03-intermediate/01-access-key-solution.md 

 ---
sidebar_position: 2
sidebar_label: "Solution as seed phrase"
title: "Replacing the solution hash with an access key"
---

import puzzleFrontrun from '/docs/assets/crosswords/puzzle-frontrun.png';
import padlockSafe from '/docs/assets/crosswords/safe-with-access-key--soulless.near--ZeroSerotonin__.png';

# Replacing our solution hash

So far in this tutorial, the user sends the plaintext solution to the crossword puzzle smart contract, where it's hashed and compared with the known answer.

This works, but we might want to be more careful and avoid sending the plaintext solution.

## Why?

Blockchains rely on many computers processing transactions. When you send a transaction to the blockchain, it doesn't immediately get processed. In some Layer 1 blockchains it can take minutes or longer. On NEAR transactions settle within a couple seconds, but nonetheless there's a small period of waiting time.

When we previously sent the crossword puzzle solution in plain text (via the parameter `solution` to `submit_solution`) it means it's visible to everyone before it gets processed.

At the time of this writing, there haven't been outstanding incidents of validators "front-running" transactions, but it's something to be aware of. Front-running is when a validator sees a transaction that might be profitable and does it themselves.

There have been several incidents of this and it continues to be an issue.

<figure>
    <img src={puzzleFrontrun} alt="Tweet talking about a puzzle where tens of thousands of dollars were taken because of a frontrun attack" width="600"/>
    <figcaption>Real-life example of a puzzle being front-run.<br/>Read <a href="https://twitter.com/_anishagnihotri/status/1444113372715356162" target="_blank" rel="noopener noreferrer">Anish Agnihotri's thread</a></figcaption>
</figure>
<br/>

## How?

We're going to do something unique ‚Äî and frankly unusual ‚Äî with our crossword puzzle. We're going to use function-call access keys in a new way.

Our crossword puzzle smart contract will add a function-call access key to itself. The private key is derived from the solution, used as a seed phrase.

:::info What's a seed phrase, again?
A private key is essentially a very large number. So large that the number of possible private keys is approaching the estimated number of atoms in the known universe.

It would be pretty long if we wrote it down, so it's often made human-readable with numbers and letters. However, even the human-readable version is hard to memorize and prone to mistakes.

A seed phrase is a series of words (usually 12 or 24 words) that create a private key. (There's actually a [bit more to it](https://learnmeabitcoin.com/technical/mnemonic).)

Seed phrases typically use a [BIP-30 wordlist](https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md), but *they do not need to* use a wordlist or have a certain number of words. As long as the words create entropy, a crossword puzzle solution can act as a deterministic seed phrase.
:::

So when we add a new puzzle, we'll use the `AddKey` Action to add a limited, function-call access key that can *only* call the `submit_solution` method.

The first user to solve the puzzle will essentially "discover" the private key and call that method. Think of it like a safe that contains a function-call access key.

<figure>
    <img src={padlockSafe} alt="A small safe with a padlock containing words to a seed phrase, and you can see through the safe, showing it holds a function-call access key. Art created by soulless.near."/>
    <figcaption className="full-width">Open the safe using answers to the puzzle, revealing the function-call access key.<br/>Art by <a href="https://twitter.com/ZeroSerotonin__" target="_blank" rel="noopener noreferrer">soulless.near</a></figcaption>
</figure><br/>

Our method `submit_solution` no longer needs to hash the plaintext answer, but instead looks at the key that signed this transaction. Cool, huh!

## Onboarding

In the previous chapter we implemented login to the crossword, but this requires a person to have a NEAR account.

If the end user is discovering a key that exists on the crossword contract, they don't even need a NEAR account, right? Well, that's partly accurate, but we'll still need to send the prize in NEAR somewhere.

What if we could make the winner an account on the fly? Is that possible? Yes, and that's what we're going to do in this chapter.




 This is the content for the doc docs/3.tutorials/crosswords/03-intermediate/02-use-seed-phrase.md 

 ---
sidebar_position: 3
sidebar_label: "Seed phrase logic"
title: "Implementing the seed phrase logic from the necessary libraries"
---

# Seed phrase and key derivation

There are two separate things we'll want to do:

1. **Create a random seed phrase** for the user when they visit the crossword puzzle. This will be used if they win and don't have a NEAR account and wish to create one. They can then paste this seed phrase into NEAR Wallet afterward to import their account (which is basically like "logging in" and is currently possible at https://testnet.mynearwallet.com/recover-seed-phrase).
2. **Turn the crossword solution into a key pair**, instead of just hashing it.

## near-seed-phrase library

We can add the `near-seed-phrase` package to our project with:

```bash
npm install near-seed-phrase --save
```

:::note Code snippets for this chapter
At this point in the tutorial, it's more difficult to share code snippets that are both meaningful and meant to be copy/pasted into a project.

The snippets provided might differ slightly from the implementation of the [completed code for chapter 3](https://github.com/near-examples/crossword-tutorial-chapter-3), which might be the best place to look for the functioning code.
:::

## Generate random seed phrase for new account creation (if the winner doesn't already have an account)

```js
import { generateSeedPhrase } from 'near-seed-phrase';

// Create a random key in here
let seedPhrase = generateSeedPhrase(); // generateSeedPhrase() returns an object {seedPhrase, publicKey, secretKey}
localStorage.setItem('playerKeyPair', JSON.stringify(seedPhrase));
```

## Parse solution as seed phrase

(This security measure prevents front-running.)

```js
import { parseSeedPhrase } from 'near-seed-phrase';
// Get the seed phrase from the completed puzzle.
// The original puzzle creator would have already called this same function with the same inputs and would have
// already called `AddKey` on this contract to add the key related to this seed phrase. Here, using this deterministic
// function, the front-end will automatically generate that same key based on the inputs from the winner.
const seedPhrase = parseSolutionSeedPhrase(data, gridData); // returns a string of space-separated words
// Get the public and private key derived from the seed phrase
const {secretKey, publicKey} = parseSeedPhrase(seedPhrase);

// Set up the account and connection, acting on behalf of the crossword account
const keyStore = new nearAPI.keyStores.InMemoryKeyStore(); // Another type of key
const keyPair = nearAPI.utils.key_pair.KeyPair.fromString(secretKey);
await keyStore.setKey(nearConfig.networkId, nearConfig.contractName, keyPair);
nearConfig.keyStore = keyStore;
const near = await nearAPI.connect(nearConfig);
const crosswordAccount = await near.account(nearConfig.contractName);

// Call the submit_solution method using the discovered function-call access key
let transaction = await crosswordAccount.functionCall(‚Ä¶);
```

The last line should look familiar. We did something similar in the last chapter, except we used the `WalletConnection`'s account to do the function call.

This time we're using an `InMemoryKeyStore` instead of the browser, as you can see toward the middle of the snippet.

### Key stores

We have now used almost all the key stores available in `near-api-js`:

1. `UnencryptedFileSystemKeyStore` ‚Äî early on, when we used the NEAR CLI command `near login`, this created a file in our operating system's home directory containing a private, full-access key to our account.
2. `BrowserLocalStorageKeyStore` ‚Äî in the last chapter, when the user first logs in, the function-call access key is saved in the browser's local storage.
3. `InMemoryKeyStore` ‚Äî for this chapter, we'll simply use the computer's memory to store the private key derived from the crossword solution.

:::tip You can have multiple key stores
Technically, there's another type of key store called the `MergeKeyStore`.

Say you want to look for private keys in various directories. You can essentially have a list of `UnencryptedFileSystemKeyStore` key stores that look in different places.

Use the `MergeKeyStore` when you might want to look for a private key in more than one place.
:::


 This is the content for the doc docs/3.tutorials/crosswords/03-intermediate/03-linkdrop.md 

 ---
sidebar_position: 4
sidebar_label: "Linkdrop contract"
title: "Introducing the linkdrop contract we can use"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

import createMainnetAccount from '/docs/assets/crosswords/create-mainnet-account.png';
import createTestnetAccount from '/docs/assets/crosswords/create-testnet-wallet-account.png';

# The linkdrop contract

We're going to take a small detour to talk about the linkdrop smart contract.  It's best that we first understand this contract and its purpose, then discuss calling a method on this contract.

[The linkdrop contract](https://github.com/near/near-linkdrop) is deployed to the accounts `testnet` and `near`, which are known as the top-level accounts of the testnet and mainnet network, respectively. (Anyone can create a linkdrop-style contract elsewhere, but the one shown here is the main one that others are patterned off of.)

## Testnet

There‚Äôs nothing special about testnet accounts; there is no real-world cost to you as a developer when creating testnet accounts, so feel free to create or delete at your convenience.

When a user signs up for a testnet account on NEAR Wallet, they'll see this:

<img src={createTestnetAccount} width="400" />

Let's discuss how this testnet account gets created.

Notice the new account will end in `.testnet`. This is because the account `testnet` will create a subaccount (like we learned about [earlier in this tutorial](../01-basics/02-add-functions-call.md#create-a-subaccount)) called `vacant-name.testnet`.

There are two ways to create this subaccount:

1. Use a full-access key for the account `testnet` to sign a transaction with the `CreateAccount` Action.
2. In a smart contract deployed to the `testnet` account, call the `CreateAccount` Action, which is an async method that returns a Promise. (More info about writing a [`CreateAccount` Promise](../../../2.build/2.smart-contracts/anatomy/actions.md#create-a-sub-account))

(In the example below that uses NEAR CLI to create a new account, it's calling `CreateAccount` on the linkdrop contract that is deployed to the top level "near" account on mainnet.)


## Mainnet

On mainnet, the account `near` also has the linkdrop contract deployed to it.

Using NEAR CLI, a person can create a `mainnet` account by calling the linkdrop contract, like shown below:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call near create_account '{"new_account_id": "aloha.near", "new_public_key": "3cQ...tAT"}' --gas 300000000000000 --deposit 15 --accountId mike.near --networkId mainnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction near create_account json-args '{"new_account_id": "aloha.near", "new_public_key": "3cQ...tAT"}' prepaid-gas '300.0 Tgas' attached-deposit '15 NEAR' sign-as mike.near network-config mainnet sign-with-keychain
    ```
  </TabItem>
</Tabs>

The above command calls the `create_account` method on the account `near`, and would create `aloha.near` **if it's available**, funding it with 15 ‚ìÉ.

We'll want to write a smart contract that calls that same method. However, things get interesting because it's possible `aloha.near` is already taken, so we'll need to learn how to handle that.

## A simple callback

### The `create_account` method

Here, we'll show the implementation of the `create_account` method. Note the `#[payable]` macro, which allows this function to accept an attached deposit. (Remember in the CLI command we were attaching 15 ‚ìÉ.)

<Github language="rust" start="128" end="152" url="https://github.com/near/near-linkdrop/blob/master/src/lib.rs" />

The most important part of the snippet above is around the middle where there's:

```rust
Promise::new(...)
    ...
    .then(
        Self::ext(env::current_account_id())
            .on_account_created(...)
    )
```

This translates to, "we're going to attempt to perform an Action, and when we're done, please call myself at the method `on_account_created` so we can see how that went."

:::caution This doesn't work

Not infrequently, developers will attempt to do this in a smart contract:

```rust
let creation_result = Promise::new("aloha.mike.near")
  .create_account();

// Check creation_result variable (can't do it!)
if creation_result {...}

```

In other programming languages promises might work like this, but we must use callbacks instead.
:::

### The callback

Now let's look at the callback:

<Github language="rust" start="199" end="212" url="https://github.com/near/near-linkdrop/blob/master/src/lib.rs" />

This calls the private helper method `is_promise_success`, which basically checks to see that there was only one promise result, because we only attempted one Promise:

<Github language="rust" start="35" end="45" url="https://github.com/near/near-linkdrop/blob/master/src/lib.rs" />

Note that the callback returns a boolean. This means when we modify our crossword puzzle to call the linkdrop contract on `testnet`, we'll be able to determine if the account creation succeeded or failed.

And that's it! Now we've seen a method and a callback in action for a simple contract.

:::tip This is important
Understanding cross-contract calls and callbacks is quite important in smart contract development.

Since NEAR's transactions are asynchronous, the use of callbacks may be a new paradigm shift for smart contract developers from other ecosystems.

Feel free to dig into the linkdrop contract and play with the ideas presented in this section.

There are two additional examples that are helpful to look at:
1. [High-level cross-contract calls](https://github.com/near/near-sdk-rs/blob/master/examples/cross-contract-calls/high-level/src/lib.rs) ‚Äî this is similar what we've seen in the linkdrop contract.
2. [Low-level cross-contract calls](https://github.com/near/near-sdk-rs/blob/master/examples/cross-contract-calls/low-level/src/lib.rs) ‚Äî a different approach where you don't use the traits we mentioned.
:::

---

Next we'll modify the crossword puzzle contract to check for the signer's public key, which is how we now determine if they solved the puzzle correctly.


 This is the content for the doc docs/3.tutorials/crosswords/03-intermediate/04-cross-contract-calls.md 

 ---
sidebar_position: 5
sidebar_label: "Cross-contract calls, etc."
title: "Adding cross-contract calls, access key shuffling, etc."
---
import {Github} from "@site/src/components/codetabs"

# Updating the contract

import shuffleKeys from '/docs/assets/crosswords/shuffle-keys.gif';
import clionSuggestion from '/docs/assets/crosswords/clion-suggestion.gif';
import carpenterAddingKey from '/docs/assets/crosswords/create-key-carpenter-near--carlcarlkarl.near--CarlCarlKarl.jpg';
import recycleKey from '/docs/assets/crosswords/remove-key-recycle--eerie_ram.near--eerie_ram.png';

To reiterate, we'd like anyone to be able to participate in the crossword puzzle, even folks who don't have a NEAR account.

The first person to win will "reserve their spot" and choose where to send the prize money: either an account they own or an account they'd like to create.

## Reserving their spot

### The plan

When a user first visits the crossword, they only see the crossword. No login button and no fields (like a `memo` field) to fill out.

On their first visit, our frontend will create a brand new, random seed phrase in their browser. We'll use this seed phrase to create the user's unique key pair. If a random seed phrase is already there, it skips this part. (We covered the code for this in [a previous section](02-use-seed-phrase.md#near-seed-phrase-library).)

If the user is the first to solve the puzzle, it discovers the function-call access key and calls `submit_solution` with that key. It's basically using someone else's key, as this key is on the crossword account.

**We'll be adding a new parameter** to the `submit_solution` so the user can include the random, public key we just stored in their browser.

During the execution of `submit_solution`, because contracts can use Promises to perform Actions, we'll remove the solution public key and add the user's public key.

This will lock out other attempts to solve the crossword puzzle and ensure there is only one winner.

<img src={shuffleKeys} width="600"/><br/><br/>

This means that a puzzle can have three states it can be in:

1. Unsolved
2. Solved and not yet claimed (not paid out)
3. Claimed and finalized

The previous chapter [we discussed enums](../02-beginner/02-structs-enums.md#using-enums), so this is simply modifying the enumeration variants.

### The implementation

First, let's see how the `submit_solution` will verify the correct solution.

<Github language="rust" start="136" end="142" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

Instead of hashing the plaintext, we simply check that the public key matches what we know the answer is. (The answer being the series of words representing the solution to the crossword puzzle, used as a seed phrase to create a key pair, including a public key.)

Further down in the `submit_solution` method we'll follow our plan by **adding a function-call access key** (that only the winner has) and removing the access key that was discovered by the winner, so no one else can use it.

<figure>
    <img src={carpenterAddingKey} alt="Illustration of a carpenter who has created a key. Art by carlcarlkarl.near" width="400"/>
    <figcaption className="small">Our smart contract is like this carpenter adding a key to itself.<br/>Art by <a href="https://twitter.com/CarlCarlKarl" target="_blank" rel="noopener noreferrer">carlcarlkarl.near</a></figcaption>
</figure>
<br/>

<Github language="rust" start="166" end="172" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

The first promise above adds an access key, and the second deletes the access key on the account that was derived from the solution as a seed phrase.

<figure>
    <img src={recycleKey} alt="Book showing pagination of hashes. Art created by eerie_ram.near" width="600"/>
    <figcaption>We delete the function-call access key so there is only one winner.<br/>Art by <a href="https://twitter.com/eerie_ram" target="_blank" rel="noopener noreferrer">eerie_ram.near</a></figcaption>
</figure>
<br/>

Note that the new function-call access key is able to call two methods we'll be adding:

1. `claim_reward` ‚Äî when the user has an existing account and wishes to send the prize to it
2. `claim_reward_new_account` ‚Äî when the user doesn't have an account, wants to create one and send the prize to it

Both functions will do cross-contract calls and use callbacks to see the result. We finally get to the meat of this chapter, let's go!

## Cross-contract calls

### The traits

We're going to be making a cross-contract call to the linkdrop account deployed to the `testnet` account. We're also going to have callbacks for that, and for a simple transfer to a (potentially existing) account. We'll create the traits that define both those methods.

<Github language="rust" start="17" end="43" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

:::tip
It's not necessary to create the trait for the callback as we could have just implemented the functions `callback_after_transfer` and `callback_after_create_account` in our `Crossword` struct implementation. We chose to define the trait and implement it to make the code a bit more readable.
:::

### `claim_reward`

Again, this function is called when the user solves the crossword puzzle and wishes to send the prize money to an existing account.

Seems straightforward, so why would we need a callback? We didn't use a callback in the previous chapter when the user logged in, so what gives?

It's possible that while claiming the prize, the user accidentally fat-fingers their username, or their cat jumps on their keyboard. Instead of typing `mike.testnet` they type `mike.testnzzz` and hit send. In short, if we try to send the prize to a non-existent account, we want to catch that.

For brevity, we'll skip some code in this function to focus on the Promise and callback:

```rust
pub fn claim_reward(
    &mut self,
    crossword_pk: PublicKey,
    receiver_acc_id: String,
    memo: String,
    ) -> Promise {
        let signer_pk = env::signer_account_pk();
        ...
        Promise::new(receiver_acc_id.parse().unwrap())
            .transfer(reward_amount)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_ACCOUNT_CALLBACK)
                    .callback_after_transfer(
                        crossword_pk,
                        receiver_acc_id,
                        memo,
                        env::signer_account_pk(),
                    ),
            )
    }
```

:::tip Your IDE is your friend

Oftentimes, the IDE can help you.

For instance, in the above snippet we have `receiver_acc_id.parse().unwrap()` which might look confusing. You can lean on code examples or documentation to see how this is done, or you can utilize the suggestions from your IDE.

:::

This `claim_reward` method will attempt to use the `Transfer` Action to send NEAR to the account specified. It might fail on a protocol level (as opposed to a smart contract failure), which would indicate the account doesn't exist.

Let's see how we check this in the callback:

<Github language="rust" start="372" end="400" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

:::info The `#[private]` macro
Notice that above the function, we have declared it to be private.

This is an ergonomic helper that checks to make sure the predecessor is the current account ID.

We actually saw this done "the long way" in the callback for the linkdrop contract in [the previous section](03-linkdrop.md#the-callback).

Every callback will want to have this `#[private]` macro above it.
:::

The snippet above essentially says it expects there to be a Promise result for exactly one Promise, and then sees if that was successful or not. Note that we're not actually getting a *value* in this callback, just if it succeeded or failed.

If it succeeded, we proceed to finalize the puzzle, like setting its status to be claimed and finished, removing it from the `unsolved_puzzles` collection, etc.

### `claim_reward_new_account`

Now we want to handle a more interesting case. We're going to do a cross-contract call to the smart contract located on `testnet` and ask it to create an account for us. This name might be unavailable, and this time we get to write a callback that *gets a value*.

Again, for brevity, we'll show the meat of the `claim_reward_new_account` method:

```rust
pub fn claim_reward_new_account(
    &mut self,
    crossword_pk: PublicKey,
    new_acc_id: String,
    new_pk: PublicKey,
    memo: String,
) -> Promise {
    ...
    ext_linkdrop::ext(AccountId::from(self.creator_account.clone()))
        .with_attached_deposit(reward_amount)
        .with_static_gas(GAS_FOR_ACCOUNT_CREATION) // This amount of gas will be split
        .create_account(new_acc_id.parse().unwrap(), new_pk)
        .then(
            // Chain a promise callback to ourselves
            Self::ext(env::current_account_id())
                .with_static_gas(GAS_FOR_ACCOUNT_CALLBACK)
                .callback_after_create_account(
                    crossword_pk,
                    new_acc_id,
                    memo,
                    env::signer_account_pk(),
                ),
        )
}
```

Then the callback:

<Github language="rust" start="401" end="433" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

In the above snippet, there's one difference from the callback we saw in `claim_reward`: we capture the value returned from the smart contract we just called. Since the linkdrop contract returns a bool, we can expect that type. (See the comments with "NOTE:" above, highlighting this.)

## Callbacks

The way that the callback works is that you start with the `Self::ext()` and pass in the current account ID using `env::current_account_id()`. This is essentially saying that you want to call a function that lives on the current account ID.

You then have a couple of config options that each start with `.with_*`:

1. You can attach a deposit of ‚ìÉ, in yocto‚ìÉ to the call by specifying the `.with_attached_deposit()` method but it is defaulted to 0 (1 ‚ìÉ = 1000000000000000000000000 yocto‚ìÉ, or 1^24 yocto‚ìÉ).
2. You can attach a static amount of GAS by specifying the `.with_static_gas()` method but it is defaulted to 0.
3. You can attach an unused GAS weight by specifying the `.with_unused_gas_weight()` method but it is defaulted to 1. The unused GAS will be split amongst all the functions in the current execution depending on their weights. If there is only 1 function, any weight above 1 will result in all the unused GAS being attached to that function. If you specify a weight of 0, however, the unused GAS will not be attached to that function. If you have two functions, one with a weight of 3, and one with a weight of 1, the first function will get 3/4 of the unused GAS and the other function will get 1/4 of the unused GAS.

After you've added the desired configurations to the call, you execute the function and pass in the parameters. In this case, we call the function `callback_after_create_account` and pass in the crossword public key, the new account ID, the memo, and the signer's public key.

This function will be called with static GAS equal to `GAS_FOR_ACCOUNT_CALLBACK` and will have no deposit attached. In addition, since the `with_unused_gas_weight()` method wasn't called, it will default to a weight of 1 meaning that it will split all the unused GAS with the `create_account` function to be added on top of the `GAS_FOR_ACCOUNT_CALLBACK`.

```rust
.then(
    // Chain a promise callback to ourselves
    Self::ext(env::current_account_id())
        .with_static_gas(GAS_FOR_ACCOUNT_CALLBACK)
        .callback_after_create_account(
            crossword_pk,
            new_acc_id,
            memo,
            env::signer_account_pk(),
        ),
)
```

:::tip Consider changing contract state in callback
It's not always the case, but often you'll want to change the contract state in the callback.

The callback is a safe place where we have knowledge of what's happened after cross-contract calls or Actions. If your smart contract is changing state *before* doing a cross-contract call, make sure there's a good reason for it. It might be best to move this logic into the callback.
:::

So what parameters should I pass into a callback?

There's no one-size-fits-all solution, but perhaps there's some advice that can be helpful.

Try to pass parameters that would be unwise to trust coming from another source. For instance, if an account calls a method to transfer some digital asset, and you need to do a cross-contract call, don't rely on the results of contract call to determine ownership. If the original function call determines the owner of a digital asset, pass this to the callback.

Passing parameters to callbacks is also a handy way to save fetching data from persistent collections twice: once in the initial method and again in the callback. Instead, just pass them along and save some CPU cycles.

## Checking the public key

The last simple change in this section is to modify the way we verify if a user has found the crossword solution.

In previous chapters we hashed the plaintext solution and compared it to the known solution's hash.

Here we're able to simply check the signer's public key, which is available in the `env` object [under `signer_account_pk`](https://docs.rs/near-sdk/latest/near_sdk/env/fn.signer_account_pk.html).

We'll do this check in both when the solution is submitted, and when the prize is claimed.

### When the crossword is solved

```rust
// The solver_pk parameter is the public key generated and stored in their browser
pub fn submit_solution(&mut self, solver_pk: PublicKey) {
    let answer_pk = env::signer_account_pk();
    // check to see if the answer_pk from signer is in the puzzles
    let mut puzzle = self
        .puzzles
        .get(&answer_pk)
        .expect("ERR_NOT_CORRECT_ANSWER");
```

### When prize is claimed

```rust
pub fn claim_reward(
    &mut self,
    crossword_pk: PublicKey,
    receiver_acc_id: String,
    memo: String,
) -> Promise {
    let signer_pk = env::signer_account_pk();
    ...
    // Check that puzzle is solved and the signer has the right public key
    match puzzle.status {
        PuzzleStatus::Solved {
            solver_pk: puzzle_pk,
        } => {
            // Check to see if signer_pk matches
            assert_eq!(signer_pk, puzzle_pk, "You're not the person who can claim this, or else you need to use your function-call access key, friend.");
        }
        _ => {
            env::panic_str("puzzle should have `Solved` status to be claimed");
        }
    };
    ...
}
```


 This is the content for the doc docs/3.tutorials/crosswords/03-intermediate/05-base64vecu8.md 

 ---
sidebar_position: 6
sidebar_label: "Base64 params, wrap up"
title: "Using base64-encoded arguments when we create a new crossword puzzle"
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Final modifications

import base64Encode from '/docs/assets/crosswords/boop-base64-encode.gif';

Let's modify our `new_puzzle` method a bit, and demonstrate how a smart contract author might use base64-encoded arguments.

In the previous chapter we had a fairly long NEAR CLI command that called the `new_puzzle`, providing it the parameters for all the clues. Having these lengthy parameters on the CLI might get cumbersome. There may be issues needing to escape single or double quotes, and each operating system may wish for a different format on the Terminal or Command Prompt.

We're going to send all the arguments as a base64-encoded string, and make this a bit simpler. For this, we're going to use [`Base64VecU8` from the SDK](https://docs.rs/near-sdk/latest/near_sdk/json_types/struct.Base64VecU8.html).

:::note `Base64VecU8` is great for binary payloads
What we're doing makes sense, but it's worth noting that it's perhaps more common to use `Base64VecU8` when sending binary parameters.

Read more [about it here](../../../2.build/2.smart-contracts/anatomy/serialization-interface.md).
:::

First we'll set up a struct for the arguments we're expecting:

<Github language="rust" start="103" end="108" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

Then we modify our `new_puzzle` method like so:

<Github language="rust" start="281" end="289" url="https://github.com/near-examples/crossword-tutorial-chapter-3/blob/master/contract/src/lib.rs" />

We can take our original arguments and base64 encode them, using whatever method you prefer. There are plenty of online tool, Terminal commands, and open source applications like [Boop](https://boop.okat.best).

We'll copy this:

```js
{
  "answer_pk": "ed25519:7PkKPmVUXcupA5oU8d6TbgyMwzFe8tPV6eV1KGwgo9xg",
  "dimensions": {
   "x": 11,
   "y": 10
  },
  "answers": [
   {
     "num": 1,
     "start": {
       "x": 0,
       "y": 1
     },
     "direction": "Across",
     "length": 12,
     "clue": "NEAR transactions are more ______ instead of atomic."
   },
   {
     "num": 2,
     "start": {
       "x": 6,
       "y": 0
     },
     "direction": "Down",
     "length": 7,
     "clue": "In a smart contract, when performing an Action, you use this in Rust."
   },
   {
     "num": 3,
     "start": {
       "x": 9,
       "y": 0
     },
     "direction": "Down",
     "length": 6,
     "clue": "In docs.rs when you search for the near-sdk crate, these items a considered a what: collections, env, json_types."
   },
   {
     "num": 4,
     "start": {
       "x": 1,
       "y": 1
     },
     "direction": "Down",
     "length": 10,
     "clue": "A series of words that can deterministically generate a private key."
   },
   {
     "num": 5,
     "start": {
       "x": 1,
       "y": 3
     },
     "direction": "Across",
     "length": 3,
     "clue": "When doing high-level cross-contract calls, we import this that ends in _contract. When calling ourselves in a callback, it is convention to call it THIS_self."
   },
   {
     "num": 6,
     "start": {
       "x": 0,
       "y": 8
     },
     "direction": "Across",
     "length": 8,
     "clue": "Use this to determine the execution outcome of a cross-contract call or Action."
   },
   {
     "num": 7,
     "start": {
       "x": 4,
       "y": 6
     },
     "direction": "Across",
     "length": 4,
     "clue": "You chain this syntax onto a promise in order to schedule a callback afterward."
   }
  ]
}
```

and base64 encode it:

<figure>
    <img src={base64Encode} alt="Animated gif of parameters getting base64 encoded with the program Boop" width="600"/>
</figure>
<br/>

Now we can build and run the new crossword puzzle contract as we have before:

```bash
cargo near build
```

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  export NEAR_ACCT=crossword.friend.testnet
  export PARENT_ACCT=friend.testnet

  near delete-account $NEAR_ACCT $PARENT_ACCT --networkId testnet
  
  # Create an account again
  near create-account $NEAR_ACCT --use-account $PARENT_ACCT --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  export NEAR_ACCT=crossword.friend.testnet
  export PARENT_ACCT=friend.testnet

  near account delete-account $NEAR_ACCT beneficiary $PARENT_ACCT network-config testnet sign-with-keychain send

  near account create-account fund-myself $NEAR_ACCT '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as $PARENT_ACCT network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

```bash
cargo near deploy build-non-reproducible-wasm $NEAR_ACCT with-init-call new json-args '{"owner_id": "'$NEAR_ACCT'", "creator_account": "testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near call $NEAR_ACCT new_puzzle '{{
    "args": "ewogICJhbnN3ZXJfcGsiOiAiZWQyNTUxOTo3UGtLUG1WVVhjdXBBNW9VOGQ2VGJneU13ekZlOHRQVjZlVjFLR3dnbzl4ZyIsCiAgImRpbWVuc2lvbnMiOiB7CiAgICJ4IjogMTEsCiAgICJ5IjogMTAKICB9LAogICJhbnN3ZXJzIjogWwogICB7CiAgICAgIm51bSI6IDEsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiAwLAogICAgICAgInkiOiAxCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkFjcm9zcyIsCiAgICAgImxlbmd0aCI6IDEyLAogICAgICJjbHVlIjogIk5FQVIgdHJhbnNhY3Rpb25zIGFyZSBtb3JlIF9fX19fXyBpbnN0ZWFkIG9mIGF0b21pYy4iCiAgIH0sCiAgIHsKICAgICAibnVtIjogMiwKICAgICAic3RhcnQiOiB7CiAgICAgICAieCI6IDYsCiAgICAgICAieSI6IDAKICAgICB9LAogICAgICJkaXJlY3Rpb24iOiAiRG93biIsCiAgICAgImxlbmd0aCI6IDcsCiAgICAgImNsdWUiOiAiSW4gYSBzbWFydCBjb250cmFjdCwgd2hlbiBwZXJmb3JtaW5nIGFuIEFjdGlvbiwgeW91IHVzZSB0aGlzIGluIFJ1c3QuIgogICB9LAogICB7CiAgICAgIm51bSI6IDMsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiA5LAogICAgICAgInkiOiAwCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkRvd24iLAogICAgICJsZW5ndGgiOiA2LAogICAgICJjbHVlIjogIkluIGRvY3MucnMgd2hlbiB5b3Ugc2VhcmNoIGZvciB0aGUgbmVhci1zZGsgY3JhdGUsIHRoZXNlIGl0ZW1zIGEgY29uc2lkZXJlZCBhIHdoYXQ6IGNvbGxlY3Rpb25zLCBlbnYsIGpzb25fdHlwZXMuIgogICB9LAogICB7CiAgICAgIm51bSI6IDQsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiAxLAogICAgICAgInkiOiAxCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkRvd24iLAogICAgICJsZW5ndGgiOiAxMCwKICAgICAiY2x1ZSI6ICJBIHNlcmllcyBvZiB3b3JkcyB0aGF0IGNhbiBkZXRlcm1pbmlzdGljYWxseSBnZW5lcmF0ZSBhIHByaXZhdGUga2V5LiIKICAgfSwKICAgewogICAgICJudW0iOiA1LAogICAgICJzdGFydCI6IHsKICAgICAgICJ4IjogMSwKICAgICAgICJ5IjogMwogICAgIH0sCiAgICAgImRpcmVjdGlvbiI6ICJBY3Jvc3MiLAogICAgICJsZW5ndGgiOiAzLAogICAgICJjbHVlIjogIldoZW4gZG9pbmcgaGlnaC1sZXZlbCBjcm9zcy1jb250cmFjdCBjYWxscywgd2UgaW1wb3J0IHRoaXMgdGhhdCBlbmRzIGluIF9jb250cmFjdC4gV2hlbiBjYWxsaW5nIG91cnNlbHZlcyBpbiBhIGNhbGxiYWNrLCBpdCBpcyBjb252ZW50aW9uIHRvIGNhbGwgaXQgVEhJU19zZWxmLiIKICAgfSwKICAgewogICAgICJudW0iOiA2LAogICAgICJzdGFydCI6IHsKICAgICAgICJ4IjogMCwKICAgICAgICJ5IjogOAogICAgIH0sCiAgICAgImRpcmVjdGlvbiI6ICJBY3Jvc3MiLAogICAgICJsZW5ndGgiOiA4LAogICAgICJjbHVlIjogIlVzZSB0aGlzIHRvIGRldGVybWluZSB0aGUgZXhlY3V0aW9uIG91dGNvbWUgb2YgYSBjcm9zcy1jb250cmFjdCBjYWxsIG9yIEFjdGlvbi4iCiAgIH0sCiAgIHsKICAgICAibnVtIjogNywKICAgICAic3RhcnQiOiB7CiAgICAgICAieCI6IDQsCiAgICAgICAieSI6IDYKICAgICB9LAogICAgICJkaXJlY3Rpb24iOiAiQWNyb3NzIiwKICAgICAibGVuZ3RoIjogNCwKICAgICAiY2x1ZSI6ICJZb3UgY2hhaW4gdGhpcyBzeW50YXggb250byBhIHByb21pc2UgaW4gb3JkZXIgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBhZnRlcndhcmQuIgogICB9CiAgXQp9"
  }}' --gas 100000000000000 --accountId $NEAR_ACCT --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-transaction $NEAR_ACCT new_puzzle json-args '{
    "args": "ewogICJhbnN3ZXJfcGsiOiAiZWQyNTUxOTo3UGtLUG1WVVhjdXBBNW9VOGQ2VGJneU13ekZlOHRQVjZlVjFLR3dnbzl4ZyIsCiAgImRpbWVuc2lvbnMiOiB7CiAgICJ4IjogMTEsCiAgICJ5IjogMTAKICB9LAogICJhbnN3ZXJzIjogWwogICB7CiAgICAgIm51bSI6IDEsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiAwLAogICAgICAgInkiOiAxCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkFjcm9zcyIsCiAgICAgImxlbmd0aCI6IDEyLAogICAgICJjbHVlIjogIk5FQVIgdHJhbnNhY3Rpb25zIGFyZSBtb3JlIF9fX19fXyBpbnN0ZWFkIG9mIGF0b21pYy4iCiAgIH0sCiAgIHsKICAgICAibnVtIjogMiwKICAgICAic3RhcnQiOiB7CiAgICAgICAieCI6IDYsCiAgICAgICAieSI6IDAKICAgICB9LAogICAgICJkaXJlY3Rpb24iOiAiRG93biIsCiAgICAgImxlbmd0aCI6IDcsCiAgICAgImNsdWUiOiAiSW4gYSBzbWFydCBjb250cmFjdCwgd2hlbiBwZXJmb3JtaW5nIGFuIEFjdGlvbiwgeW91IHVzZSB0aGlzIGluIFJ1c3QuIgogICB9LAogICB7CiAgICAgIm51bSI6IDMsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiA5LAogICAgICAgInkiOiAwCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkRvd24iLAogICAgICJsZW5ndGgiOiA2LAogICAgICJjbHVlIjogIkluIGRvY3MucnMgd2hlbiB5b3Ugc2VhcmNoIGZvciB0aGUgbmVhci1zZGsgY3JhdGUsIHRoZXNlIGl0ZW1zIGEgY29uc2lkZXJlZCBhIHdoYXQ6IGNvbGxlY3Rpb25zLCBlbnYsIGpzb25fdHlwZXMuIgogICB9LAogICB7CiAgICAgIm51bSI6IDQsCiAgICAgInN0YXJ0IjogewogICAgICAgIngiOiAxLAogICAgICAgInkiOiAxCiAgICAgfSwKICAgICAiZGlyZWN0aW9uIjogIkRvd24iLAogICAgICJsZW5ndGgiOiAxMCwKICAgICAiY2x1ZSI6ICJBIHNlcmllcyBvZiB3b3JkcyB0aGF0IGNhbiBkZXRlcm1pbmlzdGljYWxseSBnZW5lcmF0ZSBhIHByaXZhdGUga2V5LiIKICAgfSwKICAgewogICAgICJudW0iOiA1LAogICAgICJzdGFydCI6IHsKICAgICAgICJ4IjogMSwKICAgICAgICJ5IjogMwogICAgIH0sCiAgICAgImRpcmVjdGlvbiI6ICJBY3Jvc3MiLAogICAgICJsZW5ndGgiOiAzLAogICAgICJjbHVlIjogIldoZW4gZG9pbmcgaGlnaC1sZXZlbCBjcm9zcy1jb250cmFjdCBjYWxscywgd2UgaW1wb3J0IHRoaXMgdGhhdCBlbmRzIGluIF9jb250cmFjdC4gV2hlbiBjYWxsaW5nIG91cnNlbHZlcyBpbiBhIGNhbGxiYWNrLCBpdCBpcyBjb252ZW50aW9uIHRvIGNhbGwgaXQgVEhJU19zZWxmLiIKICAgfSwKICAgewogICAgICJudW0iOiA2LAogICAgICJzdGFydCI6IHsKICAgICAgICJ4IjogMCwKICAgICAgICJ5IjogOAogICAgIH0sCiAgICAgImRpcmVjdGlvbiI6ICJBY3Jvc3MiLAogICAgICJsZW5ndGgiOiA4LAogICAgICJjbHVlIjogIlVzZSB0aGlzIHRvIGRldGVybWluZSB0aGUgZXhlY3V0aW9uIG91dGNvbWUgb2YgYSBjcm9zcy1jb250cmFjdCBjYWxsIG9yIEFjdGlvbi4iCiAgIH0sCiAgIHsKICAgICAibnVtIjogNywKICAgICAic3RhcnQiOiB7CiAgICAgICAieCI6IDQsCiAgICAgICAieSI6IDYKICAgICB9LAogICAgICJkaXJlY3Rpb24iOiAiQWNyb3NzIiwKICAgICAibGVuZ3RoIjogNCwKICAgICAiY2x1ZSI6ICJZb3UgY2hhaW4gdGhpcyBzeW50YXggb250byBhIHByb21pc2UgaW4gb3JkZXIgdG8gc2NoZWR1bGUgYSBjYWxsYmFjayBhZnRlcndhcmQuIgogICB9CiAgXQp9"
  }' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $NEAR_ACCT network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Back at the project root (not in the `contract` directory) we can run our app and see the new crossword puzzle:

```bash
CONTRACT_NAME=crossword.friend.testnet npm run start
```

## Wrapping up

Once you understand cross-contract calls and callbacks and where the logic should go, you can build just about anything on NEAR.

This might be a good time for a reminder that this crossword puzzle, which checks permissions to methods based on a public key, is a bit unusual. It's more common to have simple collections or mappings for allowed users, or utilize the `owner_id` field we set up. The account and access key system in NEAR is quite powerful, and hopefully this tutorial helps stretch the limits of what's possible, like the seamless onboarding we have with the crossword puzzle.

Again, the final code for this chapter:

https://github.com/near-examples/crossword-tutorial-chapter-3

Happy hacking!


 This is the content for the doc docs/3.tutorials/examples/advanced-xcc.md 

 ---
id: advanced-xcc
title: Complex Cross Contract Call
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This example presents 3 instances of complex cross-contract calls. Particularly, it shows:

1. How to batch multiple function calls to a same contract.
2. How to call multiple contracts in parallel, each returning a different type.
3. Different ways of handling the responses in the callback.

:::info Simple Cross-Contract Calls

Check the tutorial on how to use [simple cross-contract calls](xcc.md)

:::

---

## Obtaining the Cross Contract Call Example

You have two options to start the Donation Example:

1. You can use the app through `Github Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                      | Clone locally                                               |
| ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/cross-contract-calls?quickstart=1) | üåê `https://github.com/near-examples/cross-contract-calls` |

---

## Structure of the Example

The smart contract is available in two flavors: Rust and JavaScript

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ external-contracts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ counter.wasm
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ guest-book.wasm
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ internal
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ batch_actions.ts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ constants.ts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ multiple_contracts.ts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ similar_contracts.ts
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ utils.ts
‚îÇ    ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ external-contracts
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ counter.wasm
‚îÇ    ‚îÇ    ‚îú‚îÄ‚îÄ guest-book.wasm
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ batch_actions.rs
‚îÇ    ‚îú‚îÄ‚îÄ lib.rs
‚îÇ    ‚îú‚îÄ‚îÄ multiple_contracts.rs
‚îÇ    ‚îî‚îÄ‚îÄ similar_contracts.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Smart Contract

### Batch Actions

You can aggregate multiple actions directed towards one same contract into a batched transaction.
Methods called this way are executed sequentially, with the added benefit that, if one fails then
they **all get reverted**.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
          url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
          start="38" end="41" />
    <Github fname="batch_actions.ts"
          url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/batch_actions.ts"
          start="5" end="17" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="batch_actions.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/batch_actions.rs"
            start="8" end="20" />
  </Language>
</CodeTabs>

#### Getting the Last Response

In this case, the callback has access to the value returned by the **last
action** from the chain.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="43" end="46" />
    <Github fname="batch_actions.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/batch_actions.ts"
      start="19" end="29" />
    <Github fname="utils.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/utils.ts"
      start="3" end="20" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="batch_actions.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/batch_actions.rs"
            start="22" end="35" />
  </Language>
</CodeTabs>

---

### Calling Multiple Contracts

A contract can call multiple other contracts. This creates multiple transactions that execute
all in parallel. If one of them fails the rest **ARE NOT REVERTED**.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="48" end="51" />
    <Github fname="multiple_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/multiple_contracts.ts"
      start="6" end="21" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="multiple_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/multiple_contracts.rs"
            start="16" end="55" />
  </Language>
</CodeTabs>

#### Getting All Responses

In this case, the callback has access to an **array of responses**, which have either the
value returned by each call, or an error message.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="53" end="58" />
    <Github fname="multiple_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/multiple_contracts.ts"
      start="24" end="41" />
    <Github fname="utils.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/utils.ts"
      start="3" end="20" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="multiple_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/multiple_contracts.rs"
            start="58" end="92" />
  </Language>
</CodeTabs>

---

### Multiple Calls - Same Result Type

This example is a particular case of the previous one ([Calling Multiple Contracts](#calling-multiple-contracts)).
It simply showcases a different way to check the results by directly accessing the `promise_result` array.

In this case, we call multiple contracts that will return the same type:

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="65" end="70" />
    <Github fname="similar_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/similar_contracts.ts"
      start="6" end="35" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="similar_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/similar_contracts.rs"
            start="8" end="31" />
  </Language>
</CodeTabs>

#### Getting All Responses

In this case, the callback again has access to an **array of responses**, which we can iterate checking the
results.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="contract.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/contract.ts"
      start="62" end="65" />
    <Github fname="similar_contracts.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/similar_contracts.ts"
      start="37" end="54" />
    <Github fname="utils.ts"
      url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-ts/src/internal/utils.ts"
      start="3" end="20" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="similar_contracts.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-advanced-rs/src/similar_contracts.rs"
            start="32" end="57" />
  </Language>
</CodeTabs>

---

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

  ```bash
  cd contract-advanced-ts
  yarn
  yarn test
  ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-advanced-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Go into the directory containing the smart contract (`cd contract-advanced-ts` or `cd contract-advanced-rs`), build and deploy it:

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    ```bash
    npm run build
    near deploy <accountId> ./build/cross_contract.wasm --initFunction new --initArgs '{"hello_account":"hello.near-example.testnet","guestbook_account":"guestbook_account.near-example.testnet","counter_account":"counter_account.near-example.testnet"}'
    ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cargo near deploy build-non-reproducible-wasm <accountId> with-init-call new json-args '{"hello_account":"hello.near-example.testnet","guestbook_account":"guestbook_account.near-example.testnet","counter_account":"counter_account.near-example.testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
  ```

  </TabItem>

</Tabs>

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # Execute contracts sequentially
  # Replace <accountId> with your account ID
  near call <accountId> batch_actions --accountId <accountId> --gas 300000000000000   

  # Execute contracts in parallel
  # Replace <accountId> with your account ID
  near call <accountId>  multiple_contracts --accountId <accountId> --gas 300000000000000   

  # Execute multiple instances of the same contract in parallel
  # Replace <accountId> with your account ID
  near call <accountId> similar_contracts --accountId <accountId> --gas 300000000000000
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # Execute contracts sequentially
  # Replace <accountId> with your account ID
  near contract call-function as-transaction <accountId> batch_actions json-args '{}' prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send

  # Execute contracts in parallel
  # Replace <accountId> with your account ID
  near contract call-function as-transaction <accountId> multiple_contracts json-args '{}' prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send

  # Execute multiple instances of the same contract in parallel
  # Replace <accountId> with your account ID
  near contract call-function as-transaction <accountId> similar_contracts json-args '{}' prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>


:::info
If at some point you get an "Exceeded the prepaid gas" error, try to increase the gas amount used within the functions when calling other contracts
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/examples/coin-flip.md 

 ---
id: coin-flip
title: Coin Flip
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Coin Flip is a game where the player tries to guess the outcome of a coin flip. It is one of the simplest contracts implementing random numbers.

![img](/docs/assets/examples/coin-flip.png)

---

## Starting the Game
You have two options to start the example:
1. **Recommended:** use the app through Gitpod (a web-based interactive environment)
2. Clone the project locally.

| Gitpod                                                                                                                                                            | Clone locally                                          |
| ----------------------------------------------------------------------------------------------------------------------------------------------------------------- | -----------------------------------------------------  |
| <a href="https://gitpod.io/#https://github.com/near-examples/coin-flip-examples.git" target="_blank" rel="noopener noreferrer"><img src="https://gitpod.io/button/open-in-gitpod.svg" alt="Open in Gitpod" /></a> | `https://github.com/near-examples/coin-flip-examples.git` |


If you choose Gitpod, a new browser window will open automatically with the code. Give it a minute, and the front-end will pop up (ensure the pop-up window is not blocked).

If you are running the app locally, you should build and deploy a contract (JavaScript or Rust version) and a client manually.

---

## Interacting With the Counter
Go ahead and log in with your NEAR account. If you don't have one, you can create one on the fly. Once logged in, use the `tails` and `heads` buttons to try to guess the next coin flip outcome.

![img](/docs/assets/examples/coin-flip.png)
*Frontend of the Game*

---

## Structure of a dApp

Now that you understand what the dApp does, let us take a closer look to its structure:

1. The frontend code lives in the `/frontend` folder.
2. The smart contract code in Rust is in the `/contract-rs` folder.
3. The smart contract code in JavaScript is in the `/contract-ts` folder.

:::note
Both Rust and JavaScript versions of the contract implement the same functionality.
:::

### Contract
The contract presents 2 methods: `flip_coin`, and `points_of`.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/src/contract.ts"
            start="23" end="56" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/src/lib.rs"
            start="46" end="70" />
  </Language>
</CodeTabs>

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn dev
```

<hr class="subsection" />

### Understanding the Frontend

The frontend is a [Next.JS](https://nextjs.org/) project generated by [create-near-app](https://github.com/near/create-near-app). Check `_app.js` and `index.js` to understand how components are displayed and interacting with the contract.

<Language value="js" language="js">
  <Github fname="_app.js"
          url="https://github.com/near-examples/coin-flip-workshop-js/blob/main/frontend/src/pages/_app.js"/>
  <Github fname="index.js"
          url="https://github.com/near-examples/coin-flip-workshop-js/blob/main/frontend/src/pages/index.js"/>                        
</Language>

---

## Testing

When writing smart contracts, it is very important to test all methods exhaustively. In this
project you have integration tests. Before digging into them, go ahead and perform the tests present in the dApp through the command `yarn test` for the JavaScript version, or `./test.sh` for the Rust version.

### Integration test

Integration tests can be written in both Rust and JavaScript. They automatically deploy a new
contract and execute methods on it. In this way, integration tests simulate interactions
from users in a realistic scenario. You will find the integration tests for the `coin-flip`
in `contract-ts/sandbox-ts` (for the JavaScript contract) and `contract-rs/tests` (for the Rust contract).

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="main.test.js"
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-ts/sandbox-test/main.ava.js"
            start="32" end="57" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs" 
            url="https://github.com/near-examples/coin-flip-examples/blob/main/contract-rs/tests/tests.rs"
            start="25" end="82" />
  </Language>
</CodeTabs>

---

## A Note On Randomness

Randomness in the blockchain is a complex subject. We recommend you to read and investigate about it.
You can start with our [security page on it](../../2.build/2.smart-contracts/security/random.md).

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/examples/count-near.md 

 ---
id: count-near
title: Count on NEAR
---

import {CodeTabs, Language, Github} from '@site/src/components/codetabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

Our counter example is a friendly decentralized app that stores a number and exposes methods to `increment`,
`decrement`, and `reset` it.

![img](/docs/assets/examples/count-on-near-banner.png)

---

## Obtaining the Counter Example

You have two options to start the Counter Example.

1. You can use the app through `GitHub Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                             | Clone locally                                  |
| ---------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/counters) | üåê `https://github.com/near-examples/counters` |

---

## Structure of the Example

The example is divided in two main components:

1. The smart contract, available in two flavors: Rust and JavaScript
2. The frontend, that interacts with an already deployed contract.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ src
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ    ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ    ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ package.json # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json # test script
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ tests # sandbox test
‚îÇ    ‚îî‚îÄ‚îÄ test_basics.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Frontend

The counter example includes a frontend interface designed to interact seamlessly with an existing smart contract that has been deployed. This interface allows users to increase or decrease the counter as needed.

<hr class="subsection" />

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn dev
```

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, use the `+` and `-` buttons to increase and decrease the counter. Then, use the Gameboy buttons to reset it and make the counter blink an eye!

![img](/docs/assets/examples/count-on-near.png)
_Frontend of the Counter_

<hr class="subsection" />

### Understanding the Frontend

The frontend is a [Next.JS](https://nextjs.org/) project generated by [create-near-app](https://github.com/near/create-near-app). Check `_app.js` and `index.js` to understand how components are displayed and interacting with the contract.

<Language value="js" language="js">
  <Github fname="_app.js"
          url="https://github.com/near-examples/counters/blob/main/frontend/src/pages/_app.js"/>
  <Github fname="index.js"
          url="https://github.com/near-examples/counters/blob/main/frontend/src/pages/index.js"/>
</Language>

---

## Smart Contract

The contract presents 4 methods: `get_num`, `increment`, `decrement`, and `reset`. The method `get_num` retrieves the current value, and the rest modify it.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/counters/blob/main/contract-ts/src/contract.ts"
            start="3" end="33" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/counters/blob/main/contract-rs/src/lib.rs"
            start="5" end="37" />
  </Language>
</CodeTabs>

---

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
cd contract-ts
yarn
yarn test
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Go into the directory containing the smart contract (`cd contract-ts` or `cd contract-rs`), build and deploy it:

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    ```bash
    npm run build
    near deploy <accountId> ./build/counter.wasm
    ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cargo near deploy build-non-reproducible-wasm <accountId>
  ```

  </TabItem>

</Tabs>

:::tip
To interact with your contract from the [frontend](#frontend), simply replace the value of the `testnet` key in the `config.js` file.
:::


<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands.

#### Get the current number of the counter

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view counter.near-examples.testnet get_num
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
   near contract call-function as-read-only counter.near-examples.testnet get_num json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Increment the counter

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Replace <accountId> with your account ID
  near call counter.near-examples.testnet increment --accountId <accountId>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Replace <accountId> with your account ID
  near contract call-function as-transaction counter.near-examples.testnet increment json-args {} prepaid-gas '30.0 Tgas' attached-deposit '0 NEAR' sign-as aha_6.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Decrement the counter

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Replace <accountId> with your account ID
  near call counter.near-examples.testnet decrement --accountId <accountId>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Replace <accountId> with your account ID
  near contract call-function as-transaction counter.near-examples.testnet decrement json-args {} prepaid-gas '30.0 Tgas' attached-deposit '0 NEAR' sign-as aha_6.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Reset the counter to zero

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Replace <accountId> with your account ID
  near call counter.near-examples.testnet reset --accountId <accountId>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Replace <accountId> with your account ID
  near contract call-function as-transaction counter.near-examples.testnet reset json-args {} prepaid-gas '30.0 Tgas' attached-deposit '0 NEAR' sign-as aha_6.testnet network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

:::tip
If you're using your own account, replace `counter.near-examples.testnet` with your `accountId`.
:::

---

## Moving Forward

A nice way to learn is by trying to expand the contract. Modify it by adding a parameter to `increment` and `decrement`,
so the user can choose by how much to change the value. For this, you will need to use knowledge from the [anatomy](../../2.build/2.smart-contracts/anatomy/anatomy.md)
and [storage](../../2.build/2.smart-contracts/anatomy/storage.md) sections.

<MovingForwardSupportSection />

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/examples/donation.md 

 ---
id: donation
title: Donation
---

import {CodeTabs, Language, Github} from '@site/src/components/codetabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

Our donation example enables to forward NEAR Tokens to an account while keeping track of it. It is one of the simplest examples on making a contract handle transfers.

![img](/docs/assets/examples/donation.png)
_Frontend of the Donation App_

---

## Obtaining the Donation Example

You have two options to start the Donation Example.

1. You can use the app through `Github Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                      | Clone locally                                               |
| ------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/donation-examples) | üåê `https://github.com/near-examples/donation-examples.git` |

---

## Structure of the Example

The example is divided in two main components:

1. The smart contract, available in two flavors: rust and javascript
2. The frontend, that interacts with an already deployed contract.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ src
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ    ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ    ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ contract.ts
‚îÇ    ‚îú‚îÄ‚îÄ model.ts
‚îÇ    ‚îî‚îÄ‚îÄ utils.ts
‚îú‚îÄ‚îÄ package.json # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json # test script
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # workspaces testing
‚îÇ    ‚îú‚îÄ‚îÄ workspaces.rs
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ donation.rs
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Frontend

The donation example includes a frontend that interacts with an already deployed smart contract, allowing user to donate NEAR tokens to a faucet service.

<hr class="subsection" />

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn dev
```

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, input the amount of NEAR you want to donate and press the donate button. You will be redirected to the NEAR Wallet to confirm the transaction. After confirming it, the donation will be listed in the "Latest Donations".

<hr class="subsection" />

### Understanding the Frontend

The frontend is a [Next.JS](https://nextjs.org/) project generated by [create-near-app](https://github.com/near/create-near-app). Check `DonationsTable.jsx` and `DonationsForm.jsx` to understand how components are displayed and interacting with the contract.

<Language value="js" language="js">
  <Github fname="DonationsTable.jsx"
          url="https://github.com/near-examples/donation-examples/blob/main/frontend/src/components/DonationsTable.jsx"/>
  <Github fname="DonationsForm.jsx"
          url="https://github.com/near-examples/donation-examples/blob/main/frontend/src/components/DonationForm.jsx"/>
</Language>

An interesting aspect of the donation example is that it showcases how to retrieve a result after being redirected to the
NEAR wallet to accept a transaction.

---

## Smart Contract

The contract exposes methods to donate tokens (`donate`), and methods to retrieve the recorded donations (e.g. `get_donation_for_account`).

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-ts/src/contract.ts"
            start="16" end="44" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/donation-examples/blob/main/contract-rs/src/donation.rs"
            start="17" end="74" />
  </Language>
</CodeTabs>

<hr class="subsection" />

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

  ```bash
  cd contract-ts
  yarn
  yarn test
  ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Go into the directory containing the smart contract (`cd contract-ts` or `cd contract-rs`), build and deploy it:

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    ```bash
    npm run build
    near deploy <accountId> ./build/donation.wasm
    ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cargo near deploy build-non-reproducible-wasm <accountId>
  ```

  </TabItem>

</Tabs>

:::tip
To interact with your contract from the [frontend](#frontend), simply replace the variable `CONTRACT_NAME` in the `index.js` file.
:::

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands

#### Get donations

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view donation.near-examples.testnet get_donations '{"from_index": "0","limit": "10"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only donation.near-examples.testnet get_donations json-args '{"from_index": "0","limit": "10"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Get beneficiary

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view donation.near-examples.testnet get_beneficiary
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only donation.near-examples.testnet get_beneficiary json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Get number of donors

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view donation.near-examples.testnet number_of_donors
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only donation.near-examples.testnet number_of_donors json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Get donation for an account

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Require accountId
  near view donation.near-examples.testnet get_donation_for_account '{"account_id":<accountId>}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Require accountId
  near contract call-function as-read-only donation.near-examples.testnet get_donation_for_account json-args '{"account_id":<accountId>}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Donate to the contract

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Replace <accountId> with your account ID
  # Require deposit
  near call donation.near-examples.testnet donate --accountId <accountId> --deposit 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Replace <accountId> with your account ID
  # Require deposit
  near contract call-function as-transaction donation.near-examples.testnet donate json-args {} prepaid-gas '30.0 Tgas' attached-deposit '0.1 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

:::tip
If you're using your own account, replace `donation.near-examples.testnet` with your `accountId`.
:::

---

## Moving Forward

A nice way to learn is by trying to expand a contract. Modify the donation example so it accumulates the tokens in the contract
instead of sending it immediately. Then, make a method that only the `beneficiary` can call to retrieve the tokens.

<MovingForwardSupportSection />

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/examples/factory.md 

 ---
id: factory
title: Factory
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

A factory is a smart contract that stores a compiled contract on itself, and automatizes deploying it into
sub-accounts.

We have two factory examples:

1. [**Token Factory**](https://github.com/near-examples/token-factory): A factory that creates [fungible tokens](../fts/0-intro.md) contracts.
2. [**A Generic Factory**](https://github.com/near-examples/factory-rust): A factory that creates [donation contracts](./donation.md), but allows to change the contract it deploys.

:::info
In this page we will focus on the Donation factory, to learn more about the token factory visit its repository.
:::

---

## Generic Factory

The [Generic Factory](https://github.com/near-examples/factory-rust/) presents a contract factory that:

1. Creates sub-accounts of itself and deploys its contract on them (`create_factory_subaccount_and_deploy`).
2. Can change the stored contract using the `update_stored_contract` method.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="deploy.rs"
            url="https://github.com/near-examples/factory-rust/blob/main/src/deploy.rs"
            start="14" end="66" />
    <Github fname="manager.rs"
            url="https://github.com/near-examples/factory-rust/blob/main/src/manager.rs"
            start="5" end="19" />
  </Language>
</CodeTabs>

---

## Quickstart

1. Make sure you have installed [rust](https://www.rust-lang.org/).
2. Install the [`NEAR CLI`](/tools/near-cli#installation)

<hr className="subsection" />

### Build and Deploy the Factory

You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
./deploy.sh
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<hr className="subsection" />

### Deploy the Stored Contract Into a Sub-Account

`create_factory_subaccount_and_deploy` will create a sub-account of the factory and deploy the
stored contract on it.

```bash
near call <factory-account> create_factory_subaccount_and_deploy '{ "name": "sub", "beneficiary": "<account-to-be-beneficiary>"}' --deposit 1.24 --accountId <account-id> --gas 300000000000000
```

This will create the `sub.<factory-account>`, which will have a `donation` contract deployed on it:

```bash
near view sub.<factory-account> get_beneficiary
# expected response is: <account-to-be-beneficiary>
```

<hr className="subsection" />

### Update the Stored Contract

`update_stored_contract` enables to change the compiled contract that the factory stores.

The method is interesting because it has no declared parameters, and yet it takes
an input: the new contract to store as a stream of bytes.

To use it, we need to transform the contract we want to store into its `base64`
representation, and pass the result as input to the method:

```bash
# Use near-cli to update stored contract
export BYTES=`cat ./src/to/new-contract/contract.wasm | base64`
near call <factory-account> update_stored_contract "$BYTES" --base64 --accountId <factory-account> --gas 30000000000000
```

> This works because the arguments of a call can be either a `JSON` object or a `String Buffer`

---

## Factories - Concepts & Limitations

Factories are an interesting concept, here we further explain some of their implementation aspects,
as well as their limitations.

<hr className="subsection" />

### Automatically Creating Accounts

NEAR accounts can only create sub-accounts of itself, therefore, the `factory` can only create and
deploy contracts on its own sub-accounts.

This means that the factory:

1. **Can** create `sub.factory.testnet` and deploy a contract on it.
2. **Cannot** create sub-accounts of the `predecessor`.
3. **Can** create new accounts (e.g. `account.testnet`), but **cannot** deploy contracts on them.

It is important to remember that, while `factory.testnet` can create `sub.factory.testnet`, it has
no control over it after its creation.

<hr className="subsection" />

### The Update Method

The `update_stored_contracts` has a very short implementation:

```rust
#[private]
pub fn update_stored_contract(&mut self) {
  self.code = env::input().expect("Error: No input").to_vec();
}
```

On first sight it looks like the method takes no input parameters, but we can see that its only
line of code reads from `env::input()`. What is happening here is that `update_stored_contract`
**bypasses** the step of **deserializing the input**.

You could implement `update_stored_contract(&mut self, new_code: Vec<u8>)`,
which takes the compiled code to store as a `Vec<u8>`, but that would trigger the contract to:

1. Deserialize the `new_code` variable from the input.
2. Sanitize it, making sure it is correctly built.

When dealing with big streams of input data (as is the compiled `wasm` file to be stored), this process
of deserializing/checking the input ends up **consuming the whole GAS** for the transaction.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/examples/frontend-multiple-contracts.md 

 ---
id: frontend-multiple-contracts
title: Frontend Interacting with Multiple Contracts
sidebar_label: Frontend & Multiple Contracts
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

This example showcases how to interact with multiple contracts from a single frontend.

Particularly, this example shows how to:

1. Query data from multiple contracts.
2. Call methods in multiple contracts simultaneously.

---

## Query Data from Multiple Contracts

To query multiple contracts simply perform multiple `view` calls:

<Language value="js" language="ts">
  <Github fname="index.js"
        url="https://github.com/near-examples/frontend-multiple-contracts/blob/main/frontend/index.js"
        start="70" end="76" />
</Language>

---

## Dispatching Multiple Transactions

The `wallet` object enables to dispatch multiple transactions simultaneously. However, please notice that the transactions execute independently.

Dispatching multiple transactions at once is just a nice way to improve UX, because the user interacts with the wallet only once.

<Language value="js" language="ts">
  <Github fname="index.js"
          url="https://github.com/near-examples/frontend-multiple-contracts/blob/main/frontend/index.js"
          start="35" end="62" />
</Language>

In this example, the user signs two independent transactions:

1. A transaction to call `set_greeting` in our [Hello NEAR example](https://github.com/near-examples/hello-near-examples)
2. A transaction to call `add_message` in our [GuestBook example](https://github.com/near-examples/guest-book-examples)

:::caution
Even when the user accepts signing the transactions at the same time, the
transactions remain **independent**. This is, if one fails, the other is **NOT** rolled back.
:::

---

## Batch Actions

You can aggregate multiple [actions](../../2.build/2.smart-contracts/anatomy/actions.md) directed towards a same contract into a single transaction. Batched actions execute **sequentially**, with the added benefit that, if **one fails** then they **all** get reverted.

```js
  // Register a user and transfer them FT on a single take
  const REGISTER_DEPOSIT = "1250000000000000000000";

  const ftTx = {
    receiverId: FT_ADDRESS,
    actions: [
      {
        type: 'FunctionCall',
        params: {
          methodName: 'storage_deposit',
          args: { account_id: "<receiver-account>" },
          gas: THIRTY_TGAS, deposit: REGISTER_DEPOSIT
        }
      },
      {
        type: 'FunctionCall',
        params: {
          methodName: 'ft_transfer',
          args: { receiver_id: "<receiver-account>", amount: amount_in_yocto },
          gas: THIRTY_TGAS, deposit: 1 }
      }
    ]
  }

  // Ask the wallet to sign and send the transaction
  await wallet.signAndSendTransactions({ transactions: [ ftTx ] })
```


 This is the content for the doc docs/3.tutorials/examples/guest-book.md 

 ---
id: guest-book
title: Guest Book
---

import {CodeTabs, Language, Github} from '@site/src/components/codetabs';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

Our Guest Book example is a simple app composed by two main components:

1. A smart contract that stores messages from users, allowing to attach money to them.
2. A simple web-based frontend that displays the last 10 messages posted.

![img](/docs/assets/examples/guest-book.png)

---

## Obtaining the Guest book Example

You have two options to start the Guest book Example.

1. You can use the app through `GitHub Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                        | Clone locally                                             |
|-----------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/guest-book-examples) | üåê `https://github.com/near-examples/guest-book-examples` |

---

## Structure of the Example

The example is divided in two main components:

1. The smart contract, available in two flavors: Rust and JavaScript
2. The frontend, that interacts with an already deployed contract.

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ src
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îÇ    ‚îú‚îÄ‚îÄ ava.config.cjs
‚îÇ    ‚îî‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ contract.ts
‚îÇ    ‚îî‚îÄ‚îÄ model.ts
‚îú‚îÄ‚îÄ package.json # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json # test script
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # workspaces testing
‚îÇ    ‚îú‚îÄ‚îÄ workspaces.rs
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Frontend

The guest book example includes a frontend that interacts with an already deployed smart contract, allowing user to sign a message.

<hr class="subsection" />

### Running the Frontend

To start the frontend you will need to install the dependencies and start the server.

```bash
cd frontend
yarn
yarn dev
```

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, you will be able to sign a message in the guest book. You can further send some money alongside your message. If you attach more than 0.01‚ìÉ then your message will be marked as "premium".

<hr class="subsection" />

### Understanding the Frontend

The frontend is a [Next.JS](https://nextjs.org/) project generated by [create-near-app](https://github.com/near/create-near-app). Check `_app.js` and `index.js` to understand how components are displayed and interacting with the contract.

<Language value="js" language="js">
  <Github fname="_app.js" 
          url="https://github.com/near-examples/guest-book-examples/blob/main/frontend/src/pages/_app.js"/>
  <Github fname="index.js" 
          url="https://github.com/near-examples/guest-book-examples/blob/main/frontend/src/pages/index.js"/>
</Language>

---

## Smart Contract

The contract presents 3 methods: `add_message`, `get_message` and `total_messages`.

<CodeTabs>
  <Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/guest-book-examples/blob/main/contract-ts/src/contract.ts"
            start="4" end="27" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/guest-book-examples/blob/main/contract-rs/src/lib.rs"
            start="31" end="64" />
  </Language>
  
</CodeTabs>

<hr class="subsection" />

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

```bash
cd contract-ts
yarn
yarn test
```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cd contract-rs
  cargo test
  ```

  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Go into the directory containing the smart contract (`cd contract-ts` or `cd contract-rs`), build and deploy it:

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    ```bash
    npm run build
    near deploy <accountId> ./build/guest_book.wasm
    ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cargo near deploy build-non-reproducible-wasm <accountId>
  ```

  </TabItem>

</Tabs>

:::tip
To interact with your contract from the [frontend](#frontend), simply replace the variable `CONTRACT_NAME` in the `index.js` file.
:::

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands.

#### Get messages

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view guestbook.near-examples.testnet get_messages '{"from_index": "0","limit": "10"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only guestbook.near-examples.testnet get_messages json-args '{"from_index": "0","limit": "10"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Get total number of messages

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view guestbook.near-examples.testnet total_messages
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only guestbook.near-examples.testnet total_messages json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

#### Add a message

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Replace <accountId> with your account ID
  # Required a text
  # Optional deposit to make the message premium
  near call guestbook.near-examples.testnet add_message '{"text":"Hello Near"}' --accountId <accountId> --deposit 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Replace <accountId> with your account ID
  # Required a text
  # Optional deposit to make the message premium
  near contract call-function as-transaction guestbook.near-examples.testnet add_message json-args '{"text":"Hello Near"}' prepaid-gas '30.0 Tgas' attached-deposit '0.1 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

:::tip
If you're using your own account, replace `guestbook.near-examples.testnet` with your `accountId`.
:::

---

## Moving Forward

A nice way to learn is by trying to expand a contract. You can modify the guestbook example to incorporate a feature where users can give likes to messages. Additionally, implement a method to toggle the like.

<MovingForwardSupportSection />

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/examples/near-drop.md 

 ---
id: near-drop
title: Near Drop
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

NEAR Drop is a smart contract that allows users to create token drops ($NEAR, Fungible and Non-Fungible Tokens), and link them to specific private keys. Whoever has the private key can claim the drop into an existing account, or ask the contract to create a new one for them.

Particularly, it shows:

1. How to create a token drops (NEAR, FT and NFT)
2. How to leverage Function Call keys for enabling amazing UX

:::tip

This example showcases a simplified version of the contract that both [Keypom](https://keypom.xyz/) and the [Token Drop Utility](https://dev.near.org/tools?tab=linkdrops) use to distribute tokens to users

:::

---

## Contract Overview

The contract exposes 3 methods to create drops of NEAR tokens, FT, and NFT. To claim the tokens, the contract exposes two methods, one to claim in an existing account, and another that will create a new account and claim the tokens into it.

This contract leverages NEAR unique feature of [FunctionCall keys](../../1.concepts/protocol/access-keys.md), which allows the contract to create new accounts and claim tokens on behalf of the user.

Imagine Alice want to drop some NEAR to Bob:

1. Alice will call `create_near_drop` passing some NEAR amount, and a **Public** Access Key
2. The Contract will check if Alice attached enough tokens and create the drop
3. The Contract will add the `PublicKey` as a `FunctionCall Key` to itself, that **only allow to call the claim methods**
4. Alice will give the `Private Key` to Bob
5. Bob will use the Key to sign a transaction calling the `claim_for` method
6. The Contract will check if the key is linked to a drop, and if it is, it will send the drop

It is important to notice that, in step (5), Bob will be using the Contract's account to sign the transaction, and not his own account. Remember that in step (3) the contract added the key to itself, meaning that anyone with the key can call the claim methods in the name of the contract.

<details>

<summary>Contract's interface</summary>

#### `create_near_drop(public_keys, amount_per_drop)`
Creates `#public_keys` drops, each with `amount_per_drop` NEAR tokens on them

#### `create_ft_drop(public_keys, ft_contract, amount_per_drop)`
Creates `#public_keys` drops, each with `amount_per_drop` FT tokens, corresponding to the `ft_contract`

#### `create_nft_drop(public_key, nft_contract)`
Creates a drop with an NFT token, which will come from the `nft_contract`

#### `claim_for(account_id)`
Claims a drop, which will be sent to the existing `account_id`

#### `create_account_and_claim(account_id)`
Creates the `account_id`, and then drops the tokens into it

</details>

---

## Contract's State

We can see in the contract's state that the contract keeps track of different `PublicKeys`, and links them to a specific `DropId`, which is simply an identifier for a `Drop` (see bellow). 

- `top_level_account`: The account that will be used to create new accounts, generally it will be `testnet` or `mainnet`
- `next_drop_id`: A simple counter used to assign unique identifiers to each drop
- `drop_id_by_key`: A `Map` between `PublicKey` and `DropId`, which allows the contract to know what drops are claimable by a given key
- `drop_by_id`: A simple `Map` that links each `DropId` with the actual `Drop` data.

<Github fname="lib.rs" language="rust"
      url="https://github.com/near-examples/near-drop/blob/main/src/lib.rs"
      start="22" end="29" />

---

## Drop Types

There are 3 types of drops, which differ in what the user will receive when they claims the corresponding drop - NEAR, fungible tokens (FTs) or non-fungible tokens (NFTs).

<Language value="rust" language="rust">
<Github fname="drop_types.rs"
  url="https://github.com/near-examples/near-drop/blob/main/src/drop_types.rs"
  start="8" end="16" />
<Github fname="near_drop.rs"
  url="https://github.com/near-examples/near-drop/blob/main/src/near_drop.rs"
  start="9" end="16" />
<Github fname="ft_drop.rs"
  url="https://github.com/near-examples/near-drop/blob/main/src/ft_drop.rs"
  start="16" end="24" />
<Github fname="nft_drop.rs"
  url="https://github.com/near-examples/near-drop/blob/main/src/nft_drop.rs"
  start="15" end="22" />
</Language>

:::info

Notice that in this example implementation users cannot mix drops. This is, you can either drop NEAR tokens, or FT, or NFTs, but not a mixture of them (i.e. you cannot drop 1 NEAR token and 1 FT token in the same drop)

:::

---

## Create a drop

All `create` start by checking that the user deposited enough funds to create the drop, and then proceed to add the access keys to the contract's account as [FunctionCall Keys](../../1.concepts/protocol/access-keys.md).

<Tabs>

  <TabItem value="NEAR" label="NEAR Drop">
    <Language value="rust" language="rust">
      <Github fname="create_near_drop"
        url="https://github.com/near-examples/near-drop/blob/main/src/lib.rs"
        start="44" end="66" />
      <Github fname="near_drop"
        url="https://github.com/near-examples/near-drop/blob/main/src/near_drop.rs"
        start="63" end="95" />
    </Language>
  </TabItem>
  <TabItem value="FT" label="FT Drop">
    <Language value="rust" language="rust">
      <Github fname="create_ft_drop"
        url="https://github.com/near-examples/near-drop/blob/main/src/lib.rs"
        start="68" end="89" />
      <Github fname="ft_drop"
        url="https://github.com/near-examples/near-drop/blob/main/src/ft_drop.rs"
        start="108" end="142" />
    </Language>
  </TabItem>
  <TabItem value="NFT" label="NFT Drop">
    <Language value="rust" language="rust">
      <Github fname="create_nft_drop"
        url="https://github.com/near-examples/near-drop/blob/main/src/lib.rs"
        start="91" end="103" />
      <Github fname="nft_drop"
        url="https://github.com/near-examples/near-drop/blob/main/src/nft_drop.rs"
        start="80" end="106" />
    </Language>
  </TabItem>
</Tabs>

<hr class="subsection" />

### Storage Costs

While we will not go into the details of how the storage costs are calculated, it is important to know what is being taken into account:

1. The cost of storing each Drop, which will include storing all bytes associated with the `Drop` struct
2. The cost of storing each `PublicKey -> DropId` relation in the maps
3. Cost of storing each `PublicKey` in the account

Notice that (3) is not the cost of storing the byte representation of the `PublicKey` on the state, but the cost of adding the key to the contract's account as a FunctionCall key.

---

## Claim a drop

In order to claim drop, a user needs to sign a transaction using the `Private Key`, which is the counterpart of the `Public Key` that was added to the contract.

All `Drops` have a `counter` which decreases by 1 each time a drop is claimed. This way, when all drops are claimed (`counter` == 0), we can remove all information from the Drop.

There are two ways to claim a drop: claim for an existing account and claim for a new account. The main difference between them is that the first one will send the tokens to an existing account, while the second one will create a new account and send the tokens to it.

<hr class="subsection" />

<Tabs>
  <TabItem value="existing" label="Existing Account">
    <Language value="rust" language="rust">
      <Github fname="claim_for"
        url="https://github.com/near-examples/near-drop/blob/main/src/claim.rs"
        start="11" end="14" />
      <Github fname="internal_claim"
        url="https://github.com/near-examples/near-drop/blob/main/src/claim.rs"
        start="58" end="85" />
    </Language>
  </TabItem>
  <TabItem value="new" label="New Account">
    <Language value="rust" language="rust">
      <Github fname="create_account_and_claim"
        url="https://github.com/near-examples/near-drop/blob/main/src/claim.rs"
        start="16" end="41" />
      <Github fname="resolve_account_create"
        url="https://github.com/near-examples/near-drop/blob/main/src/claim.rs"
        start="43" end="56" />
      <Github fname="internal_claim"
        url="https://github.com/near-examples/near-drop/blob/main/src/claim.rs"
        start="58" end="85" />
    </Language>
  </TabItem>
</Tabs>

---

### Testing the Contract

The contract readily includes a sandbox testing to validate its functionality. To execute the tests, run the following command:

<Tabs groupId="code-tabs">
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cargo test
  ```

  </TabItem>
</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

---

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Then build and deploy the contract:

```bash
cargo near build

cargo near deploy <accountId> with-init-call new json-args '{"top_level_account": "testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

---

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  # create a NEAR drop
  near call <account-id> create_near_drop '{"public_keys": ["ed25519:AvBVZDQrg8pCpEDFUpgeLYLRGUW8s5h57NGhb1Tc4H5q", "ed25519:4FMNvbvU4epP3HL9mRRefsJ2tMECvNLfAYDa9h8eUEa4"], "amount_per_drop": "10000000000000000000000"}' --accountId <account-id> --deposit 1 --gas 100000000000000

  # create a FT drop
  near call <account-id> create_ft_drop '{"public_keys": ["ed25519:HcwvxZXSCX341Pe4vo9FLTzoRab9N8MWGZ2isxZjk1b8", "ed25519:5oN7Yk7FKQMKpuP4aroWgNoFfVDLnY3zmRnqYk9fuEvR"], "amount_per_drop": "1", "ft_contract": "<ft-contract-account-id>"}' --accountId <account-id> --gas 100000000000000

  # create a NFT drop
  near call <account-id> create_nft_drop '{"public_key": "ed25519:HcwvxZXSCX341Pe4vo9FLTzoRab9N8MWGZ2isxZjk1b8", "nft_contract": "<nft-contract-account-id>"}' --accountId <account-id> --gas 100000000000000
  
  # claim to an existing account
  # see the full version

  # claim to a new account
  # see the full version
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  # create a NEAR drop
  near contract call-function as-transaction <account-id> create_near_drop json-args '{"public_keys": ["ed25519:AvBVZDQrg8pCpEDFUpgeLYLRGUW8s5h57NGhb1Tc4H5q", "ed25519:4FMNvbvU4epP3HL9mRRefsJ2tMECvNLfAYDa9h8eUEa4"], "amount_per_drop": "10000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '1 NEAR' sign-as <account-id> network-config testnet sign-with-keychain send

  # create a FT drop
  near contract call-function as-transaction <account-id> create_ft_drop json-args '{"public_keys": ["ed25519:HcwvxZXSCX341Pe4vo9FLTzoRab9N8MWGZ2isxZjk1b8", "ed25519:5oN7Yk7FKQMKpuP4aroWgNoFfVDLnY3zmRnqYk9fuEvR"], "amount_per_drop": "1", "ft_contract": "<ft-contract-account-id>"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <account-id> network-config testnet sign-with-keychain send

  # create a NFT drop
  near contract call-function as-transaction <account-id> create_nft_drop json-args '{"public_key": "ed25519:HcwvxZXSCX341Pe4vo9FLTzoRab9N8MWGZ2isxZjk1b8", "nft_contract": "<nft-contract-account-id>"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <account-id> network-config testnet sign-with-keychain send

  # claim to an existing account
  near contract call-function as-transaction <account-id> claim_for json-args '{"account_id": "<claimer-account-id>"}' prepaid-gas '30.0 Tgas' attached-deposit '0 NEAR' sign-as <account-id> network-config testnet sign-with-plaintext-private-key --signer-public-key ed25519:AvBVZDQrg8pCpEDFUpgeLYLRGUW8s5h57NGhb1Tc4H5q --signer-private-key ed25519:3yVFxYtyk7ZKEMshioC3BofK8zu2q6Y5hhMKHcV41p5QchFdQRzHYUugsoLtqV3Lj4zURGYnHqMqt7zhZZ2QhdgB send

  # claim to a new account
  near contract call-function as-transaction <account-id> create_account_and_claim json-args '{"account_id": "<claimer-account-id>"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <account-id> network-config testnet sign-with-plaintext-private-key --signer-public-key ed25519:4FMNvbvU4epP3HL9mRRefsJ2tMECvNLfAYDa9h8eUEa4 --signer-private-key ed25519:2xZcegrZvP52VrhehvApnx4McL85hcSBq1JETJrjuESC6v6TwTcr4VVdzxaCReyMCJvx9V4X1ppv8cFFeQZ6hJzU send
  ```
  </TabItem>
</Tabs>

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `0.17.0`
- rustc: `1.82.0`

:::

 This is the content for the doc docs/3.tutorials/examples/update.md 

 ---
id: update-contract-migrate-state
title: Self Upgrade & State Migration
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Three examples on how to handle updates and [state migration](../../2.build/2.smart-contracts/release/upgrade.md):
1. [State Migration](https://github.com/near-examples/update-migrate-rust/tree/main/basic-updates): How to implement a `migrate` method to migrate state between contract updates.
2. [State Versioning](https://github.com/near-examples/update-migrate-rust/tree/main/enum-updates): How to use readily use versioning on a state, to simplify updating it later.
3. [Self Update](https://github.com/near-examples/update-migrate-rust/tree/main/self-updates): How to implement a contract that can update itself.

---

## State Migration
The [State Migration example](https://github.com/near-examples/update-migrate-rust/tree/main/basic-updates) shows how to handle state-breaking changes
between contract updates.

It is composed by 2 contracts:
1. Base: A Guest Book where people can write messages.
2. Update: An update in which we remove a parameter and change the internal structure.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="migrate.rs"
            url="https://github.com/near-examples/update-migrate-rust/blob/main/basic-updates/update/src/migrate.rs"
            start="18" end="45" />
  </Language>
</CodeTabs>

#### The Migration Method
The migration method deserializes the current state (`OldState`) and iterates through the messages, updating them
to the new `PostedMessage` that includes the `payment` field.

:::tip
Notice that migrate is actually an [initialization method](../../2.build/2.smart-contracts/anatomy/storage.md) that ignores the existing state (`[#init(ignore_state)]`), thus being able to execute and rewrite the state.
:::

---

## State Versioning
The [State Versioning example](https://github.com/near-examples/update-migrate-rust/tree/main/enum-updates) shows how to use
[Enums](https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html) to implement state versioning on a contract.

Versioning simplifies updating the contract since you only need to add a new version of the structure.
All versions can coexist, thus you will not need to change previously existing structures.

The example is composed by 2 contracts:
1. Base: The Guest Book contract using versioned `PostedMessages` (`PostedMessagesV1`).
2. Update: An update that adds a new version of `PostedMessages` (`PostedMessagesV2`).

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="versioned_msg.rs"
            url="https://github.com/near-examples/update-migrate-rust/blob/main/enum-updates/update/src/versioned_msg.rs"
            start="18" end="36" />
  </Language>
</CodeTabs>

---

## Self Update
The [Self Update example](https://github.com/near-examples/update-migrate-rust/tree/main/self-updates) shows how to implement a contract
that can update itself.

It is composed by 2 contracts:
1. Base: A Guest Book were people can write messages, implementing a `update_contract` method.
2. Update: An update in which we remove a parameter and change the internal structure.

<CodeTabs>
  <Language value="rust" language="rust">
    <Github fname="update.rs"
            url="https://github.com/near-examples/update-migrate-rust/blob/main/self-updates/base/src/update.rs"
            start="10" end="31" />
  </Language>
</CodeTabs>


 This is the content for the doc docs/3.tutorials/examples/xcc.md 

 ---
id: xcc
title: Cross Contract Call
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from '@site/src/components/codetabs'
import MovingForwardSupportSection from '@site/src/components/MovingForwardSupportSection';

This example performs the simplest cross-contract call possible: it calls our [Hello NEAR](https://github.com/near-examples/hello-near-examples) example to set and retrieve a greeting.
It is one of the simplest examples on making a cross-contract call, and the perfect gateway to the world of interoperative contracts.

:::info Advanced Cross-Contract Calls
Check the tutorial on how to perform cross-contract calls [in batches and in parallel](./advanced-xcc)
:::

---

## Obtaining the Cross Contract Call Example

You have two options to start the project:

1. You can use the app through `Github Codespaces`, which will open a web-based interactive environment.
2. Clone the repository locally and use it from your computer.

| Codespaces                                                                                                                                      | Clone locally                                              |
| ----------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| [![Open in GitHub Codespaces](https://github.com/codespaces/badge.svg)](https://codespaces.new/near-examples/cross-contract-calls?quickstart=1) | üåê `https://github.com/near-examples/cross-contract-calls` |

---

## Structure of the Example

The smart contract is available in two flavors: Rust and JavaScript

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

```bash
‚îå‚îÄ‚îÄ sandbox-ts # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ hello-near
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ main.ava.ts
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îî‚îÄ‚îÄ contract.ts
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ tsconfig.json
```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

```bash
‚îå‚îÄ‚îÄ tests # sandbox testing
‚îÇ    ‚îú‚îÄ‚îÄ hello-near
‚îÇ    ‚îÇ    ‚îî‚îÄ‚îÄ hello-near.wasm
‚îÇ    ‚îî‚îÄ‚îÄ tests.rs
‚îú‚îÄ‚îÄ src # contract's code
‚îÇ    ‚îú‚îÄ‚îÄ external.rs
‚îÇ    ‚îî‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ Cargo.toml # package manager
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ rust-toolchain.toml
```

  </TabItem>

</Tabs>

---

## Smart Contract

### Contract
The contract exposes methods to query the greeting and change it. These methods do nothing but calling `get_greeting` and
`set_greeting` in the `hello-near` example.

<CodeTabs>
<Language value="js" language="ts">
    <Github fname="contract.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/src/contract.ts"
            start="17" end="39" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/lib.rs"
            start="22" end="51" />
            <Github fname="external.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/src/external.rs"
            start="2" end="12" />
  </Language>
</CodeTabs>

### Testing the Contract

The contract readily includes a set of unit and sandbox testing to validate its functionality. To execute the tests, run the following commands:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

  ```bash
  cd contract-simple-ts
  yarn
  yarn test
  ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  ```bash
  cd contract-simple-rs
  cargo test
  ```
  </TabItem>

</Tabs>

:::tip
The `integration tests` use a sandbox to create NEAR users and simulate interactions with the contract.
:::

In this project in particular, the integration tests first deploy the `hello-near` contract. Then,
they test that the cross-contract call correctly sets and retrieves the message. You will find the integration tests
in `sandbox-ts/` for the JavaScript version and in `tests/` for the Rust version.

<CodeTabs>
  <Language value="js" language="js">
    <Github fname="main.ava.ts"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-ts/sandbox-ts/main.ava.ts"
            start="8" end="52" />
  </Language>
  <Language value="rust" language="rust">
    <Github fname="lib.rs"
            url="https://github.com/near-examples/cross-contract-calls/blob/main/contract-simple-rs/tests/tests.rs"
            start="4" end="77" />
  </Language>
</CodeTabs>


<hr class="subsection" />

### Deploying the Contract to the NEAR network

In order to deploy the contract you will need to create a NEAR account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Create a new account pre-funded by a faucet
  near create-account <accountId> --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Create a new account pre-funded by a faucet
  near account create-account sponsor-by-faucet-service <my-new-dev-account>.testnet autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Go into the directory containing the smart contract (`cd contract-advanced-ts` or `cd contract-advanced-rs`), build and deploy it:

<Tabs groupId="code-tabs">

  <TabItem value="js" label="üåê JavaScript">

    ```bash
    npm run build
    near deploy <accountId> ./build/cross_contract.wasm --initFunction new --initArgs '{"hello_account":"hello.near-example.testnet"}'
    ```

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  ```bash
  cargo near deploy build-non-reproducible-wasm <accountId> with-init-call new json-args '{"hello_account":"hello.near-example.testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send

  ```

  </TabItem>

</Tabs>

<hr class="subsection" />

### CLI: Interacting with the Contract

To interact with the contract through the console, you can use the following commands:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  # Get message from the hello-near contract
  # Replace <accountId> with your account ID
  near call <accountId> query_greeting --accountId <accountId>

  # Set a new message for the hello-near contract
  # Replace <accountId> with your account ID
  near call <accountId> change_greeting '{"new_greeting":"XCC Hi"}' --accountId <accountId>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  # Get message from the hello-near contract
  # Replace <accountId> with your account ID
  near contract call-function as-transaction <accountId> query_greeting json-args '{}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send

  # Set a new message for the hello-near contract
  # Replace <accountId> with your account ID
  near contract call-function as-transaction <accountId> change_greeting json-args '{"new_greeting":"XCC Hi"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as <accountId> network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

---

## Moving Forward

A nice way to learn is by trying to expand a contract. Modify the cross contract example to use the [guest-book](guest-book.md)
contract!. In this way, you can try to make a cross-contract call that attaches money. Remember to correctly [handle the callback](/build/smart-contracts/anatomy/crosscontract#callback-function),
and to return the money to the user in case of error.

### Advanced Cross Contract Calls

Your contract can perform multiple cross-contract calls in simultaneous, creating promises that execute in parallel, or as a batch transaction. Check the [advanced cross contract calls
tutorial](./advanced-xcc) to learn more.

<MovingForwardSupportSection />

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `4.0.13`
- node: `18.19.1`
- rustc: `1.77.0`

:::


 This is the content for the doc docs/3.tutorials/fts/0-intro.md 

 ---
id: introduction
title: Fungible Tokens Zero to Hero
sidebar_label: Introduction
---

In this _Zero to Hero_ series, you'll find a set of tutorials covering every aspect of a fungible token (FT) smart contract. You'll start by interacting with a pre-deployed contract and by the end you'll have built a fully-fledged FT smart contract that supports every extension of the standards.

---

## Prerequisites

To complete these tutorials successfully, you'll need:

- [Rust](/build/smart-contracts/quickstart#prerequisites)
- [A NEAR wallet](https://testnet.mynearwallet.com)
- [NEAR-CLI](/tools/near-cli#installation)
- [cargo-near](https://github.com/near/cargo-near)

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.
:::

---

## Overview

These are the steps that will bring you from **_Zero_** to **_Hero_** in no time! üí™

| Step | Name                                                         | Description                                                                                                                                     |
| ---- | ------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------- |
| 1    | [Pre-deployed contract](/tutorials/fts/predeployed-contract) | Receive FTs without the need to code, create, or deploy a smart contract.                                                                       |
| 2    | [Contract architecture](/tutorials/fts/skeleton)             | Learn the basic architecture of the FT smart contract and compile the code.                                                                     |
| 3    | [Defining a Token](/tutorials/fts/defining-a-token)          | Flesh out what it means to have a FT and how you can customize your own.                                                                         |
| 4    | [Circulating Supply](/tutorials/fts/circulating-supply)      | Learn how to create an initial supply and have the token show up in your wallet.                                                                |
| 5    | [Registering Accounts](/tutorials/fts/registering-accounts)  | Explore how you can implement and understand the storage management standard to avoid malicious users from draining your funds.                 |
| 6    | [Transferring FTs](/tutorials/fts/transfers)                 | Learn how to transfer FTs and discover some of the true powers that the core standard brings                                                    |
| 7    | [Marketplace](/tutorials/fts/marketplace)                    | Learn about how common marketplaces operate on NEAR and dive into some of the code that allows buying and selling NFTs by using Fungible Tokens. |

<!--
1. [Events](/tutorials/fts/events): in this tutorial you'll explore the events extension, allowing the contract to react on certain events.
1. [Marketplace](/tutorials/fts/marketplace): in the last tutorial you'll be exploring some key aspects of the marketplace contract.
-->

---

## Next steps

Ready to start? Jump to the [Pre-deployed Contract](/tutorials/fts/predeployed-contract) tutorial and begin your learning journey!

If you already know about fungible tokens and smart contracts, feel free to skip and jump directly to the tutorial of your interest. The tutorials have been designed so you can start at any given point!


 This is the content for the doc docs/3.tutorials/fts/0-predeployed.md 

 ---
id: predeployed-contract
title: Pre-deployed Contract
sidebar_label: Pre-deployed Contract
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Learn how to easily receive fungible tokens without doing any software development by using a readily-available FT smart contract.

---

## Prerequisites

To complete this tutorial successfully, you'll need:

- [A NEAR testnet account](https://testnet.mynearwallet.com)
- [NEAR-CLI](/tools/near-cli/#installation)

---

## Using the FT contract

Create a new `testnet` account using the [web wallet](https://testnet.mynearwallet.com).

### Setup

Log in to your newly created account with `near-cli-rs` by running the following command in your terminal:

```bash
near account import-account using-web-wallet network-config testnet
```

Set an environment variable for your account ID to make it easy to copy and paste commands from this tutorial:

```bash
export NEARID=YOUR_ACCOUNT_NAME
```
:::note

Be sure to replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet`.

:::

Test that the environment variable is set correctly by running:

```bash
echo $NEARID
```

<hr className="subsection" />

### Receiving Fungible Tokens

NEAR has deployed a new Fungible Token contract to the account `ft.predeployed.examples.testnet` which allows users to freely receive some `gtNEAR` - a new fungible token aimed to promote the power of teamwork! Each `gtNEAR` is equal to `1e24 yocto-gtNEAR` similar to how 1 $NEAR is equal to 1e24 yoctoNEAR.

Using this pre-deployed contract, let's get some gtNEAR!

Start by calling the method `ft_mint` which is a custom function implemented on this contract in order to send your account some `gtNEAR`! The following command will send `0.01 gtNEAR` to your account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call ft.predeployed.examples.testnet ft_mint '{"account_id": "'$NEARID'", "amount": "10000000000000000000000"}' --gas 100000000000000 --accountId $NEARID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction ft.predeployed.examples.testnet ft_mint json-args '{"account_id": "'$NEARID'", "amount": "10000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $NEARID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
Log [ft.predeployed.examples.testnet]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_mint","data":[{"owner_id":"benjiman.testnet","amount":"10000000000000000000000","memo":"FTs Minted"}]}
Transaction Id Fhqa8YDLKxnxM9jjHCPN4hn1w1RKESYrav3kwDjhWWUu
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/Fhqa8YDLKxnxM9jjHCPN4hn1w1RKESYrav3kwDjhWWUu
''
```

</p>
</details>

To view tokens owned by an account you can call the FT contract with the following `near-cli` command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view ft.predeployed.examples.testnet ft_balance_of '{"account_id": "'$NEARID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only ft.predeployed.examples.testnet ft_balance_of json-args '{"account_id": "'$NEARID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
'10000000000000000000000'
```

</p>
</details>

***Congratulations! You just received your first Team Tokens on the NEAR blockchain!*** üéâ

üëâ Now try going to your [NEAR Wallet](https://testnet.mynearwallet.com) and view your FTs in the "Balances" tab. üëà

:::note Pre-deployed Contract
The contract used in this section has been modified such that you can infinitely get `gtNEAR` by calling `ft_mint`. This function is not part of the FT [standards](https://nomicon.io/Standards/Tokens/FungibleToken/Core) and has been implemented for the purpose of this tutorial.
:::

---

## Final remarks

This basic example illustrates all the required steps to call an FT smart contract on NEAR and receive your own fungible tokens.

Now that you're familiar with the process, you can jump to [Contract Architecture](/tutorials/fts/skeleton) and learn more about the smart contract structure and how you can build your own FT contract from the ground up.

***Happy minting!*** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli-rs: `0.17.0`
:::


 This is the content for the doc docs/3.tutorials/fts/1-skeleton.md 

 ---
id: skeleton
title: Skeleton and Rust Architecture
sidebar_label: Contract Architecture
---
import {Github} from "@site/src/components/codetabs"

In this article, you'll learn about the basic architecture behind the FT contract that you'll develop while following this _"Zero to Hero"_ series. You'll discover the contract's layout and you'll see how the Rust files are structured in order to build a feature-complete smart contract.

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.
:::

---

## Introduction

This tutorial presents the code skeleton for the FT smart contract and its file structure.
You'll find how all the functions are laid out as well as the missing Rust code that needs to be filled in.
Once every file and function has been covered, you'll go through the process of building the mock-up contract to confirm that your Rust toolchain works as expected.

---

## Files structure

The repository comes with many different folders. Each folder represents a different milestone of this tutorial starting with the skeleton folder and ending with the finished contract folder. If you step into any of these folders, you'll find that they each follow a regular [Rust](https://www.rust-lang.org/) project. The file structure for these smart contracts have:

- `Cargo.toml` file to define the code dependencies (similar to `package.json` in JavaScript and node projects)
- `src` folder where all the Rust source files are stored
- `target` folder where the compiled `wasm` will output to.

<hr className="subsection" />

### Source files

| File                             | Description                                                                      |
| -------------------------------- | -------------------------------------------------------------------------------- |
| [ft_core.rs](#ft_corers)       | Contains the logic for transferring and controlling FTs. This file represents the implementation of the [core](https://nomicon.io/Standards/Tokens/FungibleToken/Core) standard. |              |
| [lib.rs](#librs)                 | Holds the smart contract initialization functions and dictates what information is kept on-chain.                               |
| [metadata.rs](#metadatars)       | Defines the metadata structure. This file represents the implementation of the [metadata](https://nomicon.io/Standards/Tokens/FungibleToken/Metadata) extension of the standard.                                      |
| [storage.rs](#storagers)               | Contains the logic for registration and storage.  This file represents the implementation of the [storage management](https://nomicon.io/Standards/StorageManagement) standard.                                                   |

```
skeleton
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ ft_core.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ metadata.rs
    ‚îî‚îÄ‚îÄ storage.rs
```

:::tip
Explore the code in our [GitHub repository](https://github.com/near-examples/ft-tutorial/tree/main/1.skeleton).
:::

---

## `ft_core.rs`

Core logic that allows you to transfer FTs between users and query for important information.

| Method                   | Description                                                                                                                                                                                                                                                                                   |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ft_transfer**         | Transfers a specified amount of FTs to a receiver ID.|
| **ft_transfer_call**    | Transfers a specified amount of FTs to a receiver and attempts to perform a cross-contract call on the receiver‚Äôs contract to execute the `ft_on_transfer` method. The implementation of this `ft_on_transfer` method is up to the contract writer. You‚Äôll see an example implementation in the marketplace section of this tutorial. Once `ft_on_transfer` finishes executing, `ft_resolve_transfer` is called to check if things were successful or not.|
| **ft_total_supply**            | Returns the total amount of fungible tokens in circulation on the contract. |
| **ft_balance_of**            | Returns how many fungible tokens a specific user owns.|
| **ft_on_transfer**      | Method that lives on a receiver's contract. It is called when FTs are transferred to the receiver's contract account via the `ft_transfer_call` method. It returns how many FTs should be refunded back to the sender. |
| **ft_resolve_transfer** | Invoked after the `ft_on_transfer` is finished executing. This function will refund any FTs not used by the receiver contract and will return the net number of FTs sent to the receiver after the refund (if any). |

<Github language="rust" start="61" end="167" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/ft_core.rs" />

You'll learn more about these functions in the [circulating supply](/tutorials/fts/circulating-supply) and [transfers](/tutorials/fts/transfers) sections of the tutorial series.

---

## `lib.rs`

This file outlines what information the contract stores and keeps track of.

| Method               | Description                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------- |
| **new_default_meta** | Initializes the contract with default `metadata` so the user doesn't have to provide any input. In addition, a total supply is passed in which is sent to the owner. |
| **new**              | Initializes the contract with the user-provided `metadata` and total supply.                                     |

:::info Keep in mind
The initialization functions (`new`, `new_default_meta`) can only be called once.
:::

<Github language="rust" start="36" end="60" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/lib.rs" />

You'll learn more about these functions in the [define a token](2-define-a-token.md) section of the tutorial series.

---

## `metadata.rs`

This file is used to outline the metadata for the Fungible Token itself.
In addition, you can define a function to view the contract's metadata which is part of the standard's [metadata](https://nomicon.io/Standards/Tokens/FungibleToken/Metadata) extension.

| Name              | Description                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------------- |
| **FungibleTokenMetadata** | This structure defines the metadata for the fungible token.       |
| **ft_metadata**  | This function allows users to query for the token's metadata.                                      |

<Github language="rust" start="11" end="30" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/metadata.rs" />

You'll learn more about these functions in the [define a token](2-define-a-token.md) section of the tutorial series.

---

## `storage.rs`

Contains the registration logic as per the [storage management](https://nomicon.io/Standards/StorageManagement) standard.

| Method                  | Description                                                                                                   |
| ----------------------- | ------------------------------------------------------------------------------------------------------------- |
| **storage_deposit**          | Payable method that receives an attached deposit of ‚ìÉ for a given account. This will register the user on the contract. |
| **storage_balance_bounds** | Returns the minimum and maximum allowed storage deposit required to interact with the contract. In the FT contract's case, min = max.|
| **storage_balance_of** | Returns the total and available storage paid by a given user. In the FT contract's case, available is always 0 since it's used by the contract for registration and you can't overpay for storage.  |

<Github language="rust" start="81" end="108" url="https://github.com/near-examples/ft-tutorial/blob/main/1.skeleton/src/storage.rs" />

:::tip
You'll learn more about these functions in the [storage](4.storage.md) section of the tutorial series.
:::

## Building the skeleton

If you haven't cloned the main repository yet, open a terminal and run:

```sh
git clone https://github.com/near-examples/ft-tutorial/
```

Next, build the skeleton contract with the build script found in the `1.skeleton/build.sh` file.

```sh
cd ft-tutorial/1.skeleton
cargo near build
```

Since this source is just a skeleton you'll get many warnings about unused code, such as:

```
   = note: `#[warn(dead_code)]` on by default

warning: constant is never used: `GAS_FOR_RESOLVE_TRANSFER`
 --> src/ft_core.rs:5:1
  |
5 | const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: constant is never used: `GAS_FOR_FT_TRANSFER_CALL`
 --> src/ft_core.rs:6:1
  |
6 | const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

warning: `fungible-token` (lib) generated 25 warnings
    Finished release [optimized] target(s) in 1.93s
‚ú®  Done in 2.03s.
```

Don't worry about these warnings, you're not going to deploy this contract yet.
Building the skeleton is useful to validate that your Rust toolchain works properly and that you'll be able to compile improved versions of this FT contract in the upcoming tutorials.

---

## Conclusion

You've seen the layout of this FT smart contract, and how all the functions are laid out across the different source files.
Using `yarn`, you've been able to compile the contract, and you'll start fleshing out this skeleton in the next [section](/tutorials/fts/circulating-supply) of the tutorial.

---

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-sdk-rs: `5.1.0` (with enabled `legacy` feature)
- cargo-near: `0.13.2`
:::


 This is the content for the doc docs/3.tutorials/fts/2-define-a-token.md 

 ---
id: defining-a-token
title: Defining a Fungible Token
sidebar_label: Defining Your Token
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This is the first of many tutorials in a series where you'll be creating a complete FT smart contract from scratch that conforms with all the NEAR [FT standards](https://nomicon.io/Standards/Tokens/FungibleToken/Core). Today you'll learn what a Fungible Token is and how you can define one on the NEAR blockchain. You will be modifying a bare-bones [skeleton smart contract](/tutorials/fts/skeleton) by filling in the necessary code snippets needed to add this functionality.

---

## Introduction

To get started, switch to the `1.skeleton` folder in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](/tutorials/fts/skeleton) to get started.

If you wish to see the finished code for this portion of the tutorial, that can be found on the `2.defining-a-token` folder.

---

## Modifications to the skeleton contract {#modifications}

At its very core, a fungible token is an exchangeable asset that **is divisible** but is **not unique**. For example, if Benji had 1 Canadian dollar, it would be worth the exact same as Matt's Canadian dollar. Both their dollars are fungible and exchangeable. In this case, the fungible token is the canadian dollar. All fiat currencies are fungible and exchangeable.

Non-fungible tokens, on the other hand, are **unique** and **indivisible** such as a house or a car. You **cannot** have another asset that is exactly the same. Even if you had a specific car model, such as a Corvette 1963 C2 Stingray, each car would have a separate serial number with a different number of kilometers driven etc...

Now that you understand what a fungible token is, let's look at how you can define one in the contract itself.

<hr className="subsection" />

### Defining a fungible token {#defining-a-fungible-token}

Start by navigating to the `1.skeleton/src/metadata.rs` file. This is where you'll define the metadata for the fungible token itself. There are several ways NEAR allows you to customize your token, all of which are found in the [metadata](https://nomicon.io/Standards/Tokens/FungibleToken/Core#metadata) standard. Let's break them up into the optional and non-optional portions.

Required:
- **spec**: Indicates the version of the standard the contract is using. This should be set to `ft-1.0.0`.
- **name**: The human readable name of the token such as "Wrapped NEAR" or "TEAM Tokens".
- **symbol**: The abbreviation of the token such as `wNEAR` or `gtNEAR`.
- **decimals**: used in frontends to show the proper significant digits of a token. This concept is explained well in this [OpenZeppelin post](https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals).

Optional:
- **icon**: The image for the token (must be a [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)).
- **reference**: A link to any supplementary JSON details for the token stored off-chain.
- **reference_hash**: A hash of the referenced JSON.

With this finished, you can now add these fields to the metadata in the contract.

<Github language="rust" start="8" end="19" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/metadata.rs" />

Now that you've defined what the metadata will look like, you need someway to store it on the contract. Switch to the `1.skeleton/src/lib.rs` file and add the following to the `Contract` struct. You'll want to store the metadata on the contract under the `metadata` field.

<Github language="rust" start="18" end="24" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/lib.rs" />

You've now defined *where* the metadata will live but you'll also need someway to pass in the metadata itself. This is where the initialization function comes into play.

<hr className="subsection" />

#### Initialization Functions

You'll now create what's called an initialization function; you can name it `new`. This function needs to be invoked when you first deploy the contract. It will initialize all the contract's fields that you've defined with default values. It's important to note that you **cannot** call these methods more than once.

<Github language="rust" start="58" end="74" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/lib.rs" />

More often than not when doing development, you'll need to deploy contracts several times. You can imagine that it might get tedious to have to pass in metadata every single time you want to initialize the contract. For this reason, let's create a function that can initialize the contract with a set of default `metadata`. You can call it `new_default_meta`.

<Github language="rust" start="38" end="54" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/lib.rs" />

This function is simply calling the previous `new` function and passing in some default metadata behind the scenes.

At this point, you've defined the metadata for your fungible tokens and you've created a way to store this information on the contract. The last step is to introduce a getter that will query for and return the metadata. Switch to the `1.skeleton/src/metadata.rs` file and add the following code to the `ft_metadata` function.

<Github language="rust" start="21" end="31" url="https://github.com/near-examples/ft-tutorial/blob/main/2.define-a-token/src/metadata.rs" />

This function will get the `metadata` object from the contract which is of type `FungibleTokenMetadata` and will return it.

---

## Interacting with the contract on-chain

Now that the logic for defining a custom fungible token is complete and you've added a way to query for the metadata, it's time to build and deploy your contract to the blockchain.

### Deploying and initializing the contract {#deploy-the-contract}

You can build a contract using the following command:

```bash
cd 2.define-a-token
cargo near build
```

There will be a list of warnings on your console, but as the tutorial progresses, these warnings will go away.

For deployment, you will need a NEAR account with the keys stored on your local machine. Navigate to the [NEAR wallet](https://testnet.mynearwallet.com/) site and create an account.

:::info
Please ensure that you deploy the contract to an account with no pre-existing contracts. It's easiest to simply create a new account or create a sub-account for this tutorial.
:::

Log in to your newly created account with `near-cli-rs` by running the following command in your terminal.

```bash
near account import-account using-web-wallet network-config testnet
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` portion:

```bash
export FT_CONTRACT_ID="YOUR_ACCOUNT_NAME.testnet"
```

Test that the environment variable is set correctly by running:

```bash
echo $FT_CONTRACT_ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract. For simplicity, let's call the default metadata initialization function you wrote earlier so that you don't have to type the metadata manually in the CLI. In the root of your FT project run the following command to deploy your smart contract.

```bash
cargo near deploy build-non-reproducible-wasm $FT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$FT_CONTRACT_ID'", "total_supply": "0"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

At this point, the contract should have been deployed to your account and initialized.

<hr className="subsection" />

### Viewing the contract's metadata

Now that the contract has been initialized, you can query for the metadata by calling the function you wrote earlier.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $FT_CONTRACT_ID ft_metadata '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $FT_CONTRACT_ID ft_metadata json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```js
{
  spec: 'ft-1.0.0',
  name: 'Team Token FT Tutorial',
  symbol: 'gtNEAR',
  icon: 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/
        /*
        ...lots of base64 data...
        */
        j4Mvhy9H9NlnieJ4iwoo9ZlyLGx4pnrPWeB4CVGRZZcJ7Vohwhi0z5MJY4cVL4MdP/Z',
  reference: null,
  reference_hash: null,
  decimals: 24
}
```

**Go team!** You've now verified that everything works correctly and you've defined your own fungible token!

In the next tutorial, you'll learn about how to create a total supply and view the tokens in the wallet.

---

## Conclusion

In this tutorial, you went through the basics of setting up and understanding the logic behind creating a fungible token on the blockchain using a skeleton contract.

You first looked at [what a fungible token is](#modifications) and how it differs from a non-fungible token. You then learned how to customize and create your own fungible tokens and how you could modify the skeleton contract to achieve this. Finally you built and deployed the contract and interacted with it using the NEAR CLI.

## Next Steps

In the [next tutorial](/tutorials/fts/circulating-supply), you'll find out how to create an initial supply of tokens and have them show up in the NEAR wallet.

---

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-sdk-rs: `5.1.0` (with enabled `legacy` feature)
- cargo-near: `0.13.2`
- near-cli-rs: `0.17.0`
:::


 This is the content for the doc docs/3.tutorials/fts/3-circulating-supply.md 

 ---
id: circulating-supply
title: Creating a Circulating Supply
sidebar_label: Circulating Supply
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In the previous tutorial, you looked at what a fungible token was and how you could define one in your smart contract. In this tutorial, you'll learn how to create a circulating supply belonging to the contract owner and view all the tokens, with their metadata, in the NEAR wallet.

To get started, either work off the code you wrote in the previous tutorial or switch to the `2.define-a-token` folder in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](1-skeleton.md) to start.

If you wish to see the finished code for this tutorial, you can find it in the `3.initial-supply` folder.

---

## Introduction

Every fungible token contract on NEAR has what's known as a circulating supply. This is the number of tokens that exist on the contract and are actively available to trade.

When creating your contract, there are many different ways you could implement this to start. A few examples could be:
- Specify a starting total supply and distribute it based on a set of parameters (Benji gets 20%, Josh gets 2.5%, and the rest goes to Mike).
- Have a first come first serve pool where everybody claims up to X amount of tokens.
- Create tokens on demand resulting in a steady increase of the circulating supply overtime up to a specified cap.

The simplest approach, however, is to specify a total supply when initializing the contract. The entire circulating supply is then created and sent to the owner of the contract. The owner would then be able to transfer or sell the tokens as they wish. Once the initial supply is created, no more FTs could be minted. This means that the circulating supply will always be equal to the total supply.

---

## Modifications to contract

In order to implement this logic, you'll need to keep track of two things in your smart contract:
- A mapping of an account to the number of tokens they own.
- The total supply of tokens.

The mapping is so that you can easily check or modify the tokens owned by any given account at anytime within your contract. You'll also need to keep track of the total supply since it's required by the standard that you have a function to query for the supply of tokens on the contract.

<hr className="subsection" />

### Setting the supply

Head over to the `src/lib.rs` file and add the following code to the `Contract` struct.

<Github language="rust" start="21" end="33" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

You'll now want to add the functionality for depositing the tokens into the owner's account. Do this by creating a helper function that takes an amount and an account ID and performs the deposit logic for you. First create a new file `src/internal.rs` such that your file structure now looks as follows.

```
src
  ‚îú‚îÄ‚îÄ ft_core.rs
  ‚îú‚îÄ‚îÄ internal.rs
  ‚îú‚îÄ‚îÄ lib.rs
  ‚îú‚îÄ‚îÄ metadata.rs
  ‚îî‚îÄ‚îÄ storage.rs
```

In the `internal.rs` file, add the following code to create a function called `internal_deposit` which takes an `AccountId` and a `NearToken` as a balance and adds the amount to the account's current supply of FTs.

<Github language="rust" start="1" end="18" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/internal.rs" />

Now that the functionality for depositing FTs is in place, switch back to the `src/lib.rs` file and add the `internal` module:

<Github language="rust" start="8" end="10" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

In addition, add the following code to the `new` initialization function.

```rust
#[init]
pub fn new(
    owner_id: AccountId,
    total_supply: U128,
    metadata: FungibleTokenMetadata,
) -> Self {
    let casted_total_supply = NearToken::from_yoctonear(total_supply.0);
    // Create a variable of type Self with all the fields initialized.
    let mut this = Self {
        // Set the total supply
        total_supply: casted_total_supply,
        // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
        accounts: LookupMap::new(StorageKey::Accounts),
        metadata: LazyOption::new(
            StorageKey::Metadata,
            Some(&metadata),
        ),
    };

    // Set the owner's balance to the total supply.
    this.internal_deposit(&owner_id, casted_total_supply);

    // Return the Contract object
    this
}
```

This will initialize the total supply to what you passed in and will call the `internal_deposit` function to add the total supply to the owner's account.

<hr className="subsection" />

### Getting the supply

Now that you've created a way to set the total supply, you'll also want a way to query for it as well as the balance for a specific user. The [standard](https://nomicon.io/Standards/Tokens/FungibleToken/Core) dictates that you should have two methods on your smart contract for doing these operations:
- **`ft_total_supply`**
- **`ft_balance_of`**

Head on over to the `src/ft_core.rs` file and add the following code to these functions.

<Github language="rust" start="83" end="91" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/ft_core.rs" />

At this point, you have everything you need to create an initial supply of tokens and query for the balance of a given account. There is, however, a problem that we need to solve. How will the wallet know that the total supply was created and is owned by the contract owner? How would it even know that our contract is a fungible token contract? If you were to deploy the contract and run through the setup process, you would be able to query for the information from the contract but you wouldn't see any FTs in the owner's NEAR wallet.

---

## Events

Have you ever wondered how the wallet knows which FTs you own and how it can display them in the [balances tab](https://testnet.mynearwallet.com/)? Originally, an indexer used to listen for any function calls starting with `ft_` on your account. These contracts were then flagged on your account as likely FT contracts.

When you navigated to your balances tab, the wallet would then query all those contracts for the number of FTs you owned using the `ft_balance_of` function you just wrote.

<hr className="subsection" />

### The problem {#the-problem}

This method of flagging contracts was not reliable as each FT-driven application might have its own way of minting or transferring FTs. In addition, it's common for apps to transfer or mint many tokens at a time using batch functions.

<hr className="subsection" />

### The solution {#the-solution}

A standard was introduced so that smart contracts could emit an event anytime FTs were transferred, minted, or burnt. This event was in the form of a log. No matter how a contract implemented the functionality, an indexer could now listen for those standardized logs.

As per the standard, you need to implement a logging functionality that gets fired when FTs are transferred or minted. In this case, the contract doesn't support burning so you don't need to worry about that for now.

It's important to note the standard dictates that the log should begin with `"EVENT_JSON:"`. The structure of your log should, however, always contain the 3 following things:

- **standard**: the current name of the standard (e.g. `nep141`)
- **version**: the version of the standard you're using (e.g. `1.0.0`)
- **event**: a list of events you're emitting.

The event interface differs based on whether you're recording transfers or mints. The interface for both events is outlined below.

**Transfer events**:
- **old_owner_id**: the old owner of the FTs.
- **new_owner_id**: the new owner that the FTs are being transferred to.
- **amount**: the number of tokens transferred.
- *Optional* - **memo**: an optional message to include with the event.

**Minting events**:
- **owner_id**: the owner that the FTs are being minted to.
- **amount**: the amount of FTs being minted.
- *Optional* - **memo**: an optional message to include with the event.

<hr className="subsection" />

### Examples {#examples}

In order to solidify your understanding of the standard, let's walk through two scenarios and see what the logs should look like.

#### Scenario A - simple mint

In this scenario, the Benji mints 50 FTs to himself and doesn't include a message. The log should look as follows.

```js
EVENT_JSON:{
  "standard": "nep141",
  "version": "1.0.0",
  "event": "ft_mint",
  "data": [
    {"owner_id": "benji.testnet", "amount": "50"}
  ]
}
```

<hr className="subsection" />

#### Scenario B - batch transfer

In this scenario, Benji wants to perform a batch transfer. He will send FTs to Jada, Mike, Josh, and Maria. The log is as follows.

```js
EVENT_JSON:{
    "standard": "nep141",
    "version": "1.0.0",
    "event": "ft_transfer",
    "data": [
        {"old_owner_id": "benji.near", "new_owner_id": "josh.near", "amount": "1", "memo": "go team"},
        {"old_owner_id": "benji.near", "new_owner_id": "mike.near", "amount": "9000"},
        {"old_owner_id": "benji.near", "new_owner_id": "jada.near", "amount": "500"},
        {"old_owner_id": "benji.near", "new_owner_id": "maria.near", "amount": "500"}
    ]
}
```

---

## Modifications to the contract {#modifications-to-the-contract}

At this point, you should have a good understanding of what the end goal should be so let's get to work! Open the `src` directory and create a new file called `events.rs`. This is where your log structs will live.

### Creating the events file {#events-rs}

Copy the following into your file. This will outline the structs for your `EventLog`, `FtMintLog`, and `FtTransferLog`. In addition, we've added a way for `EVENT_JSON:` to be prefixed whenever you log the `EventLog`.

<Github language="rust" start="16" end="121" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/events.rs" />

<hr className="subsection" />

### Adding modules and constants {#lib-rs}

Now that you've created a new file, you need to add the module to the `lib.rs` file.

<Github language="rust" start="1" end="13" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

<hr className="subsection" />

### Logging the total supply minted

Now that all the tools are set in place, you can implement the actual logging functionality. Since the contract will only be minting tokens at the very start when it's initialized, it's trivial where you should place the log. Open the `src/lib.rs` file and navigate to the bottom of the `new` initialization function. This is where you'll construct the log for minting.

<Github language="rust" start="67" end="98" url="https://github.com/near-examples/ft-tutorial/blob/main/3.initial-supply/src/lib.rs" />

With that finished, you've successfully implemented the backbone of the events standard and it's time to start testing.

---

## Deploying the contract {#redeploying-contract}

Since the current contract you have is already initialized, let's create a sub-account and deploy to that instead.

### Creating a sub-account

Run the following command to create a sub-account `events` of your main account with an initial balance of 3 NEAR which will be transferred from the original to your new account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near create-account events.$FT_CONTRACT_ID --use-account $FT_CONTRACT_ID --initial-balance 3 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account create-account fund-myself events.$FT_CONTRACT_ID '3 NEAR' autogenerate-new-keypair save-to-keychain sign-as $FT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Next, you'll want to export an environment variable for ease of development:

```bash
export EVENTS_FT_CONTRACT_ID=events.$FT_CONTRACT_ID
```

Build the contract as you did in the previous tutorials:

```bash
cd 2.define-a-token
cargo near build
```

<hr className="subsection" />

### Deploying and Initialization {#deploying-initialization}

It's time to deploy the contract, initialize it and mint the total supply. Let's create an initial supply of 1000 `gtNEAR`. Since it has 24 decimal places, you should put `1000` followed by 24 zeros in the total supply field.

```bash
cargo near deploy build-non-reproducible-wasm $EVENTS_FT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$EVENTS_FT_CONTRACT_ID'", "total_supply": "1000000000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

You can check to see if everything went through properly by looking at the output in your CLI:

```bash
...
Transaction sent ...
--- Logs ---------------------------
Logs [events.aha_3.testnet]:
  EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_mint","data":[{"owner_id":"events.goteam.testnet","amount":"1000000000000000000000000000","memo":"Initial token supply is minted"}]}
--- Result -------------------------
Empty result
------------------------------------

Contract code has been successfully deployed.
The "new_default_meta" call to <events.goteam.testnet> on behalf of <events.goteam.testnet> succeeded.
...
```

You can see that the event was properly logged!

<hr className="subsection" />

### Querying Supply Information {#testing}

You can now test if your view functions work properly. First, try to query for the total supply.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $EVENTS_FT_CONTRACT_ID ft_total_supply '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $EVENTS_FT_CONTRACT_ID ft_total_supply json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```bash
'1000000000000000000000000000'
```

Hurray! Now you can check if the balance of the owner account works properly. If you call the following function, it should return the same number as the total supply.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $EVENTS_FT_CONTRACT_ID ft_balance_of '{"account_id": "'$EVENTS_FT_CONTRACT_ID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $EVENTS_FT_CONTRACT_ID ft_balance_of json-args '{"account_id": "'$EVENTS_FT_CONTRACT_ID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>


Returns:

```bash
'1000000000000000000000000000'
```

If you query for the balance of some other account, it should return `0`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $EVENTS_FT_CONTRACT_ID ft_balance_of '{"account_id": "benjiman.testnet"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $EVENTS_FT_CONTRACT_ID ft_balance_of json-args '{"account_id": "benjiman.testnet"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

---

## Viewing FTs in the wallet {#viewing-fts-in-wallet}

Now that your contract implements the necessary functions that the wallet uses to pickup your contract and display the FTs, you should be able to see your tokens on display in the [balances tab](https://testnet.mynearwallet.com/).

<img width="65%" src="/docs/assets/fts/filled-fts-in-wallet.png" />

üéâüéâüéâ **This is awesome! Go team!** üéâüéâüéâ You can now see your very first fungible tokens in the wallet!

---

## Conclusion

Today you went through and created the logic for minting a total supply. You then implemented some of the core standard logic and the [events standard](https://nomicon.io/Standards/Tokens/FungibleToken/Event). You created events for [minting](#modifications-to-the-contract) FTs on initialization. You then deployed and [tested](#testing) your changes and saw your very first FTs in the wallet!

In the next tutorial, you'll look at the basics of registering accounts so that they can transfer and receive FTs.

---

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-sdk-rs: `5.1.0` (with enabled `legacy` feature)
- cargo-near: `0.13.2`
- cargo-near: `0.6.1`
- near-cli-rs: `0.17.0`
:::


 This is the content for the doc docs/3.tutorials/fts/4.storage.md 

 ---
id: registering-accounts
title: Registering Accounts
sidebar_label: Registering Accounts
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In the previous tutorial, you looked at how to mint an initial circulating supply of tokens and how you could log events as per the [events standard](https://nomicon.io/Standards/Tokens/FungibleToken/Event). You then deployed the contract and saw the FTs in your wallet balance. In this tutorial, you'll learn about the [storage management](https://nomicon.io/Standards/StorageManagement) standard and how you can register accounts in your FT contract in order to prevent a malicious party from draining your contract of all its funds.

---

## Introduction

Whenever a new person receives any fungible tokens, they're added to the `accounts` lookup map on the contract. By doing this, you're adding bytes to the contract. If you made it so any user could receive FTs for free, that system could easily be abused. Users could essentially "drain" the contract of all its funds by sending small amounts of FTs to many accounts. For this reason, you'll want to charge users for the information they're storing and the bytes they're using on the contract. This way of charging users, however, should be standardized so it works across all contracts.

*Enter the [storage management](https://nomicon.io/Standards/StorageManagement) standard*

<img width="65%" src="/docs/assets/fts/storage-standard-meme.png" />

<hr className="subsection" />

### Storage Management Standard

The storage management standard is a set of rules that govern how a contract should charge users for storage. It outlines functions and behaviors such that all contracts implementing the standard are interoperable with each other. The 3 functions you'll need to implement are:
- **`storage_deposit`** - Allows a user to deposit some amount of storage to the contract. If the user over deposits, they're refunded for the excess $NEAR.
- **`storage_balance_of`** - Query for the storage paid by a given user
- **`storage_balance_bounds`** - Query for the minimum and maximum amount of storage needed to interact with a given contract.

With these functions outlined, you could make a reasonable assumption that the flow would be:
1. If a user doesn't exist on the contract, they need to deposit some storage to cover the bytes they use.
2. Once the user deposits $NEAR via the `storage_deposit` function, they're free to interact with the contract.

You might be asking yourself what the deposit amount should be. There are two ways you can go about getting this information:
- Dynamically calculate the bytes every individual user would take up in the `storage_deposit` function by inserting them into `accounts` map, measuring the bytes, and then removing them from the map after.
- Calculate the bytes for inserting a largest possible account ID once upon initializing the contract and simply charge every user the same amount.

For the purpose of simplicity, we'll assume the second method.

---

## Modifications to the Contract

This "bytes for longest account ID" should be stored in the contract's state such that we can pull the value during the `storage_deposit` function and ensure the user attaches enough $NEAR. Open the `src/lib.rs` file and add the following code to the `Contract` struct. If you're just joining us now, you can find the skeleton code for this tutorial in the `3.initial-supply` folder.

<Github language="rust" start="23" end="35" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/lib.rs" />

You'll now need a way to calculate this amount which will be done in the initialization function. Move to the `src/internal.rs` file and add the following private function `measure_bytes_for_longest_account_id` which will add the longest possible account ID and remove it while measuring how many bytes the operation took. It will then set the `bytes_for_longest_account_id` field to the result.

<Github language="rust" start="38" end="46" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs" />

You'll also want to create a function for _registering_ an account after they've paid for storage. To do this, you can simply insert them into the `accounts` map with a balance of 0. This way, you know that any account currently in the map is considered "registered" and have paid for storage. Any account that attempts to receive FTs must be in the map with a balance of 0 or greater. If they aren't, the contract should throw.

<Github language="rust" start="31" end="36" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs" />

Let's also create a function to panic with a custom message if the user doesn't exist yet.

<Github language="rust" start="8" end="16" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs" />

Now when you call the `internal_deposit` function, rather than defaulting the user's balance to `0` if they don't exist yet via:

```rust
let balance = self.accounts.get(&account_id).unwrap_or(0);
```
You can replace it with the following:

<Github language="rust" start="18" end="29" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/internal.rs#L16-L27" />

With this finished, your `internal.rs` should look as follows:

```rust
use near_sdk::{require};

use crate::*;

impl Contract {
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
      ...
    }

    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
      ...
    }

    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
      ...
    }

    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
      ...
    }
}
```

There's only one problem you need to solve with this. When initializing the contract, the implementation will throw. This is because you call `internal_deposit` and the owner doesn't have a balance yet. To fix this, let's modify the initialization function to register the owner before depositing the FTs in their account. In addition, you should measure the bytes for the registration in this function.

<Github language="rust" start="70" end="110" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/lib.rs" />

<hr className="subsection" />

### Implementing Storage Standard

With this finished, you're now ready to implement the storage management standard. If you remember, the three functions you'll be implementing, we can break each down into their core functionality and decide how to proceed.

- **`storage_balance_bounds`** - Query for the minimum and maximum amount of storage needed to interact with a given contract.

Since you're creating a fungible token contract and the storage price won't change (unless the `$NEAR` cost per byte changes), the minimum and maximum storage costs should be the same. These values should be equal to the amount of bytes for the longest account ID you calculated in the `measure_bytes_for_longest_account_id` function multiplied by the current `$NEAR` price per byte. Switch to the `src/storage.rs` file to get started.

<Github language="rust" start="120" end="130" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/storage.rs" />

- **`storage_balance_of`** - Query for the storage paid by a given user.

As we mentioned earlier, you can tell if somebody has paid for storage by checking if they're in the `accounts` map. If they are, you know that they've paid the amount returned by `storage_balance_bounds`.

<Github language="rust" start="132" end="139" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/storage.rs" />

- **`storage_deposit`** - Allows a user to deposit some amount of storage to the contract. If the user over deposits, they're refunded for the excess $NEAR.

In order to implement this logic, you first need to get the attached deposit. You'll also need to ensure that the user hasn't already paid for storage (i.e. they're in the `accounts` map). If they are, simply refund the caller for the $NEAR they attached to the call.

If the user isn't registered yet, you should get the storage cost by calling `storage_balance_bounds` and make sure they've attached enough to cover that amount. Once this if finished, you can register them and refund any excess $NEAR.

<Github language="rust" start="81" end="118" url="https://github.com/near-examples/ft-tutorial/blob/main/4.storage/src/storage.rs" />

With this finished, you're ready to build and deploy the contract!

---

## Deploying the contract {#redeploying-contract}

Since the current contract you have is already initialized, let's create a sub-account and deploy to again.

### Creating a sub-account

Run the following command to create a sub-account `storage` of your main account with an initial balance of 3 NEAR which will be transferred from the original to your new account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near create-account storage.$FT_CONTRACT_ID --use-account $FT_CONTRACT_ID --initial-balance 3 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account create-account fund-myself storage.$FT_CONTRACT_ID '3 NEAR' autogenerate-new-keypair save-to-keychain sign-as $FT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Next, you'll want to export an environment variable for ease of development:

```bash
export STORAGE_FT_CONTRACT_ID=storage.$FT_CONTRACT_ID
```

Build the contract as you did in the previous tutorials:

```bash
cd 3.initial-supply
cargo near build
```

<hr className="subsection" />

### Deploying and Initialization {#deploying-initialization}

It's time to deploy the contract, initialize it and mint the total supply. Let's once again create an initial supply of 1000 `gtNEAR`.

```bash
cargo near deploy build-non-reproducible-wasm $STORAGE_FT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$STORAGE_FT_CONTRACT_ID'", "total_supply": "1000000000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

If you now query for the storage paid by the owner, you should see that they're registered!

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $STORAGE_FT_CONTRACT_ID storage_balance_of '{"account_id": "'$STORAGE_FT_CONTRACT_ID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $STORAGE_FT_CONTRACT_ID storage_balance_of json-args '{"account_id": "'$STORAGE_FT_CONTRACT_ID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return a struct. The Total amount is roughly `0.00125 $NEAR` to register and the user has 0 available $NEAR since it's all being used up to pay for registration.

```js
{ total: '1250000000000000000000', available: '0' }
```

You can also query for the storage balance required to interact with the contract:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $STORAGE_FT_CONTRACT_ID storage_balance_bounds '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $STORAGE_FT_CONTRACT_ID storage_balance_bounds json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

You'll see that it returns the same amount as the `storage_balance_of` query above with the min equal to the max:

```js
{ min: '1250000000000000000000', max: '1250000000000000000000' }
```

---

## Conclusion

Today you went through and created the logic for registering users on the contract. This logic adheres to the [storage management standard](https://nomicon.io/Standards/StorageManagement) and is customized to meet our needs when writing a FT contract. You then built, deployed, and tested those changes. In the [next tutorial](5.transfers.md), you'll look at the basics of how to transfer FTs to other users.

---

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-sdk-rs: `5.1.0` (with enabled `legacy` feature)
- cargo-near: `0.13.2`
- near-cli-rs: `0.17.0`
:::


 This is the content for the doc docs/3.tutorials/fts/5.transfers.md 

 ---
id: transfers
title: Transferring Fungible Tokens
sidebar_label: Transferring FTs
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll learn how to implement the [core standards](https://nomicon.io/Standards/Tokens/FungibleToken/Core) into your smart contract. You'll implement the logic that allows you to transfer and receive tokens. If you're joining us for the first time, feel free to clone [this repository](https://github.com/near-examples/ft-tutorial) and follow along in the `4.storage` folder.

:::tip

If you wish to see the finished code for this _Core_ tutorial, you can find it in the [`5.transfers`](https://github.com/near-examples/ft-tutorial/blob/main/5.transfers) folder.

:::

---

## Introduction {#introduction}

Up until this point, you've created a simple FT smart contract that allows the owner to mint a total supply of tokens and view information about the Fungible Token itself. In addition, you've added the functionality to register accounts and emit events. Today, you'll expand your smart contract to allow for users to transfer and receive fungible tokens.

The logic for doing a simple transfer is quite easy to understand. Let's say Benji wants to transfer Mike 100 of his fungible tokens. The contract should do a few things:
- Check if Benji owns at least 100 tokens.
- Make sure Benji is calling the function.
- Ensure Mike is registered on the contract.
- Take 100 tokens out of Benji's account.
- Put 100 tokens into Mike's account.

At this point, you're ready to move on and make the necessary modifications to your smart contract.

---

## Modifications to the contract

Let's start our journey in the `src/ft_core.rs` file.

### Transfer function {#transfer-function}

You'll start by implementing the `ft_transfer` logic which is found in the `src/ft_core.rs` file. This function will transfer the specified `amount` to the `receiver_id` with an optional `memo` such as `"Happy Birthday Mike!"`.

<Github language="rust" start="62" end="70" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/ft_core.rs" />

There are a couple things to notice here.

1. We've introduced a new function called `assert_one_yocto()`. This method will ensure that the user is signing the transaction with a full access key by requiring a deposit of exactly 1 yoctoNEAR, the smallest possible amount of $NEAR that can be transferred. Since the transfer function is potentially transferring very valuable assets, you'll want to make sure that whoever is calling the function has a full access key.

2. We've introduced an `internal_transfer` method. This will perform all the logic necessary to transfer the tokens internally.

<hr className="subsection" />

### Internal helper functions

Let's quickly move over to the `ft-contract/src/internal.rs` file so that you can implement the `internal_transfer` method which is the core of this tutorial. This function will take the following parameters:

- **sender_id**: the account that's attempting to transfer the tokens.
- **receiver_id**: the account that's receiving the tokens.
- **amount**: the amount of FTs being transferred.
- **memo**: an optional memo to include.

The first thing you'll want to do is make sure the sender isn't sending tokens to themselves and that they're sending a positive number. After that, you'll want to withdraw the tokens from the sender's balance and deposit them into the receiver's balance. You've already written the logic to deposit FTs by using the `internal_deposit` function.

Let's use similar logic to implement `internal_withdraw`:

<Github language="rust" start="31" end="41" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/internal.rs" />

In this case, the contract will get the account's balance and ensure they are registered by calling the `internal_unwrap_balance_of` function. It will then subtract the amount from the user's balance and re-insert them into the map.

Using the `internal_deposit` and `internal_withdraw` functions together, the core of the `internal_transfer` function is complete.

There's only one more thing you need to do. When transferring the tokens, you need to remember to emit a log as per the [events](https://nomicon.io/Standards/Tokens/FungibleToken/Event) standard:

<Github language="rust" start="44" end="68" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/internal.rs" />

Now that this is finished, the simple transfer case is done! You can now transfer FTs between registered users!

<hr className="subsection" />

### Transfer call function {#transfer-call-function}

In this section, you'll learn about a new function `ft_transfer_call`. This will transfer FTs to a receiver and also call a method on the receiver's contract all in the same transaction.

Let's consider the following scenario. An account wants to transfer FTs to a smart contract for performing a service. The traditional approach would be to perform the service and then ask for the tokens in two separate transactions. If we introduce a ‚Äútransfer and call‚Äù workflow baked into a single transaction, the process can be greatly improved:

<Github language="rust" start="72" end="100" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/ft_core.rs" />

This function will do several things:

1. Ensures the caller attached exactly 1 yocto for security purposes.
2. Transfer the tokens using the `internal_transfer` you just wrote.
3. Creates a promise to call the method `ft_on_transfer` on the `receiver_id`'s contract.
4. After the promise finishes executing, the function `ft_resolve_transfer` is called.

:::info

This is a very common workflow when dealing with cross contract calls. You first initiate the call and wait for it to finish executing. Then, you invoke a function that resolves the result of the promise and act accordingly.
[Learn more here](../../2.build/2.smart-contracts/anatomy/crosscontract.md).

:::

When calling `ft_on_transfer`, it will return how many tokens the contract should refund the original sender.

This is important for a couple of reasons:
1. If you send the receiver too many FTs and their contract wants to refund the excess.
2. If any of the logic panics, all of the tokens should be refunded back to the sender.

This logic will all happen in the `ft_resolve_transfer` function:

<Github language="rust" start="170" end="214" url="https://github.com/near-examples/ft-tutorial/blob/main/5.transfers/src/ft_core.rs" />

The first thing you'll do is check the status of the promise. If anything failed, you'll refund the sender for the full amount of tokens. If the promise succeeded, you'll extract the amount of tokens to refund the sender based on the value returned from `ft_on_transfer`. Once you have the amount needed to be refunded, you'll perform the actual refund logic by using the `internal_transfer` function you wrote previously.

You'll then return the net amount of tokens that were transferred to the receiver. If the sender transferred 100 tokens but 20 were refunded, this function should return 80.

With that finished, you've now successfully added the necessary logic to allow users to transfer FTs. It's now time to deploy and do some testing.

---

## Deploying the contract {#redeploying-contract}

Let's create a new sub-account to deploy the contract to. Since these changes are only additive and non state breaking, you could have deployed a patch fix to the contract you deployed in the storage section as well. To learn more about upgrading contracts, see the [upgrading a contract](/tutorials/nfts/upgrade-contract) section in the NFT Zero to Hero tutorial.

<hr className="subsection" />

### Creating a sub-account

Run the following command to create a sub-account `transfer` of your main account with an initial balance of 3 NEAR which will be transferred from the original to your new account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near create-account transfer.$FT_CONTRACT_ID --use-account $FT_CONTRACT_ID --initial-balance 3 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near account create-account fund-myself transfer.$FT_CONTRACT_ID '3 NEAR' autogenerate-new-keypair save-to-keychain sign-as $FT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Next, you'll want to export an environment variable for ease of development:

```bash
export TRANSFER_FT_CONTRACT_ID=transfer.$FT_CONTRACT_ID
```

Build the contract as you did in the previous tutorials:

```bash
cd 4.storage
cargo near build
```

<hr className="subsection" />

### Deployment and Initialization

It's time to deploy the contract, initialize it and mint the total supply. Let's once again create an initial supply of 1000 `gtNEAR`.

```bash
cargo near deploy build-non-reproducible-wasm $TRANSFER_FT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$TRANSFER_FT_CONTRACT_ID'", "total_supply": "1000000000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

You can check if you own the FTs by running the following command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "'$TRANSFER_FT_CONTRACT_ID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $TRANSFER_FT_CONTRACT_ID ft_balance_of json-args '{"account_id": "'$TRANSFER_FT_CONTRACT_ID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Testing the transfer function

Let's test the transfer function by transferring 1 `gtNEAR` from the owner account to the account `benjiman.testnet`

:::warning Keep in mind
The Fungible tokens won't be recoverable unless the account `benjiman.testnet` transfers them back to you. If you don't want your FTs lost, make a new account and transfer the token to that account instead.
:::

You'll first need to register the account `benjiman.testnet` by running the following command.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $TRANSFER_FT_CONTRACT_ID storage_deposit '{"account_id": "benjiman.testnet"}' --gas 100000000000000 --deposit 0.01 --accountId $TRANSFER_FT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $TRANSFER_FT_CONTRACT_ID storage_deposit json-args '{"account_id": "benjiman.testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0.01 NEAR' sign-as $TRANSFER_FT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Once the account is registered, you can transfer the FTs by running the following command. Take note that you're also attaching exactly 1 yoctoNEAR by using the `--depositYocto` flag.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $TRANSFER_FT_CONTRACT_ID ft_transfer '{"receiver_id": "benjiman.testnet", "amount": "1000000000000000000000000", "memo": "Go Team :)"}' --gas 100000000000000 --depositYocto 1 --accountId $TRANSFER_FT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $TRANSFER_FT_CONTRACT_ID ft_transfer json-args '{"receiver_id": "benjiman.testnet", "amount": "1000000000000000000000000", "memo": "Go Team :)"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $TRANSFER_FT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You should see the `FtTransferEvent` being emitted in the console. At this point, if you check for the total supply, it should still be 1000 `gtNEAR` but if you check both the balance of Benji and the balance of the owner, they should reflect the transfer.

- Check owner balance:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "'$TRANSFER_FT_CONTRACT_ID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $TRANSFER_FT_CONTRACT_ID ft_balance_of json-args '{"account_id": "'$TRANSFER_FT_CONTRACT_ID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

- Check `benjiman.testnet` balance:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "benjiman.testnet"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $TRANSFER_FT_CONTRACT_ID ft_balance_of json-args '{"account_id": "benjiman.testnet"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

- Check total supply:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $TRANSFER_FT_CONTRACT_ID ft_total_supply '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $TRANSFER_FT_CONTRACT_ID ft_total_supply json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Testing the transfer call function

Now that you've tested the `ft_transfer` function, it's time to test the `ft_transfer_call` function. If you try to transfer tokens to a receiver that does **not** implement the `ft_on_transfer` function, the contract will panic and the FTs will be **refunded**. Let's test this functionality below.

You can try to transfer the FTs to the account `no-contract.testnet` which, as the name suggests, doesn't have a contract. This means that the receiver doesn't implement the `ft_on_transfer` function and the FTs should remain yours after the transaction is complete. You'll first have to register the account, however.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $TRANSFER_FT_CONTRACT_ID storage_deposit '{"account_id": "no-contract.testnet"}' --gas 100000000000000 --deposit 0.01 --accountId $TRANSFER_FT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $TRANSFER_FT_CONTRACT_ID storage_deposit json-args '{"account_id": "no-contract.testnet"}' prepaid-gas '100.0 Tgas' attached-deposit '0.01 NEAR' sign-as $TRANSFER_FT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $TRANSFER_FT_CONTRACT_ID ft_transfer_call '{"receiver_id": "no-contract.testnet", "amount": "1000000000000000000000000", "msg": "foo"}' --gas 100000000000000 --depositYocto 1 --accountId $TRANSFER_FT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $TRANSFER_FT_CONTRACT_ID ft_transfer_call json-args '{"receiver_id": "no-contract.testnet", "amount": "1000000000000000000000000", "msg": "foo"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $TRANSFER_FT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

The output response should be as follows.

```bash
Scheduling a call: transfer.dev-1660680326316-91393402417293.ft_transfer_call({"receiver_id": "no-contract.testnet", "amount": "1000000000000000000000000", "msg": "foo"}) with attached 0.000000000000000000000001 NEAR
Doing account.functionCall()
Receipts: AJ3yWv7tSiZRLtoTkyTgfdzmQP1dpjX9DxJDiD33uwTZ, EKtpDFoJWNnbyxJ7SriAFQYX8XV9ZTzwmCF2qhSaYMAc, 21UzDZ791pWZRKAHv8WaRKN8mqDVrz8zewLWGTNZTckh
	Log [transfer.dev-1660680326316-91393402417293]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"transfer.dev-1660680326316-91393402417293","new_owner_id":"no-contract.testnet","amount":"1000000000000000000000000"}]}
Receipt: 5N2WV8picxwUNC5TYa3A3v4qGquQAhkU6P81tgRt1UFN
	Failure [transfer.dev-1660680326316-91393402417293]: Error: Cannot find contract code for account no-contract.testnet
Receipt: AdT1bSZNCu9ACq7m6ynb12GgSb3zBenfzvvzRwfYPBmg
	Log [transfer.dev-1660680326316-91393402417293]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"no-contract.testnet","new_owner_id":"transfer.dev-1660680326316-91393402417293","amount":"1000000000000000000000000","memo":"Refund"}]}
Transaction Id 2XVy8MZU8TWreW8C9zK6HSyBsxE5hyTbyUyxNdncxL8g
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/2XVy8MZU8TWreW8C9zK6HSyBsxE5hyTbyUyxNdncxL8g
'0'
```

There should be a transfer event emitted for the initial transfer of tokens and then also for the refund. In addition, `0` should have been returned from the function because the sender ended up transferring net 0 tokens to the receiver since all the tokens were refunded.

If you query for the balance of `no-contract.testnet`, it should still be 0.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $TRANSFER_FT_CONTRACT_ID ft_balance_of '{"account_id": "no-contract.testnet"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $TRANSFER_FT_CONTRACT_ID ft_balance_of json-args '{"account_id": "no-contract.testnet"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

Hurray! At this point, your FT contract is fully complete and all the functionality is working as expected. Go forth and experiment! The world is your oyster and don't forget, go team!

---

## Conclusion

In this tutorial, you learned how to expand a FT contract by adding ways for users to transfer FTs. You [broke down](#introduction) the problem into smaller, more digestible subtasks and took that information and implemented both the [FT transfer](#transfer-function) and [FT transfer call](#transfer-call-function) functions. In addition, you deployed another [contract](#redeploying-contract) and [tested](#testing-the-transfer-function) the transfer functionality.

In the [next tutorial](/tutorials/fts/marketplace), you'll learn about how an NFT marketplace can operate to purchase NFTs by using Fungible Tokens.

---

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-sdk-rs: `5.1.0` (with enabled `legacy` feature)
- cargo-near: `0.13.2`
- near-cli-rs: `0.17.0`
:::


 This is the content for the doc docs/3.tutorials/fts/6-marketplace.md 

 ---
id: marketplace
title: Integrating FT Payments into an NFT Marketplace
sidebar_label: Adding FTs to a Marketplace
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll learn the basics of how an NFT marketplace contract works and how you can modify it to allow for purchasing NFTs using Fungible Tokens. In the previous tutorials, you went through and created a fully fledged FT contract that incorporates all the standards found in the [FT standard](https://nomicon.io/Standards/Tokens/FungibleToken/Core).

---

## Introduction

Throughout this tutorial, you'll learn how a marketplace contract could work on NEAR. This is meant to be an example and there is no canonical implementation. Feel free to branch off and modify this contract to meet your specific needs.

Using the same repository as the previous tutorials, if you visit the `market-contract` directory, you should have the necessary files to complete the tutorial.

---

## File structure {#file-structure}

This directory contains the actual contract code and dependencies as outlined below.

```
market-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ external.rs
    ‚îú‚îÄ‚îÄ ft_balances.rs
    ‚îú‚îÄ‚îÄ internal.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ nft_callbacks.rs
    ‚îú‚îÄ‚îÄ sale.rs
    ‚îî‚îÄ‚îÄ sale_views.rs
```

Let's start by building both the finished FT contract and the marketplace contract. Make sure you're in the root directory and run the following command in your terminal:


```bash
cd market-contract && cargo near build non-reproducible-wasm && cd ..
```

This will install the dependencies for the marketplace contract as well as the FT contract. Note that there's also `ft-tutorial/out` directory with pre-build nft contract wasm file which you'll use to place the NFTs for sale.

```
ft-tutorial
‚îî‚îÄ‚îÄ out
    ‚îî‚îÄ‚îÄ nft-contract.wasm
```

---

## Understanding the contract

The marketplace contract used in this tutorial is a modified version of the contract created at the end of the NFT zero to hero tutorial. If you'd like to learn about the backbone of how the NFTs are put for sale and the process by which they are minted / sold, check out the [NFT zero to hero tutorial](/tutorials/nfts/marketplace).

The core functionalities are the same in the sense that both this contract and the marketplace contract built in the NFT zero to hero have the following features:
- Users can put NFTs for sale and specify sale conditions
- Users must pay for storage deposit to put NFTs for sale and they can withdraw the storage at any time
- Users can update the price of an NFT or remove the sale entirely
- Buyers can purchase the NFTs by calling `offer`.

The only difference is that this marketplace has removed the ability to purchase NFTs for `$NEAR` and instead allows users to buy them with Fungible Tokens. The fungible token is specified when the contract is initialized and only **1 type of fungible token** can be used to purchase NFTs. You can't, for example, offer 100 Team Tokens for an NFT and 5000 Mike Tokens for another.

In addition, the marketplace does **not** support royalties. This is because FT transfers are less Gas efficient than regular $NEAR transfers. In addition, each user would have to be registered and it's much easier to say "hey seller, make sure you're registered before your NFT is sold" rather than enforcing that the seller and **all** accounts in the payout object are registered. When an NFT is sold, the entire price is sent directly to the seller.

<hr className="subsection" />

### Purchasing Flow

In order to purchase an NFT, the contract utilizes the "transfer and call" workflow that the FT contract provides. The marketplace contract implements the `ft_on_transfer` method that is called whenever someone transfers FTs to the marketplace contract.

The marketplace keeps track of a balance for each user that outlines how many FTs they've sent to the contract. Each time `ft_on_transfer` is called, the marketplace contract will update the balance for the user. When that user wishes to purchase an NFT, they call `offer` and pass in the amount of tokens they're willing to spend. The marketplace will then decrement from their balance and transfer the NFT to the buyer / send the FTs to the seller.

It's important to note that the seller **must** be registered in the FT contract before a sale is made otherwise the `ft_transfer` method will panic and the seller won't receive any tokens.

---

## Looking at the Code

Most of the code is the same as what's been outlined in the [NFT zero to hero tutorial](/tutorials/nfts/marketplace) but we'll go through a refresher in case you're new or have forgotten some of the details.

<hr className="subsection" />

### Main Library File

Starting at the `lib.rs` file, this outlines what information is stored on the contract as well as some other crucial functions that you'll learn about below.

<hr className="subsection" />

### Initialization function {#initialization-function}

The first function you'll look at is the initialization function. This takes an `owner_id` as well as the `ft_id` as the parameters and will default all the storage collections to their default values. The `ft_id` outlines the account ID for the fungible token that the contract will allow.

<Github language="rust" start="93" end="114" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/lib.rs" />

<hr className="subsection" />

### Storage management model {#storage-management-model}

Next, let's talk about the storage management model chosen for this contract. Users will need to deposit $NEAR onto the marketplace to cover the storage costs. Whenever someone puts an NFT for sale, the marketplace needs to store that information which costs $NEAR. Users can either deposit a large amount of $NEAR so that they never have to worry about storage again or they can deposit the minimum amount to cover 1 sale on an as-needed basis.

You might be thinking about the scenario when a sale is purchased. What happens to the storage that is now being released on the contract? This is why we have a storage withdrawal function. This allows users to withdraw any excess storage that is not being used. Let's go through some scenarios to understand the logic. The required storage for 1 sale is 0.01 NEAR on the marketplace contract.

**Scenario A**

- Benji wants to list his NFT on the marketplace but has never paid for storage.
- He deposits exactly 0.01 NEAR using the `storage_deposit` method. This will cover 1 sale.
- He lists his NFT on the marketplace and is now using up 1 out of his prepaid 1 sales and has no more storage left. If he were to call `storage_withdraw`, nothing would happen.
- Dorian loves his NFT and quickly purchases it before anybody else can. This means that Benji's sale has now been taken down (since it was purchased) and Benji is using up 0 out of his prepaid 1 sales. In other words, he has an excess of 1 sale or 0.01 NEAR.
- Benji can now call `storage_withdraw` and will be transferred his 0.01 NEAR back. On the contract's side, after withdrawing, he will have 0 sales paid for and will need to deposit storage before trying to list anymore NFTs.

**Scenario B**

- Dorian owns one hundred beautiful NFTs and knows that he wants to list all of them.
- To avoid having to call `storage_deposit` everytime he wants to list an NFT, he calls it once. Since Dorian is a baller, he attaches 10 NEAR which is enough to cover 1000 sales. He now has an excess of 9 NEAR or 900 sales.
- Dorian needs the 9 NEAR for something else but doesn't want to take down his 100 listings. Since he has an excess of 9 NEAR, he can easily withdraw and still have his 100 listings. After calling `storage_withdraw` and being transferred 9 NEAR, he will have an excess of 0 sales.

With this behavior in mind, the following two functions outline the logic.

<Github language="rust" start="119" end="182" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/lib.rs" />

In this contract, the storage required for each sale is 0.01 NEAR but you can query that information using the `storage_minimum_balance` function. In addition, if you wanted to check how much storage a given account has paid, you can query the `storage_balance_of` function.

---

## FT Deposits

If you want to learn more about how NFTs are put for sale, check out the [NFT zero to hero tutorial](/tutorials/nfts/marketplace). Once NFTs are put for sale, the owner has three options:
- Update the price of the NFT
- Remove the sale from the marketplace
- Wait for somebody to purchase it

In order to purchase NFTs, buyers need to deposit FTs in the contract and call the `offer` function. All the logic for FT deposits is outlined in the `src/ft_balances.rs` file. Starting with the `ft_on_transfer` function, this is called when a user transfers FTs to the marketplace contract. The logic can be seen below.

<Github language="rust" start="39" end="77" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/ft_balances.rs" />

Once FTs are deposited into the contract, users can either withdraw their FTs or they can use them to purchase NFTs. The withdrawing flow is outlined in the `ft_withdraw` function. It's important to note that you should decrement the user's balance **before** calling the `ft_transfer` function to avoid a common exploit scenario where a user spams the `ft_withdraw`. If you were to decrement their balance in the callback function (if the transfer was successful), they could spam the `ft_withdraw` during the time it takes the callback function to execute. A better pattern is to decrement their balance before the transfer and then if the promise was **unsuccessful**, revert the balance back to what it was before.

<Github language="rust" start="79" end="154" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/ft_balances.rs" />

---

## Purchasing NFTs

Now that you're familiar with the process of both adding storage and depositing FTs on the marketplace, let's go through what you can do once a sale has been listed. The `src/sale.rs` file outlines the functions for updating the price, removing, and purchasing NFTs. In this tutorial, we'll focus **only** on the purchasing flow. If you'd like to learn about the sale objects, updating the price, and removing a sale, check out the [NFT zero to hero tutorial](/tutorials/nfts/marketplace).

For purchasing NFTs, you must call the `offer` function. It takes an `nft_contract_id`, `token_id`, and the amount you wish to offer as parameters. Behind the scenes, this function will make sure your offer amount is greater than the list price and also that you have enough FTs deposited. It will then call a private method `process_purchase` which will perform a cross-contract call to the NFT contract to invoke the `nft_transfer` function where the NFT will be transferred to the seller.

<Github language="rust" start="68" end="145" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/sale.rs" />

Once the transfer is complete, the contract will call `resolve_purchase` where it will check the status of the transfer.If the transfer succeeded, it will send the FTs to the seller. If the transfer didn't succeed, it will increment the buyer's FT balance (acting as a refund).


<Github language="rust" start="147" end="191" url="https://github.com/near-examples/ft-tutorial/blob/main/market-contract/src/sale.rs" />

## View Methods

There are several view functions that the marketplace contract exposes. All of these functions are the same as the [NFT zero to hero tutorial](/tutorials/nfts/marketplace) except for one extra function we've added. In the `src/ft_balances.rs` file, we've added the `ft_balance_of` function. This function returns the balance of a given account.

---

## Testing

Now that you *hopefully* have a good understanding of how the marketplace contract works and how you can use the powers of the FT standard to purchase NFTs, let's move onto testing everything.

### Deploying and Initializing the Contracts

The first thing you'll want to do is deploy a new FT, NFT, and marketplace contract.

```bash
cd market-contract && cargo near build non-reproducible-wasm && cd ..
```

To deploy the FT contract and export an environment variable, run the following command:

```bash
export FT_CONTRACT=<new-ft-account-id>
near create-account $FT_CONTRACT --useFaucet
cd 5.transfers/ && cargo near deploy build-non-reproducible-wasm $FT_CONTRACT with-init-call new_default_meta json-args '{"owner_id": "'$FT_CONTRACT'", "total_supply": "1000000000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send && cd ../
```

Next, you'll deploy the NFT and marketplace contracts.

```bash
export NFT_CONTRACT=<new-nft-account-id>
near create-account $NFT_CONTRACT --useFaucet
near deploy $NFT_CONTRACT out/nft-contract.wasm
```

```bash
export MARKETPLACE_CONTRACT=<new-marketplace-account-id>
near create-account $MARKETPLACE_CONTRACT --useFaucet
cd market-contract/ && cargo near deploy build-non-reproducible-wasm $MARKETPLACE_CONTRACT with-init-call new json-args '{"owner_id": "'$MARKETPLACE_CONTRACT'", "ft_id": "'$FT_CONTRACT'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send && cd ../
```

Check and see if your environment variables are all correct by running the following command. Each output should be different.

```bash
echo $FT_CONTRACT && echo $MARKETPLACE_CONTRACT && echo $NFT_CONTRACT
```
An example output is:

```bash
ft-contract.testnet
marketplace-contract.testnet
nft-contract.testnet
```

Once that's finished, go ahead and initialize NFT contract by running the following command (FT and marketplace contract were initialized during deploying process above).

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT new_default_meta '{"owner_id": "'$NFT_CONTRACT'"}' --accountId $NFT_CONTRACT
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT new_default_meta json-args '{"owner_id": "'$NFT_CONTRACT'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $NFT_CONTRACT network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Let's check if each contract was initialized correctly. You can do this by checking the metadata of the FT and NFT contracts:

```bash
near view $FT_CONTRACT ft_metadata && near view $NFT_CONTRACT nft_metadata
```
In addition, you can check the sales of the marketplace contract and it should return 0.

```bash
near view $MARKETPLACE_CONTRACT get_supply_sales
```

<hr className="subsection" />

### Placing a Token For Sale

Now that the marketplace and NFT contracts are initialized, let's place a token for sale. Start by creating a new buyer and seller account by running the following command. In this case, we'll create a sub-account of the FT contract.

```bash
near create-account buyer.$FT_CONTRACT --masterAccount $FT_CONTRACT --initialBalance 2 && export BUYER_ID=buyer.$FT_CONTRACT
```

```bash
near create-account seller.$FT_CONTRACT --masterAccount $FT_CONTRACT --initialBalance 2 && export SELLER_ID=seller.$FT_CONTRACT
```

Check if everything went well by running the following command.

```bash
echo $BUYER_ID && echo $SELLER_ID
```
This should return something similar to:
```bash
buyer.ft-contract.testnet
seller.ft-contract.testnet
```

The next thing you'll want to do is mint a token to the seller.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT nft_mint '{"token_id": "market-token", "metadata": {"title": "Marketplace Token", "description": "testing out the marketplace", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$SELLER_ID'"}' --accountId $NFT_CONTRACT --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT nft_mint json-args '{"token_id": "market-token", "metadata": {"title": "Marketplace Token", "description": "testing out the marketplace", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$SELLER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Now you'll need to place the token for sale. This requires paying for storage as well as calling the `nft_approve` function.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $MARKETPLACE_CONTRACT storage_deposit --accountId $SELLER_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $MARKETPLACE_CONTRACT storage_deposit json-args '{}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $SELLER_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

In this case, we'll place the token for sale for `10 gtNEAR`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT nft_approve '{"token_id": "market-token", "account_id": "'$MARKETPLACE_CONTRACT'", "msg": "{\"sale_conditions\":\"10000000000000000000000000\"}"}' --accountId $SELLER_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT nft_approve json-args '{"token_id": "market-token", "account_id": "'$MARKETPLACE_CONTRACT'", "msg": "{\"sale_conditions\":\"10000000000000000000000000\"}"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $SELLER_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you now query for the supply of sales again on the marketplace, it should be 1.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT get_supply_sales
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $MARKETPLACE_CONTRACT get_supply_sales json-args {} network-config testnet now
    ```
  </TabItem>
</Tabs>

In addition, if you query for the sales by the owner ID, it should reflect the `10 gtNEAR` price.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT get_sales_by_owner_id '{"account_id": "'$SELLER_ID'"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $MARKETPLACE_CONTRACT get_sales_by_owner_id json-args '{"account_id": "'$SELLER_ID'"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

Expected output:

```bash
[
  {
    owner_id: 'seller.ft-contract.testnet',
    approval_id: 0,
    nft_contract_id: 'nft-contract.testnet',
    token_id: 'market-token',
    sale_conditions: '10000000000000000000000000'
  }
]
```

<hr className="subsection" />

### Deposit FTs into the Marketplace

Now that you have an NFT up for sale for `10 gtNEAR` on the marketplace contract, the buyer needs to deposit some FTs. The first thing you need to do is register both the marketplace contract and the buyer on the FT contract otherwise you won't be able to transfer any FTs.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $FT_CONTRACT storage_deposit '{"account_id": "'$MARKETPLACE_CONTRACT'"}' --accountId $FT_CONTRACT --amount 0.1

  near call $FT_CONTRACT storage_deposit '{"account_id": "'$BUYER_ID'"}' --accountId $FT_CONTRACT --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $FT_CONTRACT storage_deposit json-args '{"account_id": "'$MARKETPLACE_CONTRACT'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $FT_CONTRACT network-config testnet sign-with-keychain send

    near contract call-function as-transaction $FT_CONTRACT storage_deposit json-args '{"account_id": "'$BUYER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $FT_CONTRACT network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

After this, you should transfer the buyer some FTs so that they can deposit at least `10 gtNEAR`. Lets start with 50 `gtNEAR`. Run the following command to send the buyer FTs on behalf of the FT contract owner.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $FT_CONTRACT ft_transfer '{"receiver_id": "'$BUYER_ID'", "amount": "50000000000000000000000000", "memo": "Go Team!"}' --accountId $FT_CONTRACT --depositYocto 1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $FT_CONTRACT ft_transfer json-args '{"receiver_id": "'$BUYER_ID'", "amount": "50000000000000000000000000", "memo": "Go Team!"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $FT_CONTRACT network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You'll now need to deposit those tokens into the marketplace contract.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $FT_CONTRACT ft_transfer_call '{"receiver_id": "'$MARKETPLACE_CONTRACT'", "amount": "50000000000000000000000000", "msg": "Wooooooo!"}' --accountId $BUYER_ID --depositYocto 1 --gas 200000000000000
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $FT_CONTRACT ft_transfer_call json-args '{"receiver_id": "'$MARKETPLACE_CONTRACT'", "amount": "50000000000000000000000000", "msg": "Wooooooo!"}' prepaid-gas '200.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you now query for your balance on the marketplace contract, it should be `50 gtNEAR`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT ft_deposits_of '{"account_id": "'$BUYER_ID'"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $MARKETPLACE_CONTRACT ft_deposits_of json-args '{"account_id": "'$BUYER_ID'"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Purchasing the NFT

Now that the buyer has deposited FTs into the marketplace and the token is up for sale, let's go ahead and make an offer! If you try to offer more FTs than what you have, the contract will panic. Similarly, if you try to offer lower than the sale price, the contract will also panic. Since the sale price is `10 gtNEAR`, let's try to offer `20 gtNEAR` and see what happens. The expected outcome is:
- The NFT will be transferred to the buyer
- `20 gtNEAR` will be sent to the seller
- The buyer will have `30 gtNEAR` left to withdraw.

There is one thing we're forgetting, however. We need to make sure that the seller is registered on the FT contract so let's go ahead and do that now.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $FT_CONTRACT storage_deposit '{"account_id": "'$SELLER_ID'"}' --accountId $FT_CONTRACT --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $FT_CONTRACT storage_deposit json-args '{"account_id": "'$SELLER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $FT_CONTRACT network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Now let's make an offer!

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $MARKETPLACE_CONTRACT offer '{"nft_contract_id": "'$NFT_CONTRACT'", "token_id": "market-token", "amount": "20000000000000000000000000"}' --accountId $BUYER_ID --depositYocto 1 --gas 300000000000000
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $MARKETPLACE_CONTRACT offer json-args '{"nft_contract_id": "'$NFT_CONTRACT'", "token_id": "market-token", "amount": "20000000000000000000000000"}' prepaid-gas '300.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If everything went well, you should see 2 events in your terminal. One event is the NFT transfer coming from the NFT contract when the token was transferred from the seller to the buyer. The other event is the FT transfer for when the seller receives their fungible tokens.

```bash
Log [dev-1660831638497-73655245450834]: Memo: payout from market
Log [dev-1660831638497-73655245450834]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_transfer","data":[{"authorized_id":"dev-1660831638497-73655245450834","old_owner_id":"seller.dev-1660831615048-16894106456797","new_owner_id":"buyer.dev-1660831615048-16894106456797","token_ids":["market-token"],"memo":"payout from market"}]}
Receipt: BBvHig5zg1n2vmxFPTpxED4FNCAU1ZzZ3H8EBqqaeRw5
Log [dev-1660831638497-73655245450834]: EVENT_JSON:{"standard":"nep141","version":"1.0.0","event":"ft_transfer","data":[{"old_owner_id":"dev-1660831638497-73655245450834","new_owner_id":"seller.dev-1660831615048-16894106456797","amount":"20000000000000000000000000","memo":"Sale from marketplace"}]}
```

Let's call some view methods to double check if everything went well. First let's check if the seller now has `20 gtNEAR`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $FT_CONTRACT ft_balance_of '{"account_id": "'$SELLER_ID'"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $FT_CONTRACT ft_balance_of json-args '{"account_id": "'$SELLER_ID'"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

Next, let's check if the buyer has `30 gtNEAR` left to withdraw.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT ft_deposits_of '{"account_id": "'$BUYER_ID'"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $MARKETPLACE_CONTRACT ft_deposits_of json-args '{"account_id": "'$BUYER_ID'"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

Finally, let's check if the NFT is now owned by the buyer.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $NFT_CONTRACT nft_token '{"token_id": "market-token"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $NFT_CONTRACT nft_token json-args '{"token_id": "market-token"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Withdrawing the Excess Deposits

Now that the buyer purchased the NFT with `20 gtNEAR`, they should have `30 gtNEAR` left to withdraw. If they withdraw the tokens, they should be left with a balance of `30 gtNEAR` on the FT contract.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $MARKETPLACE_CONTRACT ft_withdraw '{"amount": "30000000000000000000000000"}' --accountId $BUYER_ID --depositYocto 1 --gas 300000000000000
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $MARKETPLACE_CONTRACT ft_withdraw json-args '{"amount": "30000000000000000000000000"}' prepaid-gas '300.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you now query for the buyer's balance, it should be `30 gtNEAR`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $FT_CONTRACT ft_balance_of '{"account_id": "'$BUYER_ID'"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $FT_CONTRACT ft_balance_of json-args '{"account_id": "'$BUYER_ID'"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

And just like that you're finished! You went through and put an NFT up for sale and purchased it using fungible tokens! **Go team üöÄ**

---

## Conclusion

In this tutorial, you learned about the basics of a marketplace contract and how it works. You went through the core logic both at a high level and looked at the code. You deployed an NFT, marketplace, and FT contract, initialized them all and then put an NFT for sale and sold it for fungible tokens! What an amazing experience! Go forth and expand these contracts to meet whatever needs you have. The world is your oyster and thank you so much for following along with this tutorial series. Don't hesitate to ask for help or clarification on anything in our discord or social media channels. **Go Team!**

---

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-sdk-rs: `5.1.0` (with enabled `legacy` feature)
- cargo-near: `0.13.2`
- near-cli: `4.0.13`
:::


 This is the content for the doc docs/3.tutorials/intents/0-intro.md 

 ---
id: introduction
title: Integrate with NEAR Intents
sidebar_label: Introduction
---

NEAR Intents is a powerful protocol designed to simplify and streamline interactions with multichain financial products. It enables users to define high-level financial operations without needing to manage the complexity of smart contract interactions across multiple blockchains.

The protocol abstracts execution details, making it easier for developers
and users to engage in decentralized finance (DeFi) operations seamlessly.
For more in-depth details about the architecture behind NEAR Intents and
the multichain bridge OmniBridge, visit the official
[NEAR documentation](/chain-abstraction/intents/overview).

## What You Will Learn

In this tutorial, you will learn how to:

- [Deposit tokens](1-deposit.mdx) from different chains (NEAR, EVM-compatible, Solana)
- [Execute a swap](2-swap.mdx) using the NEAR Intents protocol
- [Withdraw funds](3-withdraw.mdx) back to the destination chain if needed (NEAR, EVM-compatible, Solana)


 This is the content for the doc docs/3.tutorials/intents/1-deposit.mdx 

 ---
id: deposit
title: Deposit tokens
sidebar_label: Deposit
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Depositing tokens is the first step in using NEAR Intents. Whether you are transferring assets from NEAR or an external blockchain, this process ensures your funds are accessible within the NEAR ecosystem. The deposit mechanism depends on whether the source chain is NEAR or another blockchain.

Before making any deposits, it‚Äôs essential to check your current token balance. This ensures that your funds are properly accounted for after each transaction.

## Retrieving Available Tokens

To check your balance, you first need to obtain the correct `token_id` that corresponds to the asset you are querying. This information can be retrieved by calling the following endpoint:

```sh
https://api-mng-console.chaindefuser.com/api/tokens
```

The request payload is empty.

This will return a JSON response containing token information. An example response is:

```json
{
  "tokens": [
    {
      "defuse_asset_id": "nep141:wrap.near",
      "decimals": 24,
      "blockchain": "near",
      "symbol": "wNEAR",
      "price": 3.36,
      "price_updated_at": "2025-02-15T12:06:00.106Z",
      "contract_address": "wrap.near"
    },
    {
      "defuse_asset_id": "nep141:eth.omft.near",
      "decimals": 18,
      "blockchain": "eth",
      "symbol": "ETH",
      "price": 2671.25,
      "price_updated_at": "2025-02-15T12:06:00.106Z"
    }
  ]
}
```

Each token has a unique `defuse_asset_id`, which serves as the `token_id` required for querying balances.

## Checking Balance on NEAR

Once you have obtained the `defuse_asset_id` for the token, you can retrieve your balance by calling the `mt_batch_balance_of` view function on the `intents.near` contract. The request payload should be structured as follows:

```json
{
  "account_id": "denbite.near",
  "token_ids": ["nep141:wrap.near", "nep141:eth.omft.near"] // this list may include as many tokens as you'd like to query balances of
}
```

In this example, `nep141:wrap.near` represents NEAR (as wNEAR FungibleToken) and `nep141:eth.omft.near` represents Ethereum

<Tabs>
  <TabItem value="cli" label="Near CLI" default>

```sh
near contract call-function as-read-only intents.near mt_batch_balance_of json-args '{"account_id":"<your-account.near>","token_ids":["nep141:wrap.near", "nep141:eth.omft.near"]}' network-config mainnet now
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts
import { JsonRpcProvider } from "near-api-js/lib/providers";
import { Connection, InMemorySigner } from "near-api-js";
import { InMemoryKeyStore } from "near-api-js/lib/key_stores";
import { viewFunction } from "@near-js/accounts/lib/utils";

const provider = new JsonRpcProvider({
  url: "https://rpc.mainnet.near.org",
});

// signer without key as we're only reading from contract
const keyStore = new InMemoryKeyStore();
const signer = new InMemorySigner(keyStore);

const connection = new Connection("mainnet", provider, signer, "");

const args = {
  account_id: "<your-account.near>",
  token_ids: ["nep141:wrap.near", "nep141:eth.omft.near"],
};

const balances = await viewFunction(connection, {
  contractId: "intents.near",
  methodName: "mt_batch_balance_of",
  args: args,
});

console.log(balances);
```

  </TabItem>
</Tabs>

For the first interaction with NEAR Intents, the response will look like the following, meaning we're empty on NEAR and ETH:

```json
["0", "0"]
```

## Depositing from NEAR

If the source chain is NEAR, deposits are made by directly transferring tokens using the standard Fungible Token contract.
For example, to deposit NEAR tokens, you must send a signed transaction to `wrap.near` (wNEAR) with the following payload

```json
{
  "receiver_id": "intents.near",
  "amount": "50000000000000000000000", // equivalent of 0.05 NEAR as yoctoNear
  "msg": ""
}
```

<Tabs>
  <TabItem value="cli" label="Near CLI" default>

```sh
near transaction construct-transaction <your-account.near> wrap.near add-action function-call near_deposit json-args {} prepaid-gas '30.0 Tgas' attached-deposit '0.05 NEAR' add-action function-call ft_transfer_call json-args '{
  "receiver_id": "intents.near",
  "amount": "50000000000000000000000",
  "msg": ""
}' prepaid-gas '50.0 Tgas' attached-deposit '1 yoctoNEAR' skip network-config mainnet sign-with-legacy-keychain send
```

  </TabItem>
  <TabItem value="typescript" label="TypeScript">

```ts
import { JsonRpcProvider } from "near-api-js/lib/providers";
import { Account, Connection, InMemorySigner, KeyPair } from "near-api-js";
import { InMemoryKeyStore } from "near-api-js/lib/key_stores";
import { Action, functionCall } from "near-api-js/lib/transaction";

const provider = new JsonRpcProvider({
  url: "https://rpc.mainnet.near.org",
});

const privateKey =
  "ed25519:1bF8wCjpstE3j5kMS7RASEWz2gw4xj7mTPFsUAUxMC5gqMPKWaTsG2883wW5F5dZ1KUJjmGyaCMw2ym1yRtRSXyn";
const accountId = "<your-account.near>";

const keyPair = KeyPair.fromString(privateKey);
const signer = await InMemorySigner.fromKeyPair("mainnet", accountId, keyPair);

const connection = new Connection("mainnet", provider, signer, "");
const account = new Account(connection, accountId);

const actions: Action[] = [
  functionCall(
    "near_deposit",
    {},
    BigInt(30_000_000_000_000), // 30 TGas
    BigInt(50_000_000_000_000_000_000_000) // 0.05 NEAR
  ),
  functionCall(
    "ft_transfer_call",
    {
      receiver_id: "intents.near",
      amount: "50000000000000000000000", // equivalent of 0.05 NEAR as yoctoNear
      msg: "",
    },
    BigInt(50_000_000_000_000), // 50 TGas
    BigInt(1) // 1 yoctoNear
  ),
];
const result = await account.signAndSendTransaction({
  receiverId: "wrap.near", // wNEAR contract
  actions: actions,
});

console.log(result);
```

  </TabItem>
</Tabs>

## Depositing from Different Chains

Deposits and withdrawals from other chains into NEAR FTs are handled by the bridging service - [Omni-Bridge](../../chain-abstraction/omnibridge/overview.md).

Since deposits involve the OmniBridge, ensure that the asset you are transferring is supported. To retrieve the full list of supported assets, use the following endpoint:

```sh
POST https://bridge.chaindefuser.com/rpc
```

With the following request JSON payload:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "method": "supported_tokens",
  "params": [
    {
      "chains": [
        "eth:1", // Ethereum Mainnet
        "eth:42161", // Arbitrum Mainnet
        "solana:mainnet" // Solana Mainnet
      ]
    }
  ]
}
```

This will return a JSON response containing a list of supported tokens. An example response is:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "tokens": [
      {
        "defuse_asset_identifier": "eth:1:native", // CHAIN_TYPE:CHAIN_ID:ADDRESS
        "near_token_id": "eth.omft.near",
        "decimals": 18,
        "asset_name": "ETH",
        "min_deposit_amount": "1",
        "min_withdrawal_amount": "400000000000000",
        "withdrawal_fee": "0"
      },
      ...
    ]
  }
}
```

If the desired asset is in the list, then retrieve a deposit address on the source chain using:

```sh
POST https://bridge.chaindefuser.com/rpc
```

With the following request payload:

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "deposit_address",
  "params": [
    {
      "account_id": "<your-account.near>",
      "chain": "eth:1" // CHAIN_TYPE:CHAIN_ID
    }
  ]
}
```

This will return a JSON response containing an address on the source chain (in this example it's Ethereum Mainnet). An example response is:

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "result": {
    "address": "0xF6972DF0809aE0c8AD0bd468d385eE417561F1cB",
    "chain": "eth:1" // CHAIN_TYPE:CHAIN_ID
  }
}
```

Once you receive the deposit address, send the desired asset from the source chain using your wallet (e.g., MetaMask for Ethereum, Phantom for Solana, etc.).

:::warning

Keep in mind that the received `address` is unique for each `account_id`. **DO NOT** transfer any tokens to the address shown in this example, as you will lose those funds.

:::

After successfully depositing your tokens, query your balance again using the same method described above to confirm the deposit was successful. This time, the response should return non-zero values.

The next step is to swap them for another asset. Continue to [the next chapter](2-swap.mdx) to learn how.


 This is the content for the doc docs/3.tutorials/intents/2-swap.mdx 

 ---
id: swap
title: Swap tokens
sidebar_label: Swap
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Now that we have deposited tokens into the NEAR Intents system, the next step is to swap them for another asset. This section will guide you through the process of swapping your previously deposited NEAR tokens into ETH.

:::info

For a complete working example of token swaps using NEAR Intents, refer to the [GitHub repository](https://github.com/nearuaguild/near-intents-ts-example).

:::

## Fetch a Price Quote

To estimate the potential output for a given exact input, or determine the required input for a given exact output, request a price quote from the solver relay.

Use the following endpoint:

```sh
POST https://solver-relay-v2.chaindefuser.com/rpc
```

With the following payload:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "method": "quote",
  "params": [
    {
      "defuse_asset_identifier_in": "nep141:wrap.near",
      "defuse_asset_identifier_out": "nep141:eth.omft.near",
      "exact_amount_in": "50000000000000000000000",
      "quote_id": "00000000-0000-0000-0000-000000000000",
      "min_deadline_ms": "60000"
    }
  ]
}
```

The response will look as the following:

```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "result": {
    "quotes": [
      {
        "quote_hash": "00000000000000000000000000000000",
        "defuse_asset_identifier_in": "nep141:wrap.near",
        "defuse_asset_identifier_out": "nep141:eth.omft.near",
        "amount_in": "50000000000000000000000",
        "amount_out": "20000000",
        "expiration_time": "1726184627"
      }
    ]
  }
}
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const RPC_URL = "https://solver-relay-v2.chaindefuser.com/rpc";

const body = {
  id: "dontcare",
  jsonrpc: "2.0",
  method: "quote",
  params: [
    {
      defuse_asset_identifier_in: "nep141:wrap.near",
      defuse_asset_identifier_out: "nep141:eth.omft.near",
      exact_amount_in: "50000000000000000000000",
    },
  ],
};

const response = await fetch(RPC_URL, {
  method: "POST",
  body: JSON.stringify(body),
  headers: {
    "Content-Type": "application/json",
  },
});

const json: any = await response.json();

if (!response.ok) {
  throw new Error(
    `Request failed ${response.status} ${
      response.statusText
    } - ${JSON.stringify(json)}`
  );
}

const result = json.result;

if (result === null) return undefined;

const quote = result.at(0);
```

  </TabItem>
</Tabs>

If a quote isn't found, try again since solvers may not have provided information within the 1200ms window.

## Sign an Intent Message

Once a valid quote is retrieved, you need to create an intent message using the data from the quote. This involves generating a new nonce, serializing JSON message and signing it with the ED25519 key pair belonging to your NEAR account.

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const standard = "nep413";
const message = {
  signer_id: "<your-account.near>",
  deadline: quote["expiration_time"],
  intents: [
    {
      intent: "token_diff",
      diff: {
        [quote["defuse_asset_identifier_in"]]: `-${quote["amount_in"]}`,
        [quote["defuse_asset_identifier_out"]]: `${quote["amount_out"]}`,
      },
    },
  ],
};

const messageStr = JSON.stringify(message);
const nonce = await generateNonce();
const recipient = "intents.near";
const intent = serializeIntent(messageStr, recipient, nonce, standard);
const { signature, publicKey } = signMessage(intent);
```

  </TabItem>
</Tabs>

It's important to note that the contract deployed at `intents.near` will verify your signature. To do this, it must know the public key that was used to sign the intent message. You must call the `add_public_key` function to register your public key with the contract. This step is only required once before sending your first intent message.

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const provider = new JsonRpcProvider({
  url: "https://rpc.mainnet.near.org",
});

const privateKey =
  "ed25519:1bF8wCjpstE3j5kMS7RASEWz2gw4xj7mTPFsUAUxMC5gqMPKWaTsG2883wW5F5dZ1KUJjmGyaCMw2ym1yRtRSXyn";
const accountId = "<your-account.near>";

const keyPair = KeyPair.fromString(privateKey);
const signer = await InMemorySigner.fromKeyPair("mainnet", accountId, keyPair);

const connection = new Connection("mainnet", provider, signer, "");
const account = new Account(connection, accountId);

const publicKey = await account.connection.signer.getPublicKey(
  account.accountId,
  "mainnet"
);

// returns boolean whether this public_key is already added
const hasPublicKey = await account.viewFunction({
  contractId: "intents.near",
  methodName: "has_public_key",
  args: {
    account_id: account.accountId,
    public_key: publicKey.toString(),
  },
});

if (hasPublicKey === true) return;

// adds public_key if it wasn't there yet
await account.functionCall({
  contractId: "intents.near",
  methodName: "add_public_key",
  args: {
    public_key: publicKey.toString(),
  },
  attachedDeposit: 1n,
});
```

  </TabItem>
</Tabs>

## Publish Swap Intent

The final step is to craft the intent payload and publish it for execution, enabling the actual swap to take place. Use the following endpoint:

```sh
POST https://solver-relay-v2.chaindefuser.com/rpc
```

With the following payload:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "method": "publish_intent",
  "params": [
    {
      "quote_hashes": [quote["quote_hash"]],
      "signed_data": {
        "standard": "nep413",
        "payload": {
          "message": "{\"signer_id\":\"<your_account.near>\",\"deadline\":\"2025-02-18T18:25:25.836Z\",\"intents\":[{\"intent\":\"token_diff\",\"diff\":{\"nep141:wrap.near\":\"-5000000000000000000000\",\"nep141:eth.omft.near\":\"92984\"}}]}", // serialized message from the previous step
          "nonce": "bM0eIaBFfs9GScUJy7K7WcHEA8mK10A2s4/+1CLq4yc=",
          "recipient": "intents.near",
        },
        "signature": "ed25519:2Eh4WwskBappyRcfTSvofq3SraznbsnFkRu49pPZXA2Ag3uPYvuHKobG3cWUVHQW3wxMvGEf8jSqjkeYppFMqji",
        "public_key": "ed25519:3BLaN6qcTXEM6NNiy9AmtoxsbWVPvSHaBNjS2ULsH1M3"
      }
    }
  ]
}
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const RPC_URL = "https://solver-relay-v2.chaindefuser.com/rpc";

const signedData = {
  standard,
  payload: {
    message: messageStr,
    nonce,
    recipient,
  },
  signature: `ed25519:${bs58.encode(signature)}`,
  public_key: publicKey.toString(),
};

const body = {
  id: "dontcare",
  jsonrpc: "2.0",
  method: "publish_intent",
  params: [
    {
      quote_hashes: [quoteHash],
      signed_data: signedData,
    },
  ],
};

const response = await fetch(RPC_URL, {
  method: "POST",
  body: JSON.stringify(body),
  headers: {
    "Content-Type": "application/json",
  },
});

const json: any = await response.json();

if (!response.ok) {
  throw new Error(
    `Request failed ${response.status} ${
      response.statusText
    } - ${JSON.stringify(json)}`
  );
}

const intent = json.result || undefined;
```

  </TabItem>
</Tabs>

## Fetch Intent Status

The previous method returns an `intent_hash`, which can be used to fetch the status of the intent, whether it has been successfully resolved or failed for some reason. Use the following endpoint.

```sh
POST https://solver-relay-v2.chaindefuser.com/rpc
```

With the request payload:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "method": "get_status",
  "params": [
    {
      "intent_hash": "AKGznsj9tJPzyC53iweg7bjuVterJm18cGPkMKVPMKZG"
    }
  ]
}
```

The response will look like the following, `SETTLED` status stands up for an intent successfully completed:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "intent_hash": "AKGznsj9tJPzyC53iweg7bjuVterJm18cGPkMKVPMKZG",
    "status": "SETTLED",
    "data": { "hash": "3mWZrPWcMWwqvmxmKyCaVcEEHAtSoRQXds5MR3J1P1YU" }
  }
}f
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const RPC_URL = "https://solver-relay-v2.chaindefuser.com/rpc";

const body = {
  id: "dontcare",
  jsonrpc: "2.0",
  method: "get_status",
  params: [
    {
      intent_hash: intent["intent_hash"],
    },
  ],
};

const response = await fetch(RPC_URL, {
  method: "POST",
  body: JSON.stringify(body),
  headers: {
    "Content-Type": "application/json",
  },
});

const json: any = await response.json();

const intentStatus = json.result || undefined;
```

  </TabItem>
</Tabs>

If you ever decide to move your funds back to another chain, [the next chapter](3-withdraw.mdx) will walk you through the withdrawal process.


 This is the content for the doc docs/3.tutorials/intents/3-withdraw.mdx 

 ---
id: withdraw
title: Withdraw tokens
sidebar_label: Withdraw
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Withdrawing allows you to transfer your tokens back to their original account, whether on NEAR or another blockchain.

By following this guide, you'll learn how to do it securely and efficiently, ensuring that your funds are returned to your intended destination.

## Build Intent Message

Withdrawing tokens is similar to swapping in that you need to craft an intent message, sign it, and send it to the RPC for execution. However, unlike swapping, fetching a quote isn‚Äôt necessary since no asset exchange is involved. Instead, the withdrawal intent message defines the amount and destination chain for the transaction.

The process differs slightly depending on whether you‚Äôre withdrawing to NEAR or another chain. Let‚Äôs break down both approaches.

### Build for NEAR

The intent message is going to have the following structure

```json
{
  "deadline": "2025-02-18T20:11:03.0462",
  "signer_id": "<your-account.near>",
  "intents": [
    {
      "intent": "native_withdraw",
      "receiver_id": "<your-account.near>",
      "amount": "50000000000000000000000"
    }
  ]
}
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const standard = "nep413";
const message = {
  deadline: "2025-02-18T20:11:03.0462",
  signer_id: "<your-account.near>",
  intents: [
    {
      intent: "native_withdraw",
      receiver_id: "<your-account.near>",
      amount: "50000000000000000000000",
    },
  ],
};

const messageStr = JSON.stringify(message);
const nonce = await generateNonce();
const recipient = "intents.near";
const intent = serializeIntent(messageStr, recipient, nonce, standard);
const { signature, publicKey } = signMessage(intent);
```

  </TabItem>
</Tabs>

### Build for another chain

The intent message for withdrawing to Ethereum Mainnet is going to have the following structure

```json
{
  "deadline": "2025-02-18T20:11:03.0462",
  "signer_id": "<your-account.near>",
  "intents": [
    {
      "intent": "ft_withdraw",
      "token": "eth.omft.near",
      "receiver_id": "eth.omft.near",
      "amount": "2000000000",
      "memo": "WITHDRAW_TO:0x311F9620Be0fe8Db2d840E2b6145D1CF2975acab" // WITHDRAW_TO:ADDRESS_ON_DESTINATION_CHAIN
    }
  ]
}
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const standard = "nep413";
const message = {
  deadline: "2025-02-18T20:11:03.0462",
  signer_id: "<your-account.near>",
  intents: [
    {
      intent: "ft_withdraw",
      token: "eth.omft.near",
      receiver_id: "eth.omft.near",
      amount: "2000000000",
      memo: "WITHDRAW_TO:0x311F9620Be0fe8Db2d840E2b6145D1CF2975acab", // WITHDRAW_TO:ADDRESS_ON_DESTINATION_CHAIN
    },
  ],
};

const messageStr = JSON.stringify(message);
const nonce = await generateNonce();
const recipient = "intents.near";
const intent = serializeIntent(messageStr, recipient, nonce, standard);
const { signature, publicKey } = signMessage(intent);
```

  </TabItem>
</Tabs>

## Publish Withdraw Intent

The final step is to craft the intent payload and publish it for execution, enabling the actual withdraw to take place. Use the following endpoint:

```sh
POST https://solver-relay-v2.chaindefuser.com/rpc
```

With the following payload:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "method": "publish_intent",
  "params": [
    {
      "quote_hashes": [], // this array is empty as we're withdrawing
      "signed_data": {
        "standard": "nep413",
        "payload": {
          "message": "{\"deadline\":\"2025-02-18T20:11:03.0462\",\"intents\":[{\"intent\":\"native_withdraw\",\"receiver_id\":\"<your-account.near>\",\"amount\":\"50000000000000000000000\"}],\"signer_id\":\"<your-account.near>\"}", // serialized message from the previous step
          "nonce": "/oZRZR0WGWn73s/evEUOxFH3YHSl5JvJH88m8pp3mMI=",
          "recipient": "intents.near"
        },
        "signature": "ed25519:6f8e5hsBkCu9vt3iPuoLrmgz4GCthFyq9MEKy5xp6FUedQwrtuxq3y81ymfspsNSaTyLMeUQobnXrVvUNqEXGRDH",
        "public_key": "ed25519:14fZjXn7DmM2XrAxZWK7XE6EnZugAusMtkKM9Zbb1P3N"
      }
    }
  ]
}
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const RPC_URL = "https://solver-relay-v2.chaindefuser.com/rpc";

const signedData = {
  standard,
  payload: {
    message: messageStr,
    nonce,
    recipient,
  },
  signature: `ed25519:${bs58.encode(signature)}`,
  public_key: publicKey.toString(),
};

const body = {
  id: "dontcare",
  jsonrpc: "2.0",
  method: "publish_intent",
  params: [
    {
      quote_hashes: [], // this array is empty as we're withdrawing
      signed_data: signedData,
    },
  ],
};

const response = await fetch(RPC_URL, {
  method: "POST",
  body: JSON.stringify(body),
  headers: {
    "Content-Type": "application/json",
  },
});

const json: any = await response.json();

if (!response.ok) {
  throw new Error(
    `Request failed ${response.status} ${
      response.statusText
    } - ${JSON.stringify(json)}`
  );
}

const intent = json.result || undefined;
```

  </TabItem>
</Tabs>

## Fetch Intent Status

The previous method returns an `intent_hash`, which can be used to fetch the status of the intent, whether it has been successfully resolved or failed for some reason. Use the following endpoint.

```sh
POST https://solver-relay-v2.chaindefuser.com/rpc
```

With the request payload:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "method": "get_status",
  "params": [
    {
      "intent_hash": "AKGznsj9tJPzyC53iweg7bjuVterJm18cGPkMKVPMKZG"
    }
  ]
}
```

The response will look like the following, `SETTLED` status stands up for an intent successfully completed:

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "intent_hash": "AKGznsj9tJPzyC53iweg7bjuVterJm18cGPkMKVPMKZG",
    "status": "SETTLED",
    "data": { "hash": "3mWZrPWcMWwqvmxmKyCaVcEEHAtSoRQXds5MR3J1P1YU" }
  }
}
```

<Tabs>
  <TabItem value="typescript" label="TypeScript">

```ts
const RPC_URL = "https://solver-relay-v2.chaindefuser.com/rpc";

const body = {
  id: "dontcare",
  jsonrpc: "2.0",
  method: "get_status",
  params: [
    {
      intent_hash: intent["intent_hash"],
    },
  ],
};

const response = await fetch(RPC_URL, {
  method: "POST",
  body: JSON.stringify(body),
  headers: {
    "Content-Type": "application/json",
  },
});

const json: any = await response.json();

const intentStatus = json.result || undefined;
```

  </TabItem>
</Tabs>

## Final Thoughts

With that, we‚Äôve successfully completed the full journey of using NEAR Intents ‚Äî from depositing tokens, executing swaps, and if needed withdrawing funds back to NEAR or another blockchain. By following this process, you now have a solid understanding of how to manage cross-chain assets efficiently.


 This is the content for the doc docs/3.tutorials/multichain-dao/0-intro.md 

 ---
id: introduction
title: Near Multi-Chain DAO Governance
sidebar_label: Introduction
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Many multi-chain organizations deploy copies of the same smart contract across multiple EVM chains, which need to be kept in sync.

Generally, this is tackled by handling multiple DAOs - one per chain - where the same action is voted simultaneously, a process that is not only time-consuming, but also very expensive and error-prone.

![multi chain flow](/docs/assets/tutorials/abstract-dao/multi-dao-flow.png)

To solve this, we have built the [Abstract DAO](https://github.com/nearuaguild/abstract-dao), which enables organizations to **vote once** in NEAR, and then **execute the same action** across **multiple chains**.

![multi chain flow](/docs/assets/tutorials/abstract-dao/near-dao-flow.png)

:::warning
Abstract DAO is an example, and as such it has not been audited, use it at your own risk.
:::

---

### How It Works?

The [Abstract DAO](https://github.com/nearuaguild/abstract-dao) acts as an intermediary between NEAR DAOs and the EVM chains.

The process of voting and executing an action looks like this:

1. **Craft an EIP-1559 Payload**: You create the transaction that will execute across all chain, specifying the recipient address, nonce, value, and transaction data. Only the gas parameters are not set, as they will vary across chains.

2. **Choose a Single Allowed Account**: As part of the voting process, your organization chooses an "allowed account," which is the member who will be responsible to setup gas parameters, and generate signatures for all the chains.

3. **Vote on the Request**: Your decentralized organization votes once on NEAR to approve this request. Each member can review the transaction, then cast their vote to confirm or reject it.

4. **Generate Signatures**: Once the request has enough confirmations, the transaction is approved. The "allowed account" can now interact with the [Abstract DAO](https://github.com/nearuaguild/abstract-dao) to generate signatures for as many EVM-compatible chains as needed.

The result is a drastically simplified governance process (one vote, one confirmation) and the ability to sign and execute transactions across multiple chains in a coordinated manner.

:::tip Handling Gas
Since Gas prices can vary widely across chains, the transaction's gas price is not set until the signatures are generated.

This means that the "allowed account" will be in charge of setting the gas price for each transaction being signed.
:::


---

## Prerequisites

To complete this tutorial successfully, you will need [Near CLI](../../4.tools/cli.md#installation) to be installed, and have a general understanding of how [Chain Signatures](../../chain-abstraction/chain-signatures/getting-started.md) work.

---

## Next steps

Ready to start? Let's jump to the first step, in which we will understand how the Abstract DAO contract works.

---

:::note Versioning for this article

- near-cli: `0.12.0`
- rustc: `1.78.0`
- cargo: `1.80.1`
- cargo-near: `0.6.2`
- rustc: `1.78.0`
- node: `21.6.1`

:::


 This is the content for the doc docs/3.tutorials/multichain-dao/1-request.md 

 ---
id: request
title: "Abstract DAO: Requests"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The Abstract DAO contract works as an intermediary between decentralized organizations in NEAR and EVM networks. To better understand how it works it is better to start by using it by itself, without using a DAO yet.

Join us as we explore how to create a request in the Abstract DAO contract, that will be later used to derive signatures for foreign EVM chains. 

:::tip
We have deployed the Abstract DAO in two environments:

1. Testnet: `abstract-dao.testnet`
2. Dev (unstable): `dev.abstract-dao.testnet`
:::

---

## Ethereum Function Call

Imagine that our organization agreed on changing a value in a simple [counter we deployed on Sepolia Ethereum](https://sepolia.etherscan.io/address/0xe2a01146FFfC8432497ae49A7a6cBa5B9Abd71A3), and now want to leave this intent in the Abstract DAO.

For this, we will call the **`register_signature_request`** function on Abstract Dao saying: 

*We allow **executor.testnet** to request signatures for one of our Ethereum accounts, making it set a counter to `1000`*.

Here are the parameters, take a quick glance for now, since we will go over each one of them:

```js
{
  "request": {
    "derivation_seed_number": 0,
    "allowed_account_id": "executor.testnet",
    "transaction_payload": {
      "to": "0xe2a01146FFfC8432497ae49A7a6cBa5B9Abd71A3",
      "nonce": "0",
      "function_data": {
        "function_abi": {
          "inputs": [
            {
              "internalType": "uint256",
              "name": "_num",
              "type": "uint256"
            }
          ],
          "name": "set",
          "outputs": [],
          "stateMutability": "nonpayable",
          "type": "function"
        },
        "arguments": [
          {
            "Uint": "A97"
          }
        ]
      }
    },
  }
}
```

There are 3 arguments in the call above: `derivation_seed_number`, `transaction_payload`, and `allowed_account_id` lets see them in depth.

<hr class="subsection" />

### Derivation Path

The parameter `derivation seed number` will be used to derive which external address we will be requesting signatures from, the address will be derived as:

`DAO Address` + `Derivation Path` + `Contract Address` = `EVM Address`

For example, if we register a request from the address `...` using the derivation path `0` we will obtain control the `0x...` account.

:::tip
Learn more about derivation paths [here](../../chain-abstraction/chain-signatures.md)
:::

<hr class="subsection" />

### Transaction Payload

The `transaction_payload` contains all the information on the transaction that we want to perform, particularly:

  - `to`: The recipient address of the transaction
  - `nonce`: The transaction nonce, used to ensure uniqueness
  - `function_data`: (optional) Defines the function that will be called on the recipient's contract, including:
    - `function_abi`: The ABI of the function being called
    - `arguments`: The input arguments for the function, all ABI¬†encoded (e.g. integers are `base64`)

There are a couple important points to notice about this `transaction_payload`:

- **Readable Payload:** The parameters make it easy for anyone to quickly understand what transaction will be executed externally. The Abstract DAO is designed to be transparent and easy to audit, abstracting away the complexity of creating the transaction.

- **We Are Setting a Nonce:** By setting the nonce, we make sure that the transaction will only be valid once, as future transactions will need higher `nonces`

- **We Are Not Setting the GAS:** Gas prices are expected to vary wildly across EVMs, for which it makes no sense to setup a fixed gas amount and gas price for all the networks, for this is that we use the last parameter `allowed_account`

<hr class="subsection" />

### Allowed Account

In this case, the `allowed_account` will be the one in charge of generating the signatures. At the time of generating the signature, the account will also set the `gas_price` for the transaction on a per-chain basis.

 This is the content for the doc docs/3.tutorials/multichain-dao/2-signing.md 

 ---
id: signing
title: "Abstract Dao: Signatures"
---

In the previous section, we saw how to register a signature request on the Abstract DAO contract. Now, it is time to sign the transaction for different chains and relay it to the target EVM network.

---

## Signing the Transaction

To sign a transaction for a specific chain, the allowed account needs to call the `get_signature` function, passing the `request_id` (generated on the previous section) and all the necessary info to finish creating the transaction before signing it.

For example, to sign the transaction for the Sepolia Testnet, the following command can be used:

```bash
near contract call-function as-transaction abstract-dao.testnet get_signature json-args '{
    "request_id": 1,
    "other_payload": {
        "chain_id": 11155111,
        "max_fee_per_gas": "1000000000",
        "max_priority_fee_per_gas": "100000000"
    }
}' prepaid-gas '300.0 Tgas' attached-deposit '0.05 NEAR' sign-as executor.testnet network-config testnet
```

Note that all we are specifying now is the `chain_id` (to identify the destination chain), the `max_fee_per_gas`, and the `max_priority_fee_per_gas` (to set the transaction fee).

The account authorized to call `get_signature` - in this case `executor.testnet` cannot change any parameter of the transaction being signed besides setting a gas fee per chain.

---

## Signature Response

The signature response is going to look like this:

```json
{
  "big_r": {
      "signature": {
      "affine_point": "02D532992B0ECBF67800DB14E04530D9BA55609AD31213CC7ABDB554E8FDA986D3"
    },
    "recovery_id": 1,
    "s": {
      "scalar": "40E81711B8174712B9F34B2540EE0F642802387D15543CBFC84211BB04B83AC3"
    }
  },
  "tx": "0x02f85083aa36a702850485034c878517a4eb0789829dd094e2a01146fffc8432497ae49a7a6cba5b9abd71a380a460fe47b1000000000000000000000000000000000000000000000000000000000000a84bc0"
}
```

As we can see, it is not the signed transaction itself, but instead the data we need to reconstruct it. We have created an [script](https://github.com/nearuaguild/multichain-dao-scripts) to automate this process, as well as the relaying to the target EVM network.

 This is the content for the doc docs/3.tutorials/multichain-dao/3-voting.md 

 ---
id: voting
title: MultiSig Voting
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Now that we understand how the Abstract DAO works, it is time to use it in within an organization. Lets see how to deploy a MultiSig contract, where users will vote on a multi-chain proposal.

---

## Creating a MultiSig Contract

As a first step we need to create an account and deploy a MultiSig contract on it, so users can start creating proposals and voting on them.

:::info Deploy Multisig
You can download the [compiled multisig](https://github.com/near/core-contracts/raw/refs/heads/master/multisig2/res/multisig2.wasm) from the near repository
:::


```bash
near create-account <accountId> --useFaucet

near deploy <accountId> multisig2.wasm
```

:::tip
  See the github repository for instructions on how to [initialize the multisig contract](https://github.com/near/core-contracts/tree/master/multisig2)
:::

---

## Creating a Request on the Multisig Contract

To call `register_signature_request` on the Multi-Chain DAO Governance Contract, you need to submit a request through your Multisig contract. This ensures that the decision to generate a signature is confirmed by the necessary members.

```bash
near contract call-function as-transaction multisignature.testnet add_request json-args '{
    "request": {
        "receiver_id": "abstract-dao.testnet",
        "actions": [
            {
                "type": "FunctionCall",
                "method_name": "register_signature_request",
                "args": {
                    "request": {
                        "allowed_account_id": "executor.testnet",
                        "derivation_seed_number": 0,
                        "transaction_payload": {
                            "to": "0xe2a01146FFfC8432497ae49A7a6cBa5B9Abd71A3",
                            "nonce": "0",
                            "function_data": {
                                "function_abi": {
                                    "inputs": [
                                        {
                                            "internalType": "uint256",
                                            "name": "_num",
                                            "type": "uint256"
                                        }
                                    ],
                                    "name": "set",
                                    "outputs": [],
                                    "stateMutability": "nonpayable",
                                    "type": "function"
                                },
                                "arguments": [
                                    {
                                        "Uint": "A97"
                                    }
                                ]
                            }
                        }
                    }
                },
                "gas": "100000000000000",
                "deposit": "0.1"
            }
        ]
    }
}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as executor.testnet network-config testnet
```

---

## Voting on the Request

Once the request is submitted, members of the multisig contract have a set amount of time to vote to either Confirm or Reject the request. Each member needs to cast their vote using the following command:

```bash
near contract call-function as-transaction multisignature.testnet confirm json-args '{"request_id": 1}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as account.testnet network-config testnet
```

:::note
Replace provided `request_id` with value retrieved from the response when creating the request
:::

Once the request has received enough confirmations, it will be automatically executed. At this point, the signature request is successfully registered on the Multi-Chain DAO Governance Contract.

Now, the allowed account (specified in the request) can generate signatures for the transaction just as we saw in the [previous section](./2-signing.md).

 This is the content for the doc docs/3.tutorials/nfts/0-intro.md 

 ---
id: introduction
title: NFT Zero to Hero
sidebar_label: Introduction
---

In this _Zero to Hero_ series, you'll find a set of tutorials that will cover every aspect of a non-fungible token (NFT) smart contract.
You'll start by minting an NFT using a pre-deployed contract and by the end you'll end up building a fully-fledged NFT smart contract that supports every extension.

---

## Prerequisites

To complete these tutorials successfully, you'll need:

- [Rust](https://www.rust-lang.org/tools/install)
- [A Testnet wallet](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli#installation)
- [cargo-near](https://github.com/near/cargo-near)

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start
:::

---

## Overview

These are the steps that will bring you from **_Zero_** to **_Hero_** in no time! üí™

| Step | Name                                                          | Description                                                                                                            |
|------|---------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 1    | [Pre-deployed contract](/tutorials/nfts/predeployed-contract) | Mint an NFT without the need to code, create, or deploy a smart contract.                                              |
| 2    | [Contract architecture](/tutorials/nfts/skeleton)             | Learn the basic architecture of the NFT smart contract and compile code.                                               |
| 3    | [Minting](/tutorials/nfts/minting)                            | Flesh out the skeleton so the smart contract can mint a non-fungible token.                                            |
| 4    | [Upgrade a contract](/tutorials/nfts/upgrade-contract)        | Discover the process to upgrade an existing smart contract.                                                            |
| 5    | [Enumeration](/tutorials/nfts/enumeration)                    | Explore enumeration methods that can be used to return the smart contract's states.                                    |
| 6    | [Core](/tutorials/nfts/core)                                  | Extend the NFT contract using the core standard which allows token transfer.                                        |
| 7    | [Events](/tutorials/nfts/events)                              | The events extension, allowing the contract to react on certain events.                                              |
| 8    | [Approvals](/tutorials/nfts/approvals)                        | Expand the contract allowing other accounts to transfer NFTs on your behalf.                                           |
| 9    | [Royalty](/tutorials/nfts/royalty)                            | Add NFT royalties allowing for a set percentage to be paid out to the token creator.                                   |
| 10   | [Marketplace](/tutorials/nfts/marketplace)                    | Learn about how common marketplaces operate on NEAR and dive into some of the code that allows buying and selling NFTs. |

---

## Next steps

Ready to start? Jump to the [Pre-deployed Contract](/tutorials/nfts/predeployed-contract) tutorial and begin your learning journey!

If you already know about non-fungible tokens and smart contracts, feel free to skip and jump directly to the tutorial of your interest. The tutorials have been designed so you can start at any given point!


 This is the content for the doc docs/3.tutorials/nfts/0-predeployed.md 

 ---
id: predeployed-contract
title: Pre-deployed Contract
sidebar_label: Pre-deployed Contract
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Create your first non-fungible token by using a pre-deployed NFT smart contract which works exactly as the one you will build on this tutorial.

---

## Prerequisites

To complete this tutorial successfully, you'll need [a NEAR Wallet](https://testnet.mynearwallet.com/create) and [NEAR CLI](/tools/near-cli#installation)

---

## Using the NFT contract

Minting an NFT token on NEAR is a simple process that involves calling a smart contract function.

To interact with the contract you will need to first login to your NEAR account through `near-cli`.

<hr class="subsection" />

### Setup

Log in to your newly created account with `near-cli` by running the following command in your terminal:

```bash
near account import-account using-web-wallet network-config testnet
```

Set an environment variable for your account ID to make it easy to copy and paste commands from this tutorial:

```bash
export NEARID=YOUR_ACCOUNT_NAME
```

<hr class="subsection" />

### Minting your NFTs

We have already deployed an NFT contract to `nft.examples.testnet` which allows users to freely mint tokens. Let's use it to mint our first token.

Run this command in your terminal, remember to replace the `token_id` with a string of your choice. This string will uniquely identify the token you mint.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call nft.examples.testnet nft_mint '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "'$NEARID'", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' --gas 100000000000000 --deposit 0.1 --accountId $NEARID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction nft.examples.testnet nft_mint json-args '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "'$NEARID'", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NEARID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
Log [nft.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_mint","data":[{"owner_id":"benjiman.testnet","token_ids":["TYPE_A_UNIQUE_VALUE_HERE"]}]}
Transaction Id 8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
''
```

</p>
</details>

:::tip
You can also replace the `media` URL with a link to any image file hosted on your web server.
:::

<hr class="subsection" />

### Querying your NFT

To view tokens owned by an account you can call the NFT contract with the following `near-cli` command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view nft.examples.testnet nft_tokens_for_owner '{"account_id": "'$NEARID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only nft.examples.testnet nft_tokens_for_owner json-args '{"account_id": "'$NEARID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "Goi0CZ",
    "owner_id": "bob.testnet",
    "metadata": {
      "title": "GO TEAM",
      "description": "The Team Goes",
      "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

**Congratulations!** You just minted your first NFT token on the NEAR blockchain! üéâ

Now try going to your [NEAR Wallet](https://testnet.mynearwallet.com) and view your NFT in the "Collectibles" tab.

---

## Final remarks

This basic example illustrates all the required steps to call an NFT smart contract on NEAR and start minting your own non-fungible tokens.

Now that you're familiar with the process, you can jump to [Contract Architecture](/tutorials/nfts/skeleton) and learn more about the smart contract structure and how you can build your own NFT contract from the ground up.

***Happy minting!*** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli-rs: `0.17.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/1-skeleton.md 

 ---
id: skeleton
title: Skeleton and Rust Architecture
sidebar_label: Contract Architecture
---
import {Github} from "@site/src/components/codetabs"

In this article, you'll learn about the basic architecture behind the NFT contract that you'll develop while following this _"Zero to Hero"_ series.

You'll discover the contract's layout and you'll see how the Rust files are structured in order to build a feature-complete smart contract.

:::info Skeleton Contract
You can find the skeleton contract in our [GitHub repository](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract-skeleton)
:::

:::info New to Rust?
If you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.
:::

---

## Introduction

This tutorial presents the code skeleton for the NFT smart contract and its file structure.

Once every file and functions have been covered, we will guide you through the process of building the mock-up contract to confirm that your Rust setup works.

---

## File structure

Following a regular [Rust](https://www.rust-lang.org/) project, the file structure for this smart contract has:

```
nft-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ approval.rs
    ‚îú‚îÄ‚îÄ enumeration.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ metadata.rs
    ‚îú‚îÄ‚îÄ mint.rs
    ‚îú‚îÄ‚îÄ nft_core.rs
    ‚îú‚îÄ‚îÄ events.rs
    ‚îî‚îÄ‚îÄ royalty.rs
```

- The file `Cargo.toml` defines the code dependencies
- The `src` folder contains all the Rust source files

<hr class="subsection" />

### Source files

Here is a brief description of what each source file is responsible for:

| File                             | Description                                                                     |
|----------------------------------|---------------------------------------------------------------------------------|
| [approval.rs](#approvalrs)       | Has the functions that controls the access and transfers of non-fungible tokens |
| [enumeration.rs](#enumerationrs) | Contains the methods to list NFT tokens and their owners                        |
| [lib.rs](#librs)                 | Holds the smart contract initialization functions                               |
| [metadata.rs](#metadatars)       | Defines the token and metadata structure                                        |
| [mint.rs](#mintrs)               | Contains token minting logic                                                    |
| [nft_core.rs](#nft_corers)       | Core logic that allows you to transfer NFTs between users.                      |
| [royalty.rs](#royaltyrs)         | Contains payout-related functions                                               |
| [events.rs](#eventsrs)             | Contains events related structures                                              |

:::tip
Explore the code in our [GitHub repository](https://github.com/near-examples/nft-tutorial/).
:::

---

## `approval.rs`

> This allows people to approve other accounts to transfer NFTs on their behalf.

This file contains the logic that complies with the standard's [approvals management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension. Here is a breakdown of the methods and their functions:

| Method              | Description                                                                                               |
|---------------------|-----------------------------------------------------------------------------------------------------------|
| **nft_approve**     | Approves an account ID to transfer a token on your behalf.                                                |
| **nft_is_approved** | Checks if the input account has access to approve the token ID.                                           |
| **nft_revoke**      | Revokes a specific account from transferring the token on your behalf.                                    |
| **nft_revoke_all**  | Revokes all accounts from transferring the token on your behalf.                                          |
| **nft_on_approve**  | This callback function, initiated during `nft_approve`, is a cross contract call to an external contract. |

<Github language="rust" start="4" end="33" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/approval.rs" />

You'll learn more about these functions in the [approvals section](/tutorials/nfts/approvals) of the Zero to Hero series.

---

## `enumeration.rs`

> This file provides the functions needed to view information about NFTs, and follows the standard's [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) extension.

| Method                   | Description                                                                        |
|--------------------------|------------------------------------------------------------------------------------|
| **nft_total_supply**     | Returns the total amount of NFTs stored on the contract                           |
| **nft_tokens**           | Returns a paginated list of NFTs stored on the contract regardless of their owner. |
| **nft_supply_for_owner** | Allows you view the total number of NFTs owned by any given user                  |
| **nft_tokens_for_owner** | Returns a paginated list of NFTs owned by any given user                          |

<Github language="rust" start="4" end="44" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/enumeration.rs" />

You'll learn more about these functions in the [enumeration section](/tutorials/nfts/enumeration) of the tutorial series.

---

## `lib.rs`

> This file outlines what information the contract stores and keeps track of.

| Method               | Description                                                                                     |
|----------------------|-------------------------------------------------------------------------------------------------|
| **new_default_meta** | Initializes the contract with default `metadata` so the user doesn't have to provide any input. |
| **new**              | Initializes the contract with the user-provided `metadata`.                                     |

:::info Keep in mind
The initialization functions (`new`, `new_default_meta`) can only be called once.
:::

<Github language="rust" start="47" end="73" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/lib.rs" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/minting) of the tutorial series.

---

## `metadata.rs`

> This file is used to keep track of the information to be stored for tokens, and metadata.
> In addition, you can define a function to view the contract's metadata which is part of the standard's [metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata) extension.

| Name              | Description                                                                                                   |
|-------------------|---------------------------------------------------------------------------------------------------------------|
| **TokenMetadata** | This structure defines the metadata that can be stored for each token (title, description, media, etc.).      |
| **Token**         | This structure outlines what information will be stored on the contract for each token.                       |
| **JsonToken**     | When querying information about NFTs through view calls, the return information is stored in this JSON token. |
| **nft_metadata**  | This function allows users to query for the contact's internal metadata.                                      |

<Github language="rust" start="12" end="60" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/metadata.rs" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/minting) of the tutorial series.

---

## `mint.rs`

> Contains the logic to mint the non-fungible tokens

| Method       | Description                               |
|--------------|-------------------------------------------|
| **nft_mint** | This function mints a non-fungible token. |

<Github language="rust" start="4" end="16" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/mint.rs" />

---

## `nft_core.rs`

> Core logic that allows to transfer NFTs between users.

| Method                   | Description                                                                                                                                                                                                                                                                                   |
|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **nft_transfer**         | Transfers an NFT to a receiver ID.                                                                                                                                                                                                                                                            |
| **nft_transfer_call**    | Transfers an NFT to a receiver and calls a function on the receiver ID's contract. The function returns `true` if the token was transferred from the sender's account.                                                                                                                        |
| **nft_token**            | Allows users to query for the information about a specific NFT.                                                                                                                                                                                                                               |
| **nft_on_transfer**      | Called by other contracts when an NFT is transferred to your contract account via the `nft_transfer_call` method. It returns `true` if the token should be returned back to the sender.                                                                                                       |
| **nft_resolve_transfer** | When you start the `nft_transfer_call` and transfer an NFT, the standard also calls a method on the receiver's contract. If the receiver needs you to return the NFT to the sender (as per the return value of the `nft_on_transfer` method), this function allows you to execute that logic. |

<Github language="rust" start="7" end="56" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/nft_core.rs" />

You'll learn more about these functions in the [core section](/tutorials/nfts/core) of the tutorial series.

---

## `royalty.rs`

> Contains payout-related functions.

| Method                  | Description                                                                                                   |
|-------------------------|---------------------------------------------------------------------------------------------------------------|
| **nft_payout**          | This view method calculates the payout for a given token.                                                     |
| **nft_transfer_payout** | Transfers the token to the receiver ID and returns the payout object that should be paid for a given balance. |

<Github language="rust" start="3" end="17" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-skeleton/src/royalty.rs" />

You'll learn more about these functions in the [royalty section](/tutorials/nfts/royalty) of the tutorial series.

---

## `events.rs`

> Contains events-related structures.

| Method              | Description                                         |
|---------------------|-----------------------------------------------------|
| **EventLogVariant** | This enum represents the data type of the EventLog. |
| **EventLog**        | Interface to capture data about an event.           |
| **NftMintLog**      | An event log to capture token minting.              |
| **NftTransferLog**  | An event log to capture token transfer.             |

<Github language="rust" start="5" end="79" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/events.rs" />

You'll learn more about these functions in the [events section](/tutorials/nfts/events) of the tutorial series.

---

## Building the skeleton

If you haven't cloned the main repository yet, open a terminal and run:

```sh
git clone https://github.com/near-examples/nft-tutorial/
```

Next, go to the `nft-contract-skeleton/` folder and build the contract with `cargo-near`:

```sh
cd nft-tutorial
cd nft-contract-skeleton/
cargo near build
```

Since this source is just a skeleton you'll get many warnings about unused code, such as:

```
   Compiling nft_contract_skeleton v0.1.0 (/Users/near-examples/Documents/my/projects/near/examples/nft-tutorial/nft-contract-basic)
 ‚îÇ warning: unused imports: `LazyOption`, `LookupMap`, `UnorderedMap`, `UnorderedSet`
 ‚îÇ  --> src/lib.rs:3:29
 ‚îÇ   |
 ‚îÇ 3 | use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap, UnorderedSet};
 ‚îÇ   |                             ^^^^^^^^^^  ^^^^^^^^^  ^^^^^^^^^^^^  ^^^^^^^^^^^^
 ‚îÇ   |
 ‚îÇ   = note: `#[warn(unused_imports)]` on by default
 ‚îÇ
 ‚îÇ warning: unused import: `Base64VecU8`
 ‚îÇ  --> src/lib.rs:4:28
 ‚îÇ   |
 ‚îÇ 4 | use near_sdk::json_types::{Base64VecU8, U128};
 ‚îÇ   |

 ‚îÇ warning: `nft_contract_skeleton` (lib) generated 48 warnings (run `cargo fix --lib -p nft_contract_skeleton` to apply 45 suggestions)
 ‚îÇ     Finished release [optimized] target(s) in 11.01s
 ‚úì Contract successfully built!
```

Don't worry about these warnings, you're not going to deploy this contract yet.
Building the skeleton is useful to validate that your Rust toolchain works properly and that you'll be able to compile improved versions of this NFT contract in the upcoming tutorials.

---

## Conclusion

You've seen the layout of this NFT smart contract, and how all the functions are laid out across the different source files.
Using `yarn`, you've been able to compile the contract, and you'll start fleshing out this skeleton in the next [Minting tutorial](2-minting.md).

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- rustc: `1.76.0`
- near-sdk-rs: `5.1.0`
- cargo-near: `0.13.2`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/2-minting.md 

 ---
id: minting
title: Minting
sidebar_label: Minting
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This is the first of many tutorials in a series where you'll be creating a complete NFT smart contract from scratch that conforms with all the NEAR [NFT standards](https://nomicon.io/Standards/NonFungibleToken/).

Today you'll learn how to create the logic needed to mint NFTs and have them show up in your NEAR wallet. You will be filling a bare-bones [skeleton smart contract](1-skeleton.md) to add minting functionalities.

:::info Contracts
You can find the skeleton contract in our [Skeleton folder](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract-skeleton)

A completed version of this tutorial can be found in the [Basic NFT folder](https://github.com/near-examples/nft-tutorial/tree/main/nft-contract-basic)
:::

---

## Introduction

To get started, go to the `nft-contract-skeleton` folder in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](1-skeleton.md) to get started.

```
cd nft-contract-skeleton/
```

If you wish to see the finished code of this step-by-step basic NFT contract tutorial, that can be found on the `nft-contract-basic` folder.

---

## Modifications to the skeleton contract {#what-does-minting-mean}

In order to implement the logic needed for minting, we should break it up into smaller tasks and handle those one-by-one. Let's step back and think about the best way to do this by asking ourselves a simple question: what does it mean to mint an NFT?

To mint a non-fungible token, in the most simple way possible, a contract needs to be able to associate a token with an owner on the blockchain. This means you'll need:

- A way to keep track of tokens and other information on the contract.
- A way to store information for each token such as `metadata` (more on that later).
- A way to link a token with an owner.

That's it! We've now broken down the larger problem into some smaller, less daunting, subtasks. Let's start by tackling the first and work our way through the rest.

<hr class="subsection" />

### Storing information on the contract {#storing-information}

Start by navigating to `nft-contract-skeleton/src/lib.rs` and filling in some of the code blocks.
You need to be able to store important information on the contract such as the list of tokens that an account has.

#### Contract Struct

The first thing to do is modifying the contract `struct` as follows:
<Github language="rust" start="35" end="52" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

This allows you to get the information stored in these data structures from anywhere in the contract. The code above has created 3 token specific storages:

- **tokens_per_owner**: allows you to keep track of the tokens owned by any account
- **tokens_by_id**: returns all the information about a specific token
- **token_metadata_by_id**: returns just the metadata for a specific token

In addition, you'll keep track of the owner of the contract as well as the metadata for the contract.

You might be confused as to some of the types that are being used. In order to make the code more readable, we've introduced custom data types which we'll briefly outline below:

- **AccountId**: a string that ensures there are no special or unsupported characters.
- **TokenId**: simply a string.

As for the `Token`, `TokenMetadata`, and `NFTContractMetadata` data types, those are structs that we'll define later in this tutorial.

#### Initialization Functions

Next, create what's called an initialization function; we will name it `new`, but you can choose any name you prefer.

This function needs to be invoked when you first deploy the contract. It will initialize all the contract's fields that you've defined above with default values.
Don't forget to add the `owner_id` and `metadata` fields as parameters to the function, so only those can be customized.

This function will default all the collections to be empty and set the `owner` and `metadata` equal to what you pass in.

<Github language="rust" start="96" end="114" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

More often than not when doing development, you'll need to deploy contracts several times. You can imagine that it might get tedious to have to pass in metadata every single time you want to initialize the contract. For this reason, let's create a function that can initialize the contract with a set of default `metadata`. You can call it `new_default_meta` and it'll only take the `owner_id` as a parameter.

<Github language="rust" start="74" end="89" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

This function is simply calling the previous `new` function and passing in the owner that you specify and also passes in some default metadata.

<hr class="subsection" />

### Metadata and token information {#metadata-and-token-info}

Now that you've defined what information to store on the contract itself and you've defined some ways to initialize the contract, you need to define what information should go in the `Token`, `TokenMetadata`, and `NFTContractMetadata` data types.

Let's switch over to the `nft-contract-skeleton/src/metadata.rs` file as this is where that information will go.

If you look at the [standards for metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), you'll find all the necessary information that you need to store for both `TokenMetadata` and `NFTContractMetadata`. Simply fill in the following code.

<Github language="rust" start="10" end="39" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

This now leaves you with the `Token` struct and something called a `JsonToken`. The `Token` struct will hold all the information directly related to the token excluding the metadata. The metadata, if you remember, is stored in a map on the contract in a data structure called `token_metadata_by_id`. This allows you to quickly get the metadata for any token by simply passing in the token's ID.

For the `Token` struct, you'll just keep track of the owner for now.

<Github language="rust" start="41" end="46" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

Since NEAR smart contracts receive and return data in JSON format, the purpose of the `JsonToken` is to act as output when the user asks information for an NFT. This means you'll want to store the owner, token ID, and metadata.

<Github language="rust" start="49" end="58" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

:::tip
Some of you might be thinking _"how come we don't just store all the information in the `Token` struct?"_.
The reason behind this is that it's actually more efficient to construct the JSON token on the fly only when you need it rather than storing all the information in the token struct.
In addition, some operations might only need the metadata for a token and so having the metadata in a separate data structure is more optimal.
:::

#### Function for querying contract metadata

Now that you've defined some of the types that were used in the previous section, let's move on and create the first view function `nft_metadata`. This will allow users to query for the contract's metadata as per the [metadata standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata).

<Github language="rust" start="60" end="70" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

This function will get the `metadata` object from the contract which is of type `NFTContractMetadata` and will return it.

Just like that, you've completed the first two tasks and are ready to move onto last part of the tutorial.

<hr class="subsection" />

### Minting Logic {#minting-logic}

Now that all the information and types are defined, let's start brainstorming how the minting logic will play out. In the end, you need to link a `Token` and `TokenId` to a specific owner. Let's look back at the `lib.rs` file to see how you can accomplish this. There are a couple data structures that might be useful:

```rust
//keeps track of all the token IDs for a given account
pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,

//keeps track of the token struct for a given token ID
pub tokens_by_id: LookupMap<TokenId, Token>,

//keeps track of the token metadata for a given token ID
pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
```

Looking at these data structures, you could do the following:

- Add the token ID into the set of tokens that the receiver owns. This will be done on the `tokens_per_owner` field.
- Create a token object and map the token ID to that token object in the `tokens_by_id` field.
- Map the token ID to it's metadata using the `token_metadata_by_id`.

#### Storage Implications {#storage-implications}
With those steps outlined, it's important to take into consideration the storage costs of minting NFTs. Since you're adding bytes to the contract by creating entries in the data structures, the contract needs to cover the storage costs. If you just made it so any user could go and mint an NFT for free, that system could easily be abused and users could essentially "drain" the contract of all it's funds by minting thousands of NFTs. For this reason, you'll make it so that users need to attach a deposit to the call to cover the cost of storage. You'll measure the initial storage usage before anything was added and you'll measure the final storage usage after all the logic is finished. Then you'll make sure that the user has attached enough $NEAR to cover that cost and refund them if they've attached too much.

This is how we do it in code:

<Github language="rust" start="3" end="45" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/mint.rs" />


You'll notice that we're using some internal methods such as `refund_deposit` and `internal_add_token_to_owner`. We've described the function of `refund_deposit` and as for `internal_add_token_to_owner`, this will add a token to the set of tokens an account owns for the contract's `tokens_per_owner` data structure. You can create these functions in a file called `internal.rs`. Go ahead and create the file. Your new contract architecture should look as follows:

```
nft-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ build.sh
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ approval.rs
    ‚îú‚îÄ‚îÄ enumeration.rs
    ‚îú‚îÄ‚îÄ internal.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ metadata.rs
    ‚îú‚îÄ‚îÄ mint.rs
    ‚îú‚îÄ‚îÄ nft_core.rs
    ‚îú‚îÄ‚îÄ events.rs
    ‚îî‚îÄ‚îÄ royalty.rs
```

Add the following to your newly created `internal.rs` file.

<Github language="rust" start="1" end="133" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

:::note
You may notice more functions in the `internal.rs` file than we need for now. You may ignore them, we'll come back to them later.
:::

Let's now quickly move to the `lib.rs` file and make the functions we just created invocable in other files. We'll add the internal crates and mod the file as shown below:

<Github language="rust" start="10" end="23" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/lib.rs" />

At this point, the core logic is all in place so that you can mint NFTs. You can use the function `nft_mint` which takes the following parameters:

- **token_id**: the ID of the token you're minting (as a string).
- **metadata**: the metadata for the token that you're minting (of type `TokenMetadata` which is found in the `metadata.rs` file).
- **receiver_id**: specifies who the owner of the token will be.

Behind the scenes, the function will:

1. Calculate the initial storage before adding anything to the contract
2. Create a `Token` object with the owner ID
3. Link the token ID to the newly created token object by inserting them into the `tokens_by_id` field.
4. Link the token ID to the passed in metadata by inserting them into the `token_metadata_by_id` field.
5. Add the token ID to the list of tokens that the owner owns by calling the `internal_add_token_to_owner` function.
6. Calculate the final and net storage to make sure that the user has attached enough NEAR to the call in order to cover those costs.

<hr class="subsection" />

### Querying for token information

If you were to go ahead and deploy this contract, initialize it, and mint an NFT, you would have no way of knowing or querying for the information about the token you just minted. Let's quickly add a way to query for the information of a specific NFT. You'll move to the `nft-contract-skeleton/src/nft_core.rs` file and edit the `nft_token` function.

It will take a token ID as a parameter and return the information for that token. The `JsonToken` contains the token ID, the owner ID, and the token's metadata.

<Github language="rust" start="129" end="143" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

With that finished, it's finally time to build and deploy the contract so you can mint your first NFT.

---

## Interacting with the contract on-chain

Now that the logic for minting is complete and you've added a way to query for information about specific tokens, it's time to build and deploy your contract to the blockchain.

### Deploying the contract {#deploy-the-contract}

For deployment, you will need a NEAR account with the keys stored on your local machine. Navigate to the [NEAR wallet](https://testnet.mynearwallet.com/) site and create an account.

:::info
Please ensure that you deploy the contract to an account with no pre-existing contracts. It's easiest to simply create a new account or create a sub-account for this tutorial.
:::

Log in to your newly created account with [`near-cli-rs`](../../4.tools/cli.md) by running the following command in your terminal.

```bash
near account import-account using-web-wallet network-config testnet
```

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` portion:

```bash
export NFT_CONTRACT_ID="YOUR_ACCOUNT_NAME"
```

Test that the environment variable is set correctly by running:

```bash
echo $NFT_CONTRACT_ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your NFT project run the following command to deploy your smart contract and answer questions:

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID

> Select the need for initialization: with-init-call     - Add an initialize
> What is the name of the function? new_default_meta
> How would you like to pass the function arguments? json-args
> Enter the arguments to this function: {"owner_id": "<YOUR_NFT_CONTRACT_ID>"}
> Enter gas for function call: 100 TeraGas
> Enter deposit for a function call (example: 10NEAR or 0.5near or 10000yoctonear): 0 NEAR
> What is the name of the network? testnet
> Select a tool for signing the transaction: sign-with-keychain
> How would you like to proceed? send
```

You don't need to answer these questions every time. If you look at the results you will find the message `Here is the console command if you ever need to re-run it again`. The next line is the command which you may use instead of answering to interactive questions:

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

You've just deployed and initialized the contract with some default metadata and set your account ID as the owner. At this point, you're ready to call your first view function.

<hr class="subsection" />

### Viewing the contract's metadata

Now that the contract has been initialized, you can call some of the functions you wrote earlier. More specifically, let's test out the function that returns the contract's metadata:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $NFT_CONTRACT_ID nft_metadata '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_metadata json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```bash
{
  spec: 'nft-1.0.0',
  name: 'NFT Tutorial Contract',
  symbol: 'GOTEAM',
  icon: null,
  base_uri: null,
  reference: null,
  reference_hash: null
}
```

At this point, you're ready to move on and mint your first NFT.

<hr class="subsection" />

### Minting our first NFT {#minting-our-first-nft}

Let's now call the minting function that you've created. This requires a `token_id` and `metadata`. If you look back at the `TokenMetadata` struct you created earlier, there are many fields that could potentially be stored on-chain:

<Github language="rust" start="23" end="39" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/metadata.rs" />

Let's mint an NFT with a title, description, and media to start. The media field can be any URL pointing to a media file. We've got an excellent GIF to mint but if you'd like to mint a custom NFT, simply replace our media link with one of your choosing. If you run the following command, it will mint an NFT with the following parameters:

- **token_id**: "token-1"
- **metadata**:
  - _title_: "My Non Fungible Team Token"
  - _description_: "The Team Most Certainly Goes :)"
  - _media_: `https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif`
  - **receiver_id**: "'$NFT_CONTRACT_ID'"

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

:::info
The `amount` flag is specifying how much NEAR to attach to the call. Since you need to pay for storage, 0.1 NEAR is attached and you'll get refunded any excess that is unused at the end.
:::

<hr class="subsection" />

### Viewing information about the NFT

Now that the NFT has been minted, you can check and see if everything went correctly by calling the `nft_token` function.
This should return a `JsonToken` which should contain the `token_id`, `owner_id`, and `metadata`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_token json-args '{"token_id": "token-1"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```bash
{
  token_id: 'token-1',
  owner_id: 'goteam.examples.testnet',
  metadata: {
    title: 'My Non Fungible Team Token',
    description: 'The Team Most Certainly Goes :)',
    media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
    media_hash: null,
    copies: null,
    issued_at: null,
    expires_at: null,
    starts_at: null,
    updated_at: null,
    extra: null,
    reference: null,
    reference_hash: null
  }
}
```

</p>
</details>

**Go team!** You've now verified that everything works correctly and it's time to view your freshly minted NFT in the NEAR wallet's collectibles tab!

---

## Viewing your NFTs in the wallet

If you navigate to the [collectibles tab](https://testnet.mynearwallet.com/?tab=collectibles) in the NEAR wallet, this should list all the NFTs that you own. It should look something like the what's below.

![empty-nft-in-wallet](/docs/assets/nfts/empty-nft-in-wallet.png)

We've got a problem. The wallet correctly picked up that you minted an NFT, however, the contract doesn't implement the specific view function that is being called. Behind the scenes, the wallet is trying to call `nft_tokens_for_owner` to get a list of all the NFTs owned by your account on the contract. The only function you've created, however, is the `nft_token` function. It wouldn't be very efficient for the wallet to call `nft_token` for every single NFT that a user has to get information and so they try to call the `nft_tokens_for_owner` function.

In the next tutorial, you'll learn about how to deploy a patch fix to a pre-existing contract so that you can view the NFT in the wallet.

---

## Conclusion

In this tutorial, you went through the basics of setting up and understand the logic behind minting NFTs on the blockchain using a skeleton contract.

You first looked at [what it means](#what-does-minting-mean) to mint NFTs and how to break down the problem into more feasible chunks. You then started modifying the skeleton contract chunk by chunk starting with solving the problem of [storing information / state](#storing-information) on the contract. You then looked at what to put in the [metadata and token information](#metadata-and-token-info). Finally, you looked at the logic necessary for [minting NFTs](#minting-logic).

After the contract was written, it was time to deploy to the blockchain. You [deployed and initialized the contract](#deploy-the-contract). Finally, you [minted your very first NFT](#minting-our-first-nft) and saw that some changes are needed before you can view it in the wallet.

---

## Next Steps

In the [next tutorial](2-upgrade.md), you'll find out how to deploy a patch fix and what that means so that you can view your NFTs in the wallet.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Metadata standard: [NEP177](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), version `2.1.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/2-upgrade.md 

 ---
id: upgrade-contract
title: Upgrading the Contract
sidebar_label: Upgrade a Contract
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll build off the work you previously did to implement the [minting functionality](2-minting.md) on a skeleton smart contract. You got to the point where NFTs could be minted and the wallet correctly picked up on the fact that you owned an NFT. However, it had no way of displaying the tokens since your contract didn't implement the method that the wallet was trying to call.

---

## Introduction

Today you'll learn about deploying patch fixes to smart contracts and you'll use that knowledge to implement the `nft_tokens_for_owner` function on the contract you deployed in the previous tutorial.

---

## Upgrading contracts overview {#upgrading-contracts}

Upgrading contracts, when done right, can be an immensely powerful tool. If done wrong, it can lead to a lot of headaches. It's important to distinguish between the code and state of a smart contract. When a contract is deployed on top of an existing contract, the only thing that changes is the code. The state will remain the same and that's where a lot of developer's issues come to fruition.

The NEAR Runtime will read the serialized state from disk and it will attempt to load it using the current contract code. When your code changes, it might not be able to figure out how to do this.

You need to strategically upgrade your contracts and make sure that the runtime will be able to read your current state with the new contract code. For more information about upgrading contracts and some best practices, see the NEAR SDK's [upgrading contracts](../../2.build/2.smart-contracts/release/upgrade.md) write-up.

---

## Modifications to our contract {#modifications-to-contract}

In order for the wallet to properly display your NFTs, you need to implement the `nft_tokens_for_owner` method. This will allow anyone to query for a paginated list of NFTs owned by a given account ID.

To accomplish this, let's break it down into some smaller subtasks. First, you need to get access to a list of all token IDs owned by a user. This information can be found in the `tokens_per_owner` data structure. Now that you have a set of token IDs, you need to convert them into `JsonToken` objects as that's what you'll be returning from the function.

Luckily, you wrote a function `nft_token` which takes a token ID and returns a `JsonToken` in the `nft_core.rs` file. As you can guess, in order to get a list of `JsonToken` objects, you would need to iterate through the token IDs owned by the user and then convert each token ID into a `JsonToken` and store that in a list.

As for the pagination, Rust has some awesome functions for skipping to a starting index and taking the first `n` elements of an iterator.

Let's move over to the `enumeration.rs` file and implement that logic:

<Github language="rust" start="46" end="75" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

---

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the cargo-near, deploy the contract as you did in the previous tutorial:

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID without-init-call network-config testnet sign-with-keychain send
```

Once the contract has been redeployed, let's test and see if the state migrated correctly by running a simple view function:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $NFT_CONTRACT_ID nft_metadata '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_metadata json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```bash
{
  spec: 'nft-1.0.0',
  name: 'NFT Tutorial Contract',
  symbol: 'GOTEAM',
  icon: null,
  base_uri: null,
  reference: null,
  reference_hash: null
}
```

**Go team!** At this point, you can now test and see if the new function you wrote works correctly. Let's query for the list of tokens that you own:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 5}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 5}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```bash
[
  {
    token_id: 'token-1',
    owner_id: 'goteam.examples.testnet',
    metadata: {
      title: 'My Non Fungible Team Token',
      description: 'The Team Most Certainly Goes :)',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    }
  }
]
```

</p>
</details>

---

## Viewing NFTs in the wallet {#viewing-nfts-in-wallet}

Now that your contract implements the necessary functions that the wallet uses to display NFTs, you should be able to see your tokens on display in the [collectibles tab](https://testnet.mynearwallet.com/?tab=collectibles).

![filled-nft-in-wallet](/docs/assets/nfts/filled-nft-in-wallet.png)

---

## Conclusion

In this tutorial, you learned about the basics of [upgrading contracts](#upgrading-contracts). Then, you implemented the necessary [modifications to your smart contract](#modifications-to-contract) and [redeployed it](#redeploying-contract). Finally you navigated to the wallet collectibles tab and [viewed your NFTs](#viewing-nfts-in-wallet).

In the [next tutorial](3-enumeration.md), you'll implement the remaining functions needed to complete the [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) standard.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/3-enumeration.md 

 ---
id: enumeration
title: Enumeration
sidebar_label: Enumeration
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In the previous tutorials, you looked at ways to integrate the minting functionality into a skeleton smart contract. In order to get your NFTs to show in the wallet, you also had to deploy a patch fix that implemented one of the enumeration methods. In this tutorial, you'll expand on and finish the rest of the enumeration methods as per the [standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration).

Now you'll extend the NFT smart contract and add a couple of enumeration methods that can be used to return the contract's state.

---

## Introduction

As mentioned in the [Upgrade a Contract](2-upgrade.md) tutorial, you can deploy patches and fixes to smart contracts. This time, you'll use that knowledge to implement the `nft_total_supply`, `nft_tokens` and `nft_supply_for_owner` enumeration functions.

---

## Modifications to the contract

Let's start by opening the  `src/enumeration.rs` file and locating the empty `nft_total_supply` function.

**nft_total_supply**

This function should return the total number of NFTs stored on the contract. You can easily achieve this functionality by simply returning the length of the `nft_metadata_by_id` data structure.

<Github language="rust" start="5" end="9" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

**nft_token**

This function should return a paginated list of `JsonTokens` that are stored on the contract regardless of their owners.
If the user provides a `from_index` parameter, you should use that as the starting point for which to start iterating through tokens; otherwise it should start from the beginning. Likewise, if the user provides a `limit` parameter, the function shall stop after reaching either the limit or the end of the list.

:::tip
Rust has useful methods for pagination, allowing you to skip to a starting index and taking the first `n` elements of an iterator.
:::

<Github language="rust" start="11" end="26" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

**nft_supply_for_owner**

This function should look for all the non-fungible tokens for a user-defined owner, and return the length of the resulting set.
If there isn't a set of tokens for the provided `AccountID`, then the function shall return `0`.

<Github language="rust" start="28" end="43" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/enumeration.rs" />

Next, you can use the CLI to query these new methods and validate that they work correctly.

---

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the cargo-near, deploy the contract as you did in the previous tutorials:

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID without-init-call network-config testnet sign-with-keychain send
```

---

## Enumerating tokens

Once the updated contract has been redeployed, you can test and see if these new functions work as expected.

### NFT tokens

Let's query for a list of non-fungible tokens on the contract. Use the following command to query for the information of up to 50 NFTs starting from the 10th item:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $NFT_CONTRACT_ID nft_tokens '{"from_index": "10", "limit": 50}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_tokens json-args '{"from_index": "10", "limit": 50}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This command should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
[]
```

</p>
</details>

<hr class="subsection" />

### Tokens by owner

To get the total supply of NFTs owned by the `goteam.testnet` account, call the `nft_supply_for_owner` function and set the `account_id` parameter:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $NFT_CONTRACT_ID nft_supply_for_owner '{"account_id": "goteam.testnet"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_supply_for_owner json-args '{"account_id": "goteam.testnet"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
0
```

</p>
</details>

---

## Conclusion

In this tutorial, you have added two [new enumeration functions](/tutorials/nfts/enumeration#modifications-to-the-contract), and now you have a basic NFT smart contract with minting and enumeration methods in place. After implementing these modifications, you redeployed the smart contract and tested the functions using the CLI.

In the [next tutorial](4-core.md), you'll implement the core functions needed to allow users to transfer the minted tokens.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/4-core.md 

 ---
id: core
title: Transfers
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll learn how to implement NFT transfers as defined in the [core standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) into your smart contract.

We will define two methods for transferring NFTs:
- `nft_transfer`: that transfers ownership of an NFT from one account to another
- `nft_transfer_call`: that transfers an NFT to a "receiver" and calls a method on the receiver's account

:::tip Why two transfer methods?

`nft_transfer` is a simple transfer between two user, while `nft_transfer_call` allows you to **attach an NFT to a function call**

:::

---

## Introduction {#introduction}

Up until this point, you've created a simple NFT smart contract that allows users to mint tokens and view information using the [enumeration standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). Today, you'll expand your smart contract to allow for users to not only mint tokens, but transfer them as well.

As we did in the [minting tutorial](2-minting.md), let's break down the problem into multiple subtasks to make our lives easier. When a token is minted, information is stored in 3 places:

- **tokens_per_owner**: set of tokens for each account.
- **tokens_by_id**: maps a token ID to a `Token` object.
- **token_metadata_by_id**: maps a token ID to its metadata.

Let's now consider the following scenario. If Benji owns token A and wants to transfer it to Mike as a birthday gift, what should happen? First of all, token A should be removed from Benji's set of tokens and added to Mike's set of tokens.

If that's the only logic you implement, you'll run into some problems. If you were to do a `view` call to query for information about that token after it's been transferred to Mike, it would still say that Benji is the owner.

This is because the contract is still mapping the token ID to the old `Token` object that contains the `owner_id` field set to Benji's account ID. You still have to change the `tokens_by_id` data structure so that the token ID maps to a new `Token` object which has Mike as the owner.

With that being said, the final process for when an owner transfers a token to a receiver should be the following:

- Remove the token from the owner's set.
- Add the token to the receiver's set.
- Map a token ID to a new `Token` object containing the correct owner.

:::note
You might be curious as to why we don't edit the `token_metadata_by_id` field. This is because no matter who owns the token, the token ID will always map to the same metadata. The metadata should never change and so we can just leave it alone.
:::

At this point, you're ready to move on and make the necessary modifications to your smart contract.

---

## Modifications to the contract

Let's start our journey in the `nft-contract-skeleton/src/nft_core.rs` file.

### Transfer function {#transfer-function}

You'll start by implementing the `nft_transfer` logic. This function will transfer the specified `token_id` to the `receiver_id` with an optional `memo` such as `"Happy Birthday Mike!"`.

<Github language="rust" start="60" end="80" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

There are a couple things to notice here. Firstly, we've introduced a new function called `assert_one_yocto()`, which ensures the user has attached exactly one yoctoNEAR to the call. This is a [security measure](../../2.build/2.smart-contracts/security/one_yocto.md) to ensure that the user is signing the transaction with a [full access key](../../1.concepts/protocol/access-keys.md).

Since the transfer function is potentially transferring very valuable assets, you'll want to make sure that whoever is calling the function has a full access key.

Secondly, we've introduced an `internal_transfer` method. This will perform all the logic necessary to transfer an NFT.

<hr class="subsection" />

### Internal helper functions

Let's quickly move over to the `nft-contract/src/internal.rs` file so that you can implement the `assert_one_yocto()` and `internal_transfer` methods.

Let's start with the easier one, `assert_one_yocto()`.

#### assert_one_yocto

<Github language="rust" start="14" end="21" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

#### internal_transfer

It's now time to explore the `internal_transfer` function which is the core of this tutorial. This function takes the following parameters:

- **sender_id**: the account that's attempting to transfer the token.
- **receiver_id**: the account that's receiving the token.
- **token_id**: the token ID being transferred.
- **memo**: an optional memo to include.

The first thing we have to do is to make sure that the sender is authorized to transfer the token. In this case, we just make sure that the sender is the owner of the token. We do that by getting the `Token` object using the `token_id` and making sure that the sender is equal to the token's `owner_id`.

Second, we remove the token ID from the sender's list and add the token ID to the receiver's list of tokens. Finally, we create a new `Token` object with the receiver as the owner and remap the token ID to that newly created object.

We want to create this function within the contract implementation (below the `internal_add_token_to_owner` you created in the minting tutorial).

<Github language="rust" start="96" end="132" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

Now let's look at the function called `internal_remove_token_from_owner`. That function implements the functionality for removing a token ID from an owner's set.

In the remove function, we get the set of tokens for a given account ID and then remove the passed in token ID. If the account's set is empty after the removal, we simply remove the account from the `tokens_per_owner` data structure.

<Github language="rust" start="71" end="94" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/internal.rs" />

Your `internal.rs` file should now have the following outline:

```
internal.rs
‚îú‚îÄ‚îÄ hash_account_id
‚îú‚îÄ‚îÄ assert_one_yocto
‚îú‚îÄ‚îÄ refund_deposit
‚îî‚îÄ‚îÄ impl Contract
    ‚îú‚îÄ‚îÄ internal_add_token_to_owner
    ‚îú‚îÄ‚îÄ internal_remove_token_from_owner
    ‚îî‚îÄ‚îÄ internal_transfer
```

<hr class="subsection" />

### Transfer call function {#transfer-call-function}

The idea behind the `nft_transfer_call` function is to transfer an NFT to a receiver while calling a method on the receiver's contract all in the same transaction.

This way, we can effectively **attach an NFT to a function call**.

<Github language="rust" start="82" end="126" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

The function will first assert that the caller attached exactly 1 yocto for security purposes. It will then transfer the NFT using `internal_transfer` and start the cross contract call. It will call the method `nft_on_transfer` on the `receiver_id`'s contract, and create a promise to call back `nft_resolve_transfer` with the result. This is a very common workflow when dealing with [cross contract calls](../../2.build/2.smart-contracts/anatomy/crosscontract.md).

As dictated by the core standard, the function we are calling (`nft_on_transfer`) needs to return a boolean stating whether or not you should return the NFT to its original owner.

<Github language="rust" start="146" end="201" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-basic/src/nft_core.rs" />

If `nft_on_transfer` returned true or the called failed, you should send the token back to its original owner. On the contrary, if false was returned, no extra logic is needed.

As for the return value of our function `nft_resolve_transfer`, the standard dictates that the function should return a boolean indicating whether or not the receiver successfully received the token or not.

This means that if `nft_on_transfer` returned true, you should return false. This is because if the token is being returned its original owner, the `receiver_id` didn't successfully receive the token in the end. On the contrary, if `nft_on_transfer` returned false, you should return true since we don't need to return the token and thus the `receiver_id` successfully owns the token.

With that finished, you've now successfully added the necessary logic to allow users to transfer NFTs. It's now time to deploy and do some testing.

---

## Redeploying the contract {#redeploying-contract}

Using cargo-near, deploy the contract as you did in the previous tutorials:

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID without-init-call network-config testnet sign-with-keychain send
```

:::tip
If you haven't completed the previous tutorials and are just following along with this one, simply create an account and login with your CLI using `near login`. You can then export an environment variable `export NFT_CONTRACT_ID=YOUR_ACCOUNT_ID_HERE`.
:::

---

## Testing the new changes {#testing-changes}

Now that you've deployed a patch fix to the contract, it's time to move onto testing. Using the previous NFT contract where you had minted a token to yourself, you can test the `nft_transfer` method. If you transfer the NFT, it should be removed from your account's collectibles displayed in the wallet. In addition, if you query any of the enumeration functions, it should show that you are no longer the owner.

Let's test this out by transferring an NFT to the account `benjiman.testnet` and seeing if the NFT is no longer owned by you.

<hr class="subsection" />

### Testing the transfer function

:::note
This means that the NFT won't be recoverable unless the account `benjiman.testnet` transfers it back to you. If you don't want your NFT lost, make a new account and transfer the token to that account instead.
:::

If you run the following command, it will transfer the token `"token-1"` to the account `benjiman.testnet` with the memo `"Go Team :)"`. Take note that you're also attaching exactly 1 yoctoNEAR by using the `--depositYocto` flag.

:::tip
If you used a different token ID in the previous tutorials, replace `token-1` with your token ID.
:::

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "token-1", "memo": "Go Team :)"}' --gas 100000000000000 --depositYocto 1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "benjiman.testnet", "token_id": "token-1", "memo": "Go Team :)"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you now query for all the tokens owned by your account, that token should be missing. Similarly, if you query for the list of tokens owned by `benjiman.testnet`, that account should now own your NFT.

<hr class="subsection" />

### Testing the transfer call function

Now that you've tested the `nft_transfer` function, it's time to test the `nft_transfer_call` function. If you try to transfer an NFT to a receiver that does **not** implement the `nft_on_transfer` function, the contract will panic and the NFT will **not** be transferred. Let's test this functionality below.

First mint a new NFT that will be used to test the transfer call functionality.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-2", "metadata": {"title": "NFT Tutorial Token", "description": "Testing the transfer call function", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"token_id": "token-2", "metadata": {"title": "NFT Tutorial Token", "description": "Testing the transfer call function", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Now that you've minted the token, you can try to transfer the NFT to the account `no-contract.testnet` which as the name suggests, doesn't have a contract. This means that the receiver doesn't implement the `nft_on_transfer` function and the NFT should remain yours after the transaction is complete.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_transfer_call '{"receiver_id": "no-contract.testnet", "token_id": "token-2", "msg": "foo"}' --gas 100000000000000 --depositYocto 1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_transfer_call json-args '{"receiver_id": "no-contract.testnet", "token_id": "token-2", "msg": "foo"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you query for your tokens, you should still have `token-2` and at this point, you're finished!

---

## Conclusion

In this tutorial, you learned how to expand an NFT contract past the minting functionality and you added ways for users to transfer NFTs. You [broke down](#introduction) the problem into smaller, more digestible subtasks and took that information and implemented both the [NFT transfer](#transfer-function) and [NFT transfer call](#transfer-call-function) functions. In addition, you deployed another [patch fix](#redeploying-contract) to your smart contract and [tested](#testing-changes) the transfer functionality.

In the [next tutorial](5-approval.md), you'll learn about the approval management system and how you can approve others to transfer tokens on your behalf.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/5-approval.md 

 ---
id: approvals
title: Approvals
sidebar_label: Approvals
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll learn the basics of an approval management system which will allow you to grant others access to transfer NFTs on your behalf.

This is the backbone of all NFT marketplaces and allows for some complex yet beautiful scenarios to happen. If you're joining us for the first time, feel free to clone [this repository](https://github.com/near-examples/nft-tutorial) and go to the `nft-contract-basic/` folder to follow along.

```bash
cd nft-contract-basic/
```

:::tip
If you wish to see the finished code for this _Approval_ tutorial, you can find it in the `nft-contract-approval/` folder.
:::

---

## Introduction

Up until this point you've created a smart contract that allows users to mint and transfer NFTs as well as query for information using the [enumeration standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). As we've been doing in the previous tutorials, let's break down the problem into smaller, more digestible, tasks.

Let's first define some of the end goals that we want to accomplish as per the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension of the standard. We want a user to have the ability to:

- Grant other accounts access to transfer their NFTs on a per token basis.
- Check if an account has access to a specific token.
- Revoke a specific account the ability to transfer an NFT.
- Revoke **all** other accounts the ability to transfer an NFT.

If you look at all these goals, they are all on a per token basis. This is a strong indication that you should change the `Token` struct which keeps track of information for each token.

---

## Allow an account to transfer your NFT

Let's start by trying to accomplish the first goal. How can you grant another account access to transfer an NFT on your behalf?

The simplest way that you can achieve this is to add a list of approved accounts to the `Token` struct. When transferring the NFT, if the caller is not the owner, you could check if they're in the list.

Before transferring, you would need to clear the list of approved accounts since the new owner wouldn't expect the accounts approved by the original owner to still have access to transfer their new NFT.

<hr className="subsection" />

### The problem {#the-problem}

On the surface, this would work, but if you start thinking about the edge cases, some problems arise. Often times when doing development, a common approach is to think about the easiest and most straightforward solution. Once you've figured it out, you can start to branch off and think about optimizations and edge cases.

Let's consider the following scenario. Benji has an NFT and gives two separate marketplaces access to transfer his token. By doing so, he's putting the NFT for sale. Let's say he put the NFT for sale for 1 NEAR on both markets. The tokens list of approved account IDs would look like the following:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

Josh then comes along and purchases the NFT on marketplace A for 1 NEAR. This would take the sale down from the marketplace A and clear the list of approved accounts. Marketplace B, however, still has the token listed for sale for 1 NEAR and has no way of knowing that the token was purchased on marketplace A by Josh. The new token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: []
}
```

Let's say Josh is low on cash and wants to flip this NFT and put it for sale for 10 times the price on marketplace B. He goes to put it for sale and for whatever reason, the marketplace is built in a way that if you try to put a token up for sale twice, it keeps the old sale data. This would mean that from marketplace B's perspective, the token is still for sale for 1 NEAR (which was the price that Benji had originally listed it for).

Since Josh approved the marketplace to try and put it for sale, the token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

If Mike then comes along and purchases the NFT for only 1 NEAR on marketplace B, the marketplace would go to try and transfer the NFT and since technically, Josh approved the marketplace and it's in the list of approved accounts, the transaction would go through properly.

<hr className="subsection" />

### The solution {#the-solution}

Now that we've identified a problem with the original solution, let's think about ways that we can fix it. What would happen now if, instead of just keeping track of a list of approved accounts, you introduced a specific ID that went along with each approved account. The new approved accounts would now be a map instead of a list. It would map an account to its `approval id`.

For this to work, you need to make sure that the approval ID is **always** a unique, new ID. If you set it as an integer that always increases by 1 whenever u approve an account, this should work. Let's consider the same scenario with the new solution.

Benji puts his NFT for sale for 1 NEAR on marketplace A and marketplace B by approving both marketplaces. The "next approval ID" would start off at 0 when the NFT was first minted and will increase from there. This would result in the following token struct:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: {
        marketplace A: 0
        marketplace B: 1
    }
    next_approval_id: 2
}
```

When Benji approved marketplace A, it took the original value of `next_approval_id` which started off at 0. The marketplace was then inserted into the map and the next approval ID was incremented. This process happened again for marketplace B and the next approval ID was again incremented where it's now 2.

Josh comes along and purchases the NFT on marketplace A for 1 NEAR. Notice how the next approval ID stayed at 2:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {}
    next_approval_id: 2
}
```

Josh then flips the NFT because he's once again low on cash and approves marketplace B:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {
        marketplace B: 2
    }
    next_approval_id: 3
}
```

The marketplace is inserted into the map and the next approval ID is incremented. From marketplace B's perspective it stores its original approval ID from when Benji put the NFT up for sale which has a value of 1. If Mike were to go and purchase the NFT on marketplace B for the original 1 NEAR sale price, the NFT contract should panic. This is because the marketplace is trying to transfer the NFT with an approval ID 1 but the token struct shows that it **should** have an approval ID of 2.

<hr className="subsection" />

### Expanding the `Token` and `JsonToken` structs

Now that you understand the proposed solution to the original problem of allowing an account to transfer your NFT, it's time to implement some of the logic. The first thing you should do is modify the `Token` and `JsonToken` structs to reflect the new changes. Let's switch over to the `nft-contract-basic/src/metadata.rs` file:

<Github language="rust" start="41" end="64" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/metadata.rs" />

You'll then need to initialize both the `approved_account_ids` and `next_approval_id` to their default values when a token is minted. Switch to the `nft-contract-basic/src/mint.rs` file and when creating the `Token` struct to store in the contract, let's set the next approval ID to be 0 and the approved account IDs to be an empty map:

<Github language="rust" start="31" end="38" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/mint.rs" />

<hr className="subsection" />

### Approving accounts

Now that you've added the support for approved account IDs and the next approval ID on the token level, it's time to add the logic for populating and changing those fields through a function called `nft_approve`. This function should approve an account to have access to a specific token ID. Let's move to the `nft-contract-basic/src/approval.rs` file and edit the `nft_approve` function:

<Github language="rust" start="38" end="95" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

The function will first assert that the user has attached **at least** one yoctoNEAR (which we'll implement soon). This is both for security and to cover storage. When someone approves an account ID, they're storing that information on the contract. As you saw in the [minting tutorial](/tutorials/nfts/minting), you can either have the smart contract account cover the storage, or you can have the users cover that cost. The latter is more scalable and it's the approach you'll be working with throughout this tutorial.

After the assertion comes back with no problems, you get the token object and make sure that only the owner is calling this method. Only the owner should be able to allow other accounts to transfer their NFTs. You then get the next approval ID and insert the passed in account into the map with the next approval ID. If it's a new approval ID, storage must be paid. If it's not a new approval ID, no storage needs to be paid and only attaching 1 yoctoNEAR would be enough.

You then calculate how much storage is being used by adding that new account to the map and increment the tokens `next_approval_id` by 1. After inserting the token object back into the `tokens_by_id` map, you refund any excess storage.

You'll notice that the function contains an optional `msg` parameter. This message can be used by NFT marketplaces. If a message was provided into the function, you're going to perform a cross contract call to the account being given access. This cross contract call will invoke the `nft_on_approve` function which will parse the message and act accordingly.

It is up to the approving person to provide a properly encoded message that the marketplace can decode and use. This is usually done through the marketplace's frontend app which would know how to construct the `msg` in a useful way.

<hr className="subsection" />

### Internal functions

Now that the core logic for approving an account is finished, you need to implement the `assert_at_least_one_yocto` and `bytes_for_approved_account` functions. Move to the `nft-contract/src/internal.rs` file and copy the following function right below the `assert_one_yocto` function.

<Github language="rust" start="49" end="55" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

Next, you'll need to copy the logic for calculating how many bytes it costs to store an account ID. Place this function at the very top of the page:

<Github language="rust" start="1" end="9" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

Now that the logic for approving accounts is finished, you need to change the restrictions for transferring.


#### Changing the restrictions for transferring NFTs

Currently, an NFT can **only** be transferred by its owner. You need to change that restriction so that people that have been approved can also transfer NFTs. In addition, you'll make it so that if an approval ID is passed, you can increase the security and check if both the account trying to transfer is in the approved list **and** they correspond to the correct approval ID. This is to address the problem we ran into earlier.

In the `internal.rs` file, you need to change the logic of the `internal_transfer` method as that's where the restrictions are being made. Change the internal transfer function to be the following:

<Github language="rust" start="130" end="227" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

This will check if the sender isn't the owner and then if they're not, it will check if the sender is in the approval list. If an approval ID was passed into the function, it will check if the sender's actual approval ID stored on the contract matches the one passed in.

<hr className="subsection" />

#### Refunding storage on transfer

While you're in the internal file, you're going to need to add methods for refunding users who have paid for storing approved accounts on the contract when an NFT is transferred. This is because you'll be clearing the `approved_account_ids` map whenever NFTs are transferred and so the storage is no longer being used.

Right below the `bytes_for_approved_account_id` function, copy the following two functions:

<Github language="rust" start="11" end="29" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/internal.rs" />

These will be useful in the next section where you'll be changing the `nft_core` functions to include the new approval logic.

<hr className="subsection" />

### Changes to `nft_core.rs`

Head over to the `nft-contract-basic/src/nft_core.rs` file and the first change that you'll want to make is to add an `approval_id` to both the `nft_transfer` and `nft_transfer_call` functions. This is so that anyone trying to transfer the token that isn't the owner must pass in an approval ID to address the problem seen earlier. If they are the owner, the approval ID won't be used as we saw in the `internal_transfer` function.

<Github language="rust" start="8" end="29" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

You'll then need to add an `approved_account_ids` map to the parameters of `nft_resolve_transfer`. This is so that you can refund the list if the transfer went through properly.

<Github language="rust" start="47" end="66" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

Moving over to `nft_transfer`, the only change that you'll need to make is to pass in the approval ID into the `internal_transfer` function and then refund the previous tokens approved account IDs after the transfer is finished

<Github language="rust" start="71" end="99" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

Next, you need to do the same to `nft_transfer_call` but instead of refunding immediately, you need to attach the previous token's approved account IDs to `nft_resolve_transfer` instead as there's still the possibility that the transfer gets reverted.

<Github language="rust" start="101" end="158" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

You'll also need to add the tokens approved account IDs to the `JsonToken` being returned by `nft_token`.

<Github language="rust" start="160" end="176" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

Finally, you need to add the logic for refunding the approved account IDs in `nft_resolve_transfer`. If the transfer went through, you should refund the owner for the storage being released by resetting the tokens `approved_account_ids` field. If, however, you should revert the transfer, it wouldn't be enough to just not refund anybody. Since the receiver briefly owned the token, they could have added their own approved account IDs and so you should refund them if they did so.

<Github language="rust" start="181" end="279" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/nft_core.rs" />

With that finished, it's time to move on and complete the next task.

---

## Check if an account is approved

Now that the core logic is in place for approving and refunding accounts, it should be smooth sailing from this point on. You now need to implement the logic for checking if an account has been approved. This should take an account and token ID as well as an optional approval ID. If no approval ID was provided, it should simply return whether or not the account is approved.

If an approval ID was provided, it should return whether or not the account is approved and has the same approval ID as the one provided. Let's move to the `nft-contract-basic/src/approval.rs` file and add the necessary logic to the `nft_is_approved` function.

<Github language="rust" start="98" end="125" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

Let's now move on and add the logic for revoking an account

---

## Revoke an account

The next step in the tutorial is to allow a user to revoke a specific account from having access to their NFT. The first thing you'll want to do is assert one yocto for security purposes. You'll then need to make sure that the caller is the owner of the token. If those checks pass, you'll need to remove the passed in account from the tokens approved account IDs and refund the owner for the storage being released.

<Github language="rust" start="127" end="151" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

---

## Revoke all accounts

The final step in the tutorial is to allow a user to revoke all accounts from having access to their NFT. This should also assert one yocto for security purposes and make sure that the caller is the owner of the token. You then refund the owner for releasing all the accounts in the map and then clear the `approved_account_ids`.

<Github language="rust" start="153" end="173" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-approval/src/approval.rs" />

With that finished, it's time to deploy and start testing the contract.

---

## Testing the new changes {#testing-changes}

Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, it's best practice to create a new account and deploy the contract there.

<hr className="subsection" />

### Deployment and initialization

Next, you'll deploy this contract to the network.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  export APPROVAL_NFT_CONTRACT_ID=<accountId>
  near create-account $APPROVAL_NFT_CONTRACT_ID --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  export APPROVAL_NFT_CONTRACT_ID=<accountId>
  near account create-account sponsor-by-faucet-service $APPROVAL_NFT_CONTRACT_ID autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Using the cargo-near, deploy and initialize the contract as you did in the previous tutorials:

```bash
cargo near deploy build-non-reproducible-wasm $APPROVAL_NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<hr className="subsection" />

### Minting {#minting}

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"approval-token"` and the receiver will be your new account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_mint '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $APPROVAL_NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_mint json-args '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $APPROVAL_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

You can check to see if everything went through properly by calling one of the enumeration functions:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

Notice how the approved account IDs are now being returned from the function? This is a great sign! You're now ready to move on and approve an account to have access to your token.

<hr className="subsection" />

### Approving an account {#approving-an-account}

At this point, you should have two accounts. One stored under `$NFT_CONTRACT_ID` and the other under the `$APPROVAL_NFT_CONTRACT_ID` environment variable. You can use both of these accounts to test things out. If you approve your old account, it should have the ability to transfer the NFT to itself.

Execute the following command to approve the account stored under `$NFT_CONTRACT_ID` to have access to transfer your NFT with an ID `"approval-token"`. You don't need to pass a message since the old account didn't implement the `nft_on_approve` function. In addition, you'll need to attach enough NEAR to cover the cost of storing the account on the contract. 0.1 NEAR should be more than enough and you'll be refunded any excess that is unused.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_approve json-args '{"token_id": "approval-token", "account_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you call the same enumeration method as before, you should see the new approved account ID being returned.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": { "goteam.examples.testnet": 0 }
  }
]
```

<hr className="subsection" />

### Transferring an NFT as an approved account {#transferring-the-nft}

Now that you've approved another account to transfer the token, you can test that behavior. You should be able to use the other account to transfer the NFT to itself by which the approved account IDs should be reset. Let's test transferring the NFT with the wrong approval ID:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 1}' --gas 100000000000000 --depositYocto 1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 1}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```bash
kind: {
    ExecutionError: "Smart contract panicked: panicked at 'assertion failed: `(left == right)`\n" +
      '  left: `0`,\n' +
      " right: `1`: The actual approval_id 0 is different from the given approval_id 1', src/internal.rs:165:17"
  },
```

</p>
</details>

If you pass the correct approval ID which is `0`, everything should work fine.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 0}' --gas 100000000000000 --depositYocto 1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 0}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you again call the enumeration method, you should see the owner updated and the approved account IDs reset.

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

Let's now test the approval ID incrementing across different owners. If you approve the account that originally minted the token, the approval ID should be 1 now.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_approve json-args '{"token_id": "approval-token", "account_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Calling the view function again show now return an approval ID of 1 for the account that was approved.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 10}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": { "approval.goteam.examples.testnet": 1 }
  }
]
```

</p>
</details>

With the testing finished, you've successfully implemented the approvals extension to the standard!

---

## Conclusion

Today you went through a lot of logic to implement the [approvals extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) so let's break down exactly what you did.

First, you explored the [basic approach](#allow-an-account-to-transfer-your-nft) of how to solve the problem. You then went through and discovered some of the [problems](#the-problem) with that solution and learned how to [fix it](#the-solution).

After understanding what you should do to implement the approvals extension, you started to [modify](#expanding-the-token-and-jsontoken-structs) the JsonToken and Token structs in the contract. You then implemented the logic for [approving accounts](#approving-accounts).

After implementing the logic behind approving accounts, you went and [changed the restrictions](#changing-the-restrictions-for-transferring-nfts) needed to transfer NFTs. The last step you did to finalize the approving logic was to go back and edit the [nft_core](#changes-to-nft_corers) files to be compatible with the new changes.

At this point, everything was implemented in order to allow accounts to be approved and you extended the functionality of the [core standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) to allow for approved accounts to transfer tokens.

You implemented a view method to [check](#check-if-an-account-is-approved) if an account is approved and to finish the coding portion of the tutorial, you implemented the logic necessary to [revoke an account](#revoke-an-account) as well as [revoke all accounts](#revoke-all-accounts).

After this, the contract code was finished and it was time to move onto testing where you created an [account](#deployment-and-initialization) and tested the [approving](#approving-an-account) and [transferring](#transferring-the-nft) for your NFTs.

In the [next tutorial](6-royalty.md), you'll learn about the royalty standards and how you can interact with NFT marketplaces.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Approval standard: [NEP178](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement), version `1.1.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/6-royalty.md 

 ---
id: royalty
title: Royalty
sidebar_label: Royalty
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll continue building your non-fungible token (NFT) smart contract, and learn how to implement perpetual royalties into your NFTs. This will allow people to get a percentage of the purchase price when an NFT is sold.

## Introduction

By now, you should have a fully fledged NFT contract, except for the royalties support.
To get started, go to the `nft-contract-approval/` folder from our [GitHub repository](https://github.com/near-examples/nft-tutorial/), or continue your work from the previous tutorials.

```bash
cd nft-contract-approval/
```

:::tip
If you wish to see the finished code for this _Royalty_ tutorial, you can find it in the `nft-contract-royalty` folder.
:::

---

## Thinking about the problem

In order to implement the functionality, you first need to understand how NFTs are sold. In the previous tutorial, you saw how someone with an NFT could list it on a marketplace using the `nft_approve` function by passing in a message that could be properly decoded. When a user purchases your NFT on the marketplace, what happens?

Using the knowledge you have now, a reasonable conclusion would be to say that the marketplace transfers the NFT to the buyer by performing a cross-contract call and invokes the NFT contract's `nft_transfer` method. Once that function finishes, the marketplace would pay the seller for the correct amount that the buyer paid.

Let's now think about how this can be expanded to allow for a cut of the pay going to other accounts that aren't just the seller.

<hr class="subsection" />

### Expanding the current solution

Since perpetual royalties will be on a per-token basis, it's safe to assume that you should be changing the `Token` and `JsonToken` structs. You need some way of keeping track of what percentage each account with a royalty should have. If you introduce a map of an account to an integer, that should do the trick.

Now, you need some way to relay that information to the marketplace. This method should be able to transfer the NFT exactly like the old solution but with the added benefit of telling the marketplace exactly what accounts should be paid what amounts. If you implement a method that transfers the NFT and then calculates exactly what accounts get paid and to what amount based on a passed-in balance, that should work nicely.

This is what the [royalty standards](https://nomicon.io/Standards/NonFungibleToken/Payout) outlined. Let's now move on and modify our smart contract to introduce this behavior.

---

## Modifications to the contract

The first thing you'll want to do is add the royalty information to the structs. Open the `nft-contract-approval/src/metadata.rs` file and add `royalty` to the `Token` struct:

```rust
pub royalty: HashMap<AccountId, u32>,
```

Second, you'll want to add `royalty` to the `JsonToken` struct as well:

```rust
pub royalty: HashMap<AccountId, u32>,
```

<hr class="subsection" />

### Internal helper function

**royalty_to_payout**

To simplify the payout calculation, let's add a helper `royalty_to_payout` function to `src/internal.rs`. This will convert a percentage to the actual amount that should be paid. In order to allow for percentages less than 1%, you can give 100% a value of `10,000`. This means that the minimum percentage you can give out is 0.01%, or `1`. For example, if you wanted the account `benji.testnet` to have a perpetual royalty of 20%, you would insert the pair `"benji.testnet": 2000` into the payout map.

<Github language="rust" start="5" end="8" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/internal.rs" />

If you were to use the `royalty_to_payout` function and pass in `2000` as the `royalty_percentage` and an `amount_to_pay` of 1 NEAR, it would return a value of 0.2 NEAR.

<hr class="subsection" />

### Royalties

**nft_payout**

Let's now implement a method to check what accounts will be paid out for an NFT given an amount, or balance. Open the `nft-contract/src/royalty.rs` file, and modify the `nft_payout` function as shown.

<Github language="rust" start="22" end="67" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/royalty.rs" />

This function will loop through the token's royalty map and take the balance and convert that to a payout using the `royalty_to_payout` function you created earlier. It will give the owner of the token whatever is left from the total royalties. As an example:

You have a token with the following royalty field:

```rust
Token {
    owner_id: "damian",
    royalty: {
        "benji": 1000,
        "josh": 500,
        "mike": 2000
    }
}
```

If a user were to call `nft_payout` on the token and pass in a balance of 1 NEAR, it would loop through the token's royalty field and insert the following into the payout object:

```rust
Payout {
    payout: {
        "benji": 0.1 NEAR,
        "josh": 0.05 NEAR,
        "mike": 0.2 NEAR
    }
}
```

At the very end, it will insert `damian` into the payout object and give him `1 NEAR - 0.1 - 0.05 - 0.2 = 0.65 NEAR`.

**nft_transfer_payout**

Now that you know how payouts are calculated, it's time to create the function that will transfer the NFT and return the payout to the marketplace.

<Github language="rust" start="68" end="135" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/royalty.rs" />

<hr class="subsection" />

### Perpetual royalties

To add support for perpetual royalties, let's edit the `src/mint.rs` file. First, add an optional parameter for perpetual royalties. This is what will determine what percentage goes to which accounts when the NFT is purchased. You will also need to create and insert the royalty to be put in the `Token` object:

<Github language="rust" start="6" end="80" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/mint.rs" />

Next, you can use the CLI to query the new `nft_payout` function and validate that it works correctly.

### Adding royalty object to struct implementations

Since you've added a new field to your `Token` and `JsonToken` structs, you need to edit your implementations accordingly. Move to the `nft-contract/src/internal.rs` file and edit the part of your `internal_transfer` function that creates the new `Token` object:

<Github language="rust" start="184" end="192" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/internal.rs" />

Once that's finished, move to the `nft-contract-approval/src/nft_core.rs` file. You need to edit your implementation of `nft_token` so that the `JsonToken` sends back the new royalty information.

<Github language="rust" start="160" end="177" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-royalty/src/nft_core.rs" />

---

## Deploying the contract {#redeploying-contract}

As you saw in the previous tutorial, adding changes like these will cause problems when redeploying. Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, you'll create a new account again.

### Deployment and initialization

Next, you'll deploy this contract to the network.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  export ROYALTY_NFT_CONTRACT_ID=<accountId>
  near create-account $ROYALTY_NFT_CONTRACT_ID --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  export ROYALTY_NFT_CONTRACT_ID=<accountId>
  near account create-account sponsor-by-faucet-service $ROYALTY_NFT_CONTRACT_ID autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Using the cargo-near, deploy and initialize the contract as you did in the previous tutorials:

```bash
cargo near deploy build-non-reproducible-wasm $ROYALTY_NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$ROYALTY_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

### Minting {#minting}

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"royalty-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $ROYALTY_NFT_CONTRACT_ID nft_mint '{"token_id": "royalty-token", "metadata": {"title": "Royalty Token", "description": "testing out the new royalty extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$ROYALTY_NFT_CONTRACT_ID'", "perpetual_royalties": {"benjiman.testnet": 2000, "mike.testnet": 1000, "josh.testnet": 500}}' --gas 100000000000000 --deposit 0.1 --accountId $ROYALTY_NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $ROYALTY_NFT_CONTRACT_ID nft_mint json-args '{"token_id": "royalty-token", "metadata": {"title": "Royalty Token", "description": "testing out the new royalty extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$ROYALTY_NFT_CONTRACT_ID'", "perpetual_royalties": {"benjiman.testnet": 2000, "mike.testnet": 1000, "josh.testnet": 500}}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $ROYALTY_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

You can check to see if everything went through properly by calling one of the enumeration functions:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $ROYALTY_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$ROYALTY_NFT_CONTRACT_ID'", "limit": 10}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $ROYALTY_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$ROYALTY_NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```json
[
  {
    "token_id": "royalty-token",
    "owner_id": "royalty.goteam.examples.testnet",
    "metadata": {
      "title": "Royalty Token",
      "description": "testing out the new royalty extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
      "media_hash": null,
      "copies": null,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {},
    "royalty": {
      "josh.testnet": 500,
      "benjiman.testnet": 2000,
      "mike.testnet": 1000
    }
  }
]
```

Notice how there's now a royalty field that contains the 3 accounts that will get a combined 35% of all sales of this NFT? Looks like it works! Go team :)

### NFT payout

Let's calculate the payout for the `"royalty-token"` NFT, given a balance of 100 yoctoNEAR. It's important to note that the balance being passed into the `nft_payout` function is expected to be in yoctoNEAR.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  near view $ROYALTY_NFT_CONTRACT_ID nft_payout '{"token_id": "royalty-token", "balance": "100", "max_len_payout": 100}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  near contract call-function as-read-only $ROYALTY_NFT_CONTRACT_ID nft_payout json-args '{"token_id": "royalty-token", "balance": "100", "max_len_payout": 100}' network-config testnet now
  ```
  </TabItem>
</Tabs>

This command should return an output similar to the following:

```js
{
  payout: {
    'josh.testnet': '5',
    'royalty.goteam.examples.testnet': '65',
    'mike.testnet': '10',
    'benjiman.testnet': '20'
  }
}
```

If the NFT was sold for 100 yoctoNEAR, josh would get 5, Benji would get 20, mike would get 10, and the owner, in this case `royalty.goteam.examples.testnet` would get the rest: 65.

## Conclusion

At this point you have everything you need for a fully functioning NFT contract to interact with marketplaces.
The last remaining standard that you could implement is the events standard. This allows indexers to know what functions are being called and makes it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example.

:::info remember
If you want to see the finished code from this tutorial, you can go to the `nft-contract-royalty` folder.
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Royalties standard: [NEP199](https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout), version `2.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/7-events.md 

 ---
id: events
title: Events
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll learn about the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and how to implement it in your smart contract.

---

## Understanding the use case {#understanding-the-use-case}

Have you ever wondered how the wallet knows which NFTs you own and how it can display them in the [collectibles tab](https://testnet.mynearwallet.com/?tab=collectibles)? Originally, an indexer used to listen for any functions calls starting with `nft_` on your account. These contracts were then flagged on your account as likely NFT contracts.

When you navigated to your collectibles tab, the wallet would then query all those contracts for the list of NFTs you owned using the `nft_tokens_for_owner` function you saw in the [enumeration tutorial](3-enumeration.md).

<hr class="subsection" />

### The problem {#the-problem}

This method of flagging contracts was not reliable as each NFT-driven application might have its own way of minting or transferring NFTs. In addition, it's common for apps to transfer or mint many tokens at a time using batch functions.

<hr class="subsection" />

### The solution {#the-solution}

A standard was introduced so that smart contracts could emit an event anytime NFTs were transferred, minted, or burnt. This event was in the form of a log. No matter how a contract implemented the functionality, an indexer could now listen for those standardized logs.

As per the standard, you need to implement a logging functionality that gets fired when NFTs are transferred or minted. In this case, the contract doesn't support burning so you don't need to worry about that for now.

It's important to note the standard dictates that the log should begin with `"EVENT_JSON:"`. The structure of your log should, however, always contain the 3 following things:

- **standard**: the current name of the standard (e.g. nep171)
- **version**: the version of the standard you're using (e.g. 1.0.0)
- **event**: a list of events you're emitting.

The event interface differs based on whether you're recording transfers or mints. The interface for both events is outlined below.

**Transfer events**:
- *Optional* - **authorized_id**: the account approved to transfer on behalf of the owner.
- **old_owner_id**: the old owner of the NFT.
- **new_owner_id**: the new owner that the NFT is being transferred to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

**Minting events**:
- **owner_id**: the owner that the NFT is being minted to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

<hr class="subsection" />

### Examples {#examples}

In order to solidify your understanding of the standard, let's walk through three scenarios and see what the logs should look like.

#### Scenario A - simple mint

In this scenario, Benji wants to mint an NFT to Mike with a token ID `"team-token"` and he doesn't include a message. The log should look as follows.

```rust
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token"]}
  ]
}
```

#### Scenario B - batch mint

In this scenario, Benji wants to perform a batch mint. He will mint an NFT to Mike, Damian, Josh, and Dorian. Dorian, however, will get two NFTs. Each token ID will be `"team-token"` followed by an incrementing number. The log is as follows.


```rust
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token0"]},
    {"owner_id": "damian.testnet", "token_ids": ["team-token1"]},
    {"owner_id": "josh.testnet", "token_ids": ["team-token2"]}
    {"owner_id": "dorian.testnet", "token_ids": ["team-token3", "team-token4"]},
  ]
}
```

#### Scenario C - transfer NFTs

In this scenario, Mike is transferring both his team tokens to Josh. The log should look as follows.

```rust
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_transfer",
  "data": [
    {"old_owner_id": "mike.testnet", "new_owner_id": "josh.testnet", "token_ids": ["team-token", "team-token0"], "memo": "Go Team!"}
  ]
}
```

---

## Modifications to the contract {#modifications-to-the-contract}

At this point, you should have a good understanding of what the end goal should be so let's get to work! Open the repository and create a new file in the `nft-contract-basic/src` directory called `events.rs`. This is where your log structs will live.

If you wish to see the finished code of the events implementation, that can be found on the `nft-contract-events` folder.

### Creating the events file {#events-rs}

Copy the following into your file. This will outline the structs for your `EventLog`, `NftMintLog`, and `NftTransferLog`. In addition, we've added a way for `EVENT_JSON:` to be prefixed whenever you log the `EventLog`.

<Github language="rust" start="1" end="79" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/events.rs" />

This requires the `serde_json` package which you can easily add to your `nft-contract-skeleton/Cargo.toml` file:

<Github language="rust" start="10" end="12" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/Cargo.toml" />

<hr class="subsection" />

### Adding modules and constants {#lib-rs}

Now that you've created a new file, you need to add the module to the `lib.rs` file. In addition, you can define two constants for the standard and version that will be used across our contract.

<Github language="rust" start="10" end="30" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/lib.rs" />

<hr class="subsection" />

### Logging minted tokens {#logging-minted-tokens}

Now that all the tools are set in place, you can now implement the actual logging functionality. Since the contract will only be minting tokens in one place, open the `nft-contract-basic/src/mint.rs` file and navigate to the bottom of the file. This is where you'll construct the log for minting. Anytime someone successfully mints an NFT, it will now correctly emit a log.

<Github language="rust" start="5" end="58" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/mint.rs" />

<hr class="subsection" />

### Logging transfers {#logging-transfers}

Let's open the `nft-contract-basic/src/internal.rs` file and navigate to the `internal_transfer` function. This is the location where you'll build your transfer logs. Whenever an NFT is transferred, this function is called and so you'll correctly be logging the transfers.

<Github language="rust" start="96" end="159" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/internal.rs" />

This solution, unfortunately, has an edge case which will break things. If an NFT is transferred via the `nft_transfer_call` function, there's a chance that the transfer will be reverted if the `nft_on_transfer` function returns `true`. Taking a look at the logic for `nft_transfer_call`, you can see why this is a problem.

When `nft_transfer_call` is invoked, it will:
- Call `internal_transfer` to perform the actual transfer logic.
- Initiate a cross-contract call and invoke the `nft_on_transfer` function.
- Resolve the promise and perform logic in `nft_resolve_transfer`.
    - This will either return true meaning the transfer went fine or it will revert the transfer and return false.

If you only place the log in the `internal_transfer` function, the log will be emitted and the indexer will think that the NFT was transferred. If the transfer is reverted during `nft_resolve_transfer`, however, that event should **also** be emitted. Anywhere that an NFT **could** be transferred, we should add logs. Replace the `nft_resolve_transfer` with the following code.

<Github language="rust" start="157" end="241" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/nft_core.rs" />

In addition, you need to add an `authorized_id` and `memo` to the parameters for `nft_resolve_transfer` as shown below.

:::tip

We will talk more about this [`authorized_id`](./5-approval.md) in the following chapter.

:::

<Github language="rust" start="43" end="60" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/nft_core.rs" />


The last step is to modify the `nft_transfer_call` logic to include these new parameters:

<Github language="rust" start="86" end="135" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-contract-events/src/nft_core.rs" />

With that finished, you've successfully implemented the events standard and it's time to start testing.

---

## Deploying the contract {#redeploying-contract}

For the purpose of readability and ease of development, instead of redeploying the contract to the same account, let's create an account and deploy to that instead. You could have deployed to the same account as none of the changes you implemented in this tutorial would have caused errors.

### Deployment

Next, you'll deploy this contract to the network.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">
  
  ```bash
  export EVENTS_NFT_CONTRACT_ID=<accountId>
  near create-account $EVENTS_NFT_CONTRACT_ID --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">
  
  ```bash
  export EVENTS_NFT_CONTRACT_ID=<accountId>
  near account create-account sponsor-by-faucet-service $EVENTS_NFT_CONTRACT_ID autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Using the cargo-near, deploy and initialize the contract as you did in the previous tutorials:

```bash
cargo near deploy build-non-reproducible-wasm $EVENTS_NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$EVENTS_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<hr class="subsection" />

### Minting {#minting}

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"events-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $EVENTS_NFT_CONTRACT_ID nft_mint '{"token_id": "events-token", "metadata": {"title": "Events Token", "description": "testing out the new events extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$EVENTS_NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $EVENTS_NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $EVENTS_NFT_CONTRACT_ID nft_mint json-args '{"token_id": "events-token", "metadata": {"title": "Events Token", "description": "testing out the new events extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$EVENTS_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $EVENTS_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

You can check to see if everything went through properly by looking at the output in your CLI:

```bash
Doing account.functionCall()
Receipts: F4oxNfv54cqwUwLUJ7h74H1iE66Y3H7QDfZMmGENwSxd, BJxKNFRuLDdbhbGeLA3UBSbL8UicU7oqHsWGink5WX7S
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"events.goteam.examples.testnet","token_ids":["events-token"]}]}
Transaction Id 4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
''
```

You can see that the event was properly logged!

<hr class="subsection" />

### Transferring {#transferring}

You can now test if your transfer log works as expected by sending `benjiman.testnet` your NFT.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $EVENTS_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "events-token", "memo": "Go Team :)", "approval_id": 0}' --gas 100000000000000 --depositYocto 1 --accountId $EVENTS_NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $EVENTS_NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "benjiman.testnet", "token_id": "events-token", "memo": "Go Team :)", "approval_id": 0}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $EVENTS_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```bash
Doing account.functionCall()
Receipts: EoqBxrpv9Dgb8KqK4FdeREawVVLWepEUR15KPNuZ4fGD, HZ4xQpbgc8EfU3PiV72LvfXb2f3dVC1n9aVTbQds9zfR
	Log [events.goteam.examples.testnet]: Memo: Go Team :)
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"events.goteam.examples.testnet","old_owner_id":"events.goteam.examples.testnet","new_owner_id":"benjiman.testnet","token_ids":["events-token"],"memo":"Go Team :)"}]}
Transaction Id 4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
''
```

Hurray! At this point, your NFT contract is fully complete and the events standard has been implemented.

---

## Conclusion

Today you went through the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and implemented the necessary logic in your smart contract. You created events for [minting](#logging-minted-tokens) and [transferring](#logging-transfers) NFTs. You then deployed and tested your changes by [minting](#minting) and [transferring](#transferring) NFTs.

In the [next tutorial](8-marketplace.md), you'll look at the basics of a marketplace contract and how it was built.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Events standard: [NEP297 extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event), version `1.1.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/8-marketplace.md 

 ---
id: marketplace
title: Marketplace
sidebar_label: Marketplace
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll learn the basics of an NFT marketplace contract where you can buy and sell non-fungible tokens for $NEAR. In the previous tutorials, you went through and created a fully fledged NFT contract that incorporates all the standards found in the [NFT standard](https://nomicon.io/Standards/NonFungibleToken).

---

## Introduction

Throughout this tutorial, you'll learn how a marketplace contract **could** work on NEAR. This is meant to be **an example** as there is no **canonical implementation**. Feel free to branch off and modify this contract to meet your specific needs.

```bash
cd market-contract/
```

This folder contains both the actual contract code and dependencies as outlined below.

```
market-contract
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ external.rs
    ‚îú‚îÄ‚îÄ internal.rs
    ‚îú‚îÄ‚îÄ lib.rs
    ‚îú‚îÄ‚îÄ nft_callbacks.rs
    ‚îú‚îÄ‚îÄ sale.rs
    ‚îî‚îÄ‚îÄ sale_views.rs
```

---

## Understanding the contract

At first, the contract can be quite overwhelming but if you strip away all the fluff and dig into the core functionalities, it's actually quite simple. This contract was designed for only one thing - to allow people to buy and sell NFTs for NEAR. This includes the support for paying royalties, updating the price of your sales, removing sales and paying for storage.

Let's go through the files and take note of some of the important functions and what they do.

---

## lib.rs {#lib-rs}

This file outlines what information is stored on the contract as well as some other crucial functions that you'll learn about below.

### Initialization function {#initialization-function}

The first function you'll look at is the initialization function. This takes an `owner_id` as the only parameter and will default all the storage collections to their default values.

<Github language="rust" start="92" end="107" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/lib.rs" />

<hr className="subsection" />

### Storage management model {#storage-management-model}

Next, let's talk about the storage management model chosen for this contract. On the NFT contract, users attached $NEAR to the calls that needed storage paid for. For example, if someone was minting an NFT, they would need to attach `x` amount of NEAR to cover the cost of storing the data on the contract.

On this marketplace contract, however, the storage model is a bit different. Users will need to deposit $NEAR onto the marketplace to cover the storage costs. Whenever someone puts an NFT for sale, the marketplace needs to store that information which costs $NEAR. Users can either deposit as much NEAR as they want so that they never have to worry about storage again or they can deposit the minimum amount to cover 1 sale on an as-needed basis.

You might be thinking about the scenario when a sale is purchased. What happens to the storage that is now being released on the contract? This is why we've introduced a storage withdrawal function. This allows users to withdraw any excess storage that is not being used. Let's go through some scenarios to understand the logic. The required storage for 1 sale is 0.01 NEAR on the marketplace contract.

**Scenario A**

- Benji wants to list his NFT on the marketplace but has never paid for storage.
- He deposits exactly 0.01 NEAR using the `storage_deposit` method. This will cover 1 sale.
- He lists his NFT on the marketplace and is now using up 1 out of his prepaid 1 sales and has no more storage left. If he were to call `storage_withdraw`, nothing would happen.
- Dorian loves his NFT and quickly purchases it before anybody else can. This means that Benji's sale has now been taken down (since it was purchased) and Benji is using up 0 out of his prepaid 1 sales. In other words, he has an excess of 1 sale or 0.01 NEAR.
- Benji can now call `storage_withdraw` and will be transferred his 0.01 NEAR back. On the contract's side, after withdrawing, he will have 0 sales paid for and will need to deposit storage before trying to list anymore NFTs.

**Scenario B**

- Dorian owns one hundred beautiful NFTs and knows that he wants to list all of them.
- To avoid having to call `storage_deposit` everytime he wants to list an NFT, he calls it once. Since Dorian is a baller, he attaches 10 NEAR which is enough to cover 1000 sales. Then he lists his 100 NFTs and now he has an excess of 9 NEAR or 900 sales.
- Dorian needs the 9 NEAR for something else but doesn't want to take down his 100 listings. Since he has an excess of 9 NEAR, he can easily withdraw and still have his 100 listings. After calling `storage_withdraw` and being transferred 9 NEAR, he will have an excess of 0 sales.

With this behavior in mind, the following two functions outline the logic.

<Github language="rust" start="111" end="139" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/lib.rs" />
<Github language="rust" start="144" end="175" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/lib.rs" />

In this contract, the storage required for each sale is 0.01 NEAR but you can query that information using the `storage_minimum_balance` function. In addition, if you wanted to check how much storage a given account has paid, you can query the `storage_balance_of` function.

With that out of the way, it's time to move onto the `sale.rs` file where you'll look at how NFTs are put for sale.

---

## sale.rs {#sale}

This file is responsible for the internal marketplace logic.

### Listing logic {#listing-logic}

In order to put an NFT on sale, a user should:

1. Approve the marketplace contract on an NFT token (by calling `nft_approve` method on the NFT contract)
2. Call the `list_nft_for_sale` method on the marketplace contract.

#### nft_approve
This method has to be called by the user to [approve our marketplace](5-approval.md), so it can transfer the NFT on behalf of the user. In our contract, we only need to implement the `nft_on_approve` method, which is called by the NFT contract when the user approves our contract.

In our case, we left it blank, but you could implement it to do some additional logic when the user approves your contract.

<Github language="rust" start="23" end="33" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/nft_callbacks.rs" />


#### list_nft_for_sale
The `list_nft_for_sale` method lists an nft for sale, for this, it takes the id of the NFT contract (`nft_contract_id`), the `token_id` to know which token is listed, the [`approval_id`](5-approval.md), and the price in yoctoNEAR at which we want to sell the NFT.

<Github language="rust" start="33" end="74" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

The function first checks if the user has [enough storage available](#storage-management-model), and makes two calls in parallel to the NFT contract. The first is to check if this marketplace contract is authorized to transfer the NFT. The second is to make sure that the caller (`predecessor`) is actually the owner of the NFT, otherwise, anyone could call this method to create fake listings. This second call is mostly a measure to avoid spam, since anyways, only the owner could approve the marketplace contract to transfer the NFT.

Both calls return their results to the `process_listing` function, which executes the logic to store the sale object on the contract.

#### process_listing

The `process_listing` function will receive if our marketplace is authorized to list the NFT on sale, and if this was requested by the NFTs owner. If both conditions are met, it will proceed to check if the user has enough storage, and store the sale object on the contract.

<Github language="rust" start="264" end="344" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr class="subsection" />

### Sale object {#sale-object}

It's important to understand what information the contract is storing for each sale object. Since the marketplace has many NFTs listed that come from different NFT contracts, simply storing the token ID would not be enough to distinguish between different NFTs. This is why you need to keep track of both the token ID and the contract by which the NFT came from. In addition, for each listing, the contract must keep track of the approval ID it was given to transfer the NFT. Finally, the owner and sale conditions are needed.

<Github language="rust" start="5" end="20" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr className="subsection" />

### Removing sales {#removing-sales}

In order to remove a listing, the owner must call the `remove_sale` function and pass the NFT contract and token ID. Behind the scenes, this calls the `internal_remove_sale` function which you can find in the `internal.rs` file. This will assert one yoctoNEAR for security reasons.

<Github language="rust" start="76" end="87" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr className="subsection" />

### Updating price {#updating-price}

In order to update the list price of a token, the owner must call the `update_price` function and pass in the contract, token ID, and desired price. This will get the sale object, change the sale conditions, and insert it back. For security reasons, this function will assert one yoctoNEAR.

<Github language="rust" start="90" end="118" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

<hr className="subsection" />

### Purchasing NFTs {#purchasing-nfts}

For purchasing NFTs, you must call the `offer` function. It takes an `nft_contract_id` and `token_id` as parameters. You must attach the correct amount of NEAR to the call in order to purchase. Behind the scenes, this will make sure your deposit is greater than the list price and call a private method `process_purchase` which will perform a cross-contract call to the NFT contract to invoke the `nft_transfer_payout` function. This will transfer the NFT using the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) standard that you learned about and it will return the `Payout` object which includes royalties.

The marketplace will then call `resolve_purchase` where it will check for malicious payout objects and then if everything went well, it will pay the correct accounts.

<Github language="rust" start="121" end="151" url="https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale.rs" />

---

## sale_view.rs {#sale_view-rs}

The final file is [`sale_view.rs`](https://github.com/near-examples/nft-tutorial/blob/main/market-contract/src/sale_view.rs) file. This is where some of the enumeration methods are outlined. It allows users to query for important information regarding sales.

---

## Deployment and Initialization

Next, you'll deploy this contract to the network.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  export MARKETPLACE_CONTRACT_ID=<accountId>
  near create-account $MARKETPLACE_CONTRACT_ID --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  export MARKETPLACE_CONTRACT_ID=<accountId>
  near account create-account sponsor-by-faucet-service $MARKETPLACE_CONTRACT_ID autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Using the build script, deploy the contract as you did in the previous tutorials:

```bash
cargo near deploy build-non-reproducible-wasm $MARKETPLACE_CONTRACT_ID with-init-call new json-args '{"owner_id": "'$MARKETPLACE_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

<hr className="subsection" />

### Minting and approving

Let's mint a new NFT token and approve a marketplace contract:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_approve '{"token_id": "token-1", "account_id": "'$MARKETPLACE_CONTRACT_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_approve json-args '{"token_id": "token-1", "account_id": "'$MARKETPLACE_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Listing NFT on sale

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $MARKETPLACE_CONTRACT_ID list_nft_for_sale '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "token-1", "approval_id": 0, "msg": "{\"sale_conditions\": \"1\"}"}' --gas 300000000000000 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $MARKETPLACE_CONTRACT_ID list_nft_for_sale json-args '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "token_id": "token-1", "approval_id": 0, "msg": "{\"sale_conditions\": \"1\"}"}' prepaid-gas '300.0 Tgas' attached-deposit '0 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Total supply {#total-supply}

To query for the total supply of NFTs listed on the marketplace, you can call the `get_supply_sales` function. An example can be seen below.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT_ID get_supply_sales '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $MARKETPLACE_CONTRACT_ID get_supply_sales json-args {} network-config testnet now
  ```
  </TabItem>

</Tabs>

<hr className="subsection" />

### Total supply by owner {#total-supply-by-owner}

To query for the total supply of NFTs listed by a specific owner on the marketplace, you can call the `get_supply_by_owner_id` function. An example can be seen below.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT_ID get_supply_by_owner_id '{"account_id": "'$NFT_CONTRACT_ID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $MARKETPLACE_CONTRACT_ID get_supply_by_owner_id json-args '{"account_id": "'$NFT_CONTRACT_ID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Total supply by contract {#total-supply-by-contract}

To query for the total supply of NFTs that belong to a specific contract, you can call the `get_supply_by_nft_contract_id` function. An example can be seen below.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT_ID get_supply_by_nft_contract_id '{"nft_contract_id": "'$NFT_CONTRACT_ID'"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $MARKETPLACE_CONTRACT_ID get_supply_by_nft_contract_id json-args '{"nft_contract_id": "'$NFT_CONTRACT_ID'"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr className="subsection" />

### Query for listing information {#query-listing-information}

To query for important information for a specific listing, you can call the `get_sale` function. This requires that you pass in the `nft_contract_token`. This is essentially the unique identifier for sales on the market contract as explained earlier. It consists of the NFT contract followed by a `DELIMITER` followed by the token ID. In this contract, the `DELIMITER` is simply a period: `.`.  An example of this query can be seen below.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT_ID get_sale '{"nft_contract_token": "'$NFT_CONTRACT_ID'.token-1"}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $MARKETPLACE_CONTRACT_ID get_sale json-args '{"nft_contract_token": "'$NFT_CONTRACT_ID'.token-1"}' network-config testnet now
  ```
  </TabItem>
</Tabs>

In addition, you can query for paginated information about the listings for a given owner by calling the `get_sales_by_owner_id` function.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT_ID get_sales_by_owner_id '{"account_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 5}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $MARKETPLACE_CONTRACT_ID get_sales_by_owner_id json-args '{"account_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 5}' network-config testnet now
  ```
  </TabItem>
</Tabs>

Finally, you can query for paginated information about the listings that originate from a given NFT contract by calling the `get_sales_by_nft_contract_id` function.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $MARKETPLACE_CONTRACT_ID get_sales_by_nft_contract_id '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 5}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $MARKETPLACE_CONTRACT_ID get_sales_by_nft_contract_id json-args '{"nft_contract_id": "'$NFT_CONTRACT_ID'", "from_index": "0", "limit": 5}' network-config testnet now
  ```
  </TabItem>
</Tabs>

---

## Conclusion

In this tutorial, you learned about the basics of a marketplace contract and how it works. You went through the [lib.rs](#lib-rs) file and learned about the [initialization function](#initialization-function) in addition to the [storage management](#storage-management-model) model.

You went through the [NFTs listing process](#listing-logic). In addition, you went through some important functions needed after you've listed an NFT. This includes [removing sales](#removing-sales), [updating the price](#updating-price), and [purchasing NFTs](#purchasing-nfts).

Finally, you went through the enumeration methods found in the [`sale_view`](#sale_view-rs) file. These allow you to query for important information found on the marketplace contract.

You should now have a solid understanding of NFTs and marketplaces on NEAR. Feel free to branch off and expand on these contracts to create whatever cool applications you'd like. In the [next tutorial](9-series.md), you'll learn how to take the existing NFT contract and optimize it to allow for:
- Lazy Minting
- Creating Collections
- Allowlisting functionalities
- Optimized Storage Models

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/9-series.md 

 ---
id: series
title: Customizing the NFT Contract
sidebar_label: Lazy Minting, Collections, and More!
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll learn how to take the [existing NFT contract](https://github.com/near-examples/nft-tutorial) you've been working with and modify it to meet some of the most common needs in the ecosystem. This includes:
- [Lazy Minting NFTs](#lazy-minting)
- [Creating Collections](#nft-collections-and-series)
- [Restricting Minting Access](#restricted-access)
- [Highly Optimizing Storage](#modifying-view-calls-for-optimizations)
- Hacking Enumeration Methods

---

## Introduction

Now that you have a deeper understanding of basic NFT smart contracts, we can start to get creative and implement more unique features. The basic contract works really well for simple use-cases but as you begin to explore the potential of NFTs, you can use it as a foundation to build upon.

A fun analogy would be that you now have a standard muffin recipe and it's now up to you to decide how to alter it to create your own delicious varieties, may I suggest blueberry perhaps.

Below we've created a few of these new varieties by showing potential solutions to the problems outlined above. As we demonstrate how to customize the basic NFT contract, we hope it activates your ingenuity thus introducing you to what's possible and helping you discover the true potential of NFTs. üí™

<hr class="subsection" />

### NFT Collections and Series

NFT Collections help solve two common problems when dealing with the basic NFT contract:
- Storing repeated data.
- Organizing data and code.

The concept of a collection in the NFT space has a very loose meaning and can be interpreted in many different ways. In our case, we'll define a collection as a set of tokens that share **similar metadata**. For example, you could create a painting and want 100 identical copies to be put for sale. In this case, all one hundred pieces would be part of the same *collection*. Each piece would have the same artist, title, description, media etc.

One of the biggest problems with the basic NFT contract is that you store similar data many times. If you mint NFTs, the contract will store the metadata individually for **every single token ID**. We can fix this by introducing the idea of NFT series, or NFT collection.

A series can be thought of as a bucket of token IDs that *all* share similar information. This information is specified when the series is **created** and can be the metadata, royalties, price etc. Rather than storing this information for **every token ID**, you can simply store it once in the series and then associate token IDs with their respective buckets.

<hr class="subsection" />

### Restricted Access

Currently, the NFT contract allows anyone to mint NFTs. While this works well for some projects, the vast majority of dApps and creators want to restrict who can create NFTs on the contract. This is why you'll introduce an allowlist functionality for both series and for NFTs. You'll have two data structures customizable by the contract owner:
- Approved Minters
- Approved Creators

If you're an approved minter, you can freely mint NFTs for any given series. You cannot, however, create new series.

On the other hand, you can also be an approved creator. This allows you to define new series that NFTs can be minted from. It's important to note that if you're an approved creator, you're not automatically an approved minter as well. Each of these permissions need to be given by the owner of the contract and they can be revoked at any time.

<hr class="subsection" />

### Lazy Minting

Lazy minting allows users to mint *on demand*. Rather than minting all the NFTs and spending $NEAR on storage, you can instead mint the tokens **when they are purchased**. This helps to avoid burning unnecessary Gas and saves on storage for when not all the NFTs are purchased. Let's look at a common scenario to help solidify your understanding:

Benji has created an amazing digital painting of the famous Go Team gif. He wants to sell 1000 copies of it for 1 $NEAR each. Using the traditional approach, he would have to mint each copy individually and pay for the storage himself. He would then need to either find or deploy a marketplace contract and pay for the storage to put 1000 copies up for sale. He would need to burn Gas putting each token ID up for sale 1 by 1.

After that, people would purchase the NFTs, and there would be no guarantee that all or even any would be sold. There's a real possibility that nobody buys a single piece of his artwork, and Benji spent all that time, effort and money on nothing.

Lazy minting would allow the NFTs to be *automatically minted on-demand*. Rather than having to purchase NFTs from a marketplace, Benji could specify a price on the NFT contract and a user could directly call the `nft_mint` function whereby the funds would be distributed to Benji's account directly.

Using this model, NFTs would **only** be minted when they're actually purchased and there wouldn't be any upfront fee that Benji would need to pay in order to mint all 1000 NFTs. In addition, it removes the need to have a separate marketplace contract.

With this example laid out, a high level overview of lazy minting is that it gives the ability for someone to mint "on-demand" - they're lazily minting the NFTs instead of having to mint everything up-front even if they're unsure if there's any demand for the NFTs. With this model, you don't have to waste Gas or storage fees because you're only ever minting when someone actually purchases the artwork.

---

## New Contract File Structure

Let's now take a look at how we've implemented solutions to the issues we've discussed so far.

In your locally cloned example of the [`nft-tutorial`](https://github.com/near-examples/nft-tutorial) check out the `main` branch and be sure to pull the most recent version.

```bash
git checkout main && git pull
```

You'll notice that there's a folder at the root of the project called `nft-series`. This is where the smart contract code lives. If you open the `src` folder, it should look similar to the following:

```
src
‚îú‚îÄ‚îÄ approval.rs
‚îú‚îÄ‚îÄ enumeration.rs
‚îú‚îÄ‚îÄ events.rs
‚îú‚îÄ‚îÄ internal.rs
‚îú‚îÄ‚îÄ lib.rs
‚îú‚îÄ‚îÄ metadata.rs
‚îú‚îÄ‚îÄ nft_core.rs
‚îú‚îÄ‚îÄ owner.rs
‚îú‚îÄ‚îÄ royalty.rs
‚îú‚îÄ‚îÄ series.rs
```

---

## Differences

You'll notice that most of this code is the same, however, there are a few differences between this contract and the basic NFT contract.

### Main Library File

Starting with `lib.rs`, you'll notice that the contract struct has been modified to now store the following information.

```diff
pub owner_id: AccountId,
+ pub approved_minters: LookupSet<AccountId>,
+ pub approved_creators: LookupSet<AccountId>,
pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
pub tokens_by_id: UnorderedMap<TokenId, Token>,
- pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
+ pub series_by_id: UnorderedMap<SeriesId, Series>,
pub metadata: LazyOption<NFTContractMetadata>,
```

As you can see, we've replaced `token_metadata_by_id` with `series_by_id` and added two lookup sets:

- **series_by_id**: Map a series ID (u64) to its Series object.
- **approved_minters**: Keeps track of accounts that can call the `nft_mint` function.
- **approved_creators**: Keeps track of accounts that can create new series.

<hr class="subsection" />

### Series Object {#series-object}
In addition, we're now keeping track of a new object called a `Series`.

```rust
pub struct Series {
    // Metadata including title, num copies etc.. that all tokens will derive from
    metadata: TokenMetadata,
    // Royalty used for all tokens in the collection
    royalty: Option<HashMap<AccountId, u32>>,
    // Set of tokens in the collection
    tokens: UnorderedSet<TokenId>,
    // What is the price of each token in this series? If this is specified, when minting,
    // Users will need to attach enough $NEAR to cover the price.
    price: Option<Balance>,
    // Owner of the collection
    owner_id: AccountId,
}
```

This object stores information that each token will inherit from. This includes:
- The [metadata](2-minting.md#metadata-and-token-info).
- The [royalties](6-royalty.md).
- The price.

:::caution
If a price is specified, there will be no restriction on who can mint tokens in the series. In addition, if the `copies` field is specified in the metadata, **only** that number of NFTs can be minted. If the field is omitted, an unlimited amount of tokens can be minted.
:::

We've also added a field `tokens` which keeps track of all the token IDs that have been minted for this series. This allows us to deal with the potential `copies` cap by checking the length of the set. It also allows us to paginate through all the tokens in the series.

<hr class="subsection" />

### Creating Series

`series.rs` is a new file that replaces the old [minting](2-minting.md) logic. This file has been created to combine both the series creation and minting logic into one.

<Github language="rust" start="10" end="56" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/series.rs" />

The function takes in a series ID in the form of a [u64](https://doc.rust-lang.org/std/primitive.u64.html), the metadata, royalties, and the price for tokens in the series. It will then create the [Series object](#series-object) and insert it into the contract's series_by_id data structure. It's important to note that the caller must be an approved creator and they must attach enough $NEAR to cover storage costs.

<hr class="subsection" />

### Minting NFTs

Next, we'll look at the minting function. If you remember from before, this used to take the following parameters:
- Token ID
- Metadata
- Receiver ID
- Perpetual Royalties

With the new and improved minting function, these parameters have been changed to just two:
- The series ID
- The receiver ID.

The mint function might look complicated at first but let's break it down to understand what's happening. The first thing it does is get the [series object](#series-object) from the specified series ID. From there, it will check that the number of copies won't be exceeded if one is specified in the metadata.

It will then store the token information on the contract as explained in the [minting section](2-minting.md#storage-implications) of the tutorial and map the token ID to the series. Once this is finished, a mint log will be emitted and it will ensure that enough deposit has been attached to the call. This amount differs based on whether or not the series has a price.

#### Required Deposit

As we went over in the [minting section](2-minting.md#storage-implications) of this tutorial, all information stored on the contract costs $NEAR. When minting, there is a required deposit to pay for this storage. For *this contract*, a series price can also be specified by the owner when the series is created. This price will be used for **all** NFTs in the series when they are minted. If the price is specified, the deposit must cover both the storage as well as the price.

If a price **is specified** and the user attaches more deposit than what is necessary, the excess is sent to the **series owner**. There is also *no restriction* on who can mint tokens for series that have a price. The caller does **not** need to be an approved minter.

If **no price** was specified in the series and the user attaches more deposit than what is necessary, the excess is *refunded to them*. In addition, the contract makes sure that the caller is an approved minter in this case.

:::info
Notice how the token ID isn't required? This is because the token ID is automatically generated when minting. The ID stored on the contract is `${series_id}:${token_id}` where the token ID is a nonce that increases each time a new token is minted in a series. This not only reduces the amount of information stored on the contract but it also acts as a way to check the specific edition number.
:::

<Github language="rust" start="60" end="147" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/series.rs" />

<hr class="subsection" />

### View Functions

Now that we've introduced the idea of series, more view functions have also been added.

:::info
Notice how we've also created a new struct `JsonSeries` instead of returning the regular `Series` struct. This is because the `Series` struct contains an `UnorderedSet` which cannot be serialized.

The common practice is to return everything **except** the `UnorderedSet` in a separate struct and then have entirely different methods for accessing the data from the `UnorderedSet` itself.
<!-- TODO: add a learn more here call to action -->
:::

<Github language="rust" start="6" end="17" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

The view functions are listed below.
- **[get_series_total_supply](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L92)**: Get the total number of series currently on the contract.
  - Arguments: None.

<Github language="rust" start="92" end="96" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

- **[get_series](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L97)**: Paginate through all the series in the contract and return a vector of `JsonSeries` objects.
  - Arguments: `from_index: String | null`, `limit: number | null`.

<Github language="rust" start="97" end="113" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

- **[get_series_details](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L115)**: Get the `JsonSeries` details for a specific series.
  - Arguments: `id: number`.

<Github language="rust" start="115" end="131" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

- **[nft_supply_for_series](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L133)**: View the total number of NFTs minted for a specific series.
  - Arguments: `id: number`.

<Github language="rust" start="133" end="144" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

- **[nft_tokens_for_series](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L146)**: Paginate through all NFTs for a specific series and return a vector of `JsonToken` objects.
  - Arguments: `id: number`, `from_index: String | null`, `limit: number | null`.

<Github language="rust" start="146" end="183" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs" />

:::info
Notice how with every pagination function, we've also included a getter to view the total supply. This is so that you can use the `from_index` and `limit` parameters of the pagination functions in conjunction with the total supply so you know where to end your pagination.
:::

<hr class="subsection" />

### Modifying View Calls for Optimizations

Storing information on-chain can be very expensive. As you level up in your smart contract development skills, one area to look into is reducing the amount of information stored. View calls are a perfect example of this optimization.

For example, if you wanted to relay the edition number for a given NFT in its title, you don't necessarily need to store this on-chain for every token. Instead, you could modify the view functions to manually append this information to the title before returning it.

To do this, here's a way of modifying the `nft_token` function as it's central to all enumeration methods.

<Github language="rust" start="156" end="192" url="https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/nft_core.rs" />

For example if a token had a title `"My Amazing Go Team Gif"` and the NFT was edition 42, the new title returned would be `"My Amazing Go Team Gif - 42"`. If the NFT didn't have a title in the metadata, the series and edition number would be returned in the form of `Series {} : Edition {}`.

While this is a small optimization, this idea is extremely powerful as you can potentially save on a ton of storage. As an example: most of the time NFTs don't utilize the following fields in their metadata.
- `issued_at`
- `expires_at`
- `starts_at`
- `updated_at`

As an optimization, you could change the token metadata that's **stored** on the contract to not include these fields but then when returning the information in `nft_token`, you could simply add them in as `null` values.

<hr class="subsection" />

### Owner File

The last file we'll look at is the owner file found at `owner.rs`. This file simply contains all the functions for getting and setting approved creators and approved minters which can only be called by the contract owner.

:::info
There are some other smaller changes made to the contract that you can check out if you'd like. The most notable are:
- The `Token` and `JsonToken` objects have been [changed](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/metadata.rs#L40) to reflect the new series IDs.
- All references to `token_metadata_by_id` have been [changed](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/enumeration.rs#L23) to `tokens_by_id`
- Royalty functions [now](https://github.com/near-examples/nft-tutorial/blob/main/nft-series/src/royalty.rs#L43) calculate the payout objects by using the series' royalties rather than the token's royalties.
:::

---

## Building the Contract

Now that you hopefully have a good understanding of the contract, let's get started building it. Run the following build command to compile the contract to wasm.

```bash
cargo near build
```

---

## Deployment and Initialization

Next, you'll deploy this contract to the network.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  export NFT_CONTRACT_ID=<accountId>
  near create-account $NFT_CONTRACT_ID --useFaucet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  export NFT_CONTRACT_ID=<accountId>
  near account create-account sponsor-by-faucet-service $NFT_CONTRACT_ID autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
</Tabs>

Check if this worked correctly by echoing the environment variable.
```bash
echo $NFT_CONTRACT_ID
```
This should return your `<accountId>`. The next step is to initialize the contract with some default metadata.

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID with-init-call new_default_meta json-args '{"owner_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' network-config testnet sign-with-keychain send
```

If you now query for the metadata of the contract, it should return our default metadata.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $NFT_CONTRACT_ID nft_metadata '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID nft_metadata json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

---

## Creating The Series

The next step is to create two different series. One will have a price for lazy minting and the other will simply be a basic series with no price. The first step is to create an owner [sub-account](/tools/near-cli#create) that you can use to create both series

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  export SERIES_OWNER=owner.$NFT_CONTRACT_ID

  near create-account $SERIES_OWNER --use-account $NFT_CONTRACT_ID --initial-balance 3 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  export SERIES_OWNER=owner.$NFT_CONTRACT_ID

  near account create-account fund-myself $SERIES_OWNER '3 NEAR' autogenerate-new-keypair save-to-keychain sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

### Basic Series

You'll now need to create the simple series with no price and no royalties. If you try to run the following command before adding the owner account as an approved creator, the contract should throw an error.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID create_series '{"id": 1, "metadata": {"title": "SERIES!", "description": "testing out the new series contract", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}}' --gas 100000000000000 --deposit 1 --accountId $SERIES_OWNER --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID create_series json-args '{"id": 1, "metadata": {"title": "SERIES!", "description": "testing out the new series contract", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}}' prepaid-gas '100.0 Tgas' attached-deposit '1 NEAR' sign-as $SERIES_OWNER network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

The expected output is an error thrown: `ExecutionError: 'Smart contract panicked: only approved creators can add a type`. If you now add the series owner as a creator, it should work.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID add_approved_creator '{"account_id": "'$SERIES_OWNER'"}' --gas 100000000000000 --accountId $SERIES_OWNER --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID add_approved_creator json-args '{"account_id": "'$SERIES_OWNER'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID create_series '{"id": 1, "metadata": {"title": "SERIES!", "description": "testing out the new series contract", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}}' --gas 100000000000000 --deposit 1 --accountId $SERIES_OWNER --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID create_series json-args '{"id": 1, "metadata": {"title": "SERIES!", "description": "testing out the new series contract", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}}' prepaid-gas '100.0 Tgas' attached-deposit '1 NEAR' sign-as $SERIES_OWNER network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you now query for the series information, it should work!

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $NFT_CONTRACT_ID get_series '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID get_series json-args {} network-config testnet now
  ```
  </TabItem>
</Tabs>

Which should return something similar to:

```js
[
  {
    series_id: 1,
    metadata: {
      title: 'SERIES!',
      description: 'testing out the new series contract',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    royalty: null,
    owner_id: 'owner.nft_contract.testnet'
  }
]
```

<hr class="subsection" />

### Series With a Price

Now that you've created the first, simple series, let's create the second one that has a price of 1 $NEAR associated with it.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID create_series '{"id": 2, "metadata": {"title": "COMPLEX SERIES!", "description": "testing out the new contract with a complex series", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "price": "500000000000000000000000"}' --gas 100000000000000 --deposit 1 --accountId $SERIES_OWNER --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID create_series json-args '{"id": 2, "metadata": {"title": "COMPLEX SERIES!", "description": "testing out the new contract with a complex series", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "price": "500000000000000000000000"}' prepaid-gas '100.0 Tgas' attached-deposit '1 NEAR' sign-as $SERIES_OWNER network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you now paginate through the series again, you should see both appear.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $NFT_CONTRACT_ID get_series '{}' --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only $NFT_CONTRACT_ID get_series json-args {} network-config testnet now
  ```
  </TabItem>

</Tabs>

Which has

```js
[
  {
    series_id: 1,
    metadata: {
      title: 'SERIES!',
      description: 'testing out the new series contract',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    royalty: null,
    owner_id: 'owner.nft_contract.testnet'
  },
  {
    series_id: 2,
    metadata: {
      title: 'COMPLEX SERIES!',
      description: 'testing out the new contract with a complex series',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif',
      media_hash: null,
      copies: null,
      issued_at: null,
      expires_at: null,
      starts_at: null,
      updated_at: null,
      extra: null,
      reference: null,
      reference_hash: null
    },
    royalty: null,
    owner_id: 'owner.nft_contract.testnet'
  }
]
```

---

## Minting NFTs

Now that you have both series created, it's time to now mint some NFTs. You can either login with an existing NEAR wallet using [`near login`](/tools/near-cli#import) or you can create a sub-account of the NFT contract. In our case, we'll use a sub-account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  export BUYER_ID=buyer.$NFT_CONTRACT_ID

  near create-account $BUYER_ID --use-account $NFT_CONTRACT_ID --initial-balance 1 --network-id testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  export BUYER_ID=buyer.$NFT_CONTRACT_ID

  near account create-account fund-myself $BUYER_ID '1 NEAR' autogenerate-new-keypair save-to-keychain sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

### Lazy Minting

The first workflow you'll test out is [lazy minting](#lazy-minting) NFTs. If you remember, the second series has a price associated with it of 1 $NEAR. This means that there are no minting restrictions and anyone can try and purchase the NFT. Let's try it out.

In order to view the NFT in the NEAR wallet, you'll want the `receiver_id` to be an account you have currently available in the wallet site. Let's export it to an environment variable. Run the following command but replace `YOUR_ACCOUNT_ID_HERE` with your actual NEAR account ID.

```bash
export NFT_RECEIVER_ID=YOUR_ACCOUNT_ID_HERE
```
Now if you try and run the mint command but don't attach enough $NEAR, it should throw an error.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"id": "2", "receiver_id": "'$NFT_RECEIVER_ID'"}' --gas 100000000000000 --accountId $BUYER_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"id": "2", "receiver_id": "'$NFT_RECEIVER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Run the command again but this time, attach 1.5 $NEAR.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"id": "2", "receiver_id": "'$NFT_RECEIVER_ID'"}' --gas 100000000000000 --deposit 1.5 --accountId $BUYER_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"id": "2", "receiver_id": "'$NFT_RECEIVER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '1.5 NEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

This should output the following logs.

```bash
Receipts: BrJLxCVmxLk3yNFVnwzpjZPDRhiCinNinLQwj9A7184P, 3UwUgdq7i1VpKyw3L5bmJvbUiqvFRvpi2w7TfqmnPGH6
	Log [nft_contract.testnet]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_mint","data":[{"owner_id":"benjiman.testnet","token_ids":["2:1"]}]}
Transaction Id FxWLFGuap7SFrUPLskVr7Uxxq8hpDtAG76AvshWppBVC
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/FxWLFGuap7SFrUPLskVr7Uxxq8hpDtAG76AvshWppBVC
''
```

If you check the explorer link, it should show that the owner received on the order of `0.59305 $NEAR`.

<img width="80%" src="/docs/assets/nfts/explorer-payout-series-owner.png" />

<hr class="subsection" />

### Becoming an Approved Minter

If you try to mint the NFT for the simple series with no price, it should throw an error saying you're not an approved minter.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"id": "1", "receiver_id": "'$NFT_RECEIVER_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $BUYER_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"id": "1", "receiver_id": "'$NFT_RECEIVER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

Go ahead and run the following command to add the buyer account as an approved minter.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID add_approved_minter '{"account_id": "'$BUYER_ID'"}' --gas 100000000000000 --accountId $NFT_CONTRACT_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID add_approved_minter json-args '{"account_id": "'$BUYER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

If you now run the mint command again, it should work.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"id": "1", "receiver_id": "'$NFT_RECEIVER_ID'"}' --gas 100000000000000 --deposit 0.1 --accountId $BUYER_ID --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"id": "1", "receiver_id": "'$NFT_RECEIVER_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $BUYER_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Viewing the NFTs in the Wallet

Now that you've received both NFTs, they should show up in the NEAR wallet. Open the collectibles tab and search for the contract with the title `NFT Series Contract` and you should own two NFTs. One should be the complex series and the other should just be the simple version. Both should have ` - 1` appended to the end of the title because the NFTs are the first editions for each series.

<img width="80%" src="/docs/assets/nfts/series-wallet-collectibles.png" />

Hurray! You've successfully deployed and tested the series contract! **GO TEAM!**.

---

## Conclusion

In this tutorial, you learned how to take the basic NFT contract and iterate on it to create a complex and custom version to meet the needs of the community. You optimized the storage, introduced the idea of collections, created a lazy minting functionality, hacked the enumeration functions to save on storage, and created an allowlist functionality.

You then built the contract and deployed it on chain. Once it was on-chain, you initialized it and created two sets of series. One was complex with a price and the other was a regular series. You lazy minted an NFT and purchased it for `1.5 $NEAR` and then added yourself as an approved minter. You then minted an NFT from the regular series and viewed them both in the NEAR wallet.

Thank you so much for going through this journey with us! I wish you all the best and am eager to see what sorts of neat and unique use-cases you can come up with. If you have any questions, feel free to ask on our [Discord](https://near.chat) or any other social media channels we have. If you run into any issues or have feedback, feel free to use the `Feedback` button on the right.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- rustc: `1.77.1`
- near-cli-rs: `0.17.0`
- cargo-near `0.6.1`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/0-intro.md 

 ---
id: introduction
title: NFT Zero to Hero JavaScript Edition
sidebar_label: Introduction
---

> In this _Zero to Hero_ series, you'll find a set of tutorials that will cover every aspect of a non-fungible token (NFT) smart contract.
> You'll start by minting an NFT using a pre-deployed contract and by the end you'll end up building a fully-fledged NFT smart contract that supports every extension.



## Prerequisites

To complete these tutorials successfully, you'll need:

- [Node.js](/build/smart-contracts/quickstart?code-tabs=js)
- [A NEAR Wallet](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli#installation)

---

## Overview

These are the steps that will bring you from **_Zero_** to **_Hero_** in no time! üí™

| Step | Name                                                             | Description                                                                                                            |
|------|------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------|
| 1    | [Pre-deployed contract](/tutorials/nfts/js/predeployed-contract) | Mint an NFT without the need to code, create, or deploy a smart contract.                                              |
| 2    | [Contract architecture](/tutorials/nfts/js/skeleton)             | Learn the basic architecture of the NFT smart contract and compile code.                                               |
| 3    | [Minting](/tutorials/nfts/js/minting)                            | Flesh out the skeleton so the smart contract can mint a non-fungible token.                                            |
| 4    | [Upgrade a contract](/tutorials/nfts/js/upgrade-contract)        | Discover the process to upgrade an existing smart contract.                                                            |
| 5    | [Enumeration](/tutorials/nfts/js/enumeration)                    | Explore enumeration methods that can be used to return the smart contract's states.                                    |
| 6    | [Core](/tutorials/nfts/js/core)                                  | Extend the NFT contract using the core standard which allows token transfer                                            |
| 7    | [Approvals](/tutorials/nfts/js/approvals)                        | Expand the contract allowing other accounts to transfer NFTs on your behalf.                                           |
| 8    | [Royalty](/tutorials/nfts/js/royalty)                            | Add NFT royalties allowing for a set percentage to be paid out to the token creator.                                   |
| 9    | [Events](/tutorials/nfts/js/events)                              | in this tutorial you'll explore the events extension, allowing the contract to react on certain events.                |
| 10   | [Marketplace](/tutorials/nfts/js/marketplace)                    | Learn about how common marketplaces operate on NEAR and dive into some of the code that allows buying and selling NFTs |

---

## Next steps

Ready to start? Jump to the [Pre-deployed Contract](/tutorials/nfts/js/predeployed-contract) tutorial and begin your learning journey!

If you already know about non-fungible tokens and smart contracts, feel free to skip and jump directly to the tutorial of your interest. The tutorials have been designed so you can start at any given point!

:::info Questions?
üëâ Join us on [Discord](https://near.chat/) and let us know in the `#development` channels. üëà

We also host daily [Office Hours](https://pages.near.org/developers/get-help/office-hours/) live where the DevRel team will answer any questions you may have. ü§î

Monday ‚Äì Friday 11AM ‚Äì 12PM Pacific (6PM ‚Äì 7PM UTC)
:::


 This is the content for the doc docs/3.tutorials/nfts/js/0-predeployed.md 

 ---
id: predeployed-contract
title: Pre-deployed Contract
sidebar_label: Pre-deployed Contract
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

> Learn how to easily create your own non-fungible tokens without doing any software development by using a readily-available NFT smart contract.


## Prerequisites

To complete this tutorial successfully, you'll need:

- [A NEAR Wallet](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli#installation)

## Using the NFT contract

### Setup

- Log in to your newly created account with `near-cli` by running the following command in your terminal:

<Tabs groupId="cli-tabs">

  <TabItem value="short" label="Short">

  ```bash
  near login --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near account import-account using-web-wallet network-config testnet
  ```
  </TabItem>
</Tabs>

 - Set an environment variable for your account ID to make it easy to copy and paste commands from this tutorial:

```bash
export NEARID=YOUR_ACCOUNT_NAME
```
:::note

Be sure to replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` (or `.near` for `mainnet`).

:::

- Test that the environment variable is set correctly by running:

```bash
echo $NEARID
```

### Minting your NFTs

NEAR has deployed an NFT contract to the account `nft.examples.testnet` which allows users to freely mint tokens. Using this pre-deployed contract, let's mint our first token! 


- Run this command in your terminal, however you **must replace the `token_id` value with an UNIQUE string**.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call nft.examples.testnet nft_mint '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "'$NEARID'", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' --accountId $NEARID --deposit 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction nft.examples.testnet nft_mint json-args '{"token_id": "TYPE_A_UNIQUE_VALUE_HERE", "receiver_id": "'$NEARID'", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NEARID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

:::tip
You can also replace the `media` URL with a link to any image file hosted on your web server.
:::

<details>
<summary>Example response: </summary>
<p>

```json
Log [nft.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"nft-1.0.0","event":"nft_mint","data":[{"owner_id":"benjiman.testnet","token_ids":["TYPE_A_UNIQUE_VALUE_HERE"]}]}
Transaction Id 8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/8RFWrQvAsm2grEsd1UTASKpfvHKrjtBdEyXu7WqGBPUr
''
```

</p>
</details>

- To view tokens owned by an account you can call the NFT contract with the following `near-cli` command:

```bash
near view nft.examples.testnet nft_tokens_for_owner '{"account_id": "'$NEARID'"}'
```

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "0",
    "owner_id": "dev-xxxxxx-xxxxxxx",
    "metadata": {
      "title": "Some Art",
      "description": "My NFT media",
      "media": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/00/Olympus_Mons_alt.jpg/1024px-Olympus_Mons_alt.jpg",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

***Congratulations! You just minted your first NFT token on the NEAR blockchain!*** üéâ

üëâ Now try going to your [NEAR Wallet](https://testnet.mynearwallet.com) and view your NFT in the "Collectibles" tab. üëà 

---

## Final remarks

This basic example illustrates all the required steps to call an NFT smart contract on NEAR and start minting your own non-fungible tokens.

Now that you're familiar with the process, you can jump to [Contract Architecture](/tutorials/nfts/js/skeleton) and learn more about the smart contract structure and how you can build your own NFT contract from the ground up.

***Happy minting!*** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/1-skeleton.md 

 ---
id: skeleton
title: Skeleton and JavaScript Architecture
sidebar_label: Contract Architecture
---
import {Github} from "@site/src/components/codetabs"

> In this article, you'll learn about the basic architecture behind the NFT contract that you'll develop while following this _"Zero to Hero"_ series.
> You'll discover the contract's layout and you'll see how the JavaScript files are structured in order to build a feature-complete smart contract.




## Introduction

This tutorial presents the code skeleton for the NFT smart contract and its file structure.
You'll find how all the functions are laid out as well as the missing JS code that needs to be filled in.
Once every file and function has been covered, you'll go through the process of building the mock-up contract to confirm that everything is working correctly.

## File structure

Following a regular [JavaScript](https://www.javascript.com/) project, the file structure for this smart contract has:

- `package.json` file to define the packages and scripts used in the project.
- `src` folder where all the JavaScript source files are stored
- `build` folder where the compiled `wasm` will output to.

### Source files

| File                             | Description                                                                      |
| -------------------------------- | -------------------------------------------------------------------------------- |
| [approval.ts](#approvalts)       | Has the internal functions that controls the access and transfers of non-fungible tokens. |
| [enumeration.ts](#enumerationts) | Contains the internal methods to query for NFT tokens and their owners.                        |
| [index.ts](#indexts)                 | Holds the exposed smart contract functions.                               |
| [metadata.ts](#metadatats)       | Defines the token and metadata structures.                                        |
| [mint.ts](#mintts)               | Contains the internal token minting logic.                                                    |
| [nft_core.ts](#nft_corets)       | Has the internal core logic that allows you to transfer NFTs between users.                       |
| [royalty.ts](#royaltyts)         | Contains the internal payout-related functions.                                               |

```
nft-tutorial-js
‚îî‚îÄ‚îÄ src
    market-contract
    nft-contract
    ‚îú‚îÄ‚îÄ approval.ts
    ‚îú‚îÄ‚îÄ enumeration.ts
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ metadata.ts
    ‚îú‚îÄ‚îÄ mint.ts
    ‚îú‚îÄ‚îÄ nft_core.ts
    ‚îî‚îÄ‚îÄ royalty.ts
```

:::tip
Explore the code in our [GitHub repository](https://github.com/near-examples/nft-tutorial-js/tree/1.skeleton).
:::

---

## `approval.ts`

> This allows people to approve other accounts to transfer NFTs on their behalf.

This file contains the internal logic that complies with the standard's [approvals management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension. Here is a breakdown of the methods and their functions:

| Method              | Description                                                                                               |
| ------------------- | --------------------------------------------------------------------------------------------------------- |
| **internalNftApprove**     | Approves an account ID to transfer a token on your behalf. Called during **nft_approve**.                                                |
| **internalNftIsApproved** | Checks if the input account has access to approve the token ID. Called during **nft_is_approved**.                                            |
| **internalNftRevoke**      | Revokes a specific account from transferring the token on your behalf. Called during **nft_revoke**.                                     |
| **internalNftRevokeAll**  | Revokes all accounts from transferring the token on your behalf. Called during **nft_revoke_all**.                                         |

<Github language="js" start="9" end="69" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/approval.ts" />

You'll learn more about these functions in the [approvals section](/tutorials/nfts/js/approvals) of the Zero to Hero series.

---

## `enumeration.ts`

> This file provides the internal functions needed to view information about NFTs, and follows the standard's [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) extension.

| Method                   | Description                                                                        |
| ------------------------ | ---------------------------------------------------------------------------------- |
| **internalNftTotalSupply**           | Returns the total amount of NFTs stored on the contract. Called during **nft_total_supply**.    |
| **internalNftTokens**           | Returns a paginated list of NFTs stored on the contract regardless of their owner. Called during **nft_tokens**.    |
| **internalNftSupplyForOwner** | Allows you view the total number of NFTs owned by any given user. Called during **nft_supply_for_owner**.                     |
| **internalNftTokensForOwner** | Returns a paginated list of NFTs owned by any given user. Called during **nft_tokens_for_owner**.                             |

<Github language="js" start="8" end="62" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/enumeration.ts" />

You'll learn more about these functions in the [enumeration section](/tutorials/nfts/js/enumeration) of the tutorial series.

---

## `metadata.ts`

> This file is used to keep track of the information to be stored for tokens, and metadata.
> In addition, you can define a function to view the contract's metadata which is part of the standard's [metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata) extension.

| Name              | Description                                                                                                   |
| ----------------- | ------------------------------------------------------------------------------------------------------------- |
| **TokenMetadata** | This structure defines the metadata that can be stored for each token. (title, description, media, etc.       |
| **Token**         | This structure outlines what information will be stored on the contract for each token.                       |
| **JsonToken**     | When querying information about NFTs through view calls, the return information is stored in this JSON token. |
| **internalNftMetadata**  | This function allows users to query for the contact's internal metadata. Called during **nft_metadata**.                                           |

<Github language="js" start="12" end="46" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/metadata.ts" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/js/minting) of the tutorial series.

---

## `mint.ts`

> Contains the internal token minting logic.

| Method       | Description                               |
| ------------ | ----------------------------------------- |
| **internalNftMint** | This function mints a non-fungible token. Called during **nft_mint**. |

<Github language="js" start="7" end="23" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/mint.ts" />

---

## `nft_core.ts`

> Core logic that allows you to transfer NFTs between users.

| Method                   | Description                                                                                                                                                                                                                                                                                   |
| ------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **internalNftTransfer**         | Transfers an NFT to a receiver ID. Called during **nft_transfer**.                                                                                                                                                                                                                                                            |
| **internalNftTransferCall**    | Transfers an NFT to a receiver and calls a function on the receiver ID's contract. The function returns `true` if the token was transferred from the sender's account. Called during **nft_transfer_call**.                                                                                                                        |
| **internalNftToken**            | Allows users to query for the information about a specific NFT. Called during **nft_token**.                                                                                                                                                                                                                               |                                                                                                       |
| **internalNftResolveTransfer** | When you start the `nft_transfer_call` and transfer an NFT, the standard dictates that you should also call a method on the receiver's contract. If the receiver needs you to return the NFT to the sender (as per the return value of the `nft_on_transfer` method), this function allows you to execute that logic. Called during **nft_resolve_transfer**. |

<Github language="js" start="10" end="85" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/nft_core.ts" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/js/minting) of the tutorial series.

---

## `royalty.ts`

> Contains the internal payout-related functions.

| Method                  | Description                                                                                                   |
| ----------------------- | ------------------------------------------------------------------------------------------------------------- |
| **internalNftPayout**          | This internal method calculates the payout for a given token. Called during **nft_payout**.                                                     |
| **internalNftTransferPayout** | Internal method to transfer the token to the receiver ID and return the payout object that should be paid for a given balance. Called during **nft_transfer_payout**. |

<Github language="js" start="7" end="45" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/royalty.ts" />

You'll learn more about these functions in the [royalty section](/tutorials/nfts/js/royalty) of the tutorial series.

---

## `index.ts`

> This file outlines the smart contract class and what information it stores and keeps track of. In addition, it exposes all public facing methods that are callable by the user.

| Method               | Description                                                                                     |
| -------------------- | ----------------------------------------------------------------------------------------------- |
| **init** | Constructor function used to initialize the contract with some metadata and default state. |
| **nft_mint** | Calls the internal mint function to mint an NFT. |
| **nft_token** | Calls the internal function to query for info on a specific NFT |
| **nft_transfer** | Calls the internal function to transfer an NFT  |
| **nft_transfer_call** | Calls the internal function to transfer an NFT and call `nft_on_transfer` on the receiver's contract |
| **nft_resolve_transfer** | Calls the internal function to resolve the transfer call promise.|
| **nft_is_approved** | Calls the internal function to check whether someone is approved for an NFT|
| **nft_approve** | Calls the internal function to approve someone to transfer your NFT|
| **nft_payout** | Calls the internal function to query for the payout object for an NFT|
| **nft_transfer_payout** | Calls the internal function to transfer an NFT and return the payout object. |
| **nft_revoke** | Calls the internal function to revoke someone access to transfer your NFT|
| **nft_revoke_all** | Calls the internal function to revoke everyone's access to transfer your NFT|
| **nft_total_supply** | Calls the internal function to query the total supply of NFTs on the contract.|
| **nft_tokens** | Calls the internal function to paginate through NFTs on the contract|
| **nft_tokens_for_owner** | Calls the internal function to paginate through NFTs for a given owner|
| **nft_supply_for_owner** | Calls the internal function to query for the total number of NFTs owned by someone.|
| **nft_metadata** | Calls the internal function to query for the contract's metadata|



<Github language="js" start="16" end="157" url="https://github.com/near-examples/nft-tutorial-js/blob/1.skeleton/src/nft-contract/index.ts" />

You'll learn more about these functions in the [minting section](/tutorials/nfts/js/minting) of the tutorial series.

---

## Building the skeleton

- If you haven't cloned the main repository yet, open a terminal and run:

```sh
git clone https://github.com/near-examples/nft-tutorial-js/
```

- Next, switch to the `1.skeleton` branch. 
- Install the dependencies (including the JS SDK): `yarn`
- Build the contract with `yarn build`:

```sh
git clone https://github.com/near-examples/nft-tutorial-js/
cd nft-tutorial-js
git checkout 1.skeleton
yarn && yarn build
```

Once this finishes, the `nft-tutorial-js/build` directory should contain the `nft.wasm` smart contract!

Building the skeleton is useful to validate that everything works properly and that you'll be able to compile improved versions of this NFT contract in the upcoming tutorials.

---

## Conclusion

You've seen the layout of this NFT smart contract, and how all the functions are laid out across the different source files.
Using `yarn`, you've been able to compile the contract, and you'll start fleshing out this skeleton in the next [Minting tutorial](/tutorials/nfts/js/minting).

:::note Versioning for this article
At the time of this writing, this example works with the following versions:

- near-sdk-js: `0.4.0-5`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/2-minting.md 

 ---
id: minting
title: Minting
sidebar_label: Minting
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

This is the first of many tutorials in a series where you'll be creating a complete NFT smart contract from scratch that conforms with all the NEAR [NFT standards](https://nomicon.io/Standards/NonFungibleToken/). Today you'll learn how to create the logic needed to mint NFTs and have them show up in your NEAR wallet. You will be modifying a bare-bones [skeleton smart contract](/tutorials/nfts/js/skeleton) by filling in the necessary code snippets needed to add minting functionalities.




## Introduction

To get started, switch to the `1.skeleton` branch in our repo. If you haven't cloned the repository, refer to the [Contract Architecture](/tutorials/nfts/js/skeleton) to get started.

```
git checkout 1.skeleton
```

If you wish to see the finished code for the minting portion of the tutorial, that can be found on the `2.minting` branch.

## Modifications to the skeleton contract {#what-does-minting-mean}

In order to implement the logic needed for minting, we should break it up into smaller tasks and handle those one-by-one. Let's step back and think about the best way to do this by asking ourselves a simple question: what does it mean to mint an NFT?

To mint a non-fungible token, in the most simple way possible, a contract needs to be able to associate a token with an owner on the blockchain. This means you'll need:

- A way to keep track of tokens and other information on the contract.
- A way to store information for each token such as `metadata` (more on that later).
- A way to link a token with an owner.

That's it! We've now broken down the larger problem into some smaller, less daunting, subtasks. Let's start by tackling the first and work our way through the rest.

### Storing information on the contract {#storing-information}

Start by navigating to `nft-contract/src/index.ts` and filling in some of the code blocks.
You need to be able to store important information on the contract such as the list of tokens that an account has.


The first thing to do is add the information to the contract class.

<Github language="js" start="16" end="22" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/index.ts" />

This allows you to get the information stored in these data structures from anywhere in the contract. The code above has created 3 token specific storages:

- **tokensPerOwner**: allows you to keep track of the tokens owned by any account. It will map the account address to a set of token ID strings owned by that account.
- **tokensById**: returns all the information about a specific token. It will map a token ID string to a `Token` object. 
- **tokenMetadataById**: returns just the metadata for a specific token. It wil map a token ID string to a `TokenMetadata` object.

In addition, you'll keep track of the owner of the contract as well as the metadata for the contract.

#### Constructor Function

Next, you'll add the logic to the constructor function. This function needs to be invoked when you first deploy the contract. It will initialize all the contract's fields that you've defined above with default values.
We've added the `ownerId` and `metadata` fields as parameters to the function because those are the only ones that can be customized.

This function will default all the collections to be empty and set the `owner` and `metadata` equal to what you pass in.

<Github language="js" start="24" end="43" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/index.ts" />

More often than not when doing development, you'll need to deploy contracts several times. You can imagine that it might get tedious to have to pass in metadata every single time you want to initialize the contract. For this reason, the metadata has been defaulted with some initial data if it wasn't passed in by the user.

### Metadata and token information {#metadata-and-token-info}

Now that you've defined what information to store on the contract itself and you've defined some ways to initialize the contract, you need to define what information should go in the `Token`, `TokenMetadata`, and `NFTContractMetadata` data types.

Let's switch over to the `nft-contract/src/metadata.ts` file as this is where that information will go. If you look at the [standards for metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), you'll find all the necessary information that you need to store for both `TokenMetadata` and `NFTContractMetadata`. Simply fill in the following code.

<Github language="js" start="12" end="104" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

This now leaves you with the `Token` struct and something called a `JsonToken`. The `Token` struct will hold all the information directly related to the token excluding the metadata. The metadata, if you remember, is stored in a map on the contract in a data structured called `tokenMetadataById`. This allows you to quickly get the metadata for any token by simply passing in the token's ID.

For the `Token` struct, you'll just keep track of the owner for now.

<Github language="js" start="106" end="117" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

The purpose of the `JsonToken` is to hold all the information for an NFT that you want to send back as JSON whenever someone does a view call. This means you'll want to store the owner, token ID, and metadata.

<Github language="js" start="119" end="141" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

:::tip
Some of you might be thinking _"how come we don't just store all the information in the `Token` struct?"_.
The reason behind this is that it's actually more efficient to construct the JSON token on the fly only when you need it rather than storing all the information in the token struct.
In addition, some operations might only need the metadata for a token and so having the metadata in a separate data structure is more optimal.
:::

#### Function for querying contract metadata

Now that you've defined some of the types that were used in the previous section, let's move on and create the first view function `internalNftMetadata`. This will allow users to query for the contract's metadata as per the [metadata standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata).

<Github language="js" start="143" end="150" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

This function will get the `metadata` object from the contract which is of type `NFTContractMetadata` and will return it.

Just like that, you've completed the first two tasks and are ready to move onto last part of the tutorial.

### Minting Logic {#minting-logic}

Now that all the information and types are defined, let's start brainstorming how the minting logic will play out. In the end, you need to link a `Token` and `TokenId` to a specific owner. Let's look back at a couple data structures that might be useful:

```ts
//keeps track of all the token IDs for a given account
tokensPerOwner: LookupMap<AccountId, UnorderedSet<TokenId>>;

//keeps track of the token struct for a given token ID
tokensById: LookupMap<TokenId, Token>;

//keeps track of the token metadata for a given token ID
tokenMetadataById: UnorderedMap<TokenId, TokenMetadata>;
```

Looking at these data structures, you could do the following:

- Add the token ID into the set of tokens that the receiver owns. This will be done on the `tokensPerOwner` field.
- Create a token object and map the token ID to that token object in the `tokensById` field.
- Map the token ID to it's metadata using the `tokenMetadataById`.

With those steps outlined, it's important to take into consideration the storage costs of minting NFTs. Since you're adding bytes to the contract by creating entries in the data structures, the contract needs to cover the storage costs. If you just made it so any user could go and mint an NFT for free, that system could easily be abused and users could essentially "drain" the contract of all it's funds by minting thousands of NFTs. For this reason, you'll make it so that users need to attach a deposit to the call to cover the cost of storage. You'll measure the initial storage usage before anything was added and you'll measure the final storage usage after all the logic is finished. Then you'll make sure that the user has attached enough $NEAR to cover that cost and refund them if they've attached too much.

Now that you've got a good understanding of how everything should play out, let's fill in the necessary code.

<Github language="js" start="7" end="44" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/mint.ts" />

You'll notice that we're using some internal methods such as `refundDeposit` and `internalAddTokenToOwner`. We've described the function of `refundDeposit` and as for `internalAddTokenToOwner`, this will add a token to the set of tokens an account owns for the contract's `tokensPerOwner` data structure. You can create these functions in a file called `internal.ts`. Go ahead and create the file. Your new contract architecture should look as follows:

```
nft-contract
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ approval.ts
    ‚îú‚îÄ‚îÄ enumeration.ts
    ‚îú‚îÄ‚îÄ internal.ts
    ‚îú‚îÄ‚îÄ lib.ts
    ‚îú‚îÄ‚îÄ metadata.ts
    ‚îú‚îÄ‚îÄ mint.ts
    ‚îú‚îÄ‚îÄ nft_core.ts
    ‚îî‚îÄ‚îÄ royalty.ts
```

Add the following to your newly created `internal.ts` file.

<Github language="js" start="1" end="54" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/internal.ts" />

At this point, the core logic is all in place so that you can mint NFTs. You can use the function `nft_mint` which takes the following parameters:

- **token_id**: the ID of the token you're minting (as a string).
- **metadata**: the metadata for the token that you're minting (of type `TokenMetadata` which is found in the `metadata.ts` file).
- **receiver_id**: specifies who the owner of the token will be.

Behind the scenes, the function will:

1. Call the internal mint function.
2. Calculate the initial storage before adding anything to the contract
3. Create a `Token` object with the owner ID
4. Link the token ID to the newly created token object by inserting them into the `tokensById` field.
5. Link the token ID to the passed in metadata by inserting them into the `tokenMetadataById` field.
6. Add the token ID to the list of tokens that the owner owns by calling the `internalAddTokenToOwner` function.
7. Calculate the final and net storage to make sure that the user has attached enough NEAR to the call in order to cover those costs.

### Querying for token information

If you were to go ahead and deploy this contract, initialize it, and mint an NFT, you would have no way of knowing or querying for the information about the token you just minted. Let's quickly add a way to query for the information of a specific NFT. You'll move to the `nft-contract/src/nft_core.ts` file and edit the `internalNftToken` function.

It will take a token ID as a parameter and return the information for that token. The `JsonToken` contains the token ID, the owner ID, and the token's metadata.

<Github language="js" start="10" end="35" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/nft_core.ts" />

With that finished, it's finally time to build and deploy the contract so you can mint your first NFT.

## Interacting with the contract on-chain

Now that the logic for minting is complete and you've added a way to query for information about specific tokens, it's time to build and deploy your contract to the blockchain.

### Deploying the contract {#deploy-the-contract}

We've included a very simple way to build the smart contracts throughout this tutorial using `yarn`. The following command will build the contract and copy over the `.wasm` file to a folder `build/nft.wasm`.

```bash
yarn build:nft
```

For deployment, you will need a NEAR account with the keys stored on your local machine. Navigate to the [NEAR wallet](https://testnet.mynearwallet.com//) site and create an account.

:::info
Please ensure that you deploy the contract to an account with no pre-existing contracts. It's easiest to simply create a new account or create a sub-account for this tutorial.
:::

Log in to your newly created account with `near-cli` by running the following command in your terminal.

<Tabs groupId="cli-tabs">

  <TabItem value="short" label="Short">

  ```bash
  near login --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near account import-account using-web-wallet network-config testnet
  ```
  </TabItem>
</Tabs>

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` portion:

```bash
export NFT_CONTRACT_ID="YOUR_ACCOUNT_NAME"
```

Test that the environment variable is set correctly by running:

```bash
echo $NFT_CONTRACT_ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your NFT project run the following command to deploy your smart contract.

```bash
cargo near deploy build-non-reproducible-wasm $NFT_CONTRACT_ID
```

At this point, the contract should have been deployed to your account and you're ready to move onto testing and minting NFTs.

### Initializing the contract {#initialize-contract}

The very first thing you need to do once the contract has been deployed is to initialize it. For simplicity, let's call the default metadata initialization function you wrote earlier so that you don't have to type the metadata manually in the CLI.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID init '{"owner_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT_ID init json-args '{"owner_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You've just initialized the contract with some default metadata and set your account ID as the owner. At this point, you're ready to call your first view function.

### Viewing the contract's metadata

Now that the contract has been initialized, you can call some of the functions you wrote earlier. More specifically, let's test out the function that returns the contract's metadata:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $NFT_CONTRACT_ID nft_metadata
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $NFT_CONTRACT_ID nft_metadata json-args '{}' network-config testnet now
    ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```bash
{ spec: 'nft-1.0.0', name: 'NFT Tutorial Contract', symbol: 'GOTEAM' }
```

At this point, you're ready to move on and mint your first NFT.

### Minting our first NFT {#minting-our-first-nft}

Let's now call the minting function that you've created. This requires a `token_id` and `metadata`. If you look back at the `TokenMetadata` struct you created earlier, there are many fields that could potentially be stored on-chain:

<Github language="js" start="91" end="102" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/metadata.ts" />

Let's mint an NFT with a title, description, and media to start. The media field can be any URL pointing to a media file. We've got an excellent GIF to mint but if you'd like to mint a custom NFT, simply replace our media link with one of your choosing. If you run the following command, it will mint an NFT with the following parameters:

- **token_id**: "token-1"
- **metadata**:
  - _title_: "My Non Fungible Team Token"
  - _description_: "The Team Most Certainly Goes :)"
  - _media_: `https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif`
- **receiver_id**: "'$NFT_CONTRACT_ID'"

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"token_id": "token-1", "metadata": {"title": "My Non Fungible Team Token", "description": "The Team Most Certainly Goes :)", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

:::info
The `amount` flag is specifying how much NEAR to attach to the call. Since you need to pay for storage, 0.1 NEAR is attached and you'll get refunded any excess that is unused at the end.
:::

### Viewing information about the NFT

Now that the NFT has been minted, you can check and see if everything went correctly by calling the `nft_token` function.
This should return a `JsonToken` which should contain the `token_id`, `owner_id`, and `metadata`.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $NFT_CONTRACT_ID nft_token '{"token_id": "token-1"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"token_id": "token-1"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```bash
{
  token_id: 'token-1',
  owner_id: 'goteam.examples.testnet',
  metadata: {
    title: 'My Non Fungible Team Token',
    description: 'The Team Most Certainly Goes :)',
    media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif'
  }
}
```

</p>
</details>

**Go team!** You've now verified that everything works correctly and it's time to view your freshly minted NFT in the NEAR wallet's collectibles tab!

## Viewing your NFTs in the wallet

If you navigate to the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles) in the NEAR wallet, this should list all the NFTs that you own. Currently, It should be empty.

We've got a problem. The wallet correctly picked up that you minted an NFT, however, the contract doesn't implement the specific view function that is being called. Behind the scenes, the wallet is trying to call `nft_tokens_for_owner` to get a list of all the NFTs owned by your account on the contract. The only function you've created, however, is the `nft_token` function. It wouldn't be very efficient for the wallet to call `nft_token` for every single NFT that a user has to get information and so they try to call the `nft_tokens_for_owner` function instead.

In the next tutorial, you'll learn about how to deploy a patch fix to a pre-existing contract so that you can view the NFT in the wallet.

## Conclusion

In this tutorial, you went through the basics of setting up and understand the logic behind minting NFTs on the blockchain using a skeleton contract.

You first looked at [what it means](#what-does-minting-mean) to mint NFTs and how to break down the problem into more feasible chunks. You then started modifying the skeleton contract chunk by chunk starting with solving the problem of [storing information / state](#storing-information) on the contract. You then looked at what to put in the [metadata and token information](#metadata-and-token-info). Finally, you looked at the logic necessary for [minting NFTs](#minting-logic).

After the contract was written, it was time to deploy to the blockchain. You [deployed the contract](#deploy-the-contract) and [initialized it](#initialize-contract). Finally, you [minted your very first NFT](#minting-our-first-nft) and saw that some changes are needed before you can view it in the wallet.

## Next Steps

In the [next tutorial](/tutorials/nfts/js/upgrade-contract), you'll find out how to deploy a patch fix and what that means so that you can view your NFTs in the wallet.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Metadata standard: [NEP177](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata), version `2.1.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/2-upgrade.md 

 ---
id: upgrade-contract
title: Upgrading the Contract
sidebar_label: Upgrade a Contract
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll build off the work you previously did to implement the [minting functionality](/tutorials/nfts/js/minting) on a skeleton smart contract. You got to the point where NFTs could be minted, however, the wallet had no way of displaying the tokens since your contract didn't implement the method that the wallet was trying to call.




## Introduction

Today you'll learn about deploying patch fixes to smart contracts and you'll use that knowledge to implement the `nft_tokens_for_owner` function on the contract you deployed in the previous tutorial.

## Upgrading contracts overview {#upgrading-contracts}

Upgrading contracts, when done right, can be an immensely powerful tool. If done wrong, it can lead to a lot of headaches. It's important to distinguish between the code and state of a smart contract. When a contract is deployed on top of an existing contract, the only thing that changes is the code. The state will remain the same and that's where a lot of developer's issues come to fruition.

The NEAR Runtime will read the serialized state from disk and it will attempt to load it using the current contract code. When your code changes, it might not be able to figure out how to do this.

You need to strategically upgrade your contracts and make sure that the runtime will be able to read your current state with the new contract code. For more information about upgrading contracts and some best practices, see the NEAR SDK's [upgrading contracts](../../../2.build/2.smart-contracts/release/upgrade.md) write-up.

## Modifications to our contract {#modifications-to-contract}

In order for the wallet to properly display your NFTs, you need to implement the `nft_tokens_for_owner` method. This will allow anyone to query for a paginated list of NFTs owned by a given account ID.

To accomplish this, let's break it down into some smaller subtasks. First, you need to get access to a list of all token IDs owned by a user. This information can be found in the `tokensPerOwner` data structure. Now that you have a set of token IDs, you need to convert them into `JsonToken` objects as that's what you'll be returning from the function.

Luckily, you wrote a function `nft_token` which takes a token ID and returns a `JsonToken` in the `nft_core.ts` file. As you can guess, in order to get a list of `JsonToken` objects, you would need to iterate through the token IDs owned by the user and then convert each token ID into a `JsonToken` and store that in a list.

As for the pagination, you can use some basic JavaScript to get that done. Let's move over to the `enumeration.ts` file and implement that logic:

<Github language="js" start="47" end="82" url="https://github.com/near-examples/nft-tutorial-js/blob/2.minting/src/nft-contract/enumeration.ts" />

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the build script, deploy the contract as you did in the previous tutorial:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

This should output a warning saying that the account has a deployed contract and will ask if you'd like to proceed. Simply type `y` and hit enter.

```bash
This account already has a deployed contract [ AKJK7sCysrWrFZ976YVBnm6yzmJuKLzdAyssfzK9yLsa ]. Do you want to proceed? (y/n)
```

Once the contract has been redeployed, let's test and see if the state migrated correctly by running a simple view function:

```bash
near view $NFT_CONTRACT_ID nft_metadata
```

This should return an output similar to the following:

```bash
{ spec: 'nft-1.0.0', name: 'NFT Tutorial Contract', symbol: 'GOTEAM' }
```

**Go team!** At this point, you can now test and see if the new function you wrote works correctly. Let's query for the list of tokens that you own:

```bash
near view $NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 5}'
```

<details>
<summary>Example response: </summary>
<p>

```bash
[
  {
    token_id: 'token-1',
    owner_id: 'goteam.examples.testnet',
    metadata: {
      title: 'My Non Fungible Team Token',
      description: 'The Team Most Certainly Goes :)',
      media: 'https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif'
    }
  }
]
```

</p>
</details>

## Viewing NFTs in the wallet {#viewing-nfts-in-wallet}

Now that your contract implements the necessary functions that the wallet uses to display NFTs, you should be able to see your tokens on display in the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles).

![filled-nft-in-wallet](/docs/assets/nfts/filled-nft-in-wallet.png)

## Conclusion

In this tutorial, you learned about the basics of [upgrading contracts](#upgrading-contracts). Then, you implemented the necessary [modifications to your smart contract](#modifications-to-contract) and [redeployed it](#redeploying-contract). Finally you navigated to the wallet collectibles tab and [viewed your NFTs](#viewing-nfts-in-wallet).

In the [next tutorial](/tutorials/nfts/js/enumeration), you'll implement the remaining functions needed to complete the [enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration) standard.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/3-enumeration.md 

 ---
id: enumeration
title: Enumeration
sidebar_label: Enumeration
---
import {Github} from "@site/src/components/codetabs"

In the previous tutorials, you looked at ways to integrate the minting functionality into a skeleton smart contract. In order to get your NFTs to show in the wallet, you also had to deploy a patch fix that implemented one of the enumeration methods. In this tutorial, you'll expand on and finish the rest of the enumeration methods as per the [standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration)
Now you'll extend the NFT smart contract and add a couple of enumeration methods that can be used to return the contract's state.




## Introduction

As mentioned in the [Upgrade a Contract](/tutorials/nfts/js/upgrade-contract/) tutorial, you can deploy patches and fixes to smart contracts. This time, you'll use that knowledge to implement the `nft_total_supply`, `nft_tokens` and `nft_supply_for_owner` enumeration functions.

To get started, either switch to the `2.minting` branch from our [GitHub repository](https://github.com/near-examples/nft-tutorial/), or continue your work from the previous tutorials.
If you haven't cloned it yet, refer to the [Contract Architecture](/tutorials/nfts/js/skeleton#building-the-skeleton) to check out the repository.

```bash
git checkout 2.minting
```

:::tip
If you wish to see the finished code for this _Enumeration_ tutorial, you can find it on the `3.enumeration` branch.
:::

## Modifications to the contract

Let's start by opening the  `src/enumeration.ts` file and locating the empty `internalNftTotalSupply` function. 

### NFT Total Supply

This function should return the total number of NFTs stored on the contract. You can easily achieve this functionality by simply returning the length of the `nftMetadataById` data structure.

<Github language="js" start="8" end="16" url="https://github.com/near-examples/nft-tutorial-js/blob/3.enumeration/src/nft-contract/enumeration.ts" />

### NFT Tokens

This function should return a paginated list of `JsonTokens` that are stored on the contract regardless of their owners.
If the user provides a `from_index` parameter, you should use that as the starting point for which to start iterating through tokens; otherwise it should start from the beginning. Likewise, if the user provides a `limit` parameter, the function shall stop after reaching either the limit or the end of the list.

<Github language="js" start="18" end="43" url="https://github.com/near-examples/nft-tutorial-js/blob/3.enumeration/src/nft-contract/enumeration.ts" />

### NFT Supply For Owner

This function should look for all the non-fungible tokens for a user-defined owner, and return the length of the resulting set.
If there isn't a set of tokens for the provided Account ID, then the function shall return `0`.

<Github language="js" start="45" end="62" url="https://github.com/near-examples/nft-tutorial-js/blob/3.enumeration/src/nft-contract/enumeration.ts" />

Next, you can use the CLI to query these new methods and validate that they work correctly.

## Redeploying the contract {#redeploying-contract}

Now that you've implemented the necessary logic for `nft_tokens_for_owner`, it's time to build and re-deploy the contract to your account. Using the build script, deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

This should output a warning saying that the account has a deployed contract and will ask if you'd like to proceed. Simply type `y` and hit enter.

```
This account already has a deployed contract [ AKJK7sCysrWrFZ976YVBnm6yzmJuKLzdAyssfzK9yLsa ]. Do you want to proceed? (y/n)
```

## Enumerating tokens

Once the updated contract has been redeployed, you can test and see if these new functions work as expected.

### NFT tokens

Let's query for a list of non-fungible tokens on the contract. Use the following command to query for the information of up to 50 NFTs starting from the 10th item:

```bash
near view $NFT_CONTRACT_ID nft_tokens '{"from_index": "10", "limit": 50}'
```

This command should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
[]
```

</p>
</details>

### Tokens by owner

To get the total supply of NFTs owned by the `goteam.testnet` account, call the `nft_supply_for_owner` function and set the `account_id` parameter:

```bash
near view $NFT_CONTRACT_ID nft_supply_for_owner '{"account_id": "goteam.testnet"}'
```

This should return an output similar to the following:

<details>
<summary>Example response: </summary>
<p>

```json
0
```

</p>
</details>

## Conclusion

In this tutorial, you have added two [new enumeration functions](/tutorials/nfts/js/enumeration#modifications-to-the-contract), and now you have a basic NFT smart contract with minting and enumeration methods in place. After implementing these modifications, you redeployed the smart contract and tested the functions using the CLI.

In the [next tutorial](/tutorials/nfts/js/core), you'll implement the core functions needed to allow users to transfer the minted tokens.

:::info Remember
If you want to see the finished code from this tutorial, you can checkout the `3.enumeration` branch. 
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/4-core.md 

 ---
id: core
title: Core
sidebar_label: Core
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll learn how to implement the [core standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) into your smart contract. If you're joining us for the first time, feel free to clone [this repo](https://github.com/near-examples/nft-tutorial) and checkout the `3.enumeration` branch to follow along.


```bash
git checkout 3.enumeration
```

:::tip
If you wish to see the finished code for this _Core_ tutorial, you can find it on the `4.core` branch.
:::

## Introduction {#introduction}

Up until this point, you've created a simple NFT smart contract that allows users to mint tokens and view information using the [enumeration standards](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). Today, you'll expand your smart contract to allow for users to not only mint tokens, but transfer them as well.

As we did in the [minting tutorial](/tutorials/nfts/js/minting), let's break down the problem into multiple subtasks to make our lives easier. When a token is minted, information is stored in 3 places:

- **tokensPerOwner**: set of tokens for each account.
- **tokensById**: maps a token ID to a `Token` object.
- **tokenMetadataById**: maps a token ID to its metadata.

Let's now consider the following scenario. If Benji owns token A and wants to transfer it to Mike as a birthday gift, what should happen? First of all, token A should be removed from Benji's set of tokens and added to Mike's set of tokens.

If that's the only logic you implement, you'll run into some problems. If you were to do a `view` call to query for information about that token after it's been transferred to Mike, it would still say that Benji is the owner.

This is because the contract is still mapping the token ID to the old `Token` object that contains the `owner_id` field set to Benji's account ID. You still have to change the `tokensById` data structure so that the token ID maps to a new `Token` object which has Mike as the owner.

With that being said, the final process for when an owner transfers a token to a receiver should be the following:

- Remove the token from the owner's set.
- Add the token to the receiver's set.
- Map a token ID to a new `Token` object containing the correct owner.

:::note
You might be curious as to why we don't edit the `tokenMetadataById` field. This is because no matter who owns the token, the token ID will always map to the same metadata. The metadata should never change and so we can just leave it alone.
:::

At this point, you're ready to move on and make the necessary modifications to your smart contract.

## Modifications to the contract

Let's start our journey in the `nft-contract/src/nft_core.ts` file.

### Transfer function {#transfer-function}

You'll start by implementing the `nft_transfer` logic. This function will transfer the specified `token_id` to the `receiver_id` with an optional `memo` such as `"Happy Birthday Mike!"`. The core logic will be found in the `internalNftTransfer` function.

<Github language="js" start="37" end="64" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/nft_core.ts" />

There are a couple things to notice here. Firstly, we've introduced a new function called `assertOneYocto()`. This method will ensure that the user has attached exactly one yoctoNEAR to the call. If a function requires a deposit, you need a full access key to sign that transaction. By adding the one yoctoNEAR deposit requirement, you're essentially forcing the user to sign the transaction with a full access key.

Since the transfer function is potentially transferring very valuable assets, you'll want to make sure that whoever is calling the function has a full access key.

Secondly, we've introduced an `internalTransfer` method. This will perform all the logic necessary to transfer an NFT.

### Internal helper functions

Let's quickly move over to the `nft-contract/src/internal.ts` file so that you can implement the `assertOneYocto()` and `internalTransfer` methods.

Let's start with the easier one, `assertOneYocto()`.

#### assertOneYocto

<Github language="js" start="38" end="41" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/internal.ts" />

#### internal_transfer

It's now time to implement the `internalTransfer` function which is the core of this tutorial. This function will take the following parameters:

- **senderId**: the account that's attempting to transfer the token.
- **receiverId**: the account that's receiving the token.
- **tokenId**: the token ID being transferred.
- **memo**: an optional memo to include.

The first thing you'll want to do is to make sure that the sender is authorized to transfer the token. In this case, you'll just make sure that the sender is the owner of the token. You'll do that by getting the `Token` object using the `token_id` and making sure that the sender is equal to the token's `owner_id`.

Second, you'll remove the token ID from the sender's list and add the token ID to the receiver's list of tokens. Finally, you'll create a new `Token` object with the receiver as the owner and remap the token ID to that newly created object.

<Github language="js" start="80" end="114" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/internal.ts" />

You've previously implemented functionality for adding a token ID to an owner's set but you haven't created the functionality for removing a token ID from an owner's set. Let's do that now by created a new function called `internalRemoveTokenFromOwner` which we'll place right above our `internalTransfer` and below the `internalAddTokenToOwner` function.

In the remove function, you'll get the set of tokens for a given account ID and then remove the passed in token ID. If the account's set is empty after the removal, you'll simply remove the account from the `tokensPerOwner` data structure.

<Github language="js" start="60" end="78" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/internal.ts" />

With these internal functions complete, the logic for transferring NFTs is finished. It's now time to move on and implement `nft_transfer_call`, one of the most integral yet complicated functions of the standard.

### Transfer call function {#transfer-call-function}

Let's consider the following scenario. An account wants to transfer an NFT to a smart contract for performing a service. The traditional approach would be to use an approval management system, where the receiving contract is granted the ability to transfer the NFT to themselves after completion. You'll learn more about the approval management system in the [approvals section](/tutorials/nfts/js/approvals) of the tutorial series.

This allowance workflow takes multiple transactions. If we introduce a ‚Äútransfer and call‚Äù workflow baked into a single transaction, the process can be greatly improved.

For this reason, we have a function `nft_transfer_call` which will transfer an NFT to a receiver and also call a method on the receiver's contract all in the same transaction.

<Github language="js" start="66" end="125" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/nft_core.ts" />

The function will first assert that the caller attached exactly 1 yocto for security purposes. It will then transfer the NFT using `internalTransfer` and start the cross contract call. It will call the method `nft_on_transfer` on the `receiver_id`'s contract which returns a promise. After the promise finishes executing, the function `nft_resolve_transfer` is called. This is a very common workflow when dealing with cross contract calls. You first initiate the call and wait for it to finish executing. You then invoke a function that resolves the result of the promise and act accordingly.

In our case, when calling `nft_on_transfer`, that function will return whether or not you should return the NFT to it's original owner in the form of a boolean. This is logic will be executed in the `internalResolveTransfer` function.

<Github language="js" start="127" end="187" url="https://github.com/near-examples/nft-tutorial-js/blob/4.core/src/nft-contract/nft_core.ts" />

If `nft_on_transfer` returned true, you should send the token back to it's original owner. On the contrary, if false was returned, no extra logic is needed. As for the return value of `nft_resolve_transfer`, the standard dictates that the function should return a boolean indicating whether or not the receiver successfully received the token or not.

This means that if `nft_on_transfer` returned true, you should return false. This is because if the token is being returned to its original owner. The `receiver_id` didn't successfully receive the token in the end. On the contrary, if `nft_on_transfer` returned false, you should return true since we don't need to return the token and thus the `receiver_id` successfully owns the token.

With that finished, you've now successfully added the necessary logic to allow users to transfer NFTs. It's now time to deploy and do some testing.

## Redeploying the contract {#redeploying-contract}

Using the build script, build and deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $NFT_CONTRACT_ID
```

This should output a warning saying that the account has a deployed contract and will ask if you'd like to proceed. Simply type `y` and hit enter.

```
This account already has a deployed contract [ AKJK7sCysrWrFZ976YVBnm6yzmJuKLzdAyssfzK9yLsa ]. Do you want to proceed? (y/n)
```

:::tip
If you haven't completed the previous tutorials and are just following along with this one, simply create an account and login with your CLI using `near login`. You can then export an environment variable `export NFT_CONTRACT_ID=YOUR_ACCOUNT_ID_HERE`.
:::

## Testing the new changes {#testing-changes}

Now that you've deployed a patch fix to the contract, it's time to move onto testing. Using the previous NFT contract where you had minted a token to yourself, you can test the `nft_transfer` method. If you transfer the NFT, it should be removed from your account's collectibles displayed in the wallet. In addition, if you query any of the enumeration functions, it should show that you are no longer the owner.

Let's test this out by transferring an NFT to the account `benjiman.testnet` and seeing if the NFT is no longer owned by you.

### Testing the transfer function

:::note
This means that the NFT won't be recoverable unless the account `benjiman.testnet` transfers it back to you. If you don't want your NFT lost, make a new account and transfer the token to that account instead.
:::

If you run the following command, it will transfer the token `"token-1"` to the account `benjiman.testnet` with the memo `"Go Team :)"`. Take note that you're also attaching exactly 1 yoctoNEAR by using the `--depositYocto` flag. 

:::tip
If you used a different token ID in the previous tutorials, replace `token-1` with your token ID.
:::

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "token-1", "memo": "Go Team :)"}' --accountId $NFT_CONTRACT_ID --depositYocto 1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "benjiman.testnet", "token_id": "token-1", "memo": "Go Team :)"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you now query for all the tokens owned by your account, that token should be missing. Similarly, if you query for the list of tokens owned by `benjiman.testnet`, that account should now own your NFT.

### Testing the transfer call function

Now that you've tested the `nft_transfer` function, it's time to test the `nft_transfer_call` function. If you try to transfer an NFT to a receiver that does **not** implement the `nft_on_transfer` function, the contract will panic and the NFT will **not** be transferred. Let's test this functionality below.

First mint a new NFT that will be used to test the transfer call functionality.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_mint '{"token_id": "token-2", "metadata": {"title": "NFT Tutorial Token", "description": "Testing the transfer call function", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT_ID nft_mint json-args '{"token_id": "token-2", "metadata": {"title": "NFT Tutorial Token", "description": "Testing the transfer call function", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Now that you've minted the token, you can try to transfer the NFT to the account `no-contract.testnet` which as the name suggests, doesn't have a contract. This means that the receiver doesn't implement the `nft_on_transfer` function and the NFT should remain yours after the transaction is complete.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $NFT_CONTRACT_ID nft_transfer_call '{"receiver_id": "no-contract.testnet", "token_id": "token-2", "msg": "foo"}' --accountId $NFT_CONTRACT_ID --depositYocto 1 --gas 200000000000000
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $NFT_CONTRACT_ID nft_transfer_call json-args '{"receiver_id": "no-contract.testnet", "token_id": "token-2", "msg": "foo"}' prepaid-gas '200.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you query for your tokens, you should still have `token-2` and at this point, you're finished!

## Conclusion

In this tutorial, you learned how to expand an NFT contract past the minting functionality and you added ways for users to transfer NFTs. You [broke down](#introduction) the problem into smaller, more digestible subtasks and took that information and implemented both the [NFT transfer](#transfer-function) and [NFT transfer call](#transfer-call-function) functions. In addition, you deployed another [patch fix](#redeploying-contract) to your smart contract and [tested](#testing-changes) the transfer functionality.

In the [next tutorial](/tutorials/nfts/js/approvals), you'll learn about the approval management system and how you can approve others to transfer tokens on your behalf.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/5-approval.md 

 ---
id: approvals
title: Approvals
sidebar_label: Approvals
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll learn the basics of an approval management system which will allow you to grant others access to transfer NFTs on your behalf. This is the backbone of all NFT marketplaces and allows for some complex yet beautiful scenarios to happen. If you're joining us for the first time, feel free to clone [this repository](https://github.com/near-examples/nft-tutorial) and checkout the `4.core` branch to follow along.




```bash
git checkout 4.core
```

:::tip
If you wish to see the finished code for this _Approval_ tutorial, you can find it on the `5.approval` branch.
:::

## Introduction

Up until this point you've created a smart contract that allows users to mint and transfer NFTs as well as query for information using the [enumeration standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration). As we've been doing in the previous tutorials, let's break down the problem into smaller, more digestible, tasks. Let's first define some of the end goals that we want to accomplish as per the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) extension of the standard. We want a user to have the ability to:

- Grant other accounts access to transfer their NFTs on a per token basis.
- Check if an account has access to a specific token.
- Revoke a specific account the ability to transfer an NFT.
- Revoke **all** other accounts the ability to transfer an NFT.

If you look at all these goals, they are all on a per token basis. This is a strong indication that you should change the `Token` struct which keeps track of information for each token.

## Allow an account to transfer your NFT

Let's start by trying to accomplish the first goal. How can you grant another account access to transfer an NFT on your behalf?

The simplest way that you can achieve this is to add a list of approved accounts to the `Token` struct. When transferring the NFT, if the caller is not the owner, you could check if they're in the list.

Before transferring, you would need to clear the list of approved accounts since the new owner wouldn't expect the accounts approved by the original owner to still have access to transfer their new NFT.

### The problem {#the-problem}

On the surface, this would work, but if you start thinking about the edge cases, some problems arise. Often times when doing development, a common approach is to think about the easiest and most straightforward solution. Once you've figured it out, you can start to branch off and think about optimizations and edge cases.

Let's consider the following scenario. Benji has an NFT and gives two separate marketplaces access to transfer his token. By doing so, he's putting the NFT for sale (more about that in the [marketplace integrations](#marketplace-integrations) section). Let's say he put the NFT for sale for 1 NEAR on both markets. The token's list of approved account IDs would look like the following:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

Josh then comes along and purchases the NFT on marketplace A for 1 NEAR. This would take the sale down from the marketplace A and clear the list of approved accounts. Marketplace B, however, still has the token listed for sale for 1 NEAR and has no way of knowing that the token was purchased on marketplace A by Josh. The new token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: []
}
```

Let's say Josh is low on cash and wants to flip this NFT and put it for sale for 10 times the price on marketplace B. He goes to put it for sale and for whatever reason, the marketplace is built in a way that if you try to put a token up for sale twice, it keeps the old sale data. This would mean that from marketplace B's perspective, the token is still for sale for 1 NEAR (which was the price that Benji had originally listed it for).

Since Josh approved the marketplace to try and put it for sale, the token struct would look as follows:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: [marketplace A, marketplace B]
}
```

If Mike then comes along and purchases the NFT for only 1 NEAR on marketplace B, the marketplace would go to try and transfer the NFT and since technically, Josh approved the marketplace and it's in the list of approved accounts, the transaction would go through properly.

### The solution {#the-solution}

Now that we've identified a problem with the original solution, let's think about ways that we can fix it. What would happen now if, instead of just keeping track of a list of approved accounts, you introduced a specific ID that went along with each approved account. The new approved accounts would now be a map instead of a list. It would map an account to it's `approval id`.

For this to work, you need to make sure that the approval ID is **always** a unique, new ID. If you set it as an integer that always increases by 1 whenever u approve an account, this should work. Let's consider the same scenario with the new solution.

Benji puts his NFT for sale for 1 NEAR on marketplace A and marketplace B by approving both marketplaces. The "next approval ID" would start off at 0 when the NFT was first minted and will increase from there. This would result in the following token struct:

```
Token: {
    owner_id: Benji
    approved_accounts_ids: {
        marketplace A: 0
        marketplace B: 1
    }
    next_approval_id: 2
}
```

When Benji approved marketplace A, it took the original value of `next_approval_id` which started off at 0. The marketplace was then inserted into the map and the next approval ID was incremented. This process happened again for marketplace B and the next approval ID was again incremented where it's now 2.

Josh comes along and purchases the NFT on marketplace A for 1 NEAR. Notice how the next approval ID stayed at 2:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {}
    next_approval_id: 2
}
```

Josh then flips the NFT because he's once again low on cash and approves marketplace B:

```
Token: {
    owner_id: Josh
    approved_accounts_ids: {
        marketplace B: 2
    }
    next_approval_id: 3
}
```

The marketplace is inserted into the map and the next approval ID is incremented. From marketplace B's perspective it stores it's original approval ID from when Benji put the NFT up for sale which has a value of 1. If Mike were to go and purchase the NFT on marketplace B for the original 1 NEAR sale price, the NFT contract should panic. This is because the marketplace is trying to transfer the NFT with an approval ID 1 but the token struct shows that it **should** have an approval ID of 2.

### Expanding the `Token` and `JsonToken` structs

Now that you understand the proposed solution to the original problem of allowing an account to transfer your NFT, it's time to implement some of the logic. The first thing you should do is modify the `Token` and `JsonToken` structs to reflect the new changes. Let's switch over to the `nft-contract/src/metadata.ts` file:

<Github language="js" start="106" end="156" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/metadata.ts" />

You'll then need to initialize both the `approved_account_ids` and `next_approval_id` to their default values when a token is minted. Switch to the `nft-contract/src/mint.ts` file and when creating the `Token` struct to store in the contract, let's set the next approval ID to be 0 and the approved account IDs to be an empty object:

<Github language="js" start="23" end="31" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/mint.ts" />

### Approving accounts

Now that you've added the support for approved account IDs and the next approval ID on the token level, it's time to add the logic for populating and changing those fields through a function called `nft_approve`. This function should approve an account to have access to a specific token ID. Let's move to the `nft-contract/src/approval.ts` file and edit the `internalNftApprove` function:

<Github language="js" start="9" end="73" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

The function will first assert that the user has attached **at least** one yoctoNEAR (which we'll implement soon). This is both for security and to cover storage. When someone approves an account ID, they're storing that information on the contract. As you saw in the [minting tutorial](/tutorials/nfts/js/minting), you can either have the smart contract account cover the storage, or you can have the users cover that cost. The latter is more scalable and it's the approach you'll be working with throughout this tutorial.

After the assertion comes back with no problems, you get the token object and make sure that only the owner is calling this method. Only the owner should be able to allow other accounts to transfer their NFTs. You then get the next approval ID and insert the passed in account into the map with the next approval ID. If it's a new approval ID, storage must be paid. If it's not a new approval ID, no storage needs to be paid and only attaching 1 yoctoNEAR would be enough.

You then calculate how much storage is being used by adding that new account to the map and increment the tokens `next_approval_id` by 1. After inserting the token object back into the `tokensById` map, you refund any excess storage.

You'll notice that the function contains an optional `msg` parameter. This message is actually the foundation of all NFT marketplaces on NEAR.

#### Marketplace Integrations {#marketplace-integrations}

If a message was provided into the function, you're going to perform a cross contract call to the account being given access. This cross contract call will invoke the `nft_on_approve` function which will parse the message and act accordingly. Let's consider a general use case.

We have a marketplace that expects it's sale conditions to be passed in through the message field. Benji approves the marketplace with the `nft_approve` function and passes in a stringified JSON to the message which will outline sale conditions. These sale conditions could look something like the following:

```json
sale_conditions: {
    price: 5
}
```

By leaving the message field type as just a string, this generalizes the process and allows users to input sale conditions for many different marketplaces. It is up to the person approving to pass in an appropriate message that the marketplace can properly decode and use. This is usually done through the marketplace's frontend app which would know how to construct the `msg` in a useful way.

#### Internal functions

Now that the core logic for approving an account is finished, you need to implement the `assertAtLeastOneYocto` and `bytesForApprovedAccountId` functions. Move to the `nft-contract/src/internal.ts` file and copy the following function right below the `assertOneYocto` function.

<Github language="js" start="61" end="64" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

Next, you'll need to copy the logic for calculating how many bytes it costs to store an account ID. Place this function at the very top of the page:

<Github language="js" start="55" end="59" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

Now that the logic for approving accounts is finished, you need to change the restrictions for transferring.

### Changing the restrictions for transferring NFTs

Currently, an NFT can **only** be transferred by its owner. You need to change that restriction so that people that have been approved can also transfer NFTs. In addition, you'll make it so that if an approval ID is passed, you can increase the security and check if both the account trying to transfer is in the approved list **and** they correspond to the correct approval ID. This is to address the problem we ran into earlier.

In the `internal.ts` file, you need to change the logic of the `internalTransfer` method as that's where the restrictions are being made. Change the internal transfer function to be the following:

<Github language="js" start="108" end="163" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

This will check if the sender isn't the owner and then if they're not, it will check if the sender is in the approval list. If an approval ID was passed into the function, it will check if the sender's actual approval ID stored on the contract matches the one passed in.

#### Refunding storage on transfer

While you're in the internal file, you're going to need to add methods for refunding users who have paid for storing approved accounts on the contract when an NFT is transferred. This is because you'll be clearing the `approved_account_ids` object whenever NFTs are transferred and so the storage is no longer being used.

<Github language="js" start="13" end="28" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/internal.ts" />

These will be useful in the next section where you'll be changing the `nft_core` functions to include the new approval logic.

### Changes to `nft_core.ts`

Head over to the `nft-contract/src/nft_core.ts` file and the first change that you'll want to make is to add an `approval_id` to the `internalTransfer` function. This is so that anyone trying to transfer the token that isn't the owner must pass in an approval ID to address the problem seen earlier. If they are the owner, the approval ID won't be used as we saw in the `internalTransfer` function.


For the `nft_transfer` function, the only change that you'll need to make is to pass in the approval ID into the `internalTransfer` function and then refund the previous tokens approved account IDs after the transfer is finished

<Github language="js" start="38" end="72" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

Next, you need to do the same to `nft_transfer_call` but instead of refunding immediately, you need to attach the previous token's approved account IDs to `nft_resolve_transfer` instead as there's still the possibility that the transfer gets reverted.

<Github language="js" start="74" end="135" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

You'll also need to add the tokens approved account IDs to the `JsonToken` being returned by `nft_token`.

<Github language="js" start="10" end="36" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

Finally, you need to add the logic for refunding the approved account IDs in `internalResolveTransfer`. If the transfer went through, you should refund the owner for the storage being released by resetting the tokens `approved_account_ids` field. If, however, you should revert the transfer, it wouldn't be enough to just not refund anybody. Since the receiver briefly owned the token, they could have added their own approved account IDs and so you should refund them if they did so.

<Github language="js" start="137" end="208" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/nft_core.ts" />

With that finished, it's time to move on and complete the next task.

## Check if an account is approved

Now that the core logic is in place for approving and refunding accounts, it should be smooth sailing from this point on. You now need to implement the logic for checking if an account has been approved. This should take an account and token ID as well as an optional approval ID. If no approval ID was provided, it should simply return whether or not the account is approved.

If an approval ID was provided, it should return whether or not the account is approved and has the same approval ID as the one provided. Let's move to the `nft-contract/src/approval.ts` file and add the necessary logic to the `internalNftIsApproved` function.

<Github language="js" start="75" end="110" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

Let's now move on and add the logic for revoking an account

## Revoke an account

The next step in the tutorial is to allow a user to revoke a specific account from having access to their NFT. The first thing you'll want to do is assert one yocto for security purposes. You'll then need to make sure that the caller is the owner of the token. If those checks pass, you'll need to remove the passed in account from the tokens approved account IDs and refund the owner for the storage being released.

<Github language="js" start="112" end="145" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

## Revoke all accounts

The final step in the tutorial is to allow a user to revoke all accounts from having access to their NFT. This should also assert one yocto for security purposes and make sure that the caller is the owner of the token. You then refund the owner for releasing all the accounts in the map and then clear the `approved_account_ids`.

<Github language="js" start="147" end="177" url="https://github.com/near-examples/nft-tutorial-js/blob/5.approval/src/nft-contract/approval.ts" />

With that finished, it's time to deploy and start testing the contract.

## Testing the new changes {#testing-changes}

Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, it's best practice to create a sub-account and deploy the contract there.

### Creating a sub-account {#creating-sub-account}

Run the following command to create a sub-account `approval` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account approval.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export APPROVAL_NFT_CONTRACT_ID=approval.$NFT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $APPROVAL_NFT_CONTRACT_ID
```

### Initialization and minting {#initialization-and-minting}

Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID init '{"owner_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID init json-args '{"owner_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $APPROVAL_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"approval-token"` and the receiver will be your new account.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_mint '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_mint json-args '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $APPROVAL_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You can check to see if everything went through properly by calling one of the enumeration functions:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
    ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif",
    },
    "approved_account_ids": {}
  }
]
```

Notice how the approved account IDs are now being returned from the function? This is a great sign! You're now ready to move on and approve an account to have access to your token.

### Approving an account {#approving-an-account}

At this point, you should have two accounts. One stored under `$NFT_CONTRACT_ID` and the other under the `$APPROVAL_NFT_CONTRACT_ID` environment variable. You can use both of these accounts to test things out. If you approve your old account, it should have the ability to transfer the NFT to itself.

Execute the following command to approve the account stored under `$NFT_CONTRACT_ID` to have access to transfer your NFT with an ID `"approval-token"`. You don't need to pass a message since the old account didn't implement the `nft_on_approve` function. In addition, you'll need to attach enough NEAR to cover the cost of storing the account on the contract. 0.1 NEAR should be more than enough and you'll be refunded any excess that is unused.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$NFT_CONTRACT_ID'"}' --accountId $APPROVAL_NFT_CONTRACT_ID --deposit 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_approve json-args '{"token_id": "approval-token", "account_id": "'$NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $APPROVAL_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you call the same enumeration method as before, you should see the new approved account ID being returned.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$APPROVAL_NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
    ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "approval.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": { "goteam.examples.testnet": 0 }
  }
]
```

### Transferring an NFT as an approved account {#transferring-the-nft}

Now that you've approved another account to transfer the token, you can test that behavior. You should be able to use the other account to transfer the NFT to itself by which the approved account IDs should be reset. Let's test transferring the NFT with the wrong approval ID:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 1}' --accountId $NFT_CONTRACT_ID --depositYocto 1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 1}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```bash
kind: {
    ExecutionError: "Smart contract panicked: panicked at 'assertion failed: `(left == right)`\n" +
      '  left: `0`,\n' +
      " right: `1`: The actual approval_id 0 is different from the given approval_id 1', src/internal.ts:165:17"
  },
```

</p>
</details>

If you pass the correct approval ID which is `0`, everything should work fine.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 0}' --accountId $NFT_CONTRACT_ID --depositYocto 1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "'$NFT_CONTRACT_ID'", "token_id": "approval-token", "approval_id": 0}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

If you again call the enumeration method, you should see the owner updated and the approved account IDs reset.

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": {}
  }
]
```

Let's now test the approval ID incrementing across different owners. If you approve the sub-account that originally minted the token, the approval ID should be 1 now.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $APPROVAL_NFT_CONTRACT_ID nft_approve '{"token_id": "approval-token", "account_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' --accountId $NFT_CONTRACT_ID --deposit 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $APPROVAL_NFT_CONTRACT_ID nft_approve json-args '{"token_id": "approval-token", "account_id": "'$APPROVAL_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Calling the view function again show now return an approval ID of 1 for the sub-account that was approved.
<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 10}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $APPROVAL_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": { "approval.goteam.examples.testnet": 1 }
  }
]
```

</p>
</details>

With the testing finished, you've successfully implemented the approvals extension to the standard!

## Conclusion

Today you went through a lot of logic to implement the [approvals extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) so let's break down exactly what you did.

First, you explored the [basic approach](#allow-an-account-to-transfer-your-nft) of how to solve the problem. You then went through and discovered some of the [problems](/tutorials/nfts/js/approvals#the-problem) with that solution and learned how to [fix it](#the-solution).

After understanding what you should do to implement the approvals extension, you started to [modify](#expanding-the-token-and-jsontoken-structs) the JsonToken and Token structs in the contract. You then implemented the logic for [approving accounts](#approving-accounts) and saw how [marketplaces](#marketplace-integrations) are integrated.

After implementing the logic behind approving accounts, you went and [changed the restrictions](#changing-the-restrictions-for-transferring-nfts) needed to transfer NFTs. The last step you did to finalize the approving logic was to go back and edit the [nft_core](#changes-to-nft_corets) files to be compatible with the new changes.

At this point, everything was implemented in order to allow accounts to be approved and you extended the functionality of the [core standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core) to allow for approved accounts to transfer tokens.

You implemented a view method to [check](#check-if-an-account-is-approved) if an account is approved and to finish the coding portion of the tutorial, you implemented the logic necessary to [revoke an account](#revoke-an-account) as well as [revoke all accounts](#revoke-all-accounts).

After this, the contract code was finished and it was time to move onto testing where you created a [subaccount](#creating-sub-account) and tested the [approving](/tutorials/nfts/js/approvals#approving-an-account) and [transferring](#transferring-the-nft) for your NFTs.

In the next tutorial, you'll learn about the royalty standards and how you can interact with NFT marketplaces.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Approval standard: [NEP178](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/6-royalty.md 

 ---
id: royalty
title: Royalty
sidebar_label: Royalty
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll continue building your non-fungible token (NFT) smart contract, and learn how to implement perpetual royalties into your NFTs. This will allow people to get a percentage of the purchase price when an NFT is sold.



## Introduction

By now, you should have a fully fledged NFT contract, except for the royalties support.
To get started, either switch to the `5.approval` branch from our [GitHub repository](https://github.com/near-examples/nft-tutorial-js/), or continue your work from the previous tutorials.

```bash
git checkout 5.approval
```

:::tip
If you wish to see the finished code for this _Royalty_ tutorial, you can find it on the `6.royalty` branch.
:::

## Thinking about the problem

In order to implement the functionality, you first need to understand how NFTs are sold. In the previous tutorial, you saw how someone with an NFT could list it on a marketplace using the `nft_approve` function by passing in a message that could be properly decoded. When a user purchases your NFT on the marketplace, what happens?

Using the knowledge you have now, a reasonable conclusion would be to say that the marketplace transfers the NFT to the buyer by performing a cross-contract call and invokes the NFT contract's `nft_transfer` method. Once that function finishes, the marketplace would pay the seller for the correct amount that the buyer paid.

Let's now think about how this can be expanded to allow for a cut of the pay going to other accounts that aren't just the seller.

### Expanding the current solution

Since perpetual royalties will be on a per-token basis, it's safe to assume that you should be changing the `Token` and `JsonToken` structs. You need some way of keeping track of what percentage each account with a royalty should have. If you introduce a map of an account to an integer, that should do the trick.

Now, you need some way to relay that information to the marketplace. This method should be able to transfer the NFT exactly like the old solution but with the added benefit of telling the marketplace exactly what accounts should be paid what amounts. If you implement a method that transfers the NFT and then calculates exactly what accounts get paid and to what amount based on a passed-in balance, that should work nicely.

This is what the [royalty standards](https://nomicon.io/Standards/NonFungibleToken/Payout) outlined. Let's now move on and modify our smart contract to introduce this behavior.

## Modifications to the contract

The first thing you'll want to do is add the royalty information to the structs. Open the `nft-contract/src/metadata.ts` file and add `royalty` to the `Token` and `JsonToken` structs:

```js
royalty: { [accountId: string]: number };
```

Second, you'll want to add `royalty` to the `JsonToken` struct as well:

<Github language="js" start="106" end="166" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/metadata.ts" />

### Internal helper function

**royaltyToPayout**

To simplify the payout calculation, let's add a helper `royaltyToPayout` function to `src/internal.ts`. This will convert a percentage to the actual amount that should be paid. In order to allow for percentages less than 1%, you can give 100% a value of `10,000`. This means that the minimum percentage you can give out is 0.01%, or `1`. For example, if you wanted the account `benji.testnet` to have a perpetual royalty of 20%, you would insert the pair `"benji.testnet": 2000` into the payout map.

<Github language="js" start="13" end="16" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/internal.ts" />

If you were to use the `royaltyToPayout` function and pass in `2000` as the `royaltyPercentage` and an `amountToPay` of 1 NEAR, it would return a value of 0.2 NEAR.

### Royalties

**nft_payout**

Let's now implement a method to check what accounts will be paid out for an NFT given an amount, or balance. Open the `nft-contract/src/royalty.ts` file, and modify the `internalNftPayout` function as shown.

<Github language="js" start="7" end="53" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/royalty.ts" />

This function will loop through the token's royalty map and take the balance and convert that to a payout using the `royaltyToPayout` function you created earlier. It will give the owner of the token whatever is left from the total royalties. As an example:

You have a token with the following royalty field:

```js
Token {
    owner_id: "damian",
    royalty: {
        "benji": 1000,
        "josh": 500,
        "mike": 2000
    }
}
```

If a user were to call `nft_payout` on the token and pass in a balance of 1 NEAR, it would loop through the token's royalty field and insert the following into the payout object:

```js
Payout {
    payout: {
        "benji": 0.1 NEAR,
        "josh": 0.05 NEAR,
        "mike": 0.2 NEAR
    }
}
```

At the very end, it will insert `damian` into the payout object and give him `1 NEAR - 0.1 - 0.05 - 0.2 = 0.65 NEAR`.

**nft_transfer_payout**

Now that you know how payouts are calculated, it's time to create the function that will transfer the NFT and return the payout to the marketplace.

<Github language="js" start="55" end="121" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/royalty.ts" />

### Perpetual royalties

To add support for perpetual royalties, let's edit the `src/mint.ts` file. First, add an optional parameter for perpetual royalties. This is what will determine what percentage goes to which accounts when the NFT is purchased. You will also need to create and insert the royalty to be put in the `Token` object:

<Github language="js" start="7" end="64" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/mint.ts" />

### Adding royalty object to struct implementations

Since you've added a new field to your `Token` and `JsonToken` structs, you need to edit your implementations accordingly. Move to the `nft-contract/src/internal.ts` file and edit the part of your `internalTransfer` function that creates the new `Token` object:

<Github language="js" start="150" end="158" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/internal.ts" />

Once that's finished, move to the `nft-contract/src/nft_core.ts` file. You need to edit your implementation of `internalNftToken` so that the `JsonToken` sends back the new royalty information.

<Github language="js" start="10" end="37" url="https://github.com/near-examples/nft-tutorial-js/blob/6.royalty/src/nft-contract/nft_core.ts" />

Next, you can use the CLI to query the new `nft_payout` function and validate that it works correctly.

## Deploying the contract {#redeploying-contract}

As you saw in the previous tutorial, adding changes like these will cause problems when redeploying. Since these changes affect all the other tokens and the state won't be able to automatically be inherited by the new code, simply redeploying the contract will lead to errors. For this reason, you'll create a new sub-account again.

### Creating a sub-account

Run the following command to create a sub-account `royalty` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account royalty.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export ROYALTY_NFT_CONTRACT_ID=royalty.$NFT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $ROYALTY_NFT_CONTRACT_ID
```

### Initialization and minting {#initialization-and-minting}

Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $ROYALTY_NFT_CONTRACT_ID init '{"owner_id": "'$ROYALTY_NFT_CONTRACT_ID'"}' --accountId $ROYALTY_NFT_CONTRACT_ID
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $ROYALTY_NFT_CONTRACT_ID init json-args '{"owner_id": "'$ROYALTY_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $ROYALTY_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"royalty-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $ROYALTY_NFT_CONTRACT_ID nft_mint '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$ROYALTY_NFT_CONTRACT_ID'", "perpetual_royalties": {"benjiman.testnet": 2000, "mike.testnet": 1000, "josh.testnet": 500}}' --accountId $ROYALTY_NFT_CONTRACT_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $ROYALTY_NFT_CONTRACT_ID nft_mint json-args '{"token_id": "approval-token", "metadata": {"title": "Approval Token", "description": "testing out the new approval extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$ROYALTY_NFT_CONTRACT_ID'", "perpetual_royalties": {"benjiman.testnet": 2000, "mike.testnet": 1000, "josh.testnet": 500}}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $ROYALTY_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You can check to see if everything went through properly by calling one of the enumeration functions:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $ROYALTY_NFT_CONTRACT_ID nft_tokens_for_owner '{"account_id": "'$ROYALTY_NFT_CONTRACT_ID'", "limit": 10}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $ROYALTY_NFT_CONTRACT_ID nft_tokens_for_owner json-args '{"account_id": "'$ROYALTY_NFT_CONTRACT_ID'", "limit": 10}' network-config testnet now
    ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```json
[
  {
    "token_id": "approval-token",
    "owner_id": "royalty.goteam.examples.testnet",
    "metadata": {
      "title": "Approval Token",
      "description": "testing out the new approval extension of the standard",
      "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"
    },
    "approved_account_ids": {},
    "royalty": {
      "josh.testnet": 500,
      "benjiman.testnet": 2000,
      "mike.testnet": 1000
    }
  }
]
```

Notice how there's now a royalty field that contains the 3 accounts that will get a combined 35% of all sales of this NFT? Looks like it works! Go team :)

### NFT payout

Let's calculate the payout for the `"approval-token"` NFT, given a balance of 100 yoctoNEAR. It's important to note that the balance being passed into the `nft_payout` function is expected to be in yoctoNEAR.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $ROYALTY_NFT_CONTRACT_ID nft_payout '{"token_id": "approval-token", "balance": "100", "max_len_payout": 100}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $ROYALTY_NFT_CONTRACT_ID nft_payout json-args '{"token_id": "approval-token", "balance": "100", "max_len_payout": 100}' network-config testnet now
    ```
  </TabItem>
</Tabs>

This command should return an output similar to the following:

```bash
{
  payout: {
    'josh.testnet': '5',
    'royalty.goteam.examples.testnet': '65',
    'mike.testnet': '10',
    'benjiman.testnet': '20'
  }
}
```

If the NFT was sold for 100 yoctoNEAR, josh would get 5, benji would get 20, mike would get 10, and the owner, in this case `royalty.goteam.examples.testnet` would get the rest: 65.

## Conclusion

At this point you have everything you need for a fully functioning NFT contract to interact with marketplaces.
The last remaining standard that you could implement is the events standard. This allows indexers to know what functions are being called and makes it easier and more reliable to keep track of information that can be used to populate the collectibles tab in the wallet for example.

:::info remember
If you want to see the finished code from this tutorial, you can checkout the `6.royalty` branch.
:::

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Enumeration standard: [NEP181](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration), version `1.0.0`
- Royalties standard: [NEP199](https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout), version `2.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/7-events.md 

 ---
id: events
title: Events
sidebar_label: Events
---
import {Github} from "@site/src/components/codetabs";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial, you'll learn about the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and how to implement it in your smart contract.



## Introduction

To get started, either switch to the `6.royalty` branch from our [GitHub repository](https://github.com/near-examples/nft-tutorial/), or continue your work from the previous tutorials.

```bash
git checkout 6.royalty
```

:::tip
If you wish to see the finished code for this _Events_ tutorial, you can find it on the `7.events` branch.
:::

## Understanding the use case {#understanding-the-use-case}

Have you ever wondered how the wallet knows which NFTs you own and how it can display them in the [collectibles tab](https://testnet.mynearwallet.com//?tab=collectibles)? Originally, an indexer used to listen for any functions calls starting with `nft_` on your account. These contracts were then flagged on your account as likely NFT contracts. 

When you navigated to your collectibles tab, the wallet would then query all those contracts for the list of NFTs you owned using the `nft_tokens_for_owner` function you saw in the [enumeration tutorial](/tutorials/nfts/js/enumeration).

### The problem {#the-problem}

This method of flagging contracts was not reliable as each NFT-driven application might have its own way of minting or transferring NFTs. In addition, it's common for apps to transfer or mint many tokens at a time using batch functions. 

### The solution {#the-solution}

A standard was introduced so that smart contracts could emit an event anytime NFTs were transferred, minted, or burnt. This event was in the form of a log. No matter how a contract implemented the functionality, an indexer could now listen for those standardized logs.

As per the standard, you need to implement a logging functionality that gets fired when NFTs are transferred or minted. In this case, the contract doesn't support burning so you don't need to worry about that for now.

It's important to note the standard dictates that the log should begin with `"EVENT_JSON:"`. The structure of your log should, however, always contain the 3 following things: 

- **standard**: the current name of the standard (e.g. nep171)
- **version**: the version of the standard you're using (e.g. 1.0.0)
- **event**: a list of events you're emitting.

The event interface differs based on whether you're recording transfers or mints. The interface for both events is outlined below.

**Transfer events**:
- *Optional* - **authorized_id**: the account approved to transfer on behalf of the owner.
- **old_owner_id**: the old owner of the NFT.
- **new_owner_id**: the new owner that the NFT is being transferred to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

**Minting events**:
- **owner_id**: the owner that the NFT is being minted to.
- **token_ids**: a list of NFTs being transferred.
- *Optional* - **memo**: an optional message to include with the event.

### Examples {#examples}

In order to solidify your understanding of the standard, let's walk through three scenarios and see what the logs should look like.

#### Scenario A - simple mint

In this scenario, Benji wants to mint an NFT to Mike with a token ID `"team-token"` and he doesn't include a message. The log should look as follows.

```js
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token"]}
  ]
}
```

#### Scenario B - batch mint

In this scenario, Benji wants to perform a batch mint. He will mint an NFT to Mike, Damian, Josh, and Dorian. Dorian, however, will get two NFTs. Each token ID will be `"team-token"` followed by an incrementing number. The log is as follows.


```js
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_mint",
  "data": [
    {"owner_id": "mike.testnet", "token_ids": ["team-token0"]},
    {"owner_id": "damian.testnet", "token_ids": ["team-token1"]},
    {"owner_id": "josh.testnet", "token_ids": ["team-token2"]}
    {"owner_id": "dorian.testnet", "token_ids": ["team-token3", "team-token4"]},
  ]
}
```

#### Scenario C - transfer NFTs

In this scenario, Mike is transferring both his team tokens to Josh. The log should look as follows.

```js
EVENT_JSON:{
  "standard": "nep171",
  "version": "1.0.0",
  "event": "nft_transfer",
  "data": [
    {"old_owner_id": "mike.testnet", "new_owner_id": "josh.testnet", "token_ids": ["team-token", "team-token0"], "memo": "Go Team!"}
  ]
}
```

## Modifications to the contract {#modifications-to-the-contract}

At this point, you should have a good understanding of what the end goal should be so let's get to work!

### Logging minted tokens {#logging-minted-tokens}

Since the contract will only be minting tokens in one place, it's trivial where you should place the log. Open the `nft-contract/src/mint.ts` file and navigate to the bottom of the file. This is where you'll construct the log for minting. Anytime someone successfully mints an NFT, it will now correctly emit a log.

```js
// Construct the mint log as per the events standard.
let nftMintLog = {
    // Standard name ("nep171").
    standard: NFT_STANDARD_NAME,
    // Version of the standard ("nft-1.0.0").
    version: NFT_METADATA_SPEC,
    // The data related with the event stored in a vector.
    event: "nft_mint",
    data: [
        {
            // Owner of the token.
            owner_id: token.owner_id,
            // Vector of token IDs that were minted.
            token_ids: [tokenId],
        }
    ]
}

// Log the json.
near.log(`EVENT_JSON:${JSON.stringify(nftMintLog)}`);
```

<Github language="js" start="7" end="85" url="https://github.com/near-examples/nft-tutorial-js/blob/7.events/src/nft-contract/mint.ts" />

### Logging transfers {#logging-transfers}

Let's open the `nft-contract/src/internal.ts` file and navigate to the `internalTransfer` function. This is the location where you'll build your transfer logs. Whenever an NFT is transferred, this function is called and so you'll correctly be logging the transfers.

```js
// Construct the transfer log as per the events standard.
let nftTransferLog = {
    // Standard name ("nep171").
    standard: NFT_STANDARD_NAME,
    // Version of the standard ("nft-1.0.0").
    version: NFT_METADATA_SPEC,
    // The data related with the event stored in a vector.
    event: "nft_transfer",
    data: [
        {
            // The optional authorized account ID to transfer the token on behalf of the old owner.
            authorized_id: authorizedId,
            // The old owner's account ID.
            old_owner_id: token.owner_id,
            // The account ID of the new owner of the token.
            new_owner_id: receiverId,
            // A vector containing the token IDs as strings.
            token_ids: [tokenId],
            // An optional memo to include.
            memo,
        }
    ]
}

// Log the serialized json.
near.log(`EVENT_JSON:${JSON.stringify(nftTransferLog)}`);
```
<Github language="js" start="113" end="205" url="https://github.com/near-examples/nft-tutorial-js/blob/7.events/src/nft-contract/internal.ts" />

This solution, unfortunately, has an edge case which will break things. If an NFT is transferred via the `nft_transfer_call` function, there's a chance that the transfer will be reverted if the `nft_on_transfer` function returns `true`. Taking a look at the logic for `nft_transfer_call`, you can see why this is a problem.

When `nft_transfer_call` is invoked, it will: 
- Call `internalTransfer` to perform the actual transfer logic.
- Initiate a cross-contract call and invoke the `nft_on_transfer` function.
- Resolve the promise and perform logic in `internalResolveTransfer`.
    - This will either return true meaning the transfer went fine or it will revert the transfer and return false.

If you only place the log in the `internalTransfer` function, the log will be emitted and the indexer will think that the NFT was transferred. If the transfer is reverted during `internalResolveTransfer`, however, that event should **also** be emitted. Anywhere that an NFT **could** be transferred, we should add logs. Replace the `internalResolveTransfer` with the following code.

<Github language="js" start="138" end="242" url="https://github.com/near-examples/nft-tutorial-js/blob/7.events/src/nft-contract/nft_core.ts" />

With that finished, you've successfully implemented the events standard and it's time to start testing.

## Deploying the contract {#redeploying-contract}

For the purpose of readability and ease of development, instead of redeploying the contract to the same account, let's create a sub-account and deploy to that instead. You could have deployed to the same account as none of the changes you implemented in this tutorial would have caused errors.

### Creating a sub-account

Run the following command to create a sub-account `events` of your main account with an initial balance of 25 NEAR which will be transferred from the original to your new account.

```bash
near create-account events.$NFT_CONTRACT_ID --masterAccount $NFT_CONTRACT_ID --initialBalance 25
```

Next, you'll want to export an environment variable for ease of development:

```bash
export EVENTS_NFT_CONTRACT_ID=events.$NFT_CONTRACT_ID
```

Using the build script, build the deploy the contract as you did in the previous tutorials:

```bash
yarn build && near deploy --wasmFile build/nft.wasm --accountId $EVENTS_NFT_CONTRACT_ID
```

### Initialization and minting {#initialization-and-minting}

Since this is a new contract, you'll need to initialize and mint a token. Use the following command to initialize the contract:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $EVENTS_NFT_CONTRACT_ID init '{"owner_id": "'$EVENTS_NFT_CONTRACT_ID'"}' --accountId $EVENTS_NFT_CONTRACT_ID
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $EVENTS_NFT_CONTRACT_ID init json-args '{"owner_id": "'$EVENTS_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $EVENTS_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Next, you'll need to mint a token. By running this command, you'll mint a token with a token ID `"events-token"` and the receiver will be your new account. In addition, you're passing in a map with two accounts that will get perpetual royalties whenever your token is sold.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $EVENTS_NFT_CONTRACT_ID nft_mint '{"token_id": "events-token", "metadata": {"title": "Events Token", "description": "testing out the new events extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$EVENTS_NFT_CONTRACT_ID'"}' --accountId $EVENTS_NFT_CONTRACT_ID --amount 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $EVENTS_NFT_CONTRACT_ID nft_mint json-args '{"token_id": "events-token", "metadata": {"title": "Events Token", "description": "testing out the new events extension of the standard", "media": "https://bafybeiftczwrtyr3k7a2k4vutd3amkwsmaqyhrdzlhvpt33dyjivufqusq.ipfs.dweb.link/goteam-gif.gif"}, "receiver_id": "'$EVENTS_NFT_CONTRACT_ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $EVENTS_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

You can check to see if everything went through properly by looking at the output in your CLI:

```bash
Doing account.functionCall()
Receipts: F4oxNfv54cqwUwLUJ7h74H1iE66Y3H7QDfZMmGENwSxd, BJxKNFRuLDdbhbGeLA3UBSbL8UicU7oqHsWGink5WX7S
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"events.goteam.examples.testnet","token_ids":["events-token"]}]}
Transaction Id 4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4Wy2KQVTuAWQHw5jXcRAbrz7bNyZBoiPEvLcGougciyk
''
```

You can see that the event was properly logged!

### Transferring {#transferring}

You can now test if your transfer log works as expected by sending `benjiman.testnet` your NFT.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $EVENTS_NFT_CONTRACT_ID nft_transfer '{"receiver_id": "benjiman.testnet", "token_id": "events-token", "memo": "Go Team :)", "approval_id": 0}' --accountId $EVENTS_NFT_CONTRACT_ID --depositYocto 1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $EVENTS_NFT_CONTRACT_ID nft_transfer json-args '{"receiver_id": "benjiman.testnet", "token_id": "events-token", "memo": "Go Team :)", "approval_id": 0}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as $EVENTS_NFT_CONTRACT_ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

This should return an output similar to the following:

```bash
Doing account.functionCall()
Receipts: EoqBxrpv9Dgb8KqK4FdeREawVVLWepEUR15KPNuZ4fGD, HZ4xQpbgc8EfU3PiV72LvfXb2f3dVC1n9aVTbQds9zfR
	Log [events.goteam.examples.testnet]: Memo: Go Team :)
	Log [events.goteam.examples.testnet]: EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"events.goteam.examples.testnet","old_owner_id":"events.goteam.examples.testnet","new_owner_id":"benjiman.testnet","token_ids":["events-token"],"memo":"Go Team :)"}]}
Transaction Id 4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4S1VrepKzA6HxvPj3cK12vaT7Dt4vxJRWESA1ym1xdvH
''
```

Hurray! At this point, your NFT contract is fully complete and the events standard has been implemented.

## Conclusion

Today you went through the [events standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event) and implemented the necessary logic in your smart contract. You created events for [minting](#logging-minted-tokens) and [transferring](#logging-transfers) NFTs. You then deployed and [tested](#initialization-and-minting) your changes by minting and transferring NFTs.

In the next tutorial, you'll look at the basics of a marketplace contract and how it was built.

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`
- Events standard: [NEP297 extension](https://nomicon.io/Standards/Tokens/NonFungibleToken/Event), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/js/8-marketplace.md 

 ---
id: marketplace
title: Marketplace
sidebar_label: Marketplace
---
import {Github} from "@site/src/components/codetabs"

In this tutorial, you'll learn the basics of an NFT marketplace contract where you can buy and sell non-fungible tokens for $NEAR. In the previous tutorials, you went through and created a fully fledged NFT contract that incorporates all the standards found in the [NFT standard](https://nomicon.io/Standards/NonFungibleToken).



## Introduction

Throughout this tutorial, you'll learn how a marketplace contract could work on NEAR. This is meant to be an example and there is no canonical implementation. Feel free to branch off and modify this contract to meet your specific needs.

Using the same repository as the previous tutorials, if you checkout the `8.marketplace` branch, you should have the necessary files to complete the tutorial.

```bash
git checkout 8.marketplace
```

## File structure {#file-structure}

```
market-contract
‚îî‚îÄ‚îÄ src
    ‚îú‚îÄ‚îÄ internal.ts
    ‚îú‚îÄ‚îÄ index.ts
    ‚îú‚îÄ‚îÄ nft_callbacks.ts
    ‚îú‚îÄ‚îÄ sale.ts
    ‚îî‚îÄ‚îÄ sale_views.ts
```

Usually, when doing work on multiple smart contracts that all pertain to the same repository, it's a good idea to structure them in their own folders as done in this tutorial. To make your work easier when building the smart contracts, we've also modified the repository's `package.json` file so that building both smart contracts can be easily done by running the following command.

```bash
yarn build
```
This will install the dependencies for both contracts and compile them to `wasm` files that are stored in the following directory.

```
nft-tutorial-js
‚îî‚îÄ‚îÄ build
    ‚îú‚îÄ‚îÄ nft.wasm
    ‚îî‚îÄ‚îÄ market.wasm
```

## Understanding the contract

At first, the contract can be quite overwhelming but if you strip away all the fluff and dig into the core functionalities, it's actually quite simple. This contract was designed for only one thing - to allow people to buy and sell NFTs for NEAR. This includes the support for paying royalties, updating the price of your sales, removing sales and paying for storage.

Let's go through the files and take note of some of the important functions and what they do.

## index.ts {#index-ts}

This file outlines what information is stored on the contract as well as some other crucial functions that you'll learn about below.

### Constructor logic {#constructor-logic}

The first function you'll look at is the constructor function. This takes an `owner_id` as the only parameter and will default all the storage collections to their default values.

<Github language="js" start="40" end="52" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/index.ts" />

### Storage management model {#storage-management-model}

Next, let's talk about the storage management model chosen for this contract. On the NFT contract, users attached $NEAR to the calls that needed storage paid for. For example, if someone was minting an NFT, they would need to attach `x` amount of NEAR to cover the cost of storing the data on the contract.

On this marketplace contract, however, the storage model is a bit different. Users will need to deposit $NEAR onto the marketplace to cover the storage costs. Whenever someone puts an NFT for sale, the marketplace needs to store that information which costs $NEAR. Users can either deposit as much NEAR as they want so that they never have to worry about storage again or they can deposit the minimum amount to cover 1 sale on an as-needed basis.

You might be thinking about the scenario when a sale is purchased. What happens to the storage that is now being released on the contract? This is why we've introduced a storage withdrawal function. This allows users to withdraw any excess storage that is not being used. Let's go through some scenarios to understand the logic. The required storage for 1 sale is 0.01 NEAR on the marketplace contract.

**Scenario A**

- Benji wants to list his NFT on the marketplace but has never paid for storage.
- He deposits exactly 0.01 NEAR using the `storage_deposit` method. This will cover 1 sale.
- He lists his NFT on the marketplace and is now using up 1 out of his prepaid 1 sales and has no more storage left. If he were to call `storage_withdraw`, nothing would happen.
- Dorian loves his NFT and quickly purchases it before anybody else can. This means that Benji's sale has now been taken down (since it was purchased) and Benji is using up 0 out of his prepaid 1 sales. In other words, he has an excess of 1 sale or 0.01 NEAR.
- Benji can now call `storage_withdraw` and will be transferred his 0.01 NEAR back. On the contract's side, after withdrawing, he will have 0 sales paid for and will need to deposit storage before trying to list anymore NFTs.

**Scenario B**

- Dorian owns one hundred beautiful NFTs and knows that he wants to list all of them.
- To avoid having to call `storage_deposit` everytime he wants to list an NFT, he calls it once. Since Dorian is a baller, he attaches 10 NEAR which is enough to cover 1000 sales. He now has an excess of 9 NEAR or 900 sales.
- Dorian needs the 9 NEAR for something else but doesn't want to take down his 100 listings. Since he has an excess of 9 NEAR, he can easily withdraw and still have his 100 listings. After calling `storage_withdraw` and being transferred 9 NEAR, he will have an excess of 0 sales.

With this behavior in mind, the following two functions outline the logic.

<Github language="js" start="58" end="121" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/index.ts" />

In this contract, the storage required for each sale is 0.01 NEAR but you can query that information using the `storage_minimum_balance` function. In addition, if you wanted to check how much storage a given account has paid, you can query the `storage_balance_of` function.

With that out of the way, it's time to move onto the `nft_callbacks.ts` file where you'll look at how NFTs are put for sale.

## nft_callbacks.ts {#nft_callbacks-ts}

This file is responsible for the logic used to put NFTs for sale. If you remember from the [marketplaces section](/tutorials/nfts/js/approvals#marketplace-integrations) of the approvals tutorial, when users call `nft_approve` and pass in a message, it will perform a cross-contract call to the `receiver_id`'s contract and call the method `nft_on_approve`. This `nft_callbacks.ts` file will implement that function.

### Listing logic {#listing-logic}

The market contract is expecting the message that the user passes into `nft_approve` on the NFT contract to be JSON stringified sale arguments. This outlines the sale price in yoctoNEAR for the NFT that is listed.

The `nft_on_approve` function is called via a cross-contract call by the NFT contract. It will make sure that the signer has enough storage to cover adding another sale. It will then attempt to get the sale conditions from the message and create the listing.

<Github language="js" start="6" end="73" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/nft_callbacks.ts" />

## sale.ts {#sale-ts}

Now that you're familiar with the process of both adding storage and listing NFTs on the marketplace, let's go through what you can do once a sale has been listed. The `sale.ts` file outlines the functions for updating the price, removing, and purchasing NFTs.

### Sale object {#sale-object}

It's important to understand what information the contract is storing for each sale object. Since the marketplace has many NFTs listed that come from different NFT contracts, simply storing the token ID would not be enough to distinguish between different NFTs. This is why you need to keep track of both the token ID and the contract by which the NFT came from. In addition, for each listing, the contract must keep track of the approval ID it was given to transfer the NFT. Finally, the owner and sale conditions are needed.

<Github language="js" start="9" end="42" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

### Removing sales {#removing-sales}

In order to remove a listing, the owner must call the `remove_sale` function and pass the NFT contract and token ID. Behind the scenes, this calls the `internallyRemoveSale` function which you can find in the `internal.ts` file. This will assert one yoctoNEAR for security reasons.

<Github language="js" start="44" end="65" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

### Updating price {#updating-price}

In order to update the list price of a token, the owner must call the `update_price` function and pass in the contract, token ID, and desired price. This will get the sale object, change the sale conditions, and insert it back. For security reasons, this function will assert one yoctoNEAR.

<Github language="js" start="67" end="96" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

### Purchasing NFTs {#purchasing-nfts}

For purchasing NFTs, you must call the `offer` function. It takes an `nft_contract_id` and `token_id` as parameters. You must attach the correct amount of NEAR to the call in order to purchase. Behind the scenes, this will make sure your deposit is greater than the list price and call a private method `processPurchase` which will perform a cross-contract call to the NFT contract to invoke the `nft_transfer_payout` function. This will transfer the NFT using the [approval management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement) standard that you learned about and it will return the `Payout` object which includes royalties.

The marketplace will then call `resolve_purchase` where it will check for malicious payout objects and then if everything went well, it will pay the correct accounts.

<Github language="js" start="98" end="131" url="https://github.com/near-examples/nft-tutorial-js/blob/8.marketplace/src/market-contract/sale.ts" />

## sale_view.ts {#sale_view-ts}

The final file we'll go through is the `sale_view.ts` file. This is where some of the enumeration methods are outlined. It allows users to query for important information regarding sales.

### Total supply {#total-supply}

To query for the total supply of NFTs listed on the marketplace, you can call the `get_supply_sales` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_sales
```

### Total supply by owner {#total-supply-by-owner}

To query for the total supply of NFTs listed by a specific owner on the marketplace, you can call the `get_supply_by_owner_id` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_by_owner_id '{"account_id": "benji.testnet"}'
```

### Total supply by contract {#total-supply-by-contract}

To query for the total supply of NFTs that belong to a specific contract, you can call the `get_supply_by_nft_contract_id` function. An example can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_supply_by_nft_contract_id '{"nft_contract_id": "fayyr-nft.testnet"}'
```

### Query for listing information {#query-listing-information}

To query for important information for a specific listing, you can call the `get_sale` function. This requires that you pass in the `nft_contract_token`. This is essentially the unique identifier for sales on the market contract as explained earlier. It consists of the NFT contract followed by a `DELIMITER` followed by the token ID. In this contract, the `DELIMITER` is simply a period: `.`.  An example of this query can be seen below.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sale '{"nft_contract_token": "fayyr-nft.testnet.token-42"}'
```

In addition, you can query for paginated information about the listings for a given owner by calling the `get_sales_by_owner_id` function.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sales_by_owner_id '{"account_id": "benji.testnet", "from_index": "5", "limit": 10}'
```

Finally, you can query for paginated information about the listings that originate from a given NFT contract by calling the `get_sales_by_nft_contract_id` function.

```bash
near view $MARKETPLACE_CONTRACT_ID get_sales_by_nft_contract_id '{"nft_contract_id": "fayyr-nft.testnet, "from_index": "5", "limit": 10}'
```

## Conclusion

In this tutorial, you learned about the basics of a marketplace contract and how it works. You went through the [index.ts](#index-ts) file and learned about the initialization function in addition to the [storage management](#storage-management-model) model.

You then went through the [nft_callbacks](#nft_callbacks-ts) file to understand how to [list NFTs](#listing-logic). In addition, you went through some important functions needed for after you've listed an NFT. This includes [removing sales](#removing-sales), [updating the price](#updating-price), and [purchasing NFTs](#purchasing-nfts).

Finally, you went through the enumeration methods found in the [`sale_view`](#sale_view-ts) file. These allow you to query for important information found on the marketplace contract.

You should now have a solid understanding of NFTs and marketplaces on NEAR. Feel free to branch off and expand on these contracts to create whatever cool applications you'd like. The world is your oyster! Thanks for joining on this journey and don't forget, **Go Team!**

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- near-cli: `3.0.0`
- NFT standard: [NEP171](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core), version `1.0.0`

:::


 This is the content for the doc docs/3.tutorials/nfts/minting-nfts.md 

 ---
id: minting-nfts
title: Minting NFTs
sidebar_label: Minting NFTs
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

In this tutorial you'll learn how to easily create your own NFTs without doing any software development by using a readily-available smart contract and a decentralized storage solution like [IPFS](https://ipfs.io/).

## Overview {#overview}

This article will guide you in setting up an [NFT smart contract](#non-fungible-token-contract), and show you [how to build](#building-the-contract), [test](#testing-the-contract) and [deploy](#deploying-the-contract) your NFT contract on NEAR.
Once the contract is deployed, you'll learn [how to mint](#minting-your-nfts) non-fungible tokens from media files [stored on IPFS](#uploading-the-image) and view them in your Wallet.

## Prerequisites {#prerequisites}

To complete this tutorial successfully, you'll need:

- [Rust toolchain](/build/smart-contracts/quickstart#prerequisites)
- [A NEAR account](#wallet)
- [NEAR command-line interface](/tools/near-cli#installation) (`near-cli`)

## Wallet {#wallet}

To store your non-fungible tokens you'll need a [NEAR Wallet](https://testnet.mynearwallet.com//).
If you don't have one yet, you can create one easily by following [these instructions](https://testnet.mynearwallet.com/create).

> **Tip:** for this tutorial we'll use a `testnet` wallet account. The `testnet` network is free and there's no need to deposit funds.

Once you have your Wallet account, you can click on the [Collectibles](https://testnet.mynearwallet.com//?tab=collectibles) tab where all your NFTs will be listed:

![Wallet](/docs/assets/nfts/nft-wallet.png)

<!--
Briefly talks about how the wallet listens for methods that start with `nft_` and then flags the contracts.
-->

## IPFS {#ipfs}

The [InterPlanetary File System](https://ipfs.io/) (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices.

### Uploading the image {#uploading-the-image}

To upload the NFT image, you should use a [decentralized storage](/concepts/storage/storage-solutions) provider such as IPFS.

:::note
This example uses IPFS, but you could use a different solution like Filecoin, Arweave, or a regular centralized Web2 hosting.
:::

Once you have uploaded your file to IPFS, you'll get a unique `CID` for your content, and a URL like:

```
https://bafyreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/
```

## Non-fungible Token contract {#non-fungible-token-contract}

[This repository](https://github.com/near-examples/NFT) includes an example implementation of a [non-fungible token] contract which uses [near-contract-standards] and simulation tests.

[non-fungible token]: https://nomicon.io/Standards/NonFungibleToken
[near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards

### Clone the NFT repository {#clone-the-nft-repository}

In your terminal run the following command to clone the NFT repo:

```
git clone https://github.com/near-examples/NFT
```

### Explore the smart contract {#explore-the-smart-contract}

The source code for this contract can be found in `nft/src/lib.rs`. This contract contains logic which follows the [NEP-171 standard][non-fungible token] (NEAR Enhancement Proposal) and the implementation of this standard which can be found [here](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs).

At first, the code can be a bit overwhelming, but if we only consider the aspects involved with minting, we can break it down into 2 main categories - the contract struct and the minting process.

#### Contract Struct {#contract-struct}

The contract keeps track of two pieces of information - `tokens` and `metadata`. For the purpose of this tutorial we will only deal with the `tokens` field.

```rust
#[near(contract_state)]
#[derive(PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}
```

The tokens are of type `NonFungibleToken` which come from the [core standards](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs). There are several fields that make up the struct but for the purpose of this tutorial, we'll only be concerned with the `owner_by_id` field. This keeps track of the owner for any given token.

```rust
pub struct NonFungibleToken {
    // owner of contract
    pub owner_id: AccountId,

    // keeps track of the owner for any given token ID.
    pub owner_by_id: TreeMap<TokenId, AccountId>,

    ...
}
```

Now that we've explored behind the scenes and where the data is being kept, let's move to the minting functionality.

#### Minting {#minting}

In order for a token to be minted you will need to call the `nft_mint` function. There are three arguments that are passed to this function:

- `token_id`
- `receiver_id`
- `token_metadata`

This function executes `self.tokens.mint` which calls the mint function in the [core standards](https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/non_fungible_token/core/core_impl.rs) creating a record of the token with the owner being `receiver_id`.

```rust
#[payable]
pub fn nft_mint(
    &mut self,
    token_id: TokenId,
    receiver_id: ValidAccountId,
    token_metadata: TokenMetadata,
) -> Token {
    self.tokens.mint(token_id, receiver_id, Some(token_metadata))
}
```

This creates that record by inserting the token into the `owner_by_id` data structure that we mentioned in the previous section.

```rust
self.owner_by_id.insert(&token_id, &owner_id);
```

### Building the contract {#building-the-contract}

To build your contract run the following command in your terminal which builds your contract using Rust's `cargo`.

```bash
cargo near build
```

This will generate WASM binaries into your `res/` directory. This WASM file is the smart contract we'll be deploying onto the NEAR blockchain.

:::tip
If you run into errors make sure you have [Rust installed](/build/smart-contracts/quickstart#prerequisites) and are in the root directory of the NFT example.
:::

### Testing the contract {#testing-the-contract}

Written in the smart contract there are pre-written tests that you can run. Run the following command in your terminal to perform these simple tests to verify that your contract code is working.

```bash
cargo test
```

> **Note:** the more complex simulation tests aren't performed with this command but you can find them in `tests/sim`.

## Using the NFT contract {#using-the-nft-contract}

Now that you have successfully built and tested the NFT smart contract, you're ready to [deploy it](#deploying-the-contract)
and start using it [mint your NFTs](#minting-your-nfts).

### Deploying the contract {#deploying-the-contract}

This smart contract will be deployed to your NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared.

> **Note:** If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete` and then recreate it in Wallet. To create (or recreate) an account, please follow the directions in [Test Wallet](https://testnet.mynearwallet.com/) or ([NEAR Wallet](https://wallet.near.org/) if we're using `mainnet`).

Log in to your newly created account with `near-cli` by running the following command in your terminal.

<Tabs groupId="cli-tabs">

  <TabItem value="short" label="Short">

  ```bash
  near login --networkId testnet
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near account import-account using-web-wallet network-config testnet
  ```
  </TabItem>
</Tabs>

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account ID. In the command below, replace `YOUR_ACCOUNT_NAME` with the account name you just logged in with including the `.testnet` (or `.near` for `mainnet`):

```bash
export ID=YOUR_ACCOUNT_NAME
```

Test that the environment variable is set correctly by running:

```bash
echo $ID
```

Verify that the correct account ID is printed in the terminal. If everything looks correct you can now deploy your contract.
In the root of your NFT project run the following command to deploy your smart contract.

```bash
near deploy $ID res/non_fungible_token.wasm
```

<details>
<summary>Example response: </summary>
<p>

```bash
Starting deployment. Account id: ex-1.testnet, node: https://rpc.testnet.near.org, file: res/non_fungible_token.wasm
Transaction Id E1AoeTjvuNbDDdNS9SqKfoWiZT95keFrRUmsB65fVZ52
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/E1AoeTjvuNbDDdNS9SqKfoWiZT95keFrRUmsB65fVZ52
Done deploying to ex-1.testnet
```

</p>
</details>


### Minting your NFTs {#minting-your-nfts}

A smart contract can define an initialization method that can be used to set the contract's initial state.
In our case, we need to initialize the NFT contract before usage. For now, we'll initialize it with the default metadata.

> **Note:** each account has a data area called `storage`, which is persistent between function calls and transactions.
> For example, when you initialize a contract, the initial state is saved in the persistent storage.

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $ID new_default_meta '{"owner_id": "'$ID'"}' --accountId $ID
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $ID new_default_meta json-args '{"owner_id": "'$ID'"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as $ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

> **Tip:** you can find more info about the NFT metadata at [nomicon.io](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata).

You can then view the metadata by running the following `view` call:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $ID nft_metadata
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $ID nft_metadata json-args '{}' network-config testnet now
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "spec": "nft-1.0.0",
  "name": "Example NEAR non-fungible token",
  "symbol": "EXAMPLE",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E",
  "base_uri": null,
  "reference": null,
  "reference_hash": null
}
```

</p>
</details>

Now let's mint our first token! The following command will mint one copy of your NFT. Replace the `media` url with the one you [uploaded to IPFS](#uploading-the-image) earlier:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call $ID nft_mint '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "Some Art", "description": "My NFT media", "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/", "copies": 1}}' --accountId $ID --deposit 0.1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction $ID nft_mint json-args '{"token_id": "0", "receiver_id": "'$ID'", "token_metadata": { "title": "Some Art", "description": "My NFT media", "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/", "copies": 1}}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $ID network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
{
  "token_id": "0",
  "owner_id": "dev-xxxxxx-xxxxxxx",
  "metadata": {
    "title": "Some Art",
    "description": "My NFT media",
    "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/",
    "media_hash": null,
    "copies": 1,
    "issued_at": null,
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": null,
    "reference_hash": null
  },
  "approved_account_ids": {}
}
```

</p>
</details>

To view tokens owned by an account you can call the NFT contract with the following `near-cli` command:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view $ID nft_tokens_for_owner '{"account_id": "'$ID'"}'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-read-only $ID nft_tokens_for_owner json-args '{"account_id": "'$ID'"}' network-config testnet now
    ```
  </TabItem>
</Tabs>

<details>
<summary>Example response: </summary>
<p>

```json
[
  {
    "token_id": "0",
    "owner_id": "dev-xxxxxx-xxxxxxx",
    "metadata": {
      "title": "Some Art",
      "description": "My NFT media",
      "media": "https://bafkreiabag3ztnhe5pg7js4bj6sxuvkz3sdf76cjvcuqjoidvnfjz7vwrq.ipfs.dweb.link/",
      "media_hash": null,
      "copies": 1,
      "issued_at": null,
      "expires_at": null,
      "starts_at": null,
      "updated_at": null,
      "extra": null,
      "reference": null,
      "reference_hash": null
    },
    "approved_account_ids": {}
  }
]
```

</p>
</details>

> <br/>
>
> **Tip:** after you mint your first non-fungible token, you can [view it in your Wallet](https://testnet.mynearwallet.com//?tab=collectibles):
>
> ![Wallet with token](/docs/assets/nfts/nft-wallet-token.png)
>
> <br/>

**_Congratulations! You just minted your first NFT token on the NEAR blockchain!_** üéâ

## Final remarks {#final-remarks}

This basic example illustrates all the required steps to deploy an NFT smart contract, store media files on IPFS,
and start minting your own non-fungible tokens.

Now that you're familiar with the process, you can check out our [NFT Example](0-intro.md) and learn more about the smart contract code and how you can transfer minted tokens to other accounts.
Finally, if you are new to Rust and want to dive into smart contract development, our [Quick-start guide](../../2.build/2.smart-contracts/quickstart.md) is a great place to start.

**_Happy minting!_** ü™ô

:::note Versioning for this article

At the time of this writing, this example works with the following versions:

- cargo: `cargo 1.83.0 (5ffbef321 2024-10-29)`
- rustc: `rustc 1.83.0 (90b35a623 2024-11-26)`
- near-cli-rs: `0.16.1`

:::


 This is the content for the doc docs/3.tutorials/templates/blog.md 

 ---
id: blog
title: Onchain Blog
---

# Blogchain

[![Demo](https://img.shields.io/badge/Demo-Visit%20Demo-brightgreen)](https://blogchain.mintbase.xyz/)
[![Deploy](https://img.shields.io/badge/Deploy-on%20Vercel-blue)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FMintbase%2Ftemplates%2Ftree%2Fmain%2Fblogchain)

Blogchain makes your content unstoppable. Transform your blogs into smart contracts and posts into NFTs.

![img](https://i.imgur.com/oAVyr9o.png)

:::tip Mintbase Templates
This is part of the [Mintbase Templates](https://templates.mintbase.xyz/), a collection of templates that you can use to scaffold your own project
:::

---

## Project Walkthrough

Within the framework of blogchain, every blog manifests as an nft contract deployed from the Mintbase contract factory, while each individual blog post is uniquely represented as a non-fungible token (NFT).

*NOTE: As a standard on Mintbase as we use the latest versions of Next.js we recommend using pnpm, but the package manager is up to your personal choice.*

---

## Run the project

```bash
# install
pnpm i
#run project
pnpm run dev
```

---

## Create a Blog (deploy contract)

### Step 1: check if the contract (blog) name already exists

Using [@mintbase-js/data](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data/api/checkstorename) checkStoreName method we can check if the store already exists.

```typescript
const { data: checkStore } = await checkStoreName(
  data.name,
  NEAR_NETWORKS.TESTNET
);

if (checkStore?.nft_contracts.length === 0) {
  (...)
}
```

<hr class="subsection" />

### Step 2: if contract name doesn't exist execute the deploy contract action with the instantiated wallet

Create deploy contract args using [mintbase-js/sdk](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/deploycontract) deployContract method. This will deploy an NFT contract from the [mintbase contract factory](https://github.com/Mintbase/mb-contracts/tree/main/mb-factory-v1)

```typescript
const wallet = await selector.wallet();

const deployArgs = deployContract({
  name: data.name,
  ownerId: activeAccountId,
  factoryContractId: MINTBASE_CONTRACTS.testnet,
  metadata: {
    symbol: "",
  },
});
```

We can then execute the deploy contract by passing in the wallet. If you wan't to learn about wallet connection check out the [wallet starter template](https://templates.mintbase.xyz/templates/starter-next)

```typescript
  await execute({ wallet }, deployArgs);
```

---

## Create a Blog Post (mint an NFT)

### Step 1: call storage method to upload file inserted by the user to arweave

Using [@mintbase-js/storage](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/storage#uploadreference-referenceobject-referenceobject-arweaveresponse) uploadReference method we upload the nft image to arweave.

```typescript
const metadata = {
  title: data.title,
  media: data.media,
};
const referenceJson = await uploadReference(metadata);
const reference = referenceJson.id;
```

<hr class="subsection" />

### Step 2: mint the nft in the contract (blog)

Create mint args using [mintbase-js/sdk](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/mint) mint method.

```typescript
const wallet = await selector.wallet();

const mintCall = mint({
  noMedia: true,
  metadata: {
    reference: reference,
    title: data.title,
    description: postContent,
    extra: "blogpost",
  },
  contractAddress: data.contract,
  ownerId: activeAccountId,
});
```

We can then execute the mint nft method

```typescript
  await execute({ wallet }, mintCall);
```

:::note
We populate the 'extra' field with the value 'blogpost' to subsequently filter the displayed NFTs and blogs in blogchain, ensuring that only blogs are included.
:::

---

## Get Data

### Get blog posts (nfts) from a blog (smart contract)

Using [Mintbase GraphQL Indexer](https://docs.mintbase.xyz/dev/mintbase-graph) we can fetch the nfts from a specific smart contract - to filter by blog post we use 'blogpost' as an extra field as explained in the previous step.

```typescript
export const GET_BLOG_POSTS =
`
query GET_BLOG_POSTS($contractId: String!) {
    mb_views_nft_tokens(
      where: {extra: {_eq: "blogpost"}, _and: {nft_contract_id: {_eq: $contractId}}}
    ) {
      metadata_id
      title
      description
      media
      minted_timestamp
    }
  }
  `;
```

<hr class="subsection" />

### Get user blog posts (nfts)

```typescript
export const GET_USER_POSTS =
`
query GET_USER_POSTS($accountId: String!) {
    mb_views_nft_tokens(
      where: {extra: {_eq: "blogpost"}, _and: {nft_contract_owner_id: {_eq: $accountId}}}
    ) {
      metadata_id
      title
      description
      media
      minted_timestamp
    }
  }
  `;
```

<hr class="subsection" />

### Get user blogs (smart contracts)

```typescript
export const GET_USER_BLOGS =
`
query GET_USER_BLOGS($accountId: String!) {
    nft_contracts(where: {owner_id: {_eq: $accountId}}) {
      id
    }
  }
  `;
```

<hr class="subsection" />

### Get latest blogs (smart contracts)

```typescript
export const GET_LATEST_UPDATED_BLOGS =
`
query GET_LATEST_UPDATED_BLOGS {
  mb_views_nft_metadata(
    where: {extra: {_eq: "blogpost"}}
    distinct_on: [nft_contract_id, nft_contract_created_at]
    limit: 6
    order_by: [{nft_contract_created_at: desc}, {nft_contract_id: desc}]
  ) {
    nft_contract_id
    nft_contract_owner_id
  }
  }
  `;
```

<hr class="subsection" />

### Get latest blog posts (nfts)

```typescript
export const GET_LATEST_POSTS =
`
query GET_LATEST_POSTS {
    mb_views_nft_tokens(
      where: {extra: {_eq: "blogpost"}}
      limit: 10
      order_by: {minted_timestamp: desc}
    ) {
    metadata_id
    title
    description
    media
    minted_timestamp
    minter
    nft_contract_id
    }
  }`;
```

<hr class="subsection" />

### Get blog post (nft) data

```typescript
export const GET_POST_METADATA =
`
query GET_POST_METADATA($metadataId: String!) {
    mb_views_nft_tokens(where: {metadata_id: {_eq: $metadataId}}) {
      metadata_id
      title
      description
      media
      minted_timestamp
      minter
      nft_contract_id
    }
  }`;
```

Presently, this template exclusively functions within the testnet environment. To transition to a different network the configuration must be changed in ```<MintbaseWalletContextProvider>``` and every 'testnet' instance.

---

## Extending

This project is setup using Next.js + @mintbase/js
You can use this project as a reference to build your own, and use or remove any library you think it would suit your needs.

:::info Get in touch
You can get in touch with the mintbase team using the following channels:

- Support: [Join the Telegram](https://t.me/mintdev)
- Twitter: [@mintbase](https://twitter.com/mintbase)
:::

 This is the content for the doc docs/3.tutorials/templates/marketplace.md 

 # Marketplace Frontend

[![Demo](https://img.shields.io/badge/Demo-Visit%20Demo-brightgreen)](https://marketplace-template.mintbase.xyz/)
[![Deploy](https://img.shields.io/badge/Deploy-on%20Vercel-blue)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FMintbase%2Ftemplates%2Ftree%2Fmain%2Fmarketplace)

Unlock Your NFT Storefront: Clone & Customize Your Path to Blockchain Success with this whitelabel marketplace template!

![img](https://i.imgur.com/FjcUss9.png)

:::tip Mintbase Templates
This is part of the [Mintbase Templates](https://templates.mintbase.xyz/), a collection of templates that you can use to scaffold your own project
:::

---

## Project Walkthrough

This guide will take you step by step through the process of creating a basic marketplace frontend where you can purchase tokens and filter your selection by store. It uses [mintbase-js/data](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data) for retrieving data and [mintbase-js/sdk](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk) for executing marketplace methods on the [mintbase marketplace contract](https://github.com/Mintbase/mb-contracts/tree/main/mb-interop-market).

The mintbase-js/data package provides convenient functions for retrieving nft data from the mintbase indexer. In this example, you will be able to view and purchase NFTs from a specific nft contract.

You can find more information on Github: [GitHub link](https://github.com/Mintbase/mintbase-js/tree/beta/packages/data)

A live demo of the marketplace can be found here: [Live demo link](https://marketplace-template.mintbase.xyz/)


### Setup

```bash
# install dependencies
pnpm install

#run the project
pnpm dev
```

<hr class="subsection" />

### Step 1: Connect Wallet

Before proceeding, it is important to have a wallet connection feature implemented in your application in order to interact with the contract. To do this, you can check our guide [Wallet Connection Guide](https://docs.mintbase.xyz/dev/getting-started/add-wallet-connection-to-your-react-app).

<hr class="subsection" />

### Step 2: Get NFTs from Store

In this example, we utilized react-query to manage the loading state when retrieving NFTs from the contract via the storeNfts method. This method returns all listed NFTs from the specified contract, allowing you to display them in the user interface.

```ts
// src/hooks/useStoreNfts.ts
import { useQuery } from 'react-query';
import { storeNfts } from '@mintbase-js/data';

const useStoreNfts = (store?: string) => {
  const defaultStores = process.env.NEXT_PUBLIC_STORES || MAINNET_CONFIG.stores;
  const formattedStores = defaultStores.split(/[ ,]+/);

  const { isLoading, error, data } = useQuery(['storeNfts', store], () => storeNfts(store || formattedStores, true), {
    retry: false,
    refetchOnWindowFocus: false,
    select: mapStoreNfts,
  });

  return { ...data, error, loading: isLoading };
};

export { useStoreNfts };
```

<hr class="subsection" />

### Step 3: Get Store Data

To control the tabs, we need to retrieve store data using the storeData method. This method returns the data from the specified contract, enabling you to display it in the user interface.

```ts
// src/hooks/useStoreData.ts
import { useQuery } from 'react-query';
import { storeData } from '@mintbase-js/data';

const useStoreData = () => {
  const defaultStores = process.env.NEXT_PUBLIC_STORES || MAINNET_CONFIG.stores;
  const formattedStores = defaultStores.split(/[ ,]+/);

  const { isLoading, error, data } = useQuery('storeData', () => storeData(formattedStores), {
    retry: false,
    refetchOnWindowFocus: false,
    select: mapStoreData,
  });

  return { ...data, error, loading: isLoading };
};

export { useStoreData };

```

<hr class="subsection" />

### Step 4: Get Metadata from an NFT

To display NFT pricing information, available quantities, and other details in the user interface, it is necessary to access the NFT metadata using the metadataByMetadataId method.

```ts
// src/hooks/useMetadataByMetadataId.ts
import { useQuery } from 'react-query';
import { metadataByMetadataId } from '@mintbase-js/data';

const useMetadataByMetadataId = ({ metadataId }) => {
  const { isLoading, data: metadata } = useQuery('metadataByMetadataId', () => metadataByMetadataId(metadataId), {
    retry: false,
    refetchOnWindowFocus: false,
    select: mapMetadata,
  });

  return { ...metadata, isTokenListLoading: isLoading };
};

export { useMetadataByMetadataId };
```

<hr class="subsection" />

### Step 5: Get Current NEAR Price

To obtain the current price of the NFT in USD, it is necessary to retrieve the current Near price. We accomplish this by using the nearPrice method.

```ts
// src/hooks/useNearPrice.ts
import { useEffect, useState } from 'react';
import { nearPrice } from '@mintbase-js/data';

const useNearPrice = () => {
  const [nearPriceData, setNearPriceData] = useState('0');

  useEffect(() => {
    const getNearPrice = async () => {
      const { data: priceData, error } = await nearPrice();
      setNearPriceData(error ? '0' : priceData);
    };

    getNearPrice();
  }, []);

  return nearPriceData;
};

export { useNearPrice };
```

<hr class="subsection" />

### Step 6: Execute the Contract Call - Buy

The execute method accepts one or more contract call objects and executes them using a specified wallet instance. In this example, we need to use the execute method to execute the "buy" call, allowing the user to purchase the desired NFT.

```ts
const singleBuy = async () => {
    const wallet = await selector.wallet();

    if (tokenId) {
      (await execute(
        { wallet, callbackArgs: callback },
        {
          ...buy({
            contractAddress: nftContractId,
            tokenId,
            affiliateAccount:
              process.env.NEXT_PUBLIC_AFFILIATE_ACCOUNT ||
              MAINNET_CONFIG.affiliate,
            marketId,
            price: nearToYocto(currentPrice?.toString()) || "0",
          }),
        }
      )) as FinalExecutionOutcome;
    }
  };
```

---

## Set ENV variables

Once that's done, copy the `.env.example` file in this directory to `.env.local` (which will be ignored by Git):

```bash
cp .env.example .env.local
```

if you use windows without powershell or cygwin:

```bash
copy .env.example .env.local
```

To get your `api key` visit :

[Mintbase Developers Page for Mainnet](https://www.mintbase.xyz/developer):
[Mintbase Developers Page for testnet](https://testnet.mintbase.xyz/developer):

```
NEXT_PUBLIC_DEVELOPER_KEY=your_mintbase_api_key
```

`NEXT_PUBLIC_NETWORK` could be `testnet` or `mainnet`

```
NEXT_PUBLIC_NETWORK=testnet
```

`NEXT_PUBLIC_STORES` is your store's ids

```
NEXT_PUBLIC_STORES=latium.mintspace2.testnet,mufasa.mintspace2.testnet
```

`NEXT_PUBLIC_AFFILIATE_ACCOUNT` is your near account where your should get your market fee

```
NEXT_PUBLIC_AFFILIATE_ACCOUNT=your_near_account.near
```

## Extending

This project is setup using Next.js + @mintbase/js
You can use this project as a reference to build your own, and use or remove any library you think it would suit your needs.

:::info Get in touch
You can get in touch with the mintbase team using the following channels:

- Support: [Join the Telegram](https://t.me/mintdev)
- Twitter: [@mintbase](https://twitter.com/mintbase)
:::

 This is the content for the doc docs/3.tutorials/templates/minter.md 

 ---
id: minter
title: NFT minter
---

# NFT Minter

[![Demo](https://img.shields.io/badge/Demo-Visit%20Demo-brightgreen)](https://minter.mintbase.xyz/)
[![Deploy](https://img.shields.io/badge/Deploy-on%20Vercel-blue)](https://vercel.com/new/clone?repository-url=https%3A%2F%2Fgithub.com%2FMintbase%2Ftemplates%2Fblob%2Fmain%2Fminter)

This is a Next.js 14 frontend minter example that includes a simple interface from which you can mint nfts easily

![img](https://i.imgur.com/QDJPsAA.png)

:::tip Mintbase Templates
This is part of the [Mintbase Templates](https://templates.mintbase.xyz/), a collection of templates that you can use to scaffold your own project
:::

---

## Project Walkthrough

This is a simple minter example built on top of **Next.js 14** using some of [@mintbase-js](https://github.com/Mintbase/mintbase-js) packages.

*NOTE: As a standard on Mintbase as we use the latest versions of Next.js we recommend using pnpm, but the package manager is up to your personal choice.*

if you dont have a store you can [deploy a new contract](https://www.mintbase.xyz/launchpad/contracts/0) on our launchpad

---

## Pre-Setup
If you would like the minter to use your own NFT contract you can easily deploy one through the mintbase market UI, additionally if you want to open up minting to be available for any person you will need to connect it to a proxy contract

### Deploying a Near Contract on Mintbase:
1. Login on Mintbase and access [Contracts Page](https://www.mintbase.xyz/launchpad/contracts/0)
2. Click on New Contract
3. Choose Store Name (this will be the contract address to add on your minsta instance, this need to be added on the `process.env.NEXT_PUBLIC_NFT_CONTRACT_ADDRESS` environment variable) and Store Symbol
4. Proceed to transaction.
5. Succeeded
6. Go to Contract Settings

<hr class="subsection" />

### Add Proxy Minter Contract
1. Under Contract Settings go to Minters
2. add `0.drop.proxy.mintbase.near` (this is the contract address that need to be added on `process.env.NEXT_PUBLIC_PROXY_MINTER_CONTRACT_ADDRESS`), and click Add Minters.
3. Proceed to transaction.
4. Succeeded

<hr class="subsection" />

### Step 1: Get the wallet connection

This method will get the wallet instance used to send the mint transaction. To learn more about this, you can check our guide at [Wallet Connection Guide](https://docs.mintbase.xyz/dev/getting-started/add-wallet-connection-to-your-react-app).

```typescript
 const getWallet = async () => {
    try {
      return await selector.wallet();
    } catch (error) {
      console.error("Failed to retrieve the wallet:", error);
      throw new Error("Failed to retrieve the wallet");
    }
  };
  ```

<hr class="subsection" />

### Step 2: Use the onSubmit method 

Get all the form data and use the onSubmit method to handle the minting process

```typescript
const onSubmit = async (data: SubmitData) => {
    const wallet = await getWallet();

    const reference = await uploadReference({
      title: typeof data?.title === "string" ? data.title : "",
      media: data?.media as unknown as File,
    });

    const file = uploadFile(data?.media as unknown as File);

    await handleMint(
      reference.id,
      file,
      activeAccountId as string,
      wallet,
      reference.media_url as string,
      data.title
    );
  };
  ```

<hr class="subsection" />

### Step 3: Upload the NFT reference

The nft reference represents the offchain data which permanently stored on IPFS on Arweave in this case you can use [@mintbase-js/data](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data) to easily upload it to arweave.

In this not only are we uploading an offchain JSON object which contains the media as well as the title but also uploading a separate media file to be included onchain.

[Learn more about how references work here](https://docs.mintbase.xyz/dev/getting-started/anatomy-of-a-non-fungible-token)

```typescript
const reference = await uploadReference({
    title: typeof data?.title === "string" ? data.title : "",
    media: data?.media as unknown as File,
  });

  const file = uploadFile(data?.media as unknown as File);
```

<hr class="subsection" />

### Step 4: Handling the mint

Here we start by configuring the callback which is the link and params to where the user will be redirected after minting after signing the mint transaction on the wallet.

In this case a number of params are included to be able to show a better success page.

The argument for calling the contracts "mint" function is then built. This transaction will be sent to the proxy contract which then calls the nft contracts nft_batch_mint method


  ```typescript
   async function handleMint(
    reference: string,
    media: Promise<ArweaveResponse>,
    activeAccountId: string,
    wallet: Wallet,
    mediaUrl: string,
    nftTitle: string
  ) {
    const callbackArgs = {
      contractAddress: MintbaseWalletSetup.contractAddress.toString(),
      amount: 1,
      ref: `${reference}`,
      mediaUrl: mediaUrl,
      title: nftTitle,
    };

    if (reference) {
      await wallet.signAndSendTransaction({
        signerId: activeAccountId,
        receiverId: proxyAddress,
        callbackUrl: cbUrl(reference, callbackArgs),
        actions: [
          {
            type: "FunctionCall",
            params: {
              methodName: "mint",
              args: {
                metadata: JSON.stringify({
                  reference,
                  media: (await media).id,
                }),
                nft_contract_id: MintbaseWalletSetup.contractAddress,
              },
              gas: "200000000000000",
              deposit: "10000000000000000000000",
            },
          },
        ],
      });
    }
  }

  return { form, onSubmit, preview, setPreview };
};

```

This sums up the blockchain portion of the code

<hr class="subsection" />

### Setup
In the `minter/src/config/setup.ts` file, we define several key configurations for interacting with the Mintbase platform. This setup is crucial for ensuring that our application communicates correctly with Mintbase smart contracts.

---

## ENV Variables

- `proxyAddress`: This is the address of the proxy contract on Mintbase. It is either taken from the environment variable `NEXT_PUBLIC_PROXY_CONTRACT_ADDRESS` or defaults to `"0.minsta.proxy.mintbase.testnet"` if the environment variable is not set.

- `contractAddress`: The address of the minting contract. Similar to `proxyAddress`, it is sourced from `NEXT_PUBLIC_MINT_CONTRACT_ADDRESS` or defaults to `"test122212.mintspace2.testnet"`.

- `network`: Indicates the blockchain network we are interacting with. It defaults to `"testnet"` if `NEXT_PUBLIC_NETWORK` is not specified in the environment.

- `callbackUrl`: A URL used for callbacks, constructed dynamically based on the `network` variable. If we are on the testnet, it uses the testnet URL; otherwise, it defaults to the mainnet URL.

To customize these configurations for different environments, you can set the following environment variables in your `.env` file:

`NOTE: the env variables need to have the NEXT_PUBLIC_ on the variable name due to be available for the browser to process`

- `NEXT_PUBLIC_PROXY_CONTRACT_ADDRESS`: Your proxy contract address on Mintbase.
- `NEXT_PUBLIC_MINT_CONTRACT_ADDRESS`: Your mint contract address on Mintbase.
- `NEXT_PUBLIC_NETWORK`: The network you want to interact with (`"testnet"` or `"mainnet"`).

after that you can run

```bash
pnpm install
pnpm dev
```

---

## Extending

This project is setup using Next.js + @mintbase/js
You can use this project as a reference to build your own, and use or remove any library you think it would suit your needs.

:::info Get in touch
You can get in touch with the mintbase team using the following channels:

- Support: [Join the Telegram](https://t.me/mintdev)
- Twitter: [@mintbase](https://twitter.com/mintbase)
:::

 This is the content for the doc docs/3.tutorials/welcome.md 

 ---
id: welcome
title: Examples & Tutorials
sidebar_label: Home
hide_table_of_contents: true
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

Explore our collection of Examples and Tutorials

<FeatureList>
  <Column title="Popular Examples">
    <Feature url="/tutorials/examples/guest-book" title="Guest Book" subtitle="Create a simple guest book" image="guest-book.png" />
    <Feature url="/tutorials/examples/donation" title="Donation" subtitle="Receive and send tokens" image="donation.png" />
    <Feature url="/tutorials/examples/xcc" title="Basic Cross-Contract Call" subtitle="Learn how to call other contracts" image="cross-call.png" />
    <Feature url="/tutorials/examples/coin-flip" title="Coin Flip Game" subtitle="Learn to create basic random numbers" image="random.png" />
    <Feature url="/tutorials/examples/factory" title="Factory Contract" subtitle="Build a contract that deploys contracts" image="factory.png" />
    <Feature url="/tutorials/examples/update-contract-migrate-state" title="Update & Migrate" subtitle="Programmatically update contracts" image="update.png" />
    <Feature url="/tutorials/examples/frontend-multiple-contracts" title="Multi-Contract Frontend" subtitle="Interact with multiple contracts" image="multiple.png" />

  </Column>
  <Column title="Popular Tutorials">
    <Feature url="/tutorials/nfts/minting-nfts" title="NFT Mint" subtitle="Mint an NFT without using code" image="frontend-bos.png" />
    <Feature url="/build/data-infrastructure/lake-framework/building-indexers/nft-indexer" title="Events (NEAR Lake)"
             subtitle="Use our Data Lake to listen for events" image="monitor.png" />
  </Column>
  <Column title="From Zero to Hero">
     <Feature url="/tutorials/auction/introduction" title="Master Applications on NEAR"
             subtitle="Learn to build a Web3 application from start to finish" image="near-zero-to-hero.png" />
    <Feature url="/tutorials/nfts/js/introduction" title="Master NFTs on NEAR (JS)" subtitle="Learn everything about NFT in JS" image="nft-marketplace-js.png" />
    <Feature url="/tutorials/nfts/introduction" title="Master NFTs on NEAR (RS)" subtitle="Learn everything about NFT in Rust" image="nft-marketplace-rs.png" />
    <Feature url="/tutorials/fts/introduction" title="Fungible Tokens 101"
             subtitle="Learn everything about fungible tokens" image="ft.png" />
    <Feature url="/tutorials/crosswords/basics/overview" title="Crossword Game" 
             subtitle="Build a Crossword Game from zero" image="crossword.png" />
  </Column>
</FeatureList>


 This is the content for the doc docs/4.tools/clear-state.md 

 ---
id: clear-state
title: "Clear Contract State"
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github} from "@site/src/components/codetabs";


This simple command-line tool allows you to clean up the state of a NEAR account without deleting it.

## How it works

This JavaScript CLI tool deploys a [`state-cleanup.wasm`](https://github.com/near-examples/near-clear-state/blob/main/contractWasm/state_cleanup.wasm) contract replacing the current one, and then uses the new contract to clean up the account's state, so you can easily redeploy a new contract or use the account in any other way.

Here's a quick snippet of the contract's main code:

<Github language="rust" url="https://github.com/near-examples/near-clear-state/blob/main/state-cleanup/src/lib.rs" start="21" end="24" />

:::tip Want to check the smart contract?

Check the GitHub repository and learn more about the [State Cleanup tool](https://github.com/near-examples/near-clear-state).

<!-- https://github.com/nameskyteam/state-cleanup -->

:::


---

## How to use


### Requirements

You'll need [NEAR CLI](cli.md). You can install it by running:

```bash
npm install -g near-cli-rs@latest
```

### Clear your Account State

To clear your Account state, follow these steps.

#### 1. Login with NEAR CLI

This will store a full access key locally on your machine.
Select the account you wish to clear the state.

```bash
near login
```

:::warning Legacy keychain
Be sure to select `Store the access key in my legacy keychain (compatible with the old near CLI)` to store the access key on the legacy keychain.
:::

#### 2. Clone the `near-clear-state` Repository

```sh
git clone https://github.com/near-examples/near-clear-state.git
```

#### 3. Install dependencies

```bash
cd near-clear-state && npm i
```

#### 4. Clear your State

```bash
npx near-clear-state clear-state --account <account-name.testnet>
```

:::tip mainnet

If you want to clean the state of a `mainnet` account, use the `--network` option:

```sh
npx near-clear-state clear-state --account <account-name.near> --network mainnet
```

:::

#### (Optional) Check your results

You can view the all the state keys have been erased in your account with:

```bash
near view-state <account-name.testnet>
```

---

## Troubleshooting

If your contract state is large, depending on the RPC node, you may get the error:

```
State of contract example.near is too large to be viewed.
```

This is an RPC issue, as the RPC node has a limited contract state view.

You can prevent the error `State of contract example.near is too large to be viewed` when calling view-state via the JSON RPC API if you select an alternative RPC provider. You can find different providers in [this RPC list](../5.api/rpc/providers.md).

<Github language="javascript" url="https://github.com/near-examples/near-clear-state/blob/main/commands/clearState.js" start="22" end="30" />

For example, you could replace the default RPC node in [`commands/clearState.js`](https://github.com/near-examples/near-clear-state/blob/main/commands/clearState.js) with another RPC server:

```js
config = {
  networkId: netId,
  keyStore,
  nodeUrl: "https://endpoints.omniatech.io/v1/near/"+ netId +"/public",
  ...
```


 This is the content for the doc docs/4.tools/cli.md 

 ---
id: near-cli
title: NEAR CLI
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The NEAR [Command Line Interface](https://github.com/near/near-cli-rs) (CLI) is a tool that enables to interact with the NEAR network directly from the shell. Among other things, the NEAR CLI enables you to:

- Create a new NEAR account
- Query information about an account
- Send Tokens such as NEAR, FTs, and NFTs
- Create, Add and Delete Account Keys
- Deploy a contract
- Call functions on a deployed contract

---

## Installation

<Tabs>
  <TabItem value="npm">

  ```bash
  npm install -g near-cli-rs@latest
  ```
  </TabItem>
  <TabItem value="Cargo">

  ```
  $ cargo install near-cli-rs
  ```
  </TabItem>
  <TabItem value="Mac and Linux (binaries)">

  ```bash
  curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near/near-cli-rs/releases/latest/download/near-cli-rs-installer.sh | sh
  ```
  </TabItem>
  <TabItem value="Windows (binaries)">

  ```bash
  irm https://github.com/near/near-cli-rs/releases/latest/download/near-cli-rs-installer.ps1 | iex
  ```
  </TabItem>
</Tabs>

---

## Configuration file
The directory with access keys and available connection networks are defined in the configuration file (`near-cli/config.toml`), which is located depending on the operating system in the following places:

- macOS: `$HOME/Library/Application Support` (e.g. `/Users/Alice/Library/Application Support`)
- Linux: `$XDG_CONFIG_HOME` or `$HOME/.config` (e.g. `/home/alice/.config`)
- Windows: `{FOLDERID*RoamingAppData}` (e.g. `C:\Users\Alice\AppData\Roaming`)

You can learn more about working with the configuration file [here](https://github.com/near/near-cli-rs/blob/main/docs/GUIDE.en.md#config---manage-connections-in-a-configuration-file).


:::tip Custom RPC
You can setup a custom [RPC server](../api/rpc/providers) by changing the `rpc_url` parameter in `near-cli` settings:

```bash
near config edit-connection testnet --key rpc_url --value https://archival-rpc.testnet.near.org/
```
:::


---

## Interactive mode

To use the `near-cli` simply run the following in your terminal.

```bash
$ near
```

You should then see the following. Use the arrow keys and hit `enter` or simply type out one of the available options to select an option

![](/docs/assets/near-cli-rs.png)

:::important
We provide examples only of the most used commands. Such commands may have two versions - a **full** one and a **short** one. If you want to explore all options provided by `near-cli` use the interactive mode described above.
:::

---

## Account

This option will allow you to manage, control, and retrieve information on your accounts.

### Summary

`view-account-summary` - view properties for an account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

    ```bash
    export ACCOUNT_ID=bob.testnet
    near account view-account-summary $ACCOUNT_ID network-config testnet now
    ```
  </TabItem>
  <TabItem value="Short">

    ```bash
    export ACCOUNT_ID=bob.testnet
    near state $ACCOUNT_ID --networkId testnet
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Import

`import-account` - import existing account (a.k.a. "sign in").

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  near account import-account using-web-wallet network-config testnet
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  near login --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Export

`export-account` - export existing account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near account export-account $ACCOUNT_ID using-web-wallet network-config testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Create

`create-account` - create a new account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near account create-account sponsor-by-faucet-service $ACCOUNT_ID autogenerate-new-keypair save-to-keychain network-config testnet create
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near create-account $ACCOUNT_ID --useFaucet --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Delete

`delete-account` - delete an account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export BENEFICIARY_ID=alice.testnet

  near account delete-account $ACCOUNT_ID beneficiary $BENEFICIARY_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export BENEFICIARY_ID=alice.testnet

  near delete-account $ACCOUNT_ID $BENEFICIARY_ID --networkId testnet
  ```
  </TabItem>
</Tabs>

---

## Keys

Showing, adding and removing account keys.

### List keys

`list-keys` - view a list of keys for an account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near account list-keys $ACCOUNT_ID network-config testnet now
  ```
  </TabItem>

  <TabItem value="Short">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near list-keys $ACCOUNT_ID --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Add key

`add-key` - add an access key to an account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near account add-key $ACCOUNT_ID grant-full-access use-manually-provided-public-key ed25519:CXqAs8c8kZz81josLw82RQsnZXk8CAdUo7jAuN7uSht2 network-config testnet sign-with-keychain send
  ```

  </TabItem>
  <TabItem value="Short">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near add-key $ACCOUNT_ID ed25519:CXqAs8c8kZz81josLw82RQsnZXk8CAdUo7jAuN7uSht2 --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Delete key

`delete-keys` - delete an access key from an account.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near account delete-keys $ACCOUNT_ID public-keys ed25519:HdkFZFEPoWfgrrLK3R4t5dWtNoLC8WymBzhCXoP3zrjh network-config testnet sign-with-keychain send
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near delete-key $ACCOUNT_ID ed25519:HdkFZFEPoWfgrrLK3R4t5dWtNoLC8WymBzhCXoP3zrjh --networkId testnet
  ```
  </TabItem>
</Tabs>

---

## Tokens

This will allow you to manage your token assets such as NEAR, FTs and NFTs.

### Send NEAR

`send-near` - transfers NEAR to a specified recipient in units of NEAR or yoctoNEAR.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export RECEIVER_ID=alice.testnet
  near tokens $ACCOUNT_ID send-near $RECEIVER_ID '0.5 NEAR' network-config testnet sign-with-keychain send
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export RECEIVER_ID=alice.testnet

  near send-near $ACCOUNT_ID $RECEIVER_ID 0.5 --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Send FT

`send-ft` - transfer Fungible Tokens to a specified user.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export RECEIVER_ID=alice.testnet
  export FT_CONTRACT_ID=0c97251cd1f630c444dbusdt.testnet

  near tokens $ACCOUNT_ID send-ft $FT_CONTRACT_ID $RECEIVER_ID amount-ft '1 USDT' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Send NFT

`send-nft` - transfers NFTs between accounts.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export RECEIVER_ID=alice.testnet
  export NFT_CONTRACT_ID=nft.examples.testnet

  near tokens $ACCOUNT_ID send-nft $NFT_CONTRACT_ID $RECEIVER_ID 1 --prepaid-gas '100.0 Tgas' --attached-deposit '1 yoctoNEAR' network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### View NEAR balance

`view-near-balance` - view the balance of NEAR tokens.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  near tokens $ACCOUNT_ID view-near-balance network-config testnet now
  ```

  </TabItem>
</Tabs>

<hr class="subsection" />

### View FT balance

`view-ft-balance` - view the balance of Fungible Tokens.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export FT_CONTRACT_ID=0c97251cd1f630c444dbusdt.testnet
  near tokens $ACCOUNT_ID view-ft-balance $FT_CONTRACT_ID network-config testnet now
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### View NFT balance

`view-nft-assets` - view the balance of NFT tokens.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export ACCOUNT_ID=bob.testnet
  export NFT_CONTRACT_ID=nft.examples.testnet
  near tokens $ACCOUNT_ID view-nft-assets $NFT_CONTRACT_ID network-config testnet now
  ```
  </TabItem>
</Tabs>

---

## Contract

This option allows you to manage and interact with your smart contracts.

### Call

`call-function` - execute function (contract method).

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  # View method
  export CONTRACT_ID=nft.examples.testnet
  near contract call-function as-read-only $CONTRACT_ID nft_tokens json-args '{"from_index": "0", "limit": 2}' network-config testnet now

  # Call method
  export ACCOUNT_ID=bob.testnet
  near contract call-function as-transaction $CONTRACT_ID nft_mint json-args '{"metadata": {"copies": 1, "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "title": "GO TEAM"}, "receiver_id": "bob.testnet", "token_id": "5895"}' prepaid-gas '100.0 Tgas' attached-deposit '0.1 NEAR' sign-as $ACCOUNT_ID network-config testnet sign-with-keychain send
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  # View method
  export CONTRACT_ID=nft.examples.testnet
  near view $CONTRACT_ID nft_tokens '{"from_index": "0", "limit": 2}' --networkId testnet

  # Call method
  export ACCOUNT_ID=bob.testnet
  near call $CONTRACT_ID nft_mint '{"metadata": {"copies": 1, "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "title": "GO TEAM"}, "receiver_id": "bob.testnet", "token_id": "5896"}' --deposit 0.1 --useAccount $ACCOUNT_ID --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Deploy

`deploy` - add a new contract code.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export CONTRACT_ID=contract.testnet
  near contract deploy $CONTRACT_ID use-file ../target/near/contract.wasm without-init-call network-config testnet sign-with-keychain send
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  export CONTRACT_ID=contract.testnet
  near deploy $CONTRACT_ID ../target/near/contract.wasm --networkId testnet
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Inspect

`inspect` - get a list of available function names.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  export CONTRACT_ID=nft.examples.testnet
  near contract view-storage $CONTRACT_ID all as-text network-config testnet now
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  export CONTRACT_ID=nft.examples.testnet
  near storage $CONTRACT_ID --finality final --utf8 --networkId testnet
  ```
  </TabItem>
</Tabs>

---

## Transaction

Operate transactions.

### View status

`view-status` - view a transaction status.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  near transaction view-status BFrVVtjqD2p1zYX1UCvn4nJpy7zPHpY5cTgQaKCZjBvw network-config testnet
  ```
  </TabItem>
  <TabItem value="Short">

  ```bash
  near tx-status BFrVVtjqD2p1zYX1UCvn4nJpy7zPHpY5cTgQaKCZjBvw --networkId testnet
  ```
  </TabItem>
</Tabs>

---

## Config

Manage the connection parameters inside the `config.toml` file for `near-cli`.

This will allow you to change or modify the network connections for your CLI.

### Show connections

`show-connections` - show a list of network connections.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  near config show-connections
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Edit connection

`edit-connection` - edit a network connection.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

  ```bash
  near config edit-connection testnet --key rpc_url --value https://test.rpc.fastnear.com
  ```
  </TabItem>
</Tabs>

---

:::important
We provide examples only of the most used commands. If you want to explore all options provided by `near-cli` use [the interactive mode](#interactive-mode).
:::

---

## Validators

You can use the following commands to interact with the blockchain and view validator stats. There are three reports used to monitor validator status:

- [Proposals](#proposals)
- [Current validators](#current-validators)
- [Next validators](#next-validators)

:::tip
To use these commands, you **must** install the CLI [validator extension](#validator-extension).
:::

### Validator Extension

If you want to interact with [NEAR Validators](https://pages.near.org/papers/economics-in-sharded-blockchain/#validators) from command line, you can install the [NEAR Validator CLI Extension](https://github.com/near-cli-rs/near-validator-cli-rs):

<Tabs>
  <TabItem value="npm">

  ```bash
  npm install -g near-validator
  ```
  </TabItem>
  <TabItem value="Cargo">

  ```bash
  $ cargo install near-validator
  ```
  </TabItem>
  <TabItem value="Mac and Linux (binaries)">

  ```bash
  curl --proto '=https' --tlsv1.2 -LsSf https://github.com/near-cli-rs/near-validator-cli-rs/releases/latest/download/near-validator-installer.sh | sh
  ```
  </TabItem>
  <TabItem value="Windows (binaries)">

  ```bash
  irm https://github.com/near-cli-rs/near-validator-cli-rs/releases/latest/download/near-validator-installer.ps1 | iex
  ```
  </TabItem>
</Tabs>

### Proposals

A proposal by a validator indicates they would like to enter the validator set, in order for a proposal to be accepted it must meet the minimum seat price.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near-validator proposals network-config mainnet
```

  </TabItem>
</Tabs>

### Current Validators

This shows a list of active validators in the current epoch, the number of blocks produced, number of blocks expected, and online rate. Used to monitor if a validator is having issues.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near-validator validators network-config mainnet now
```

  </TabItem>
</Tabs>

### Next Validators

This shows validators whose proposal was accepted one epoch ago, and that will enter the validator set in the next epoch.

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near-validator validators network-config mainnet next
```

  </TabItem>
</Tabs>

### Staking

For validators, there's also an option to stake NEAR tokens without deploying a staking pool smart contract.

#### View validator stake

To view the validator's stake on the last block, you need to enter in the terminal command line:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near-validator staking view-stake examples.testnet network-config testnet now
```

  </TabItem>
</Tabs>

#### Stake directly without a staking pool

To stake the amount you must enter in the terminal command line:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near-validator staking stake-proposal examples.testnet ed25519:AiEo5xepXjY7ChihZJ6AsfoDAaUowhPgvQp997qnFuRP '1500 NEAR' network-config testnet sign-with-keychain send
```

  </TabItem>
</Tabs>

#### Unstake directly without a staking pool

To unstake you must enter in the terminal command line:

<Tabs groupId="cli-commands">
  <TabItem value="Full">

```sh
near-validator staking unstake-proposal examples.testnet ed25519:AiEo5xepXjY7ChihZJ6AsfoDAaUowhPgvQp997qnFuRP network-config testnet sign-with-keychain send
```

  </TabItem>
</Tabs>


 This is the content for the doc docs/4.tools/ecosystem-apis/fastnear-api.md 

 ---
id: fastnear
title: FastNEAR
---

[FastNEAR](https://fastnear.com/) allows to easily query the NEAR blockchain to get an account's assets, map keys into account IDs, explore a block's transactions, etc.

Possible use cases include:
- Querying all assets of an account (including fungible and non-fungible tokens)
- Querying the last block produced
- Mapping Public Key to Account ID
- Mapping Full Access Public Key to Account ID
- Knowing a user's staking pools (validators)
- Querying the top holders of a token

:::tip Documentation

[Click here](https://github.com/fastnear/fastnear-api-server-rs?tab=readme-ov-file#api-v1) to see the complete list of endpoints and usage examples

:::

---

## Endpoints

The [FastNEAR Server](https://github.com/fastnear/fastnear-api-server-rs) provides a low-latency endpoint for wallets and explorers.

- Mainnet: `https://api.fastnear.com`
- Testnet: `https://test.api.fastnear.com`

---

## Examples

### [Query last block produced](https://github.com/fastnear/neardata-server/)

```bash
curl https://mainnet.neardata.xyz/v0/last_block/final
```

<details>
  <summary> Response </summary>

```json
  {
    "block": {
      "author": "aurora.pool.near",
      "header": {
        "height": 129311487,
        "prev_height": 129311486,
        ...
      }
    }
  }
```

</details>

<hr className="subsection"/>

### [Query User's Balance](https://github.com/fastnear/fastnear-api-server-rs)

```bash
# Query user's FTs
curl https://api.fastnear.com/v1/account/root.near/ft
```

<details>
  <summary> Response </summary>

```json
{"account_id":"root.near","tokens":[{"balance":"199462092","contract_id":"pixeltoken.near","last_update_block_height":null},...
```

</details>

<hr className="subsection"/>

```sh
# Query user's NFTs
curl https://api.fastnear.com/v1/account/root.near/nft
```

<details>
  <summary> Response </summary>

```json
{"account_id":"root.near","tokens":[{"contract_id":"nft.goodfortunefelines.near","last_update_block_height":null},...
```

</details>

<hr className="subsection"/>

```sh
# Query all user's assets
curl https://api.fastnear.com/v1/account/root.near/full
```

<details>
  <summary> Response </summary>

```json
  {
    "account_id": "root.near",
    "tokens": [
      { "balance": "199462092", "contract_id": "the-token.near" },
      ...
    ]
  }
```

</details>


 This is the content for the doc docs/4.tools/ecosystem-apis/nearblocks-api.md 

 ---
id: nearblocks
title: NearBlocks
---

[NearBlocks](https://api.nearblocks.io/api-docs/) provides an endpoint to query actions that happened on a NEAR account, possible use cases include:

- Query an account balance
- Query all function calls to specific contract
- Get total NEAR supply and circulating supply
- Query the number of total transactions on NEAR 

:::tip Documentation 

You can find the complete endpoint list in [this page](https://api.nearblocks.io/api-docs/)

:::

---

## Endpoints

- Mainnet: `https://api.nearblocks.io`
- Testnet: `https://api-testnet.nearblocks.io`

:::note
NearBlocks API supports `GET` requests only.
:::

If you have a Pro subscription, you can pass the API key into a REST API call as `Authorization` header with the following format. Replace `API_KEY` with the key string of your API key. For example, to pass an API key for an Account API:

```sh
 curl -X GET -H "Authorization: Bearer API_KEY" "https://api.nearblocks.io/v1/account/wrap.near"
 ```
---

## Examples

All the transactions where somebody called `create_drop` on Keypom

```bash
curl -X GET "https://api.nearblocks.io/v1/account/v2.keypom.near/txns?method=create_drop"
```

<details>
  <summary> Response </summary>

```json
{"cursor":"10055367839","txns":[{"id":"10830753377","receipt_id":"5F79mMVCnRrHRbdYmrSPjRwnAgUBc3H2okMHo69cZcJV","predecessor_account_id":"dragov.near","receiver_account_id":"v2.keypom.near","receipt_kind":"ACTION","receipt_block":{"block_hash":"E3KaP9w1y8CzWFajYBjx9oJFuhjjXuM8vaNPdnAXJeHp","block_height":134346961,"block_timestamp":1733475275522260000},"receipt_outcome":{"gas_burnt":5361098685764,"tokens_burnt":536109868576400000000,"executor_account_id":"v2.keypom.near","status":true},"transaction_hash":"9Y6WvywzX23YLCEuoXDqcaYJMRYihpXWwb4gsBwuXJFX","included_in_block_hash":"yfiq5z1JK6xUzdJk71W1N8yiK65Xt7xFXs6aiKLDtSH","block_timestamp":"1733475274374657534","block":{"block_height":134346960},"receipt_conversion_tokens_burnt":"31845454987000000000","actions":[{"action":"FUNCTION_CALL","method":"create_drop","deposit":1.0426e+24,"fee":536109868576400000000,"args":"{\"drop_id\": \"1733475264350\", \"metadata\": \"{\\\\\\\\\\\\\\\"dropName\\\\\\\\\\\\\\\":\\\\\\\\\\\\\\\"Vrscert NEAR account creation \\\\\\\\\\\\\\\"}\", \"public_keys\": [\"ed25519:DJrjp8VpUKn3dnfV7Yyt2BHCC3wujjjjynUHhkrJWpVQ\"], \"deposit_per_use\": \"1000000000000000000000000\"}"}],"actions_agg":{"deposit":1.0426e+24},"outcomes":{"status":true},"outcomes_agg":{"transaction_fee":588989004589500000000}}, ...
```

</details>

<hr className="subsection" />

All the times that `gagdiez.near` called `create_drop` on Keypom

```sh
curl -X GET "https://api.nearblocks.io/v1/account/v2.keypom.near/txns?method=create_drop&from=gagdiez.near"
```

<details>
  <summary> Response </summary>

```json
{
  "txns": [
    {
      "predecessor_account_id": "gagdiez.near",
      "receiver_account_id": "v2.keypom.near",
      "receipt_kind": "ACTION",
      "receipt_outcome": {
        "status": true,
        ...
      },
      ...
    }
  ]
}
```

</details>


 This is the content for the doc docs/4.tools/ecosystem-apis/pikespeak-api.md 

 ---
id: pikespeak
title: Pikespeak
---

[Pikespeak](https://pikespeak.ai) allows you to fetch blockchain events and aggregated analytics on wallets, validators, delegators, money transfers, dApps activity, and more.

Use case includes:
- Querying account balances
- Querying the most active wallets
- Querying historic account events

:::tip Documentation

You can find the complete API endpoint list in [this page](https://doc.pikespeak.ai/)

:::

---

## Endpoints

To access the Pikespeak API you'll need to [register and create an account](https://pikespeak.ai/plans). Once you're registered, under the [`My Account`](https://pikespeak.ai/myaccount) page you can get your API key.

- Mainnet: `https://api.pikespeak.ai`

---

## Examples

Check the account balance for `root.near`:

```sh
curl -X 'GET' \
  'https://api.pikespeak.ai/account/balance/root.near' \
  -H 'accept: application/json' \
  -H 'x-api-key: YOUR-PIKESPEAK-API-KEY'
```

<details>
  <summary> Response </summary>

```json
[
  {
    "contract": "Near",
    "amount": 5796.337470826706,
    "symbol": "NEAR",
    "isParsed": true,
    "icon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA2AAAANgCAIAAADF8JzzAAA...
  }
]
```

</details>

<hr className="subsection" />

Most active wallets NEAR senders:

```sh
curl -X 'GET' \
  'https://api.pikespeak.ai/hot-wallets/near' \
  -H 'accept: application/json' \
  -H 'x-api-key: YOUR-PIKESPEAK-API-KEY'
```

<details>
  <summary> Response </summary>

```json
{
  "totalAmount": "43620883.893401468080059376309428",
  "totalUSDValue": "0",
  "topAccounts": [
    {
      "account": "jap1m48ko2uu.users.kaiching",
      "amount": "0.00642925390730650000000",
      "txCount": "1",
      "usdValue": "0"
    },
    {
      "account": "jb6050zkcoky.users.kaiching",
      "amount": "0.00924935417618550000000",
      "txCount": "1",
      "usdValue": "0"
    },
    ...
    ]
}
```

</details>

<hr className="subsection" />

Get historic account events for `keypom.near`:

```sh
curl -X 'GET' \
  'https://api.pikespeak.ai/event-historic/keypom.near' \
  -H 'accept: application/json' \
  -H 'x-api-key: YOUR-PIKESPEAK-API-KEY'
```

<details>
  <summary> Response </summary>

```json
[
  {
    "direction": "send",
    "transaction_id": "Beh3TGHXWveH7n2aWmPoVUsFMuMSWUyKStZNccYbnUJA",
    "receipt_id": "DvMhKedP25koZTw2RJ2DW3A8Ch4C7FsrZQZFv8hNCRkk",
    "index": 0,
    "sender": "keypom.near",
    "receiver": "chaotictempest.near",
    "type": "NEAR_TRANSFER",
    "block_height": "132716642",
    "timestamp": "1731632151999",
    "transaction_type": "SEND_RECEIVE",
    "token": null,
    "2fa": false,
    "amount": "5.00000000000000000000000",
    "transaction_view": {
      "type": "NEAR_TRANSFER",
      "index": 0,
      "amount": 5,
      "sender": "keypom.near",
      "status": true,
      "two_fa": false,
      "receiver": "chaotictempest.near",
      "timestamp": 1731635751999756300,
      "receipt_id": "DvMhKedP25koZTw2RJ2DW3A8Ch4C7FsrZQZFv8hNCRkk",
      "block_height": 132716642,
      "transaction_id": "Beh3TGHXWveH7n2aWmPoVUsFMuMSWUyKStZNccYbnUJA",
      "transaction_type": "SEND_RECEIVE"
    },
    "amount_numeric": "5.00000000000000000000000"
  },
  ...
]
```

</details>


 This is the content for the doc docs/4.tools/explorer.md 

 ---
id: explorer
title: Explorer
sidebar_label: Explorers
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Explorers are web applications that allows you to quickly obtain information from the blockchain through a friendly user interface:

1. Check the balance of an account
2. Search for a transactions and its receipts
3. Check the history of interactions in an account / contract
4. View block creations in real time

---

## NearBlocks

Created by the community, [NearBlocks](https://nearblocks.io/) enables to check accounts and transactions with an interface similar to etherscan.

![NearBlocks](/docs/assets/explorers/nearblocks.png)
*Main page of [NearBlocks](https://nearblocks.io/)*

<hr className="subsection"/>

## Nearscope

[Nearscope](https://nearscope.net/) provides a NEAR node validator and delegator explorer.

![Nearscope](/docs/assets/explorers/nearscope.png)
*Main page of [Nearscope](https://nearscope.net/)*

<hr className="subsection"/>

## DappLooker

[DappLooker](https://dapplooker.com/) lets you analyze and query NEAR blockchain data, build dashboards to visualize data and share with your community.

![DappLooker](/docs/assets/explorers/dapplooker.png)
*Main page of [DappLooker](https://dapplooker.com/)*

<hr className="subsection"/>

## Pikespeak

[Pikespeak](https://pikespeak.ai/) provides access to real-time and historical data on the NEAR Protocol.

![Pikespeak](/docs/assets/explorers/pikespeak.png)
*Main page of [Pikespeak](https://pikespeak.ai/)*

## NEARCatalog

[NEARCatalog](https://dev.near.org/applications) provides access to trending decentralized applications (DApps) on the NEAR Protocol.


![Nearcatalog](/docs/assets/explorers/nearcatalog.png)
*Main page of [NEARCatalog](https://dev.near.org/applications)*


 This is the content for the doc docs/4.tools/indexing-tools.md 

 ---
id: indexing
title: Indexing Solutions on NEAR
sidebar_label: "Indexing Solutions"
---

Indexers are services that are constantly listening to the blockchain, processing the transactions and storing them in a database that can be easily queried.

Indexers are used by apps that need to access blockchain data efficiently, such as wallets and explorers.

- [BigQuery](../2.build/6.data-infrastructure/big-query.md): Blockchain data indexing in NEAR Public Lakehouse is for anyone wanting to understand blockchain data.

- [NEAR Lake Framework](../2.build/6.data-infrastructure/lake-framework/near-lake.md): a companion library to NEAR Lake. It allows you to build your own indexer that watches a stream of blocks **from a NEAR Lake data source** and allows you to **create your own logic to process that data**. Keep in mind this is **the one you want to use for future projects**, instead of the Indexer Framework. Read [why it is better](/build/data-infrastructure/lake-framework/near-lake-framework#how-does-it-compare-to-near-indexer-framework).

- [Indexer.xyz Multichain Indexer](https://indexer.xyz/): Indexer.xyz is an application layer that you can build your NFT or DeFi applications entirely on top of. In addition to raw transaction indexing, Indexer.xyz provides you with a standardized GraphQL API layer to easily tap into transactions across contracts and chains.

- [The Graph](https://thegraph.com/docs/en/cookbook/near/): development tools to process blockchain events and make the resulting data easily available via a GraphQL API, known individually as a subgraph. [Graph Node](https://github.com/graphprotocol/graph-node) is able to process NEAR events, which means that NEAR developers can build subgraphs to index their smart contracts.

- [GetBlock](https://getblock.io/explorers/near/blocks/): developer tools offering a simple and reliable API access to multiple blockchains including NEAR Protocol.

- [NearBlocks](https://api.nearblocks.io/api-docs/#/): build precise & reliable dApps with NearBlocks APIs.

- [Covalent](https://www.covalenthq.com/docs/networks/aurora/): for [Aurora EVM](https://aurora.dev/) indexing, Covalent provides a unified API bringing visibility to billions of Web3 data points.

- [NEAR Indexer Framework](https://github.com/near/nearcore/tree/master/chain/indexer): a micro-framework providing you with a "live" stream of blocks. Useful to handle on-chain real-time `events`.

- [NEAR Indexer for Explorer](https://github.com/near/near-indexer-for-explorer): an indexer built on top of the indexer microframework. It watches and stores all events/data from the blockchain to a **PostgreSQL database**.
  You can clone the [GitHub repository](https://github.com/near/near-indexer-for-explorer) and customize your own indexer solution.

- [SubQuery](https://academy.subquery.network/quickstart/quickstart_chains/near.html): is an end to end multi-blockchain indexing solution that provides NEAR developers with fast, flexible, universal, open source and decentralized APIs for web3 projects. The [NEAR starter project](https://github.com/subquery/near-subql-starter/tree/main/Near/near-starter) provides a template for developers to get up and running within minutes.


 This is the content for the doc docs/4.tools/near-api.md 

 ---
id: near-api
title: NEAR API
sidebar_label: NEAR API
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github, Language} from "@site/src/components/codetabs"

The NEAR API is a set of libraries that allow you to interact with the NEAR blockchain. You can use it to in frontend and backend applications to:

- Call functions on a deployed contract
- Query information about an account
- Create NEAR accounts
- Send Tokens such as NEAR, FTs, and NFTs
- Create, Add and Delete Account Keys
- Deploy a contract

Our API is available in multiple languages, including:
- JavaScript: [`near-api-js`](https://github.com/near/near-api-js)
- Rust: [`near-api-rs`](https://github.com/near/near-api-rs)
- Python: [`py-near`](https://github.com/pvolnov/py-near)

:::tip Wallet Integration
To allow users to login into your web application using a wallet you will need the `wallet-selector`. Read more in our [Web Frontend integration](/build/web3-apps/integrate-contracts) article
:::

---

## Install

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">
  Include `near-api-js` as a dependency in your package.

  ```bash
  npm i near-api-js
  ```

  :::tip Static HTML
  If you are building a site without using `npm`, you can include the library directly in your HTML file through a CDN.

  ```html
  <script src="https://cdn.jsdelivr.net/npm/near-api-js/dist/near-api-js.min.js"></script>
  ```
  :::

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  ```bash
  cargo add near-api
  ```
  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```shell
  pip install py-near
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Import {#import}

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">
  You can use the API library in the browser, or in Node.js runtime. 

  <Github fname="send-tokens.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/send-tokens.js#L1"
    start="1" end="1" />

  <details>
    <summary>Using the API in Node.js</summary>

    All these examples are written for the browser, to use these examples in Node.js you should convert the project to an ES module. To do this, add the following to your `package.json`:

  <Github fname="package.json" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/package.json#L1-L2"
    start="1" end="2" />

  </details>

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  The methods to interact with the NEAR API are available through the `prelude` module.

  <Github fname="send_tokens.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/send_tokens.rs#L2"
    start="2" end="2" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  You can use the NEAR API by importing the `py_near` package, either entirely
  ```python
  import py_near
  ```

  or only the parts you need, for example:
  ```python
  from py_near.account import Account
  from py_near.providers import JsonProvider
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Connecting to NEAR {#connect}

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  The object returned from `connect` is your entry-point for all commands in the API.
  To transactions you'll need a [`KeyStore`](#key-handlers-stores--signers).

  <Github fname="send-tokens.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/send-tokens.js#L17-L22"
    start="17" end="22" />

  <details>
    <summary>Mainnet/Localnet connection</summary>

    ```js
    // Mainnet config example
    const connectionConfig = {
      networkId: "mainnet",
      keyStore: myKeyStore,
      nodeUrl: "https://rpc.mainnet.near.org",
    };

    // Localnet config example
    const connectionConfig = {
      networkId: "local",
      nodeUrl: "http://localhost:3030",
    };
    ```
  </details>

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  To interact with the blockchain you'll need to create a `NetworkConfig` object.

  Preset connections `mainnet` and `testnet` are available that come with standard configurations for each network.

  <Github fname="send_tokens.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/send_tokens.rs#L19"
    start="19" end="19" />

  You can also create your own custom connection.

  <Github fname="custom_rpc.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/custom_rpc.rs#L6-L16"
    start="6" end="16" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Key Handlers: Stores & Signers 

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  To sign transactions you'll need to a `KeyStore` with valid keypairs.

  <Tabs>
  <TabItem value="browser" label="Browser" default>

  `BrowserLocalStorageKeyStore` can only be used in the browser, it uses the browser's local storage to store the keys.

  ```js
  // Creates keyStore using private key in local storage

  const { keyStores } = nearAPI;
  const myKeyStore = new keyStores.BrowserLocalStorageKeyStore();
  ```

  </TabItem>
  <TabItem value="dir" label="Credentials Path">

  `UnencryptedFileSystemKeyStore` can be used is used to load keys from the legacy credentials directory used by the NEAR CLI.

  <Github fname="credentials-directory.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keystore-options/credentials-directory.js#L11-L13"
    start="11" end="13" />

  </TabItem>
  <TabItem value="file" label="File">

  Keystores can be created by loading a private key from a json file.

  <Github fname="credentials-file.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keystore-options/credentials-file.js#L10-L16"
    start="10" end="16" />

  </TabItem>
  <TabItem value="key" label="Private Key">

  Keystores can be created by using a private key string.

  Private keys have the format "ed25519:5Fg2...".

  <Github fname="private-key-string.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keystore-options/private-key-string.js#L10-L12"
    start="10" end="12" />

  </TabItem>
  <TabItem value="seed" label="Seed Phrase">

  Keystores can be created by using a seed phrase. To parse the seed phrase into a private key, the `near-seed-phrase` library is needed.

  ```bash
  npm i near-seed-phrase
  ```

  Seed phrases have the format "shoe three gate ..." and are usually 12 words long.

  <Github fname="seed-phrase.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keystore-options/seed-phrase.js#L11-L14"
    start="11" end="14" />

  </TabItem>
  </Tabs>
  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

  To sign transactions you'll need to create a `Signer` that holds a valid keypair.

  <Tabs>
  <TabItem value="keystore" label="Keystore" default>

  Signers can be created using the Keystore that is also used as the standard for saving keys with the NEAR CLI.

  <Github fname="keystore.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/signer_options/keystore.rs#L12-L18"
    start="12" end="18" />

  </TabItem>
  <TabItem value="dir" label="Credentials Path">

  Signers can be created using the credentials directory which is the legacy option for saving keys with the NEAR CLI.

  <Github fname="credentials_directory.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/signer_options/credentials_directory.rs#L10-L13"
    start="10" end="13" />

  </TabItem>
  <TabItem value="file" label="File">

  Signers can be created by loading a public and private key from a file.

  <Github fname="credentials_file.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/signer_options/credentials_file.rs#L12-L13"
    start="12" end="13" />

  </TabItem>
  <TabItem value="key" label="Private Key">

  Signers can be created by using a private key string.

  Private keys have the format "ed25519:5Fg2...".

  <Github fname="private_key_string.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/signer_options/private_key_string.rs#L13-L14"
    start="13" end="14" />

  </TabItem>
  <TabItem value="seed" label="Seed Phrase">

  Signers can be created by using a seed phrase.

  Seed phrases have the format "shoe three gate ..." and are usually 12 words long.

  <Github fname="seed_phrase.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/signer_options/seed_phrase.rs#L11-L12"
    start="11" end="12" />

  </TabItem>
    </Tabs>

  </TabItem>
  <TabItem value="python" label="üêç Python">
  TODO: not exactly the same in Python, it's more and account + RPC URL, or a JSON RPC provider
  </TabItem>
</Tabs>


  <hr class="subsection" />

  ### RPC Failover

  RPC providers can experience intermittent downtime, connectivity issues, or rate limits that cause client transactions to fail. This can be prevented by using the `FailoverRpcProvider` that supports multiple RPC providers.

  <Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="rpc-failover.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/rpc-failover.js#L12-L34"
    start="12" end="34" />

  </TabItem>
  <TabItem value="python" label="üêç Python">
    You can pass multiple RPC providers to `JsonRpcProvider`

    ```python
    from py_near.providers import JsonProvider

    provider = JsonProvider(["https://test.rpc.fastnear.com", "https://rpc.testnet.pagoda.co"])
    ```
  </TabItem>
</Tabs>

---

## Account

### Instantiate Account {#instantiate-account}

This will return an Account object for you to interact with.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="account-details.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/account-details.js#L9"
    start="9" end="9" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="account_details.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/account_details.rs#L5-L7"
    start="5" end="7" />

  </TabItem>
  <TabItem value="python" label="üêç Python">
    You can instantiate any account with the following code:

    ```python
    from py_near.account import Account

    account = Account(account_id="example-account.testnet", rpc_addr="https://rpc.testnet.pagoda.co")
    await account.startup()
    ```

    If you want to use it to submit transactions later, you need to also pass the `private_key` param:

    ```python
    account = Account(account_id="example-account.testnet", private_key="ed25519:...", rpc_addr="https://rpc.testnet.pagoda.co")
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Get Balance {#get-balance}

Gets the available and staked balance of an account in yoctoNEAR.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="account-details.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/account-details.js#L12"
    start="12" end="12" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="account_details.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/account_details.rs#L13-L18"
    start="13" end="18" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

    ```python
    from py_near.account import Account

    account = Account(account_id="example-account.testnet", rpc_addr="https://rpc.testnet.pagoda.co")
    await account.startup()

    account_balance = account.get_balance()
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Get State {#get-state}

Get basic account information, such as its code hash and storage usage.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="account-details.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/account-details.js#L16"
    start="16" end="16" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">
  
  <Github fname="account_details.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/account_details.rs#L21-L21"
    start="21" end="21" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

    ```python
    from py_near.account import Account

    account = Account(account_id="example-account.testnet", rpc_addr="https://rpc.testnet.pagoda.co")
    await account.startup()

    account_state = account.fetch_state()
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Get Details {#get-details}

Returns the authorized apps of an account. This is a list of contracts that the account has function call access keys for.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="account-details.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/account-details.js#L20"
    start="20" end="20" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Create an Account {#create-account}

In order to create .near or .testnet accounts, you need to make a function call to the top-level-domain account (i.e. `near` or `testnet`), calling `create_account`. In this example we generate a new public key for the account by generating a random private key.

The deposit determines the initial balance of the account.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="create-account.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/create-account.js#L24-L39"
    start="24" end="39" />

  <details>
    <summary>Creating an account from a seed phrase</summary>

    You can also create an account with a public key that is derived from a randomly generated seed phrase.

    <Github fname="create-account-from-seed.js" language="javascript"
      url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/create-account-from-seed.js#L26-L39"
      start="26" end="39" />

  </details>

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="create_account.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/create_account.rs#L32-L49"
    start="32" end="49" />

  <details>
    <summary>Creating an account from a seed phrase</summary>

    You can also create an account via a randomly generated seed phrase.

    <Github fname="create_account_from_seed.rs" language="rust"
      url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/create_account_from_seed.rs#L32-L48"
      start="32" end="48" />

  </details>

  </TabItem>
  <TabItem value="python" label="üêç Python">
  
    ```python
    await account.function_call("testnet", "create_account", {"new_account_id": "example-account.testnet", "new_public_key": "ed25519:..."}, "30000000000000", 1 * NEAR)
    ```

  </TabItem>

</Tabs>

<hr class="subsection" />

### Create a Sub-Account {#create-sub-account}

Accounts can create sub-accounts of themselves, which are useful for creating separate accounts for different purposes. It is important to remark that the parent account has no control over any of its sub-accounts.

The deposit determines the initial balance of the account.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="create-account.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/create-account.js#L45-L56"
    start="45" end="56" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="create_account.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/create_account.rs#L65-L82"
    start="65" end="82" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

    Create a sub-account and fund it with your main account:

    ```python
    from py_near.account import Account
    from py_near.dapps.core import NEAR

    account = Account(account_id="example-account.testnet", private_key="ed25519:...", rpc_addr="https://rpc.testnet.pagoda.co")
    await account.startup()

    res = account.create_account(account_id="sub.example-account.testnet", public_key="...", initial_balance=1 * NEAR))
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Delete Account {#delete-account}

When deleting an account, you need to specify a beneficiary account id. This is the account that will receive the remaining NEAR balance of the account being deleted. 

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="delete-account.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/delete-account.js#L45-L46"
    start="45" end="46" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="delete_account.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/delete_account.rs#L54-L59"
    start="54" end="59" />

  </TabItem>
</Tabs>

:::warning

Only NEAR tokens will be transferred to the beneficiary, so you should transfer all your FTs, NFTs, etc. to another account before deleting.

:::

:::danger

If the beneficiary account does not exist, the NEAR tokens will be burned

:::

---

## Transactions

### Send Tokens {#send-tokens}

Transfer NEAR tokens between accounts. 

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="send-tokens.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/send-tokens.js#L27-L30"
    start="27" end="30" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="send_tokens.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/send_tokens.rs#L22-L28"
    start="22" end="28" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

    ```python
    from py_near.account import Account
    from py_near.dapps.core import NEAR

    account = Account(account_id="example-account.testnet", private_key="ed25519:...", rpc_addr="https://rpc.testnet.pagoda.co")
    await account.startup()

    await account.send_money("receiver-account.testnet", 1 * NEAR))
    ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Call Function

A call function changes the contract's state and requires a signer/keypair.


<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="contract-interaction.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/contract-interaction.js#L65-L73"
    start="65" end="73" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="contract_interaction.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/contract_interaction.rs#L23-L24"
    start="23" end="24" />

  <Github fname="contract_interaction.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/contract_interaction.rs#L37-L49"
    start="37" end="49" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  await account.function_call("usn.near", "ft_transfer", {"receiver_id": "bob.near", "amount": "1000000000000000000000000"})
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Batch Actions

You can send multiple [actions](../1.concepts/protocol/transaction-anatomy.md#actions) in a batch to a single receiver. If one action fails then the entire batch of actions will be reverted.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">
  
  <Github fname="batch-actions.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/batch-actions.js#L22-L35"
    start="22" end="35" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="batch_actions.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/batch_actions.rs#L22-L42"
    start="22" end="42" />

  </TabItem>
</Tabs>

<hr class="subsection" />

### Simultaneous Transactions

Transactions can be sent in parallel to the network, so you don't have to wait for one transaction to complete before sending the next one. Note that these one transaction could be successful and the other one could fail. 

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="simultaneous-transactions.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/simultaneous-transactions.js#L22-L49"
    start="22" end="49" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="simultaneous_transactions.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/simultaneous_transactions.rs#L23-L55"
    start="23" end="55" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  import asyncio
  from py_near.account import Account

  account = Account(account_id="example-account.testnet", private_key="ed25519:...", rpc_addr="https://rpc.testnet.pagoda.co")
  await account.startup()

  # Prepare the transactions
  tx1 = account.function_call("guestbook.near-examples.testnet", "add_message", { "text": "Hello, world!" })
  tx2 = account.function_call("counter.near-examples.testnet", "increment", {})

  # Send the transactions simultaneously
  const transactionsResults = await asyncio.gather(tx1, tx2)
  ```

  </TabItem>
</Tabs>

<hr class="subsection" />

### Deploy a Contract {#deploy-a-contract}

You can deploy a contract from a compiled WASM file. 

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="contract-interaction.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/contract-interaction.js#L77-L80"
    start="77" end="80" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  Note that the `signer` here needs to be a signer for the same `account_id` as the one used to construct the `Contract` object.

  <Github fname="contract_interaction.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/contract_interaction.rs#L54-L61"
    start="54" end="61" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  import asyncio
  from py_near.account import Account

  account = Account(account_id="example-account.testnet", private_key="ed25519:...", rpc_addr="https://rpc.testnet.pagoda.co")
  await account.startup()

  with open("contract.wasm", "rb") as f:
    contract_code = f.read()
  await account.deploy_contract(contract_code)
  ```
  </TabItem>
</Tabs>

---

## View Function

View functions are read-only functions that don't change the state of the contract. We can call these functions without a signer / keypair or any gas.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="contract-interaction.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/contract-interaction.js#L23-L62"
    start="23" end="62" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="contract_interaction.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/contract_interaction.rs#L22-L33"
    start="22" end="33" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  view_call_result = await account.view_function("guestbook.near-examples.testnet", "total_messages", {})
  # If args are required, they can be passed in like this in the 3rd argument:
  # {
  #   "from_index": "0",
  #   "limit": "10"
  # }
  print(view_call_result)
  ```
  </TabItem>
</Tabs>

---

## Keys

### Get All Access Keys {#get-all-access-keys}

List all the access keys for an account.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="keys.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keys.js#L22-L22"
    start="22" end="22" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="keys.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/keys.rs#L22-L22"
    start="22" end="22" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  keys = await account.get_access_key_list()
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Add Full Access Key {#add-full-access-key}

Add a new [full access key](../1.concepts/protocol/access-keys.md#full-access-keys) to an account. Here we generate a random keypair, alternatively you can use a keypair from a seed phrase.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="keys.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keys.js#L26-L33"
    start="26" end="33" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="keys.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/keys.rs#L22-L39"
    start="22" end="39" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  keys = await account.add_full_access_public_key("5X9WvUbRV3aSd9Py1LK7HAndqoktZtcgYdRjMt86SxMj")
  ```
  </TabItem>
</Tabs>

<hr class="subsection" />

### Add Function Call Key {#add-function-call-key}

Add a new [function call key](../1.concepts/protocol/access-keys.md#function-call-keys) to an account. When adding the key you should specify the contract id the key can call, an array of methods the key is allowed to call, and the allowance in gas for the key.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="keys.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keys.js#L37-L47"
    start="36" end="43" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="keys.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/keys.rs#L43-L62"
    start="43" end="62" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  await account.add_public_key(
    "5X9WvUbRV3aSd9Py1LK7HAndqoktZtcgYdRjMt86SxMj",
    "example-contract.testnet", # Contract this key is allowed to call
    ["example_method"], # Methods this key is allowed to call (optional)
    0.25 * NEAR # Gas allowance key can use to call methods (optional)
  )
  ```
  </TabItem>

</Tabs>

<hr class="subsection" />

### Delete Access Key {#delete-access-key}

When deleting an access key, you need to specify the public key of the key you want to delete.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="keys.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/keys.js#L52-L52"
    start="52" end="52" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="keys.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/keys.rs#L67-L72"
    start="67" end="72" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

  ```python
  await account.delete_public_key("5X9WvUbRV3aSd9Py1LK7HAndqoktZtcgYdRjMt86SxMj")
  ```
  </TabItem>
</Tabs>

---

## Validate Message Signatures

Users can sign messages using the `wallet-selector` `signMessage` method, which returns a signature. This signature can be verified using the following code:

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

    <Github fname="authenticate.js" language="javascript"
      url="https://github.com/near-examples/near-api-examples/blob/main/javascript/examples/verify-signature/authentication.js" />

  </TabItem>
</Tabs>

---


## Utilities

### NEAR to yoctoNEAR {#near-to-yoctonear}

Convert an amount in NEAR to an amount in yoctoNEAR.

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  <Github fname="utils.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/utils.js#L4-L4"
    start="4" end="4" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  <Github fname="utils.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/utils.rs#L7"
    start="7" end="7" />

  </TabItem>
  <TabItem value="python" label="üêç Python">

   ```python
   from py_near.dapps.core import NEAR

   amount_in_yocto = 1 * NEAR
   ```

  </TabItem>
</Tabs>

<hr class="subsection" />

### Format Amount {#format-amount}

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  Format an amount in yoctoNEAR to an amount in NEAR.

  <Github fname="utils.js" language="javascript"
    url="https://github.com/PiVortex/near-api-examples/tree/main/javascript/examples/utils.js#L8"
    start="8" end="8" />

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  Format an amount of NEAR into a string of NEAR or yoctoNEAR depending on the amount.

  <Github fname="utils.rs" language="rust"
    url="https://github.com/PiVortex/near-api-examples/tree/main/rust/examples/utils.rs#L32"
    start="32" end="32" />

  </TabItem>
</Tabs>

---

## Additional resources

<Tabs groupId="api">
  <TabItem value="js" label="üåê JavaScript">

  - [Documentation](https://near.github.io/near-api-js)
  - [Github](https://github.com/near/near-api-js)
  - [Full Examples](https://github.com/PiVortex/near-api-examples/tree/main/javascript)
  - [Cookbook](https://github.com/near/near-api-js/tree/master/packages/cookbook) which contains examples using the near-js/client package, a wrapper tree shakable package for near-api-js.

  </TabItem>
  <TabItem value="rust" label="ü¶Ä Rust">

  - [Documentation](https://docs.rs/near-api/latest/near_api/)
  - [Github](https://github.com/near/near-api-rs)
  - [Full Examples](https://github.com/PiVortex/near-api-examples/tree/main/rust)

  </TabItem>
  <TabItem value="python" label="üêç Python">

    - [Phone number transfer](https://py-near.readthedocs.io/en/latest/clients/phone.html)

  </TabItem>
</Tabs>


 This is the content for the doc docs/4.tools/sdk.md 

 ---
id: sdk
title: "NEAR SDK"
hide_table_of_contents: false
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {Github} from "@site/src/components/codetabs"
import {FeatureList, Column, Feature} from "@site/src/components/featurelist";

The NEAR SDK is a library that allow to develop smart contracts. Currently, there exist two versions of NEAR SDK: one for Rust and one for JavaScript.

:::tip Want to build a smart contract?

The best place to start learning is our [QuickStart Guide](../2.build/2.smart-contracts/quickstart.md)

:::

<FeatureList>
  <Column title="" size="6">
    <Feature url="https://docs.rs/near-sdk/latest/near_sdk/" title="Rust SDK" subtitle="Rust SDK Reference docs" image="smartcontract-rust.png" />
  </Column>
  <Column title="" size="6">
    <Feature url="https://near.github.io/near-sdk-js/" title="JavaScript SDK" subtitle="Javascript SDK Reference docs" image="smartcontract-js.png" />
  </Column>
</FeatureList>

---

## Smart Contracts on NEAR


This is how a smart contract written in Rust and JavaScript using the NEAR SDK looks like:

<Tabs groupId="code-tabs">
  <TabItem value="js" label="üåê JavaScript">

    ```js
    @NearBindgen({})
    class HelloNear {
      greeting: string = 'Hello';

      @view({}) // This method is read-only and can be called for free
      get_greeting(): string {
        return this.greeting;
      }

      @call({}) // This method changes the state, for which it cost gas
      set_greeting({ greeting }: { greeting: string }): void {
        near.log(`Saving greeting ${greeting}`);
        this.greeting = greeting;
      }
    }
    
    ```

  </TabItem>

  <TabItem value="rust" label="ü¶Ä Rust">

    ```rust
    #[near(contract_state)]
    pub struct Contract {
        greeting: String,
    }

    impl Default for Contract {
        fn default() -> Self {
            Self { greeting: "Hello".to_string(), }
        }
    }

    #[near]
    impl Contract {
        pub fn get_greeting(&self) -> String {
            self.greeting.clone()
        }

        pub fn set_greeting(&mut self, greeting: String) {
            self.greeting = greeting;
        }
    }
    ```

  </TabItem>

</Tabs>

:::tip

Want to build a smart contract? Check our [QuickStart Guide](../2.build/2.smart-contracts/quickstart.md)

:::

---

## üéâ Ready to start developing?

Start from our [Smart Contract QuickStart Guide](../2.build/2.smart-contracts/quickstart.md), and let it guide you through all our documentation on building smart contracts

---

## Want to See Examples?

We have a section dedicated to [tutorials and examples](../3.tutorials/examples/guest-book.md) that will help you understand diverse use cases and how to implement them

:::tip

If you are new to smart contracts, we recommend you start with our [Smart Contract QuickStart Guide](../2.build/2.smart-contracts/quickstart.md) before moving to the examples

:::

---

## Searching for the Reference Docs

If you need to find a specific function signature, or understand the SDK struct/classes, please visit the SDK specific pages:

- [Rust SDK](https://docs.rs/near-sdk/latest/near_sdk/)
- [JavaScript SDK](https://near.github.io/near-sdk-js/)

:::tip

If you are new to smart contracts, we recommend you start with our [Smart Contract QuickStart Guide](../2.build/2.smart-contracts/quickstart.md) before moving to the reference documentation

:::


 This is the content for the doc docs/4.tools/wallet-selector.md 

 ---
id: wallet-selector
title: Wallet Selector
sidebar_label: NEAR Wallet Selector
---

The [Wallet Selector](https://github.com/near/wallet-selector) is a `JS`/`TS` library that lets users connect to your application using their preferred wallet. 

![Preview](/docs/assets/wallet-selector-preview.png)
*Initial screen of [Wallet Selector](https://near.github.io/wallet-selector/)*

<details>
<summary> List of NEAR Wallets </summary>

Here is a list of user-friendly wallets that support the NEAR blockchain, you can find more at the [NEAR Wallets](https://wallet.near.org/) page.

- [HERE Wallet](https://www.herewallet.app/): Non-custodial mobile wallet with a friendly user interface and advanced features.

- [Meteor Wallet](https://wallet.meteorwallet.app/): Both a browser and extension wallet, with advanced NFT features.

- [Mintbase Wallet](https://wallet.mintbase.xyz/): A passkey meta-transaction, browser wallet, with advanced NFT and AI features. If you're looking to integrate Mintbase Wallet into your applications, [check this tutorial](https://docs.mintbase.xyz/wallet/integrating-mintbase-wallet) to get started.

- [MyNearWallet](https://mynearwallet.com/): A browser based wallet that offers the same UI and features of `wallet.near.org`.

- [NEAR Mobile](https://nearmobile.app/): A non-custodial wallet that is easy to use and well designed to manage your crypto wherever you go.

- [Nightly Wallet](https://wallet.nightly.app/download): A mobile and extension wallet, with support for multiple ecosystems.

- [Sender Wallet](https://sender.org/): Security-audited mobile & extension wallet with 1M+ users, supporting NEAR & Aurora.

- [WELLDONE Wallet](https://welldonestudio.io/): A multi-chain extension wallet that gives you control over all your assets from a single platform.

</details>

---

## Unlocking the wallet ecosystem

Wallet Selector makes it easy for users to interact with dApps by providing an abstraction over various wallets and wallet types within the NEAR ecosystem.

:::info

You can check the current list of supported wallets in the [README.md](https://github.com/near/wallet-selector/blob/main/README.md) file of near/wallet-selector repository.

:::

---

## Install

The easiest way to use NEAR Wallet Selector is to install the core package from the NPM registry, some packages may require near-api-js v0.44.2 or above check them at packages.

```bash
npm install near-api-js
```

```bash
npm install @near-wallet-selector/core
```

Next, you'll need to install the wallets you want to support:

```bash
npm install \
  @near-wallet-selector/near-wallet \
  @near-wallet-selector/my-near-wallet \
  @near-wallet-selector/sender \
  @near-wallet-selector/nearfi \
  @near-wallet-selector/here-wallet \
  @near-wallet-selector/math-wallet \
  @near-wallet-selector/nightly \
  @near-wallet-selector/meteor-wallet \
  @near-wallet-selector/ledger \
  @near-wallet-selector/wallet-connect \
  @near-wallet-selector/nightly-connect \
  @near-wallet-selector/default-wallets \
  @near-wallet-selector/coin98-wallet
```

---

## Setup Wallet Selector

Optionally, you can install our [`modal-ui`](https://www.npmjs.com/package/@near-wallet-selector/modal-ui) or [`modal-ui-js`](https://www.npmjs.com/package/@near-wallet-selector/modal-ui-js) package for a pre-built interface that wraps the `core` API and presents the supported wallets:

```bash
npm install @near-wallet-selector/modal-ui
```

Then use it in your dApp:

```ts
import { setupWalletSelector } from "@near-wallet-selector/core";
import { setupModal } from "@near-wallet-selector/modal-ui";
import { setupNearWallet } from "@near-wallet-selector/near-wallet";

const selector = await setupWalletSelector({
  network: "testnet",
  modules: [setupNearWallet()],
});

const modal = setupModal(selector, {
  contractId: "test.testnet",
});

modal.show();
```

:::info Required CSS

To integrate the Wallet Selector, you also need to include the required CSS:

```
import "@near-wallet-selector/modal-ui/styles.css"
```

:::

---

## Reference

The API reference of the selector can be found [`here`](https://github.com/near/wallet-selector/blob/main/packages/core/docs/api/selector.md)

### Sign in

```ts
// NEAR Wallet.
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  const accounts = await wallet.signIn({ contractId: "test.testnet" });
})();
```

### Sign out

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.signOut();
})();
```

### Get accounts

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  const accounts = await wallet.getAccounts();
  console.log(accounts); // [{ accountId: "test.testnet" }]
})();
```

### Verify Owner

```ts
// MyNearWallet
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.verifyOwner({
    message: "Test message",
  });
})();
```

### Sign and send transaction

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.signAndSendTransaction({
    actions: [
      {
        type: "FunctionCall",
        params: {
          methodName: "addMessage",
          args: { text: "Hello World!" },
          gas: "30000000000000",
          deposit: "10000000000000000000000",
        },
      },
    ],
  });
})();
```

### Sign and send transactions

```ts
(async () => {
  const wallet = await selector.wallet("my-near-wallet");
  await wallet.signAndSendTransactions({
    transactions: [
      {
        receiverId: "guest-book.testnet",
        actions: [
          {
            type: "FunctionCall",
            params: {
              methodName: "addMessage",
              args: { text: "Hello World!" },
              gas: "30000000000000",
              deposit: "10000000000000000000000",
            },
          },
        ],
      },
    ],
  });
})();
```


 This is the content for the doc docs/4.tools/welcome.md 

 ---
id: welcome
title: Tools
sidebar_label: Home
hide_table_of_contents: true
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist"

The NEAR ecosystem has a complete set of tools for you to make the most out of our network.

<FeatureList>
  <Column title="Essentials">
    <Feature url="/tools/near-cli" title="NEAR CLI" subtitle="An all-in-one solution in your terminal" image="near-cli.png" />
    <Feature url="/tools/near-api" title="NEAR API" subtitle="Interface with NEAR from JS, Rust and Python" image="quickstart.png" />
    <Feature url="/tools/sdk" title="NEAR SDK" subtitle="The best way to create contracts" image="smartcontract.png" />
    <Feature url="/tools/wallet-selector" title="Wallet Selector" subtitle="Integrate all wallets in your app" image="multiple.png" />
  </Column>
  <Column title="Data Tools">
    <Feature url="/tools/explorer" title="Explorers" subtitle="Web apps to access on-chain data" image="update.png" />
    <Feature url="/tools/ecosystem-apis/fastnear" title="Data APIs" subtitle="The simplest way to query on-chain data" image="experiment.png" />
    <Feature url="/tools/indexing" title="Indexers" subtitle="Services to create your own data APIs" image="blocks.png" />
  </Column>
  <Column title="Ecosystem Tools">
    <Feature url="https://near-faucet.io/" title="Testnet Faucet" subtitle="Get tokens for your testing accounts" image="transaction.png" />
    <Feature url="https://dev.near.org/" title="Developer Portal" subtitle="Discover news, communities and more tools" image="tutorials.png" />
    <Feature url="https://app.nearcatalog.xyz/" title="NEAR Catalog" subtitle="A catalog full of awesome NEAR apps" image="guest-book.png" />
  </Column>
</FeatureList>


 This is the content for the doc docs/5.api/rpc/access-keys.md 

 ---
id: access-keys
title: Access Keys
---

import ViewAccessKey from '@site/src/components/docs/5.api/rpc/access-keys/view-access-key/index.mdx';
import ViewAccessKeyList from '@site/src/components/docs/5.api/rpc/access-keys/view-access-key-list/index.mdx';
import ViewAccessKeyChangesSingle from '@site/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/index.mdx';
import ViewAccessKeyChangesAll from '@site/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/index.mdx';

The RPC API enables you to retrieve information about an account's access keys.

---
<ViewAccessKey />
---
<ViewAccessKeyList />
---
<ViewAccessKeyChangesSingle />
---
<ViewAccessKeyChangesAll />
---


 This is the content for the doc docs/5.api/rpc/block-chunk.md 

 ---
id: block-chunk
title: Block / Chunk
---

import BlockDetails from '@site/src/components/docs/5.api/rpc/block-chunk/block-details/index.mdx';
import ChangesInBlock from '@site/src/components/docs/5.api/rpc/block-chunk/changes-in-block/index.mdx';
import ChunkDetails from '@site/src/components/docs/5.api/rpc/block-chunk/chunk-details/index.mdx';

The RPC API enables you to query the network and get details about specific blocks or chunks.

---
<BlockDetails />
---
<ChangesInBlock />
---
<ChunkDetails />
---


 This is the content for the doc docs/5.api/rpc/contracts.md 

 ---
id: contracts
title: Accounts / Contracts
---

import ViewAccount from '@site/src/components/docs/5.api/rpc/contracts/view-account/index.mdx';
import ViewAccountChanges from '@site/src/components/docs/5.api/rpc/contracts/view-account-changes/index.mdx';
import ViewContractCode from '@site/src/components/docs/5.api/rpc/contracts/view-contract-code/index.mdx';
import ViewContractState from '@site/src/components/docs/5.api/rpc/contracts/view-contract-state/index.mdx';
import ViewContractStateChanges from '@site/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/index.mdx';
import ViewContractCodeChanges from '@site/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/index.mdx';
import CallAContractFunction from '@site/src/components/docs/5.api/rpc/contracts/call-a-contract-function/index.mdx';

The RPC API enables you to view details about accounts and contracts as well as perform contract calls.

---
<ViewAccount />
---
<ViewAccountChanges />
---
<ViewContractCode />
---
<ViewContractState />
---
<ViewContractStateChanges />
---
<ViewContractCodeChanges />
---
<CallAContractFunction />
---


 This is the content for the doc docs/5.api/rpc/gas.md 

 ---
id: gas
title: Gas 
---

import GasPrice from '@site/src/components/docs/5.api/rpc/gas/gas-price/index.mdx';

The RPC API enables you to query the gas price for a specific block or hash.

---
<GasPrice />
---


 This is the content for the doc docs/5.api/rpc/introduction.md 

 ---
id: introduction
sidebar_label: Home
title: NEAR RPC API
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

The RPC API allows you to communicate directly with the NEAR network. For example,
tools such as [near-api](../../4.tools/near-api.md) are just abstractions making RPC calls.

<hr className="subsection" />

## RPC Providers

There are multiple [RPC providers which you can choose from](./providers.md). These providers will work as intermediaries to help you interact with the NEAR network.

## Node Snapshots

If you're looking for node snapshots  in order to set up a validator node or RPC, you can download the latest NEAR blockchain state from:

- [Allnodes](https://www.publicnode.com/snapshots#near)
- [FastNEAR](https://docs.fastnear.com/docs/snapshots)

<hr className="subsection" />

## NEAR RPC - Quick Links

| API                                                 | Description                                                                  |
|-----------------------------------------------------|------------------------------------------------------------------------------|
| [Access Keys](/api/rpc/access-keys)                 | Retrieve information about an account's access keys.                         |
| [Accounts / Contracts](/api/rpc/contracts)          | View details about accounts and contracts as well as perform contract calls. |
| [Block / Chunk](/api/rpc/block-chunk)               | Query the network and get details about specific blocks or chunks.           |
| [Gas](/api/rpc/gas)                                 | Get gas price for a specific block or hash.                                  |
| [Protocol](/api/rpc/protocol)                       | Retrieve current genesis and protocol configuration.                         |
| [Network](/api/rpc/network)                         | Return status information for nodes and validators.                          |
| [Transactions](/api/rpc/transactions)               | Send transactions and query their status.                                    |

:::tip
You can access the JSON RPC 2.0 endpoints using [Postman](/api/rpc/setup#postman-setup),
[JavaScript](/api/rpc/setup#javascript-setup), and [HTTPie](/api/rpc/setup#httpie-setup).
:::


 This is the content for the doc docs/5.api/rpc/maintenance-windows.md 

 ---
id: maintenance-windows
title: Maintenance Windows
---

import MaintenanceWindows from '@site/src/components/docs/5.api/rpc/maintenance-windows/maintenance-windows/index.mdx';

The RPC API enables you to query future maintenance windows for a specific validator 
in current epoch

---
<MaintenanceWindows />
---


 This is the content for the doc docs/5.api/rpc/network.md 

 ---
id: network
title: Network
---

import NodeStatus from '@site/src/components/docs/5.api/rpc/network/node-status/index.mdx';
import NetworkInfo from '@site/src/components/docs/5.api/rpc/network/network-info/index.mdx';
import ValidationStatus from '@site/src/components/docs/5.api/rpc/network/validation-status/index.mdx';

The RPC API enables you to query status information for nodes and validators.

---
<NodeStatus />
---
<NetworkInfo />
---
<ValidationStatus />
---


 This is the content for the doc docs/5.api/rpc/protocol.md 

 ---
id: protocol
title: Protocol
---

import GenesisConfig from '@site/src/components/docs/5.api/rpc/protocol/genesis-config/index.mdx';
import ProtocolConfig from '@site/src/components/docs/5.api/rpc/protocol/protocol-config/index.mdx';

The RPC API enables you to retrieve the current genesis and protocol configuration.

---
<GenesisConfig />
---
<ProtocolConfig />
---


 This is the content for the doc docs/5.api/rpc/providers.md 

 ---
id: providers
title: RPC Providers
---

There are multiple RPC providers from which you can choose from. These providers will work as intermediaries to help you interact with the NEAR network.
You'll experience different latency levels depending on the provider's location. You can potentially use multiple providers for redundancy and
balancing.

:::tip

If you want to use a custom RPC provider with NEAR Wallet Selector, [check this example](../../2.build/4.web3-apps/integrate-contracts.md#setting-customs-rpc-endpoints).

:::

## Mainnet

| Provider                                                                   | Endpoint Root                                                |
| -------------------------------------------------------------------------- | ------------------------------------------------------------ |
| [NEAR.org (deprecated)](setup.md)                                          | `https://rpc.mainnet.near.org`                               |
| [1RPC](https://docs.1rpc.io/overview/about-1rpc)                           | `https://1rpc.io/near`                                       |
| [All That Node](https://www.allthatnode.com/)                              | `https://allthatnode.com/protocol/near.dsrv`                 |
| [ankr.com](https://www.ankr.com/docs/rpc-service/chains/chains-list/#near) | `https://rpc.ankr.com/near`                                  |
| [BlockPI Network](https://blockpi.io)                                      | `https://near.blockpi.network/v1/rpc/public`                 |
| [dRPC](https://drpc.org/)                                                  | `https://near.drpc.org`                                      |
| [fast-near web4](https://github.com/vgrichina/fast-near)                   | `https://rpc.web4.near.page`                                 |
| [FASTNEAR](https://fastnear.com)                                           | `https://free.rpc.fastnear.com`                              |
| [Gateway.fm](https://gateway.fm/)                                          | `https://rpc.near.gateway.fm/`                               |
| [GetBlock](https://getblock.io/nodes/near/)                                | `https://getblock.io/nodes/near/`                            |
| [Lava Network](https://www.lavanet.xyz/get-started/near)                   | `https://near.lava.build`                                    |
| [Lavender.Five Nodes](https://lavenderfive.com/)                           | `https://near.lavenderfive.com/`                             |
| [NodeReal](https://nodereal.io)                                            | `https://nodereal.io/api-marketplace/near-rpc`               |
| [NOWNodes](https://nownodes.io/)                                           | `https://near.nownodes.io/`                                  |
| [OMNIA](https://omniatech.io)                                              | `https://endpoints.omniatech.io/v1/near/mainnet/public`      |
| [QuickNode](https://www.quicknode.com/chains/near)                         | -                                                            |
| [Seracle](https://docs.seracle.com/)                                       | `https://api.seracle.com/saas/baas/rpc/near/mainnet/public/` |
| [Zeeve](https://www.zeeve.io/)                                             | -                                                            |

## Testnet

| Provider                                                                   | Endpoint Root                                                |
| -------------------------------------------------------------------------- | ------------------------------------------------------------ |
| [NEAR.org (deprecated)](setup.md)                                          | `https://rpc.testnet.near.org`                               |
| [FASTNEAR](https://fastnear.com)                                           | `https://test.rpc.fastnear.com`                              |
| [All That Node](https://www.allthatnode.com/)                              | `https://allthatnode.com/protocol/near.dsrv`                 |

## RPC Failover

In `near-api-js` you can use [`FailoverRpcProvider`](../../4.tools/near-api.md#rpc-failover) to automatically switch RPC providers when one provider is experiencing downtime, or implement an RPC selection widget that allows users to add their own RPC provider.

As a user, if a dApp or wallet doesn't support RPC failover and the primary provider is down, you can use an RPC Selector browser extension to redirect all requests to an RPC provider of your choice.

## On NEAR.org RPC Deprecation

Please read the following announcement: [Future of Pagoda Services](https://docs.near.org/blog/2024-08-13-pagoda-services).

> The Infrastructure Committee feels that Pagoda's fully-subsidized near.org RPC service is getting in the way of decentralization efforts and is preventing high-quality commercial RPC offerings from gaining traction. If a NEAR core team continues to support a free-to-use near.org RPC service, it will be required to gradually lower its rate limits over the coming months to prevent abuse. In light of this proposed change, high-traffic near.org RPC users should start making plans to switch to other RPC providers.

### The current rate-limits of NEAR.org RPC endpoints

Starting December 1st, 2024:

* **RPC Mainnet**: 2000 requests/30s per IP
* **RPC Testnet**: 900 requests/30s per IP
* **Archival-RPC Mainnet**: 200 requests/30s IP
* **Archival-RPC Testnet**: 400 requests/30s per IP

Starting January 1st, 2025:

* **RPC Mainnet**: 500 requests/30s per IP or referrer
* **RPC Testnet**: 600 requests/30s per IP or referrer
* **Archival-RPC Mainnet**: 100 requests/30s per IP or referrer
* **Archival-RPC Testnet**: 200 requests/30s per IP or referrer

Starting February 1st, 2025

* **RPC Mainnet**: 150 req/30s per IP or referrer
* **RPC Testnet**: 300 requests/30s per IP or referrer
* **Archival-RPC Mainnet**: 20 requests/30s per IP or referrer
* **Archival-RPC Testnet**: 100 requests/30s per IP or referrer

:::note
Rate limits will be applied by IP or by the HTTP `Referer` header, whichever hits first. Frontend applications will likely be rate-limited by the referrer, while backend applications will likely be rate-limited by the IP address.
:::



 This is the content for the doc docs/5.api/rpc/setup.md 

 ---
id: setup
title: Setup 
---

In order to use the RPC API you will need to setup the correct RPC endpoints.

<hr className="subsection" />

## RPC Endpoint Setup
- `POST` for all methods
- `JSON RPC 2.0`
- `id: "dontcare"`
- endpoint URL varies by network:
  - mainnet `https://rpc.mainnet.near.org`
  - testnet `https://rpc.testnet.near.org`
  - betanet `https://rpc.betanet.near.org` _(may be unstable)_
  - localnet `http://localhost:3030`

### Limits
- Maximum number of requests per IP: 600 req/min

<hr className="subsection" />

## Querying Historical Data
Querying historical data (older than 5 [epochs](../../1.concepts/basics/epoch.md) or ~2.5 days), you may get responses that the data is not available anymore. In that case, archival RPC nodes will come to your rescue:

- mainnet `https://archival-rpc.mainnet.near.org`
- testnet `https://archival-rpc.testnet.near.org`

You can see this interface defined in `nearcore` [here](https://github.com/near/nearcore/blob/bf9ae4ce8c680d3408db1935ebd0ca24c4960884/chain/jsonrpc/client/src/lib.rs#L181).

### Limits
- Maximum number of requests per IP: 600 req/min

---

## Postman Setup {#postman-setup}

An easy way to test the queries in this documentation page is to use an API request tool such as [Postman](https://www.postman.com/).
You only need to configure two things:

1. Make sure you add a header with a key of `Content-Type` and value of `application/json`.
   ![postman-setup-header](/docs/assets/postman-setup-headers.png)

2. Then select the `Body` tab and choose the `raw` radio button and ensure `JSON` is the selected format.
   ![postman-setup-header](/docs/assets/postman-setup-body.png)

After that is set up, just copy/paste the `JSON object` example snippets below into the `body` of your request, on Postman, and click `send`.

---
## JavaScript Setup {#javascript-setup}

All of the queries listed in this documentation page can be called using [`near-api-js`](https://github.com/near/near-api-js).

- For `near-api-js` installation and setup please refer to `near-api-js` [quick reference documentation](../../4.tools/near-api.md).
- All JavaScript code snippets require a `near` object. For examples of how to instantiate, [**click here**](../../4.tools/near-api.md#connect).

---
## HTTPie Setup {#httpie-setup}

If you prefer to use a command line interface, we have provided RPC examples you can use with [HTTPie](https://httpie.org/). Please note that params take
either an object or array passed as a string.

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=network_info params:='[]'
```

---

## Using `block_id` param {#using-block_id-param}

The `block_id` param can take either the block number (e.g. `27912554`) or the block hash (e.g. `'3Xz2wM9rigMXzA2c5vgCP8wTgFBaePucgUmVYPkMqhRL'` ) as an argument.

:::caution

The block IDs of transactions shown in [NearBlocks Explorer](https://testnet.nearblocks.io) are not necessarily the block ID of the executed transaction. Transactions may execute a block or two after its recorded, and in some cases, can take place over several blocks. Due to this, it is important to check subsequent blocks to be sure all results related to the queried transaction are discovered.

:::

---

## Using `finality` param {#using-finality-param}

The `finality` param has two options: `optimistic` and `final`.
1. `optimistic` uses the latest block recorded on the node that responded to your query _(< 1 second delay after the transaction is submitted)_
2. `final` is for a block that has been validated on at least 66% of the nodes in the network _(usually takes 2 blocks / approx. 2 second delay)_


 This is the content for the doc docs/5.api/rpc/transactions.md 

 ---
id: transactions
title: RPC Endpoints
sidebar_label: Transactions
---

import SendTx from '@site/src/components/docs/5.api/rpc/transactions/send-tx/index.mdx';
import TransactionStatus from '@site/src/components/docs/5.api/rpc/transactions/transaction-status/index.mdx';
import TransactionStatusWithReceipts from '@site/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/index.mdx';
import ReceiptById from '@site/src/components/docs/5.api/rpc/transactions/receipt-by-id/index.mdx';
import TxStatusResult from '@site/src/components/docs/5.api/rpc/transactions/tx-status-result/index.mdx';
import SendTransactionAsync from '@site/src/components/docs/5.api/rpc/transactions/send-transaction-async/index.mdx';
import SendTransactionAwait from '@site/src/components/docs/5.api/rpc/transactions/send-transaction-await/index.mdx';

The RPC API enables you to send transactions and query their status.

---
<SendTx />
---
<TransactionStatus />
---
<TransactionStatusWithReceipts />
---
<ReceiptById />
---
<TxStatusResult />
---

# Deprecated methods {#deprecated}

<SendTransactionAsync/>
---
<SendTransactionAwait />
---


 This is the content for the doc docs/6.integrations/accounts.md 

 ---
id: accounts
title: Accounts
sidebar_label: Accounts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Introduction {#introduction}

Please see the [documentation for accounts](/concepts/protocol/account-model) for basic information.

- For exchanges, NEAR supports [implicit account](https://nomicon.io/DataStructures/Account.html#implicit-account-ids) creation which allows the creation of accounts without paying for transactions.
- You can create an implicit account by following the steps in [this guide](/integrations/implicit-accounts).
- Accounts must have enough tokens to cover its storage which currently costs `0.0001 NEAR` per byte. This equates to a minimum balance of `0.00182 NEAR` for an account with one access key. You can query the live storage price using the [`protocol-config`](https://docs.near.org/api/rpc/setup#protocol-config) RPC endpoint. For more details on storage fees see [this section of the economics paper](https://pages.near.org/papers/economics-in-sharded-blockchain/#transaction-and-storage-fees).

## Transfer from Function Call {#transfer-from-function-call}

NEAR allows transfers to happen within a function call. More importantly, when an account is deployed with some contract, it is possible that the only way to transfer tokens from that account is through a function call. Therefore, exchanges need to support transfers through function calls as well. We recommend the following approach:

Exchange can [query block by height](/api/rpc/block-chunk#block-details) to get blocks on each height, and for every block,
[query its chunk](/api/rpc/block-chunk#chunk-details) to obtain the transactions included in the block. For each transaction,
[query its status](/api/rpc/transactions#transaction-status-with-receipts) to see the receipts generated from
transactions. Since exchanges are only interested in transfers to their addresses, they only need to filter receipts that
only contain `Transfer` action and whose `predecessor_id` is not `system` (receipts with `predecessor_id` equal to `system`
are [refunds](https://nomicon.io/RuntimeSpec/Refunds.html)). Then, to check whether the receipt succeeds, it is sufficient
to look for the `receipt_id` in `receipts_outcome` and see if its status is `SuccessValue`.

Alternatively, exchange can use [the indexer framework](https://github.com/near/nearcore/tree/master/chain/indexer)
to help index on-chain data which include receipts. An example usage of the indexer can be found [here](https://github.com/near/nearcore/tree/master/tools/indexer/example).

Below we include examples from the contracts that are likely to be used to perform transfers through function calls.

**Example of transfer from a lockup contract**

A contract `evgeny.lockup.near` is deployed and we can check its owner by

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near view evgeny.lockup.near get_owner_account_id
  # View call: evgeny.lockup.near.get_owner_account_id()
  # 'evgeny.near'
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near contract call-function as-read-only evgeny.lockup.near get_owner_account_id json-args '{}' network-config testnet now
  # View call: evgeny.lockup.near.get_owner_account_id()
  # 'evgeny.near'
  ```
  </TabItem>
</Tabs>

Now we want to transfer some unlocked tokens (1 NEAR) with the following call

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call evgeny.lockup.near transfer '{"amount":"1000000000000000000000000", "receiver_id": "evgeny.near"}' --accountId=evgeny.near
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction evgeny.lockup.near transfer json-args '{"amount":"1000000000000000000000000", "receiver_id": "evgeny.near"}' prepaid-gas '100.0 Tgas' attached-deposit '0 NEAR' sign-as evgeny.near network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

**Note**: the response below can be obtained by hitting the RPC with the transaction hash and NEAR account like this:

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=txstatus method=EXPERIMENTAL_tx_status \
  params:='[ "GXP8YaSonoN2eBY6dB3FbMN2NyYD2JeJJvKdvbL4Jmb2", "evgeny.near"]'
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "evgeny.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJhbW91bnQiOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIiwicmVjZWl2ZXJfaWQiOiJldmdlbnkubmVhciJ9",
                  "deposit": "0",
                  "gas": 100000000000000,
                  "method_name": "transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU",
        "receiver_id": "evgeny.lockup.near"
      },
      {
        "predecessor_id": "evgeny.lockup.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1000000000000000000000000"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
        "receiver_id": "evgeny.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "19200274886926125000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv",
        "receiver_id": "evgeny.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18655658845681462514128"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "evgeny.near",
            "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
          }
        },
        "receipt_id": "6PFaxnNvK5r6qxBq5WfV9uGjoNM6qjhHwLehLP1qak9d",
        "receiver_id": "evgeny.near"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "9boEKq9G1UFsEuzmuQrxh5dkRc8xsv8PSPGEkYiTyRLj",
        "id": "CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU",
        "outcome": {
          "executor_id": "evgeny.lockup.near",
          "gas_burnt": 3574640311481,
          "logs": [
            "Transferring 1000000000000000000000000 to account @evgeny.near"
          ],
          "receipt_ids": [
            "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
            "6PFaxnNvK5r6qxBq5WfV9uGjoNM6qjhHwLehLP1qak9d"
          ],
          "status": {
            "SuccessReceiptId": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC"
          },
          "tokens_burnt": "357464031148100000000"
        },
        "proof": []
      },
      {
        "block_hash": "7qn4BjmMD4QbyVvMa8QEzm7h5YuhoGTFTgLeNMUp85UQ",
        "id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
        "outcome": {
          "executor_id": "evgeny.near",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": ["J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "AwHdk5dushTSXHFBt3R5MiexjiXybwdnEaB7L9iJ5F6t"
          }
        ]
      },
      {
        "block_hash": "46788Ay85YGnQaH5tfbboQNWJs3gyXsPbcWzRyxqw56K",
        "id": "J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv",
        "outcome": {
          "executor_id": "evgeny.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "7qn4BjmMD4QbyVvMa8QEzm7h5YuhoGTFTgLeNMUp85UQ",
        "id": "6PFaxnNvK5r6qxBq5WfV9uGjoNM6qjhHwLehLP1qak9d",
        "outcome": {
          "executor_id": "evgeny.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "9RRJpH5VdDxsHpp323EshcAauV5wUNDyW9FpEJBRXXq8"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJhbW91bnQiOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIiwicmVjZWl2ZXJfaWQiOiJldmdlbnkubmVhciJ9",
            "deposit": "0",
            "gas": 100000000000000,
            "method_name": "transfer"
          }
        }
      ],
      "hash": "GXP8YaSonoN2eBY6dB3FbMN2NyYD2JeJJvKdvbL4Jmb2",
      "nonce": 6,
      "public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq",
      "receiver_id": "evgeny.lockup.near",
      "signature": "ed25519:4nfzTMpQJKCY3KaqUTFig4Xy9uxwbMeQpMJjtNKsXmwiVqgcVSWRguZEgZM8L2x1jvdpZHsYjLCxc9cSBamXuXPH",
      "signer_id": "evgeny.near"
    },
    "transaction_outcome": {
      "block_hash": "4u7maz2U43W4DPxqQE8KoRNi5dTRHrAsKsFk2qDQsQEw",
      "id": "GXP8YaSonoN2eBY6dB3FbMN2NyYD2JeJJvKdvbL4Jmb2",
      "outcome": {
        "executor_id": "evgeny.near",
        "gas_burnt": 2428086459116,
        "logs": [],
        "receipt_ids": ["CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU"],
        "status": {
          "SuccessReceiptId": "CyJL22SYqt26qgh2XVnk9MGfvzgyiiq5Lny7DdbTdTWU"
        },
        "tokens_burnt": "242808645911600000000"
      },
      "proof": []
    }
  }
}
```
</details>

As we can see, there are four receipts generated in this function call. If we apply the criteria mentioned above, we can
find in `receipts` field this object

```json
{
  "predecessor_id": "evgeny.lockup.near",
  "receipt": {
    "Action": {
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "gas_price": "186029458",
      "input_data_ids": [],
      "output_data_receivers": [],
      "signer_id": "evgeny.near",
      "signer_public_key": "ed25519:BVRTxEEMx3gFceSgJtnvPFbSnPDwwUzHe6KGduRh5Byq"
    }
  },
  "receipt_id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
  "receiver_id": "evgeny.near"
}
```

which contains only `Transfer` action and whose `predecessor_id` is not `system`. Now we can check the status of the
execution by looking for the same receipt id `EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC` in `receipts_outcome` field
of the rpc return result, this leads us to this execution outcome

```json
{
  "block_hash": "7qn4BjmMD4QbyVvMa8QEzm7h5YuhoGTFTgLeNMUp85UQ",
  "id": "EvHfj4fUyVuLBRKNdCZmFGr4WfqwYf7YCbzFsRGFTFJC",
  "outcome": {
    "executor_id": "evgeny.near",
    "gas_burnt": 223182562500,
    "logs": [],
    "receipt_ids": ["J1bBKH43nXHYg4NuS97R1PFzdZchrJboVAdRsK5NRrAv"],
    "status": {
      "SuccessValue": ""
    },
    "tokens_burnt": "22318256250000000000"
  },
  "proof": [
    {
      "direction": "Right",
      "hash": "AwHdk5dushTSXHFBt3R5MiexjiXybwdnEaB7L9iJ5F6t"
    }
  ]
}
```

and its status contains `SuccessValue`, which indicates that the receipt has succeeded. Therefore we know that
`1000000000000000000000000` yoctoNEAR, or 1 NEAR has been successfully transferred.

**Example of transfer from a multisig contract**

Multisig contract, as the name suggests, uses multiple signatures to confirm a transaction and therefore, actions performed
by the multisig contract involve multiple transactions. In the following example, we will show how a transfer is done from
a multisig contract that requires two confirmations.

- First step: `add_request_and_confirm`. This initiates the action that the multisig contract wants to perform with one
  confirmation. The multisig contract `multisigtest.testnet` wants to transfer 1 NEAR to `bowen` and it first
  sends a transaction that calls `add_request_and_confirm` with a request

```json
{
  "request": {
    "receiver_id": "bowen",
    "actions": [
      {
        "type": "Transfer",
        "amount": "1000000000000000000000000"
      }
    ]
  }
}
```

that indicates it wants to transfer 1 NEAR to `bowen`. Notice that this transaction only records the action
but does not perform the actual transfer. The transaction result is as follows:

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "3069687780141648922140"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:JDewsbE7nz6orFD4zJ3mVzqhfcaoSD6Hmi5as3AHHiTt"
          }
        },
        "receipt_id": "4qgDptd7Wm6vswAhWMCsVpTjBEkmLJEUxSNVQS1wu3rD",
        "receiver_id": "multisigtest.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "6uJWHTvUrtFQAurUyfuAfy9EdoR9FhLodGh44aHJta6m",
        "id": "94LiYwKJEDherHMNg9fqLy9ShFTDiQiUN3nDaGmLZwth",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 8024094920263,
          "logs": [],
          "receipt_ids": ["4qgDptd7Wm6vswAhWMCsVpTjBEkmLJEUxSNVQS1wu3rD"],
          "status": {
            "SuccessValue": "OA=="
          },
          "tokens_burnt": "802409492026300000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "GedzmwRkxA5VkT8GLBCnrPUmnEhWPXadPmiq4Ho1s9pH"
          },
          {
            "direction": "Right",
            "hash": "GirkzdS9YpsAz5fXuL5T3rXd93aRcnXNAdXYi241qpWK"
          }
        ]
      },
      {
        "block_hash": "4JyQ6guJKeWZxxXrKndLDuSa5URuirmBi6RzsbKYFsBE",
        "id": "4qgDptd7Wm6vswAhWMCsVpTjBEkmLJEUxSNVQS1wu3rD",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      }
    ],
    "status": {
      "SuccessValue": "OA=="
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZXF1ZXN0Ijp7InJlY2VpdmVyX2lkIjoiYm93ZW4iLCJhY3Rpb25zIjpbeyJ0eXBlIjoiVHJhbnNmZXIiLCJhbW91bnQiOiIxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwIn1dfX0=",
            "deposit": "0",
            "gas": 30000000000000,
            "method_name": "add_request_and_confirm"
          }
        }
      ],
      "hash": "FGREJkC1e8y95Rc35iD1LVRiDy1WcAZhAxxkSinfb2mL",
      "nonce": 10,
      "public_key": "ed25519:JDewsbE7nz6orFD4zJ3mVzqhfcaoSD6Hmi5as3AHHiTt",
      "receiver_id": "multisigtest.testnet",
      "signature": "ed25519:3NUKXd4uj2eEBqGQtRAxkTFW7UfG44tjvQNNHBDvN9ZswTTMRsDrMJSd1U3GqWF7QToqWQR9J8atNEVTemSWYw41",
      "signer_id": "multisigtest.testnet"
    },
    "transaction_outcome": {
      "block_hash": "6uJWHTvUrtFQAurUyfuAfy9EdoR9FhLodGh44aHJta6m",
      "id": "FGREJkC1e8y95Rc35iD1LVRiDy1WcAZhAxxkSinfb2mL",
      "outcome": {
        "executor_id": "multisigtest.testnet",
        "gas_burnt": 2428204963618,
        "logs": [],
        "receipt_ids": ["94LiYwKJEDherHMNg9fqLy9ShFTDiQiUN3nDaGmLZwth"],
        "status": {
          "SuccessReceiptId": "94LiYwKJEDherHMNg9fqLy9ShFTDiQiUN3nDaGmLZwth"
        },
        "tokens_burnt": "242820496361800000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "AsNAQabPFkmaugRGhCbzcEcR8Gnd22WXxPM2fb2cwHiv"
        },
        {
          "direction": "Right",
          "hash": "GirkzdS9YpsAz5fXuL5T3rXd93aRcnXNAdXYi241qpWK"
        }
      ]
    }
  }
}
```
</details>

- Second step: `confirm`. A second transaction is sent to confirm the transfer. This transaction takes the request id
  returned by the first transaction and does the actual transfer. The transaction result is as follows

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "123",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "multisigtest.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1000000000000000000000000"
                }
              }
            ],
            "gas_price": "451542320",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
          }
        },
        "receipt_id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
        "receiver_id": "bowen"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "78458115804795000000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
          }
        },
        "receipt_id": "6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd",
        "receiver_id": "multisigtest.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "112870156274913516718240"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "multisigtest.testnet",
            "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
          }
        },
        "receipt_id": "CHfzz6NLcQMyiLHBQoczhgm5BFjLVfv9B7eCyXKLhhcT",
        "receiver_id": "multisigtest.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "9JEiMrZ1SpAUEbQswde3Diptzwy35Vrvd41VZWG9hYVE",
        "id": "FfuhYhsgFL7sLC8pk1tuRnMHJdqycE6gEcfgZLW9fmFB",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 10109796553814,
          "logs": [],
          "receipt_ids": [
            "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
            "CHfzz6NLcQMyiLHBQoczhgm5BFjLVfv9B7eCyXKLhhcT"
          ],
          "status": {
            "SuccessReceiptId": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy"
          },
          "tokens_burnt": "1010979655381400000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "9e2UcG6qBRahBh3V2Z8bGJLh5c4jXfZdP3WBJkCpJCfj"
          }
        ]
      },
      {
        "block_hash": "4LkVfqyhhrxDdVFmow6NxLf1jTaj6XVr7CVcUxxySd1R",
        "id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
        "outcome": {
          "executor_id": "bowen",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": ["6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "FFWaWUFt6sNx5XNHzGYsYBSYFWtGPoww5XQz1QmLVc8i"
          }
        ]
      },
      {
        "block_hash": "G6LDdnAa2b38TB4KZ89HAyVgfgyiRPDDgSxoZypbUYpx",
        "id": "6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "4LkVfqyhhrxDdVFmow6NxLf1jTaj6XVr7CVcUxxySd1R",
        "id": "CHfzz6NLcQMyiLHBQoczhgm5BFjLVfv9B7eCyXKLhhcT",
        "outcome": {
          "executor_id": "multisigtest.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "DpDYAEKZTtSomgyeNcJ2i4qjvfqnCtf1CXa83Cz5wvEy"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZXF1ZXN0X2lkIjo4fQ==",
            "deposit": "0",
            "gas": 250000000000000,
            "method_name": "confirm"
          }
        }
      ],
      "hash": "Fu39vwxC4mu9ks1DZA5Cib63RnBMHpFonk2DcbpioEYc",
      "nonce": 9,
      "public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz",
      "receiver_id": "multisigtest.testnet",
      "signature": "ed25519:2raQq7t3cmzSL2krE2xaNqXhAw7cKMoXrBjT2ZhAGfCVtGwzbbQ8zkB17vrCSFZDbFmPWSJpoqsw8qPZZiorwSzS",
      "signer_id": "multisigtest.testnet"
    },
    "transaction_outcome": {
      "block_hash": "9JEiMrZ1SpAUEbQswde3Diptzwy35Vrvd41VZWG9hYVE",
      "id": "Fu39vwxC4mu9ks1DZA5Cib63RnBMHpFonk2DcbpioEYc",
      "outcome": {
        "executor_id": "multisigtest.testnet",
        "gas_burnt": 2427972426482,
        "logs": [],
        "receipt_ids": ["FfuhYhsgFL7sLC8pk1tuRnMHJdqycE6gEcfgZLW9fmFB"],
        "status": {
          "SuccessReceiptId": "FfuhYhsgFL7sLC8pk1tuRnMHJdqycE6gEcfgZLW9fmFB"
        },
        "tokens_burnt": "242797242648200000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "B6hN48qeVP8J3hP8XGcANShM264QkNjgJAfMtsuknqex"
        }
      ]
    }
  }
}
```
</details>

Notice that similar to the transfer from lockup contract, there is also one receipt in the `receipts` field that meet
our requirements:

```json
{
  "predecessor_id": "multisigtest.testnet",
  "receipt": {
    "Action": {
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "gas_price": "451542320",
      "input_data_ids": [],
      "output_data_receivers": [],
      "signer_id": "multisigtest.testnet",
      "signer_public_key": "ed25519:BmVX32jhvEd8d8outiQdjf66GGYV3pb7kaxrKTdNisCz"
    }
  },
  "receipt_id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
  "receiver_id": "bowen"
}
```

and we can find its outcome in `receipts_outcome`:

```json
{
  "block_hash": "4LkVfqyhhrxDdVFmow6NxLf1jTaj6XVr7CVcUxxySd1R",
  "id": "DZbHTEf3i3XznK4oJHQfcrteoiCL6WykRiA8vsn4LmAy",
  "outcome": {
    "executor_id": "bowen",
    "gas_burnt": 223182562500,
    "logs": [],
    "receipt_ids": ["6SxC9GfYdjqm7Ao5EAw51XUAjgoN8Lj2X9xJfxjDQYXd"],
    "status": {
      "SuccessValue": ""
    },
    "tokens_burnt": "22318256250000000000"
  },
  "proof": [
    {
      "direction": "Right",
      "hash": "FFWaWUFt6sNx5XNHzGYsYBSYFWtGPoww5XQz1QmLVc8i"
    }
  ]
}
```

which indicates that the transaction is successful.

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/balance.md 

 ---
id: balance-changes
title: Balance changes
sidebar_label: Balance Changes
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Prerequisites {#prerequisites}

- [NEAR Account](https://testnet.mynearwallet.com/create)
- [NEAR-CLI](/tools/near-cli)
- Credentials for sender account stored locally by running [`near login`](/tools/near-cli#import)

### Native NEAR (‚ìÉ) {#native-near}

> Balance changes on accounts can be tracked by using our [changes RPC endpoint](/api/rpc/contracts#view-account-changes). You can test this out by sending tokens to an account using [NEAR-CLI](/tools/near-cli#send-near) and then viewing the changes made.

## Send Tokens {#send-tokens}

- Send tokens using [`near send`](../4.tools/cli.md#send-near)

<Tabs groupId="cli-tabs">

  <TabItem value="short" label="Short">

  ```bash
  near send sender.testnet receiver.testnet 1
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near tokens sender.testnet send-near receiver.testnet '1 NEAR' network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

- You should see a result in your terminal that looks something like this:

```bash
Sending 1 NEAR to receiver.testnet from sender.testnet
Transaction Id 4To336bYcoGc3LMucJPMk6fMk5suKfCrdNotrRtTxqDy
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/4To336bYcoGc3LMucJPMk6fMk5suKfCrdNotrRtTxqDy
```

## View Balance Changes {#view-balance-changes}

- Open the transaction URL in [NearBlocks Explorer](https://testnet.nearblocks.io/) and copy the `BLOCK HASH`.
- Using the `BLOCK HASH` and the accountId, query the [changes RPC endpoint](/api/rpc/contracts#view-account-changes) to view changes.

**Example Query using HTTPie:**

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare \
    method=EXPERIMENTAL_changes \
    'params:={
        "block_id": "CJ24svU3C9FaULVjcNVnWuVZjK6mNaQ8p6AMyUDMqB37",
        "changes_type": "account_changes",
        "account_ids": ["sender.testnet"]
    }'
```

<details>
<summary>**Example Response:**</summary>

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "BRgE4bjmUo33jmiVBcZaWGkSLVeL7TTi4ZxYTvJdPbB9",
    "changes": [
      {
        "cause": {
          "tx_hash": "4To336bYcoGc3LMucJPMk6fMk5suKfCrdNotrRtTxqDy",
          "type": "transaction_processing"
        },
        "change": {
          "account_id": "sender.testnet",
          "amount": "11767430014412510000000000",
          "code_hash": "11111111111111111111111111111111",
          "locked": "0",
          "storage_paid_at": 0,
          "storage_usage": 806
        },
        "type": "account_update"
      }
    ]
  }
}
```
</details>

---

Alternatively, you can view account balances by [querying `view_account`](/api/rpc/contracts#view-account) which only requires an accountId.

**Example HTTPie Request:**

  ```bash
  http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=query \
  params:='{
    "request_type": "view_account",
    "finality": "final",
    "account_id": "sender.testnet"
  }'
  ```

**Example Response:**

```json
{
  "id": "dontcare",
  "jsonrpc": "2.0",
  "result": {
    "amount": "11767430683960197500000000",
    "block_hash": "HUiscpNyoyR5z1UdnZhAJLNz1G8UjBrFTecSYqCrvdfW",
    "block_height": 50754977,
    "code_hash": "11111111111111111111111111111111",
    "locked": "0",
    "storage_paid_at": 0,
    "storage_usage": 806
  }
}
```

**Note:** Gas prices can change between blocks. Even for transactions with deterministic gas cost the cost in NEAR could also be different. You can query the gas price for recent blocks using the [`gas_price` RPC endpoint](https://docs.near.org/api/rpc/setup#gas-price).

---

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/create-transactions.md 

 ---
id: create-transactions
title: Create Transactions
sidebar_label: Create a Transaction
---

To construct & process transactions you will need our API JavaScript library: [`near-api-js`](/build/web3-apps/integrate-contracts). There are many ways to create transactions but for this example we'll show you two ways to create a simple token transfer transaction.

- [HIGH LEVEL](#high-level----create-a-transaction) - _easiest way to create a transaction_
- [LOW LEVEL](#low-level----create-a-transaction) - _performs the exact same transaction as above, but deconstructs the entire process for those curious about each step_

At the core, all transactions require the following:

- `signerId` _(account ID of the transaction originator)_
- `signerPublicKey`
- `receiverId` _(account ID of the transaction recipient)_
- `nonceForPublicKey` _(each time a key is used the nonce value should be incremented by 1)_
- `actions` _( [[click here]](/concepts/protocol/transaction-anatomy#actions) for supported arguments)_
- `blockHash` _(a current block hash (within 24hrs) to prove the transaction was recently created)_

See [Transaction Class](https://near.github.io/near-api-js/classes/near-api-js.transaction.Transaction.html) for a more in depth outline.

---

## HIGH LEVEL -- Create a transaction

### Setup

1. Clone the [transaction-examples](https://github.com/near-examples/transaction-examples) repository by running:

```bash
git clone https://github.com/near-examples/transaction-examples.git
```

2. Follow [setup instructions](https://github.com/near-examples/transaction-examples/blob/master/README.md#prerequisites)

### Imports

In [`send-tokens-easy.js`](https://github.com/near-examples/transaction-examples/blob/9e999253aafa2c3e3b537810a0b8ce7596c3506c/send-tokens-easy.js#L1-L5) we use two dependencies:

1. [NEAR API JavaScript library](https://github.com/near/near-api-js)
2. [`dotenv`](https://www.npmjs.com/package/dotenv) (used to load environment variables for private key)

```js
const nearAPI = require("near-api-js");
const { connect, KeyPair, keyStores, utils } = nearAPI;
require("dotenv").config();
```

The second line above deconstructs several utilities from nearAPI that you will use to interact with the blockchain.

- `connect` - create a connection to NEAR passing configuration variables
- `KeyPair` - creates a keyPair from the private key you'll provide in an `.env` file
- `keyStores` - stores the keyPair that you will create from the private key and used to sign Transactions
- `utils` - used to format NEAR amounts

### Accounts & Network

Next, you'll need to enter the `accountId` of the `sender` and `receiver`, as well as the `networkId` (`betanet`, `testnet`, or `mainnet`).

```js
const sender = "sender.testnet";
const receiver = "receiver.testnet";
const networkId = "testnet";
```

### Formatting Token Amounts

When sending NEAR tokens (‚ìÉ) during a transaction, the amount needs to be converted into [Yocto](https://en.wikipedia.org/wiki/Yocto-) ‚ìÉ or (10^-24).

- To perform this you will use the [`near-api-js`](https://github.com/near/near-api-js) method [`parseNearAmount()`](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/format.ts#L53-L63) (located in `utils/format`)

```js
const amount = nearAPI.utils.format.parseNearAmount("1.5");
```

### Create a Key Store

In order to sign transactions you will need to create a "Key Store" that will hold a [full access key](/concepts/protocol/access-keys#full-access-keys) to sign your transactions. There are several ways to accomplish this, but for this example we will use a private key stored in either an `.env` file in your project or an environment variable exported globally.

- If you created the account using [`near-cli`](../4.tools/cli.md) or ran [`near login`](../4.tools/cli.md#import) in your terminal, your private key can be found in the your machine's keychain.
- If you created an account using [NEAR Wallet](https://testnet.mynearwallet.com/), your key will be found in your browser's `Local Storage`.
  - In your browser's dev tools... `Application` >> `Storage` >> `Local Storage`

```js
// sets up an empty keyStore object in memory using near-api-js
const keyStore = new keyStores.InMemoryKeyStore();
// creates a keyPair from the private key provided in your .env file
const keyPair = KeyPair.fromString(process.env.SENDER_PRIVATE_KEY);
// adds the key you just created to your keyStore which can hold multiple keys (must be inside an async function)
await keyStore.setKey(networkId, sender, keyPair);
```

### Setting up a connection to NEAR

Now create a connection to NEAR using a configuration object that will contain your `networkId` setup earlier as well as your `keyStore`.

```js
// configuration used to connect to NEAR
const prefix = (networkId === "testnet") ? "testnet" : "www";

const config = {
  networkId,
  keyStore,
  nodeUrl: `https://rpc.${networkId}.near.org`,
  walletUrl: `https://wallet.${networkId}.near.org`,
  helperUrl: `https://helper.${networkId}.near.org`,
  explorerUrl: `https://${prefix}.nearblocks.io`,
};

// connect to NEAR! :)
const near = await connect(config);
// create a NEAR account object
const senderAccount = await near.account(sender);
```

You'll notice the last line uses your NEAR connection to create a `senderAccount` object that you'll use to perform the transaction.

### Create, Sign, & Send Transaction

Now that everything is setup, creating the transaction is a single line of code.

```js
const result = await senderAccount.sendMoney(receiver, amount);
```

This simple command constructs, signs, and sends a token transfer transaction on the NEAR blockchain. There is no need to create a `result` variable aside from inspecting the response details from your transaction and even create a link to [NearBlocks Explorer](https://testnet.nearblocks.io/) to view a GUI version of the transaction details.

---

## LOW LEVEL -- Create a Transaction

### Setup

1. Clone the [transaction-examples](https://github.com/near-examples/transaction-examples) repository by running:

```bash
git clone https://github.com/near-examples/transaction-examples.git
```

2. Follow [setup instructions](https://github.com/near-examples/transaction-examples/blob/master/README.md#prerequisites)

---

### Imports

In [`send-tokens-deconstructed.js`](https://github.com/near-examples/transaction-examples/blob/master/send-tokens-deconstructed.js#L1-L4) we use three dependencies:

1. [NEAR API JavaScript library](https://github.com/near/near-api-js)
2. [`js-sha256`](https://www.npmjs.com/package/js-sha256) (cryptographic hashing algorithm)
3. [`dotenv`](https://www.npmjs.com/package/dotenv) (used to load environment variables)

```js
const nearAPI = require("near-api-js");
const sha256 = require("js-sha256");
require("dotenv").config();
```

---

### Accounts & Network

Next, you'll need to enter the `accountId` of the `sender` and `receiver`, as well as the `networkId` (`betanet`, `testnet`, or `mainnet`).

```js
const sender = "sender.testnet";
const receiver = "receiver.testnet";
const networkId = "testnet";
```

---

### Formatting Token Amounts

When sending NEAR tokens (‚ìÉ) during a transaction, the amount needs to be converted into [Yocto](https://en.wikipedia.org/wiki/Yocto-) ‚ìÉ or (10^-24).

- To perform this you will use the [`near-api-js`](https://github.com/near/near-api-js) method [`parseNearAmount()`](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/format.ts#L53-L63) (located in `utils/format`)

```js
const amount = nearAPI.utils.format.parseNearAmount("1.5");
```

---

### Setting up a connection to NEAR

In this example, we will create a NEAR RPC `provider` that allows us to interact with the chain via [RPC endpoints](/api/rpc/introduction).

```js
const provider = new nearAPI.providers.JsonRpcProvider(
  `https://rpc.${networkId}.near.org`
);
```

---

### Access Keys

To sign a transaction to send NEAR ‚ìÉ, we will need a `FullAccess` key to the sender's account.

- If you created the account using [`near-cli`](../4.tools/cli.md) or ran [`near login`](../4.tools/cli.md#import) in your terminal, your private key can be found in your machine's keychain.
- If you created an account using [NEAR Wallet](https://testnet.mynearwallet.com/), your key will be found in your browser's `Local Storage`.
  - In your browser's dev tools... `Application` >> `Storage` >> `Local Storage`

Once you have access to the private key of the sender's account, create an environment variable `SENDER_PRIVATE_KEY` or hard code it as a string on [line 18](https://github.com/near-examples/transaction-examples/blob/master/send-tokens-deconstructed.js#L18) of `send-tokens.js`.

- With this `privateKey`, we can now construct a `keyPair` object to sign transactions.

```js
const privateKey = process.env.SENDER_PRIVATE_KEY;
const keyPair = nearAPI.KeyPair.fromString(privateKey);
```

---

### Transaction Requirements

As stated before, all transactions require six parts:

1. [`signerId`](#1-signerid)
2. [`signerPublicKey`](#2-signerpublickey)
3. [`receiverId`](#3-receiverid)
4. [`nonceForPublicKey`](#4-nonceforpublickey)
5. [`actions`](/concepts/protocol/transaction-anatomy#actions)
6. [`blockHash`](#6-blockhash)

### 1 `signerId`

- The `signerId` is the account ID of the transaction originator.
- This value is passed as a string (ex. `'example.testnet'` or `'bob.near'`)

### 2 `signerPublicKey`

- The `signerPublicKey` is required to be an object with two key value pairs: `keyType` and `data`.

```js
PublicKey = {
  keyType: 0,
  data: Uint8Array(32)[
    (190,
    150,
    152,
    145,
    232,
    248,
    128,
    151,
    167,
    165,
    128,
    46,
    20,
    231,
    103,
    142,
    39,
    56,
    152,
    46,
    135,
    1,
    161,
    180,
    94,
    212,
    195,
    201,
    73,
    190,
    70,
    242)
  ],
};
```

- This can be constructed by calling `getPublicKey()` using the `keyPair` we [setup earlier](#access-keys).

```js
const publicKey = keyPair.getPublicKey();
```

### 3 `receiverId`

- The `receiverId` is the account ID of the transaction recipient.
- This value is passed as a string (ex. `'example.testnet'` or `'bob.near'`)
- The certain cases, the `signerId` and the `receiverId` can be the same account.

### 4 `nonceForPublicKey`

- A unique number or `nonce` is required for each transaction signed with an access key.
- To ensure a unique number is created for each transaction, the current `nonce` should be queried and then incremented by 1.
- Current nonce can be retrieved using the `provider` we [created earlier](#setting-up-a-connection-to-near).

```js
const accessKey = await provider.query(
  `access_key/${sender}/${publicKey.toString()}`,
  ""
);
```

- now we can create a unique number for our transaction by incrementing the current `nonce`.

```js
const nonce = ++accessKey.nonce;
```

### 5 `actions`

- There are currently eight supported `Action` types. [[see here]](/concepts/protocol/transaction-anatomy#actions)
- For this example, we are using `Transfer`
- This transfer action can be created using the [imported `nearAPI` object](#imports) and the [formatted ‚ìÉ amount](#formatting-token-amounts) created earlier.

```js
const actions = [nearAPI.transactions.transfer(amount)];
```

[[click here]](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L70-L72) to view source for `transfer()`.

### 6 `blockHash`

- Each transaction requires a current block hash (within 24hrs) to prove that the transaction was created recently.
- Hash must be converted to an array of bytes using the `base_decode` method found in [`nearAPI`](#imports).

```js
const recentBlockHash = nearAPI.utils.serialize.base_decode(
  accessKey.block_hash
);
```

[[click here]](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/utils/serialize.ts#L16-L17) to view source for `base_decode()`.

---

### Constructing the Transaction

With all of our [required arguments](#transaction-requirements), we can construct the transaction.

- Using [`nearAPI`](#imports), we call on `createTransaction()` to perform this task.

```js
const transaction = nearAPI.transactions.createTransaction(
  sender,
  publicKey,
  receiver,
  nonce,
  actions,
  recentBlockHash
);
```

[[click here]](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L95-L110) to view source code for the Transaction class

---

### Sign Transaction

Now that the transaction is created, we sign it before sending it to the NEAR blockchain. At the lowest level, there are four steps to this process.

1. Using [`nearAPI`](#imports), we call on `serialize()` to serialize the transaction in [Borsh](https://borsh.io/).

```js
const serializedTx = nearAPI.utils.serialize.serialize(
  nearAPI.transactions.SCHEMA.Transaction,
  transaction
);
```

2. Hash the serialized transaction using a `sha256` cryptographic hashing algorithm.

```js
const serializedTxHash = new Uint8Array(sha256.sha256.array(serializedTx));
```

3. Create a signature with the `keyPair`.

```js
const signature = keyPair.sign(serializedTxHash);
```

4. Construct the signed transaction using `near-api-js` [SignedTransaction class](https://github.com/near/near-api-js/blob/d4d4cf1ac3182fa998b1e004e6782219325a641b/src/transaction.ts#L112-L123).

```js
const signedTransaction = new nearAPI.transactions.SignedTransaction({
  transaction,
  signature: new nearAPI.transactions.Signature({
    keyType: transaction.publicKey.keyType,
    data: signature.signature,
  }),
});
```

### Send Transaction

Final step is to encode and send the transaction.

- First we serialize transaction into [Borsh](https://borsh.io/), and store the result as `signedSerializedTx`. _(required for all transactions)_
- Then we send the transaction via [RPC call](/api/rpc/introduction) using the `sendJsonRpc()` method nested inside [`near`](#setting-up-a-connection-to-near).

```js
// encodes transaction to serialized Borsh (required for all transactions)
const signedSerializedTx = signedTransaction.encode();
// sends transaction to NEAR blockchain via JSON RPC call and records the result
const result = await provider.sendJsonRpc("broadcast_tx_commit", [
  Buffer.from(signedSerializedTx).toString("base64"),
]);
```

### Transaction Results

Detailed transaction results of the transaction are returned in the following format:

```bash
{
  status: { SuccessValue: '' },
  transaction: {
    signer_id: 'sender.testnet',
    public_key: 'ed25519:8RazSLHvzj4TBSKGUo5appP7wVeqZNQYjP9hvhF4ZKS2',
    nonce: 57,
    receiver_id: 'receiver.testnet',
    actions: [ [Object] ],
    signature: 'ed25519:2sK53w6hybSxX7qWShXz6xKnjnYRUW7Co3evEaaggNW6pGSCNPvx7urY4akwnzAbxZGwsKjx8dcVm73qbitntJjz',
    hash: 'EgGzB73eFxCwZRGcEyCKedLjvvgxhDXcUtq21SqAh79j'
  },
  transaction_outcome: {
    proof: [ [Object] ],
    block_hash: 'J6cFDzAFkuknHMCEYW2uPQXDvCfSndkJmADVEWJbtTwV',
    id: 'EgGzB73eFxCwZRGcEyCKedLjvvgxhDXcUtq21SqAh79j',
    outcome: {
      logs: [],
      receipt_ids: [Array],
      gas_burnt: 223182562500,
      tokens_burnt: '22318256250000000000',
      executor_id: 'sender.testnet',
      status: [Object]
    }
  },
  receipts_outcome: [
    {
      proof: [Array],
      block_hash: 'FSS7UzTpMr4mUm6aw8MmzP6Q7wnQs35VS8vYm1R461dM',
      id: '3LjBxe2jq1s7XEPrYxihp4rPVdyHAbYfkcdJjUEVijhJ',
      outcome: [Object]
    },
    {
      proof: [Array],
      block_hash: '4XBio5dM5UGYjJgzZjgckfVgMZ9uKGbTkt8zZi5webxw',
      id: 'AXFA4kwiYfruKQ4LkD1qZA8P7HoAvtFwGqwQYdWtWNaW',
      outcome: [Object]
    }
  ]
}
Transaction Results:  {
  signer_id: 'sender.testnet',
  public_key: 'ed25519:8RazSLHvzj4TBSKGUo5appP7wVeqZNQYjP9hvhF4ZKS2',
  nonce: 57,
  receiver_id: 'receiver.testnet',
  actions: [ { Transfer: [Object] } ],
  signature: 'ed25519:2sK53w6hybSxX7qWShXz6xKnjnYRUW7Co3evEaaggNW6pGSCNPvx7urY4akwnzAbxZGwsKjx8dcVm73qbitntJjz',
  hash: 'EgGzB73eFxCwZRGcEyCKedLjvvgxhDXcUtq21SqAh79j'
}
```

For detailed information on transaction receipts [[click here]](https://nomicon.io/RuntimeSpec/Receipts.html)

- To view the transaction in [NearBlocks Explorer](https://testnet.nearblocks.io/), enter the `hash` located under `transaction` / `Transaction Results`.
- In addition, you can create a link in JS using the `networkId` and `result.transaction.hash`.

```js
const prefix = (networkId === "testnet") ? "testnet." : "";
const transactionLink = `https://${prefix}nearblocks.io/txns/${result.transaction.hash}`;
```

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"><h8>Ask it on StackOverflow!</h8></a>
:::

Happy Coding! üöÄ


 This is the content for the doc docs/6.integrations/errors/error-implementation.md 

 ---
id: error-implementation
title: Source Code Survey
sidebar_label: Source Code Survey
---

This page provides a very high level, sometimes "pseudocode", view of error types and related messages as implemented by the NEAR platform.

Errors raised by the NEAR platform are implemented in the following locations in `nearcore`:

- [nearcore/core/primitives/src/errors.rs](https://github.com/near/nearcore/blob/master/core/primitives/src/errors.rs)
- [nearcore/runtime/near-vm-errors/src/lib.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-errors/src/lib.rs)

---

## RuntimeError and subtypes {#runtimeerror-and-subtypes}

### RuntimeError {#runtimeerror}

#### Definition {#definition}

```rust
/// Error returned from `Runtime::apply`
pub enum RuntimeError {
    /// An unexpected integer overflow occurred. The likely issue is an invalid state or the transition.
    UnexpectedIntegerOverflow,
    /// An error happened during TX verification and account charging. It's likely the chunk is invalid.
    /// and should be challenged.
    InvalidTxError(InvalidTxError),
    /// Unexpected error which is typically related to the node storage corruption.account
    /// That it's possible the input state is invalid or malicious.
    StorageError(StorageError),
    /// An error happens if `check_balance` fails, which is likely an indication of an invalid state.
    BalanceMismatchError(BalanceMismatchError),
}
```

#### Error Messages {#error-messages}

- see below: `InvalidTxError`, `StorageError` and `BalanceMismatchError`

### InvalidTxError {#invalidtxerror}

#### Definition {#definition-1}

```rust
/// An error happened during TX execution
pub enum InvalidTxError {
    /// Happens if a wrong AccessKey used or AccessKey has not enough permissions
    InvalidAccessKeyError(InvalidAccessKeyError),
    /// TX signer_id is not in a valid format or not satisfy requirements see `near_core::primitives::utils::is_valid_account_id`
    InvalidSignerId { signer_id: AccountId },
    /// TX signer_id is not found in a storage
    SignerDoesNotExist { signer_id: AccountId },
    /// Transaction nonce must be account[access_key].nonce + 1
    InvalidNonce { tx_nonce: Nonce, ak_nonce: Nonce },
    /// TX receiver_id is not in a valid format or not satisfy requirements see `near_core::primitives::utils::is_valid_account_id`
    InvalidReceiverId { receiver_id: AccountId },
    /// TX signature is not valid
    InvalidSignature,
    /// Account does not have enough balance to cover TX cost
    NotEnoughBalance {
        signer_id: AccountId,
        balance: Balance,
        cost: Balance,
    },
    /// Signer account rent is unpaid
    RentUnpaid {
        /// An account which is required to pay the rent
        signer_id: AccountId,
        /// Required balance to cover the state rent
        amount: Balance,
    },
    /// An integer overflow occurred during transaction cost estimation.
    CostOverflow,
    /// Transaction parent block hash doesn't belong to the current chain
    InvalidChain,
    /// Transaction has expired
    Expired,
    /// An error occurred while validating actions of a Transaction.
    ActionsValidation(ActionsValidationError),
}
```


#### Error Messages {#error-messages-1}

```rust
InvalidTxError::InvalidSignerId { signer_id }
    "Invalid signer account ID {:?} according to requirements"

InvalidTxError::SignerDoesNotExist { signer_id }
    "Signer {:?} does not exist"

InvalidTxError::InvalidAccessKeyError(access_key_error)

InvalidTxError::InvalidNonce { tx_nonce, ak_nonce }
    "Transaction nonce {} must be larger than nonce of the used access key {}"

InvalidTxError::InvalidReceiverId { receiver_id }
    "Invalid receiver account ID {:?} according to requirements"

InvalidTxError::InvalidSignature
    "Transaction is not signed with the given public key"

InvalidTxError::NotEnoughBalance { signer_id, balance, cost }
    "Sender {:?} does not have enough balance {} for operation costing {}"

InvalidTxError::RentUnpaid { signer_id, amount }
    "Failed to execute, because the account {:?} wouldn't have enough to pay required rent {}" 

InvalidTxError::CostOverflow
    "Transaction gas or balance cost is too high"

InvalidTxError::InvalidChain
    "Transaction parent block hash doesn't belong to the current chain"

InvalidTxError::Expired
    "Transaction has expired"

InvalidTxError::ActionsValidation(error)
    "Transaction actions validation error: {}"
```

### StorageError {#storageerror}

#### Definition {#definition-2}

```rust
pub enum StorageError {
    /// Key-value db internal failure
    StorageInternalError,
    /// Storage is PartialStorage and requested a missing trie node
    TrieNodeMissing,
    /// Either invalid state or key-value db is corrupted.
    /// For PartialStorage it cannot be corrupted.
    /// Error message is unreliable and for debugging purposes only. It's also probably ok to
    /// panic in every place that produces this error.
    /// We can check if db is corrupted by verifying everything in the state trie.
    StorageInconsistentState(String),
}
```

### BalanceMismatchError {#balancemismatcherror}

#### Definition {#definition-3}

```rust
/// Happens when the input balance doesn't match the output balance in Runtime apply.
pub struct BalanceMismatchError {
    // Input balances
    pub incoming_validator_rewards: Balance,
    pub initial_accounts_balance: Balance,
    pub incoming_receipts_balance: Balance,
    pub processed_delayed_receipts_balance: Balance,
    pub initial_postponed_receipts_balance: Balance,
    // Output balances
    pub final_accounts_balance: Balance,
    pub outgoing_receipts_balance: Balance,
    pub new_delayed_receipts_balance: Balance,
    pub final_postponed_receipts_balance: Balance,
    pub total_rent_paid: Balance,
    pub total_validator_reward: Balance,
    pub total_balance_burnt: Balance,
    pub total_balance_slashed: Balance,
}
```

#### Error Messages {#error-messages-2}

```rust
"Balance Mismatch Error. The input balance {} doesn't match output balance {}\n\
Inputs:\n\
    \tIncoming validator rewards sum: {}\n\
    \tInitial accounts balance sum: {}\n\
    \tIncoming receipts balance sum: {}\n\
    \tProcessed delayed receipts balance sum: {}\n\
    \tInitial postponed receipts balance sum: {}\n\
Outputs:\n\
    \tFinal accounts balance sum: {}\n\
    \tOutgoing receipts balance sum: {}\n\
    \tNew delayed receipts balance sum: {}\n\
    \tFinal postponed receipts balance sum: {}\n\
    \tTotal rent paid: {}\n\
    \tTotal validators reward: {}\n\
    \tTotal balance burnt: {}\n\
    \tTotal balance slashed: {}",
```

### InvalidAccessKeyError {#invalidaccesskeyerror}

#### Definition {#definition-4}

```rust
pub enum InvalidAccessKeyError {
    /// The access key identified by the `public_key` doesn't exist for the account
    AccessKeyNotFound { account_id: AccountId, public_key: PublicKey },
    /// Transaction `receiver_id` doesn't match the access key receiver_id
    ReceiverMismatch { tx_receiver: AccountId, ak_receiver: AccountId },
    /// Transaction method name isn't allowed by the access key
    MethodNameMismatch { method_name: String },
    /// Transaction requires a full permission access key.
    RequiresFullAccess,
    /// Access Key does not have enough allowance to cover transaction cost
    NotEnoughAllowance {
        account_id: AccountId,
        public_key: PublicKey,
        allowance: Balance,
        cost: Balance,
    },
    /// Having a deposit with a function call action is not allowed with a function call access key.
    DepositWithFunctionCall,
}
```

#### Error Messages {#error-messages-3}

```rust
InvalidAccessKeyError::AccessKeyNotFound { account_id, public_key }
    "Signer {:?} doesn't have access key with the given public_key {}"

InvalidAccessKeyError::ReceiverMismatch { tx_receiver, ak_receiver }
    "Transaction receiver_id {:?} doesn't match the access key receiver_id {:?}"

InvalidAccessKeyError::MethodNameMismatch { method_name }
    "Transaction method name {:?} isn't allowed by the access key"

InvalidAccessKeyError::RequiresFullAccess
    "The transaction contains more then one action, but it was signed \
     with an access key which allows transaction to apply only one specific action. \
     To apply more then one actions TX must be signed with a full access key"

InvalidAccessKeyError::NotEnoughAllowance { account_id, public_key, allowance, cost }
    "Access Key {:?}:{} does not have enough balance {} for transaction costing {}"

InvalidAccessKeyError::DepositWithFunctionCall
    "Having a deposit with a function call action is not allowed with a function call access key."
```

### ActionsValidationError {#actionsvalidationerror}

#### Definition {#definition-5}

```rust
/// Describes the error for validating a list of actions.
pub enum ActionsValidationError {
    /// The total prepaid gas (for all given actions) exceeded the limit.
    TotalPrepaidGasExceeded { total_prepaid_gas: Gas, limit: Gas },
    /// The number of actions exceeded the given limit.
    TotalNumberOfActionsExceeded { total_number_of_actions: u64, limit: u64 },
    /// The total number of bytes of the method names exceeded the limit in a Add Key action.
    AddKeyMethodNamesNumberOfBytesExceeded { total_number_of_bytes: u64, limit: u64 },
    /// The length of some method name exceeded the limit in a Add Key action.
    AddKeyMethodNameLengthExceeded { length: u64, limit: u64 },
    /// Integer overflow during a compute.
    IntegerOverflow,
    /// Invalid account ID.
    InvalidAccountId { account_id: AccountId },
    /// The size of the contract code exceeded the limit in a DeployContract action.
    ContractSizeExceeded { size: u64, limit: u64 },
    /// The length of the method name exceeded the limit in a Function Call action.
    FunctionCallMethodNameLengthExceeded { length: u64, limit: u64 },
    /// The length of the arguments exceeded the limit in a Function Call action.
    FunctionCallArgumentsLengthExceeded { length: u64, limit: u64 },
}
```

#### Error Messages {#error-messages-4}

```rust
ActionsValidationError::TotalPrepaidGasExceeded     { total_prepaid_gas, limit }
     "The total prepaid gas {} exceeds the limit {}"
     
ActionsValidationError::TotalNumberOfActionsExceeded {total_number_of_actions, limit }
     "The total number of actions {} exceeds the limit {}"
     
ActionsValidationError::AddKeyMethodNamesNumberOfBytesExceeded { total_number_of_bytes, limit }
     "The total number of bytes in allowed method names {} exceeds the maximum allowed number {} in a AddKey action"
     
ActionsValidationError::AddKeyMethodNameLengthExceeded { length, limit }
     "The length of some method name {} exceeds the maximum allowed length {} in a AddKey action"
     
ActionsValidationError::IntegerOverflow
     "Integer overflow during a compute"
     
ActionsValidationError::InvalidAccountId { account_id }
     "Invalid account ID `{}`"
     
ActionsValidationError::ContractSizeExceeded { size, limit }
     "The length of the contract size {} exceeds the maximum allowed size {} in a DeployContract action"
     
ActionsValidationError::FunctionCallMethodNameLengthExceeded { length, limit }
     "The length of the method name {} exceeds the maximum allowed length {} in a FunctionCall action"
     
ActionsValidationError::FunctionCallArgumentsLengthExceeded { length, limit }
     "The length of the arguments {} exceeds the maximum allowed length {} in a FunctionCall action"
     
```

## TxExecutionError and subtypes {#txexecutionerror-and-subtypes}

### TxExecutionError {#txexecutionerror}

#### Definition {#definition-6}
```rust
/// Error returned in the ExecutionOutcome in case of failure
pub enum TxExecutionError {
    /// An error happened during Acton execution
    ActionError(ActionError),
    /// An error happened during Transaction execution
    InvalidTxError(InvalidTxError),
}
```

### ActionError {#actionerror}

#### Definition {#definition-7}

```rust
ActionError
pub struct ActionError {
    /// Index of the failed action in the transaction.
    /// Action index is not defined if ActionError.kind is `ActionErrorKind::RentUnpaid`
    pub index: Option<u64>,
    /// The kind of ActionError happened
    pub kind: ActionErrorKind,
}
```

### ActionErrorKind {#actionerrorkind}

#### Definition {#definition-8}

```rust
pub enum ActionErrorKind {
    /// Happens when CreateAccount action tries to create an account with account_id which is already exists in the storage
    AccountAlreadyExists { account_id: AccountId },
    /// Happens when TX receiver_id doesn't exist (but action is not Action::CreateAccount)
    AccountDoesNotExist { account_id: AccountId },
    /// A newly created account must be under a namespace of the creator account
    CreateAccountNotAllowed { account_id: AccountId, predecessor_id: AccountId },
    /// Administrative actions like `DeployContract`, `Stake`, `AddKey`, `DeleteKey`. can be proceed only if sender=receiver
    /// or the first TX action is a `CreateAccount` action
    ActorNoPermission { account_id: AccountId, actor_id: AccountId },
    /// Account tries to remove an access key that doesn't exist
    DeleteKeyDoesNotExist { account_id: AccountId, public_key: PublicKey },
    /// The public key is already used for an existing access key
    AddKeyAlreadyExists { account_id: AccountId, public_key: PublicKey },
    /// Account is staking and can not be deleted
    DeleteAccountStaking { account_id: AccountId },
    /// Foreign sender (sender=!receiver) can delete an account only if a target account hasn't enough tokens to pay rent
    DeleteAccountHasRent {
        account_id: AccountId,
        balance: Balance,
    },
    /// ActionReceipt can't be completed, because the remaining balance will not be enough to pay rent.
    RentUnpaid {
        /// An account which is required to pay the rent
        account_id: AccountId,
        /// Rent due to pay.
        amount: Balance,
    },
    /// Account is not yet staked, but tries to unstake
    TriesToUnstake { account_id: AccountId },
    /// The account doesn't have enough balance to increase the stake.
    TriesToStake {
        account_id: AccountId,
        stake: Balance,
        locked: Balance,
        balance: Balance,
    },
    /// An error occurred during a `FunctionCall` Action.
    FunctionCallError(FunctionCallError),
    /// Error occurs when a new `ActionReceipt` created by the `FunctionCall` action fails
    /// receipt validation.
    NewReceiptValidationError(ReceiptValidationError),
}
```

#### Error Messages {#error-messages-5}

```rust
ActionErrorKind::AccountAlreadyExists { account_id } 
"Can't create a new account {:?}, because it already exists"

ActionErrorKind::AccountDoesNotExist { account_id } 
"Can't complete the action because account {:?} doesn't exist"

ActionErrorKind::ActorNoPermission { actor_id, account_id } 
"Actor {:?} doesn't have permission to account {:?} to complete the action"

ActionErrorKind::RentUnpaid { account_id, amount } 
"The account {} wouldn't have enough balance to pay required rent {}"

ActionErrorKind::TriesToUnstake { account_id } 
"Account {:?} is not yet staked, but tries to unstake"

ActionErrorKind::TriesToStake { account_id, stake, locked, balance } 
"Account {:?} tries to stake {}, but has staked {} and only has {}"

ActionErrorKind::CreateAccountNotAllowed { account_id, predecessor_id } 
"The new account_id {:?} can't be created by {:?}"

ActionErrorKind::DeleteKeyDoesNotExist { account_id, .. } 
"Account {:?} tries to remove an access key that doesn't exist"

ActionErrorKind::AddKeyAlreadyExists { public_key, .. } 
"The public key {:?} is already used for an existing access key"

ActionErrorKind::DeleteAccountStaking { account_id }
"Account {:?} is staking and can not be deleted"

ActionErrorKind::DeleteAccountHasRent { account_id, balance } 
"Account {:?} can't be deleted. It has {}, which is enough to cover the rent"

ActionErrorKind::FunctionCallError(s) 

ActionErrorKind::NewReceiptValidationError(e) 
"An new action receipt created during a FunctionCall is not valid: {}"
```


### ReceiptValidationError {#receiptvalidationerror}

#### Definition {#definition-9}

```rust
/// Describes the error for validating a receipt.
pub enum ReceiptValidationError {
    /// The `predecessor_id` of a Receipt is not valid.
    InvalidPredecessorId { account_id: AccountId },
    /// The `receiver_id` of a Receipt is not valid.
    InvalidReceiverId { account_id: AccountId },
    /// The `signer_id` of an ActionReceipt is not valid.
    InvalidSignerId { account_id: AccountId },
    /// The `receiver_id` of a DataReceiver within an ActionReceipt is not valid.
    InvalidDataReceiverId { account_id: AccountId },
    /// The length of the returned data exceeded the limit in a DataReceipt.
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    /// The number of input data dependencies exceeds the limit in an ActionReceipt.
    NumberInputDataDependenciesExceeded { number_of_input_data_dependencies: u64, limit: u64 },
    /// An error occurred while validating actions of an ActionReceipt.
    ActionsValidation(ActionsValidationError),
    /// Receipt is bigger than the limit.
    /// ReceiptSizeExceeded means that there was a receipt above the size limit (currently 4MiB).
    /// NEAR will refuse to execute receipts that are above the size limit.
    /// The most likely source of such receipts would be cross-contract calls with a lot of large actions
    /// (contract deployment, function call with large args, etc).
    /// This error means that the user has to adjust their contract to generate smaller receipts.
    ReceiptSizeExceeded { size: u64, limit: u64 },
}
```

#### Error Messages {#error-messages-6}

```rust
ReceiptValidationError::InvalidPredecessorId { account_id } 
"The predecessor_id `{}` of a Receipt is not valid."

ReceiptValidationError::InvalidReceiverId { account_id } 
"The receiver_id `{}` of a Receipt is not valid."

ReceiptValidationError::InvalidSignerId { account_id } 
"The signer_id `{}` of an ActionReceipt is not valid."

ReceiptValidationError::InvalidDataReceiverId { account_id } 
"The receiver_id `{}` of a DataReceiver within an ActionReceipt is not valid."

ReceiptValidationError::ReturnedValueLengthExceeded { length, limit } 
"The length of the returned data {} exceeded the limit {} in a DataReceipt"

ReceiptValidationError::NumberInputDataDependenciesExceeded { number_of_input_data_dependencies, limit } 
"The number of input data dependencies {} exceeded the limit {} in an ActionReceipt"

ReceiptValidationError::ActionsValidation(e) 

ReceiptValidationError::ReceiptSizeExceeded { size, limit }
"The size of the receipt exceeded the limit: {} > {}",
```


## VMError and subtypes {#vmerror-and-subtypes}

### VMError {#vmerror}

#### Definition {#definition-10}

```rust
pub enum VMError {
    FunctionCallError(FunctionCallError),
    /// Serialized external error from External trait implementation.
    ExternalError(Vec<u8>),
    /// An error that is caused by an operation on an inconsistent state.
    /// E.g. an integer overflow by using a value from the given context.
    InconsistentStateError(InconsistentStateError),
}
```

#### Error Messages {#error-messages-7}

```rust
VMError::ExternalError
  "Serialized ExternalError"
```

### FunctionCallError {#functioncallerror}

#### Definition {#definition-11}

```rust
pub enum FunctionCallError {
    CompilationError(CompilationError),
    LinkError { msg: String },
    MethodResolveError(MethodResolveError),
    WasmTrap { msg: String },
    HostError(HostError),
}
```

#### Error Messages {#error-messages-8}

```rust
FunctionCallError::WasmTrap
  "WebAssembly trap: {}"
```

### MethodResolveError {#methodresolveerror}

#### Definition {#definition-12}

```rust
pub enum MethodResolveError {
    MethodEmptyName,
    MethodUTF8Error,
    MethodNotFound,
    MethodInvalidSignature,
}
```

### CompilationError {#compilationerror}

#### Definition {#definition-13}

```rust
pub enum CompilationError {
    CodeDoesNotExist { account_id: String },
    PrepareError(PrepareError),
    WasmerCompileError { msg: String },
}
```
#### Error Messages {#error-messages-9}

```rust
CompilationError::CodeDoesNotExist
  "cannot find contract code for account {}"

CompilationError::PrepareError(p)
  "PrepareError: {}"

CompilationError::WasmerCompileError
  "Wasmer compilation error: {}"
```

### PrepareError {#prepareerror}

#### Definition {#definition-14}

```rust
/// Error that can occur while preparing or executing Wasm smart-contract.
pub enum PrepareError {
    /// Error happened while serializing the module.
    Serialization,
    /// Error happened while deserializing the module.
    Deserialization,
    /// Internal memory declaration has been found in the module.
    InternalMemoryDeclared,
    /// Gas instrumentation failed.
    ///
    /// This most likely indicates the module isn't valid.
    GasInstrumentation,
    /// Stack instrumentation failed.
    ///
    /// This  most likely indicates the module isn't valid.
    StackHeightInstrumentation,
    /// Error happened during instantiation.
    ///
    /// This might indicate that `start` function trapped, or module isn't
    /// instantiable and/or unlinkable.
    Instantiate,
    /// Error creating memory.
    Memory,
}
```

#### Error Messages {#error-messages-10}

```rust
Serialization
  "Error happened while serializing the module."

Deserialization
  "Error happened while deserializing the module."

InternalMemoryDeclared
  "Internal memory declaration has been found in the module."

GasInstrumentation
  "Gas instrumentation failed."

StackHeightInstrumentation
  "Stack instrumentation failed."

Instantiate
  "Error happened during instantiation."

Memory
  "Error creating memory"
```

### HostError {#hosterror}

#### Definition {#definition-15}

```rust
pub enum HostError {
    /// String encoding is bad UTF-16 sequence
    BadUTF16,
    /// String encoding is bad UTF-8 sequence
    BadUTF8,
    /// Exceeded the prepaid gas
    GasExceeded,
    /// Exceeded the maximum amount of gas allowed to burn per contract
    GasLimitExceeded,
    /// Exceeded the account balance
    BalanceExceeded,
    /// Tried to call an empty method name
    EmptyMethodName,
    /// Smart contract panicked
    GuestPanic { panic_msg: String },
    /// IntegerOverflow happened during a contract execution
    IntegerOverflow,
    /// `promise_idx` does not correspond to existing promises
    InvalidPromiseIndex { promise_idx: u64 },
    /// Actions can only be appended to non-joint promise.
    CannotAppendActionToJointPromise,
    /// Returning joint promise is currently prohibited
    CannotReturnJointPromise,
    /// Accessed invalid promise result index
    InvalidPromiseResultIndex { result_idx: u64 },
    /// Accessed invalid register id
    InvalidRegisterId { register_id: u64 },
    /// Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie
    IteratorWasInvalidated { iterator_index: u64 },
    /// Accessed memory outside the bounds
    MemoryAccessViolation,
    /// VM Logic returned an invalid receipt index
    InvalidReceiptIndex { receipt_index: u64 },
    /// Iterator index `iterator_index` does not exist
    InvalidIteratorIndex { iterator_index: u64 },
    /// VM Logic returned an invalid account id
    InvalidAccountId,
    /// VM Logic returned an invalid method name
    InvalidMethodName,
    /// VM Logic provided an invalid public key
    InvalidPublicKey,
    /// `method_name` is not allowed in view calls
    ProhibitedInView { method_name: String },
    /// The total number of logs will exceed the limit.
    NumberOfLogsExceeded { limit: u64 },
    /// The storage key length exceeded the limit.
    KeyLengthExceeded { length: u64, limit: u64 },
    /// The storage value length exceeded the limit.
    ValueLengthExceeded { length: u64, limit: u64 },
    /// The total log length exceeded the limit.
    TotalLogLengthExceeded { length: u64, limit: u64 },
    /// The maximum number of promises within a FunctionCall exceeded the limit.
    NumberPromisesExceeded { number_of_promises: u64, limit: u64 },
    /// The maximum number of input data dependencies exceeded the limit.
    NumberInputDataDependenciesExceeded { number_of_input_data_dependencies: u64, limit: u64 },
    /// The returned value length exceeded the limit.
    ReturnedValueLengthExceeded { length: u64, limit: u64 },
    /// The contract size for DeployContract action exceeded the limit.
    ContractSizeExceeded { size: u64, limit: u64 },
}
```
#### Error Messages {#error-messages-11}
```rust
BadUTF8 
  "String encoding is bad UTF-8 sequence."

BadUTF16 
  "String encoding is bad UTF-16 sequence."

GasExceeded 
  "Exceeded the prepaid gas."

GasLimitExceeded 
  "Exceeded the maximum amount of gas allowed to burn per contract."

BalanceExceeded 
  "Exceeded the account balance."

EmptyMethodName 
  "Tried to call an empty method name."

GuestPanic { panic_msg } 
  "Smart contract panicked: {}"

IntegerOverflow 
  "Integer overflow."

InvalidIteratorIndex { iterator_index } 
  "Iterator index {:?} does not exist"

InvalidPromiseIndex { promise_idx } 
  "{:?} does not correspond to existing promises"

CannotAppendActionToJointPromise 
  "Actions can only be appended to non-joint promise."

CannotReturnJointPromise 
  "Returning joint promise is currently prohibited."

InvalidPromiseResultIndex { result_idx } 
  "Accessed invalid promise result index: {:?}"

InvalidRegisterId { register_id } 
  "Accessed invalid register id: {:?}"

IteratorWasInvalidated { iterator_index } 
  "Iterator {:?} was invalidated after its creation by performing a mutable operation on trie"

MemoryAccessViolation 
  "Accessed memory outside the bounds."

InvalidReceiptIndex { receipt_index } 
  "VM Logic returned an invalid receipt index: {:?}"

InvalidAccountId 
  "VM Logic returned an invalid account id"

InvalidMethodName 
  "VM Logic returned an invalid method name"

InvalidPublicKey 
  "VM Logic provided an invalid public key"

ProhibitedInView { method_name } 
  "{} is not allowed in view calls"

NumberOfLogsExceeded { limit } 
  "The number of logs will exceed the limit {}"

KeyLengthExceeded { length, limit } 
  "The length of a storage key {} exceeds the limit {}"

ValueLengthExceeded { length, limit } 
  "The length of a storage value {} exceeds the limit {}"

TotalLogLengthExceeded{ length, limit } 
  "The length of a log message {} exceeds the limit {}"

NumberPromisesExceeded { number_of_promises, limit } 
  "The number of promises within a FunctionCall {} exceeds the limit {}"

NumberInputDataDependenciesExceeded { number_of_input_data_dependencies, limit } 
  "The number of input data dependencies {} exceeds the limit {}"

ReturnedValueLengthExceeded { length, limit } 
  "The length of a returned value {} exceeds the limit {}"

ContractSizeExceeded { size, limit } 
  "The size of a contract code in DeployContract action {} exceeds the limit {}"

```


### VMLogicError {#vmlogicerror}

#### Definition {#definition-16}

```rust
pub enum VMLogicError {
    HostError(HostError),
    /// Serialized external error from External trait implementation.
    ExternalError(Vec<u8>),
    /// An error that is caused by an operation on an inconsistent state.
    InconsistentStateError(InconsistentStateError),
}
```

### InconsistentStateError {#inconsistentstateerror}

#### Definition {#definition-17}

```rust
pub enum InconsistentStateError {
    /// Math operation with a value from the state resulted in a integer overflow.
    IntegerOverflow,
}
```

#### Error Messages {#error-messages-12}
```rust
InconsistentStateError::IntegerOverflow
    "Math operation with a value from the state resulted in a integer overflow."
```


## RPC interface {#rpc-interface}

- error name
- error subtype(s)
- error properties

### Error Schema {#error-schema}

```json
{
  "schema": {
    "BadUTF16": {
      "name": "BadUTF16",
      "subtypes": [],
      "props": {}
    },
    "BadUTF8": {
      "name": "BadUTF8",
      "subtypes": [],
      "props": {}
    },
    "BalanceExceeded": {
      "name": "BalanceExceeded",
      "subtypes": [],
      "props": {}
    },
    "CannotAppendActionToJointPromise": {
      "name": "CannotAppendActionToJointPromise",
      "subtypes": [],
      "props": {}
    },
    "CannotReturnJointPromise": {
      "name": "CannotReturnJointPromise",
      "subtypes": [],
      "props": {}
    },
    "CodeDoesNotExist": {
      "name": "CodeDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "CompilationError": {
      "name": "CompilationError",
      "subtypes": [
        "CodeDoesNotExist",
        "PrepareError",
        "WasmerCompileError"
      ],
      "props": {}
    },
    "ContractSizeExceeded": {
      "name": "ContractSizeExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "size": ""
      }
    },
    "Deserialization": {
      "name": "Deserialization",
      "subtypes": [],
      "props": {}
    },
    "EmptyMethodName": {
      "name": "EmptyMethodName",
      "subtypes": [],
      "props": {}
    },
    "FunctionCallError": {
      "name": "FunctionCallError",
      "subtypes": [
        "CompilationError",
        "LinkError",
        "MethodResolveError",
        "WasmTrap",
        "HostError"
      ],
      "props": {}
    },
    "GasExceeded": {
      "name": "GasExceeded",
      "subtypes": [],
      "props": {}
    },
    "GasInstrumentation": {
      "name": "GasInstrumentation",
      "subtypes": [],
      "props": {}
    },
    "GasLimitExceeded": {
      "name": "GasLimitExceeded",
      "subtypes": [],
      "props": {}
    },
    "GuestPanic": {
      "name": "GuestPanic",
      "subtypes": [],
      "props": {
        "panic_msg": ""
      }
    },
    "HostError": {
      "name": "HostError",
      "subtypes": [
        "BadUTF16",
        "BadUTF8",
        "GasExceeded",
        "GasLimitExceeded",
        "BalanceExceeded",
        "EmptyMethodName",
        "GuestPanic",
        "IntegerOverflow",
        "InvalidPromiseIndex",
        "CannotAppendActionToJointPromise",
        "CannotReturnJointPromise",
        "InvalidPromiseResultIndex",
        "InvalidRegisterId",
        "IteratorWasInvalidated",
        "MemoryAccessViolation",
        "InvalidReceiptIndex",
        "InvalidIteratorIndex",
        "InvalidAccountId",
        "InvalidMethodName",
        "InvalidPublicKey",
        "ProhibitedInView",
        "NumberOfLogsExceeded",
        "KeyLengthExceeded",
        "ValueLengthExceeded",
        "TotalLogLengthExceeded",
        "NumberPromisesExceeded",
        "NumberInputDataDependenciesExceeded",
        "ReturnedValueLengthExceeded",
        "ContractSizeExceeded"
      ],
      "props": {}
    },
    "Instantiate": {
      "name": "Instantiate",
      "subtypes": [],
      "props": {}
    },
    "IntegerOverflow": {
      "name": "IntegerOverflow",
      "subtypes": [],
      "props": {}
    },
    "InternalMemoryDeclared": {
      "name": "InternalMemoryDeclared",
      "subtypes": [],
      "props": {}
    },
    "InvalidAccountId": {
      "name": "InvalidAccountId",
      "subtypes": [],
      "props": {}
    },
    "InvalidIteratorIndex": {
      "name": "InvalidIteratorIndex",
      "subtypes": [],
      "props": {
        "iterator_index": ""
      }
    },
    "InvalidMethodName": {
      "name": "InvalidMethodName",
      "subtypes": [],
      "props": {}
    },
    "InvalidPromiseIndex": {
      "name": "InvalidPromiseIndex",
      "subtypes": [],
      "props": {
        "promise_idx": ""
      }
    },
    "InvalidPromiseResultIndex": {
      "name": "InvalidPromiseResultIndex",
      "subtypes": [],
      "props": {
        "result_idx": ""
      }
    },
    "InvalidPublicKey": {
      "name": "InvalidPublicKey",
      "subtypes": [],
      "props": {}
    },
    "InvalidReceiptIndex": {
      "name": "InvalidReceiptIndex",
      "subtypes": [],
      "props": {
        "receipt_index": ""
      }
    },
    "InvalidRegisterId": {
      "name": "InvalidRegisterId",
      "subtypes": [],
      "props": {
        "register_id": ""
      }
    },
    "IteratorWasInvalidated": {
      "name": "IteratorWasInvalidated",
      "subtypes": [],
      "props": {
        "iterator_index": ""
      }
    },
    "KeyLengthExceeded": {
      "name": "KeyLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "LinkError": {
      "name": "LinkError",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "Memory": {
      "name": "Memory",
      "subtypes": [],
      "props": {}
    },
    "MemoryAccessViolation": {
      "name": "MemoryAccessViolation",
      "subtypes": [],
      "props": {}
    },
    "MethodEmptyName": {
      "name": "MethodEmptyName",
      "subtypes": [],
      "props": {}
    },
    "MethodInvalidSignature": {
      "name": "MethodInvalidSignature",
      "subtypes": [],
      "props": {}
    },
    "MethodNotFound": {
      "name": "MethodNotFound",
      "subtypes": [],
      "props": {}
    },
    "MethodResolveError": {
      "name": "MethodResolveError",
      "subtypes": [
        "MethodEmptyName",
        "MethodUTF8Error",
        "MethodNotFound",
        "MethodInvalidSignature"
      ],
      "props": {}
    },
    "MethodUTF8Error": {
      "name": "MethodUTF8Error",
      "subtypes": [],
      "props": {}
    },
    "NumberInputDataDependenciesExceeded": {
      "name": "NumberInputDataDependenciesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "number_of_input_data_dependencies": ""
      }
    },
    "NumberOfLogsExceeded": {
      "name": "NumberOfLogsExceeded",
      "subtypes": [],
      "props": {
        "limit": ""
      }
    },
    "NumberPromisesExceeded": {
      "name": "NumberPromisesExceeded",
      "subtypes": [],
      "props": {
        "limit": "",
        "number_of_promises": ""
      }
    },
    "PrepareError": {
      "name": "PrepareError",
      "subtypes": [
        "Serialization",
        "Deserialization",
        "InternalMemoryDeclared",
        "GasInstrumentation",
        "StackHeightInstrumentation",
        "Instantiate",
        "Memory"
      ],
      "props": {}
    },
    "ProhibitedInView": {
      "name": "ProhibitedInView",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "ReturnedValueLengthExceeded": {
      "name": "ReturnedValueLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "Serialization": {
      "name": "Serialization",
      "subtypes": [],
      "props": {}
    },
    "StackHeightInstrumentation": {
      "name": "StackHeightInstrumentation",
      "subtypes": [],
      "props": {}
    },
    "TotalLogLengthExceeded": {
      "name": "TotalLogLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "ValueLengthExceeded": {
      "name": "ValueLengthExceeded",
      "subtypes": [],
      "props": {
        "length": "",
        "limit": ""
      }
    },
    "WasmTrap": {
      "name": "WasmTrap",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "WasmerCompileError": {
      "name": "WasmerCompileError",
      "subtypes": [],
      "props": {
        "msg": ""
      }
    },
    "AccessKeyNotFound": {
      "name": "AccessKeyNotFound",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "AccountAlreadyExists": {
      "name": "AccountAlreadyExists",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "AccountDoesNotExist": {
      "name": "AccountDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "ActionError": {
      "name": "ActionError",
      "subtypes": [
        "AccountAlreadyExists",
        "AccountDoesNotExist",
        "CreateAccountNotAllowed",
        "ActorNoPermission",
        "DeleteKeyDoesNotExist",
        "AddKeyAlreadyExists",
        "DeleteAccountStaking",
        "DeleteAccountHasRent",
        "RentUnpaid",
        "TriesToUnstake",
        "TriesToStake",
        "FunctionCallError",
        "NewReceiptValidationError"
      ],
      "props": {
        "index": ""
      }
    },
    "ActorNoPermission": {
      "name": "ActorNoPermission",
      "subtypes": [],
      "props": {
        "account_id": "",
        "actor_id": ""
      }
    },
    "AddKeyAlreadyExists": {
      "name": "AddKeyAlreadyExists",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "BalanceMismatchError": {
      "name": "BalanceMismatchError",
      "subtypes": [],
      "props": {
        "final_accounts_balance": "",
        "final_postponed_receipts_balance": "",
        "incoming_receipts_balance": "",
        "incoming_validator_rewards": "",
        "initial_accounts_balance": "",
        "initial_postponed_receipts_balance": "",
        "new_delayed_receipts_balance": "",
        "outgoing_receipts_balance": "",
        "processed_delayed_receipts_balance": "",
        "total_balance_burnt": "",
        "total_balance_slashed": "",
        "total_rent_paid": "",
        "total_validator_reward": ""
      }
    },
    "CostOverflow": {
      "name": "CostOverflow",
      "subtypes": [],
      "props": {}
    },
    "CreateAccountNotAllowed": {
      "name": "CreateAccountNotAllowed",
      "subtypes": [],
      "props": {
        "account_id": "",
        "predecessor_id": ""
      }
    },
    "DeleteAccountHasRent": {
      "name": "DeleteAccountHasRent",
      "subtypes": [],
      "props": {
        "account_id": "",
        "balance": ""
      }
    },
    "DeleteAccountStaking": {
      "name": "DeleteAccountStaking",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "DeleteKeyDoesNotExist": {
      "name": "DeleteKeyDoesNotExist",
      "subtypes": [],
      "props": {
        "account_id": "",
        "public_key": ""
      }
    },
    "DepositWithFunctionCall": {
      "name": "DepositWithFunctionCall",
      "subtypes": [],
      "props": {}
    },
    "Expired": {
      "name": "Expired",
      "subtypes": [],
      "props": {}
    },
    "InvalidAccessKeyError": {
      "name": "InvalidAccessKeyError",
      "subtypes": [
        "AccessKeyNotFound",
        "ReceiverMismatch",
        "MethodNameMismatch",
        "RequiresFullAccess",
        "NotEnoughAllowance",
        "DepositWithFunctionCall"
      ],
      "props": {}
    },
    "InvalidChain": {
      "name": "InvalidChain",
      "subtypes": [],
      "props": {}
    },
    "InvalidNonce": {
      "name": "InvalidNonce",
      "subtypes": [],
      "props": {
        "ak_nonce": "",
        "tx_nonce": ""
      }
    },
    "InvalidReceiverId": {
      "name": "InvalidReceiverId",
      "subtypes": [],
      "props": {
        "receiver_id": ""
      }
    },
    "InvalidSignature": {
      "name": "InvalidSignature",
      "subtypes": [],
      "props": {}
    },
    "InvalidSignerId": {
      "name": "InvalidSignerId",
      "subtypes": [],
      "props": {
        "signer_id": ""
      }
    },
    "InvalidTxError": {
      "name": "InvalidTxError",
      "subtypes": [
        "InvalidAccessKeyError",
        "InvalidSignerId",
        "SignerDoesNotExist",
        "InvalidNonce",
        "InvalidReceiverId",
        "InvalidSignature",
        "NotEnoughBalance",
        "RentUnpaid",
        "CostOverflow",
        "InvalidChain",
        "Expired",
        "ActionsValidation"
      ],
      "props": {}
    },
    "MethodNameMismatch": {
      "name": "MethodNameMismatch",
      "subtypes": [],
      "props": {
        "method_name": ""
      }
    },
    "NotEnoughAllowance": {
      "name": "NotEnoughAllowance",
      "subtypes": [],
      "props": {
        "account_id": "",
        "allowance": "",
        "cost": "",
        "public_key": ""
      }
    },
    "NotEnoughBalance": {
      "name": "NotEnoughBalance",
      "subtypes": [],
      "props": {
        "balance": "",
        "cost": "",
        "signer_id": ""
      }
    },
    "ReceiverMismatch": {
      "name": "ReceiverMismatch",
      "subtypes": [],
      "props": {
        "ak_receiver": "",
        "tx_receiver": ""
      }
    },
    "RentUnpaid": {
      "name": "RentUnpaid",
      "subtypes": [],
      "props": {
        "account_id": "",
        "amount": ""
      }
    },
    "RequiresFullAccess": {
      "name": "RequiresFullAccess",
      "subtypes": [],
      "props": {}
    },
    "SignerDoesNotExist": {
      "name": "SignerDoesNotExist",
      "subtypes": [],
      "props": {
        "signer_id": ""
      }
    },
    "TriesToStake": {
      "name": "TriesToStake",
      "subtypes": [],
      "props": {
        "account_id": "",
        "balance": "",
        "locked": "",
        "stake": ""
      }
    },
    "TriesToUnstake": {
      "name": "TriesToUnstake",
      "subtypes": [],
      "props": {
        "account_id": ""
      }
    },
    "TxExecutionError": {
      "name": "TxExecutionError",
      "subtypes": [
        "ActionError",
        "InvalidTxError"
      ],
      "props": {}
    },
    "Closed": {
      "name": "Closed",
      "subtypes": [],
      "props": {}
    },
    "ServerError": {
      "name": "ServerError",
      "subtypes": [
        "TxExecutionError",
        "Timeout",
        "Closed"
      ],
      "props": {}
    },
    "Timeout": {
      "name": "Timeout",
      "subtypes": [],
      "props": {}
    }
  }
}
```

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/errors/introduction.md 

 ---
id: introduction
title: Introduction
sidebar_label: Introduction
---

<blockquote className="info">
<strong>did you know?</strong><br /><br />

The [NEAR Platform overview](/concepts/basics/protocol) clarifies much of the language in this section.

</blockquote>

## The life of a transaction: {#the-life-of-a-transaction}

- A client creates a transaction, computes the transaction hash and signs this hash to get a signed transaction. Now this signed transaction can be sent to a node.
- The RPC interface receives the transaction and routes it to the correct physical node using `signer_id`.  Since the `signer_id` must be a NEAR Account ID which lives on a single shard, the account is mapped to a shard which is followed by at least one validator running at least one machine with an IP address.
- When a node receives a new signed transaction, it validates the transaction for signer, receiver, account balance, cost overflow, signature, etc. ([see here](https://nomicon.io/RuntimeSpec/Scenarios/FinancialTransaction.html#transaction-to-receipt)) and gossips it to all peers following the same shard. If a transaction has an invalid signature or would be invalid on the latest state, it is rejected quickly and returns an error to the original RPC call. 
- Valid transactions are added to the transaction pool (every validating node has its own independent copy of a transaction pool). The transaction pool maintains transactions that are not yet discarded and not yet included into the chain.
- A pool iterator is used to pick transactions from the pool one at a time, ordered from the smallest nonce to largest, until the pool is drained or some chunk limit is reached (max number of transactions per chunk or max gas burnt per chunk to process transactions).  Please refer to articles on the [pool iterator](https://nomicon.io/ChainSpec/Transactions.html?highlight=pool#pool-iterator) and [gas](/concepts/protocol/gas) for more details.
- To accommodate the distributed nature of a sharded blockchain, all transactions are subsequently returned to a segmented transaction pool having 3 distinct layers: accepted transactions (which will be processed on the next chunk), pending transactions (which exceeded the limits of the current chunk and will be included in a later round of processing) and invalid transactions (which will be rejected at the next available opportunity).
- Before producing a chunk, transactions are ordered and validated again. This is done to produce chunks with only valid transactions across a distributed system.
- While a transaction is being processed on to a chunk, any errors raised by the application of its actions are also returned via RPC.


## NEAR Platform Errors {#near-platform-errors}

Errors raised by the NEAR platform are implemented in the following locations in `nearcore`:

- [nearcore/core/primitives/src/errors.rs](https://github.com/near/nearcore/blob/master/core/primitives/src/errors.rs)
- [nearcore/runtime/near-vm-errors/src/lib.rs](https://github.com/near/nearcore/blob/master/runtime/near-vm-errors/src/lib.rs)

This page includes: 
- **RuntimeError and subtypes**: errors raised when a transaction is first received by the destination node and again before it's processed and applied to a chunk
- **TxExecutionError and subtypes**: errors raised while a transaction and its component action(s) are being validated and applied to a chunk
- **VMerror and subtypes**: errors raised during the execution of a Wasm contract by the NEAR VM

### RuntimeError and subtypes {#runtimeerror-and-subtypes}

```text
RuntimeError                                              Error returned from `Runtime::apply  
  StorageError                                            Unexpected error which is typically related to the node storage corruption.account
  BalanceMismatchError                                    An error happens if `check_balance` fails, which is likely an indication of an invalid state
  InvalidTxError                                          An error happened during TX verification and account charging
    InvalidAccessKeyError                                 Describes the error for validating access key
    ActionsValidationError                                Describes the error for validating a list of actions    
      TotalPrepaidGasExceeded                             The total prepaid gas (for all given actions) exceeded the limit.
      TotalNumberOfActionsExceeded                        The number of actions exceeded the given limit.
      AddKeyMethodNamesNumberOfBytesExceeded              The total number of bytes of the method names exceeded the limit in a Add Key action.
      AddKeyMethodNameLengthExceeded                      The length of some method name exceeded the limit in a Add Key action.
      IntegerOverflow                                     Integer overflow during a compute.
      InvalidAccountId                                    Invalid account ID.
      ContractSizeExceeded                                The size of the contract code exceeded the limit in a DeployContract action.
      FunctionCallMethodNameLengthExceeded                The length of the method name exceeded the limit in a Function Call action.
      FunctionCallArgumentsLengthExceeded                 The length of the arguments exceeded the limit in a Function Call action.
```

### TxExecutionError and subtypes {#txexecutionerror-and-subtypes}

```text
TxExecutionError                                          Error returned in the ExecutionOutcome in case of failure
  InvalidTxError                                          An error happened during Transaction execution
    InvalidAccessKeyError                                 Describes the error for validating access key
    ActionsValidationError                                Describes the error for validating a list of actions
      TotalPrepaidGasExceeded                             The total prepaid gas (for all given actions) exceeded the limit.
      TotalNumberOfActionsExceeded                        The number of actions exceeded the given limit.
      AddKeyMethodNamesNumberOfBytesExceeded              The total number of bytes of the method names exceeded the limit in a Add Key action.
      AddKeyMethodNameLengthExceeded                      The length of some method name exceeded the limit in a Add Key action.
      IntegerOverflow                                     Integer overflow during a compute.
      InvalidAccountId                                    Invalid account ID.
      ContractSizeExceeded                                The size of the contract code exceeded the limit in a DeployContract action.
      FunctionCallMethodNameLengthExceeded                The length of the method name exceeded the limit in a Function Call action.
      FunctionCallArgumentsLengthExceeded                 The length of the arguments exceeded the limit in a Function Call action.
  ActionError                                             An error happened during Acton execution
    ActionErrorKind                                       The kind of ActionError happened
      RuntimeCallError 
      ReceiptValidationError                              Describes the error for validating a receipt
        ActionsValidationError                            Describes the error for validating a list of actions    
          TotalPrepaidGasExceeded                         The total prepaid gas (for all given actions) exceeded the limit.
          TotalNumberOfActionsExceeded                    The number of actions exceeded the given limit.
          AddKeyMethodNamesNumberOfBytesExceeded          The total number of bytes of the method names exceeded the limit in a Add Key action.
          AddKeyMethodNameLengthExceeded                  The length of some method name exceeded the limit in a Add Key action.
          IntegerOverflow                                 Integer overflow during a compute.
          InvalidAccountId                                Invalid account ID.
          ContractSizeExceeded                            The size of the contract code exceeded the limit in a DeployContract action.
          FunctionCallMethodNameLengthExceeded            The length of the method name exceeded the limit in a Function Call action.
          FunctionCallArgumentsLengthExceeded             The length of the arguments exceeded the limit in a Function Call action.
```


### VMerror and subtypes {#vmerror-and-subtypes}

```text
VMerror                                                   An error that occurs in the NEAR virtual machine
  ExternalError                                           Serialized external error from External trait implementation
  InconsistentStateError                                  An error that is caused by an operation on an inconsistent state (ie. an integer overflow by using a value from the given context
    IntegerOverflow                                       Math operation with a value from the state resulted in a integer overflow
  FunctionCallError 
    LinkError 
    WasmTrap 
    MethodResolveError 
      MethodEmptyName 
      MethodUTF8Error 
      MethodNotFound 
      MethodInvalidSignature 
    HostError 
      BadUTF16                                            String encoding is bad UTF-16 sequence
      BadUTF8                                             String encoding is bad UTF-8 sequence
      GasExceeded                                         Exceeded the prepaid ga
      GasLimitExceeded                                    Exceeded the maximum amount of gas allowed to burn per contract
      BalanceExceeded                                     Exceeded the account balance
      EmptyMethodName                                     Tried to call an empty method nam
      GuestPanic                                          Smart contract panicked
      IntegerOverflow                                     IntegerOverflow happened during a contract execution
      InvalidPromiseIndex                                 `promise_idx` does not correspond to existing promises
      CannotAppendActionToJointPromise                    Actions can only be appended to non-joint promise.
      CannotReturnJointPromise                            Returning joint promise is currently prohibited
      InvalidPromiseResultIndex                           Accessed invalid promise result index
      InvalidRegisterId                                   Accessed invalid register id
      IteratorWasInvalidated                              Iterator `iterator_index` was invalidated after its creation by performing a mutable operation on trie
      MemoryAccessViolation                               Accessed memory outside the bounds
      InvalidReceiptIndex                                 VM Logic returned an invalid receipt index
      InvalidIteratorIndex                                Iterator index `iterator_index` does not exist
      InvalidAccountId                                    VM Logic returned an invalid account id
      InvalidMethodName                                   VM Logic returned an invalid method name
      InvalidPublicKey                                    VM Logic provided an invalid public key
      ProhibitedInView                                    `method_name` is not allowed in view calls
      NumberOfLogsExceeded                                The total number of logs will exceed the limit.
      KeyLengthExceeded                                   The storage key length exceeded the limit.
      ValueLengthExceeded                                 The storage value length exceeded the limit.
      TotalLogLengthExceeded                              The total log length exceeded the limit.
      NumberPromisesExceeded                              The maximum number of promises within a FunctionCall exceeded the limit.
      NumberInputDataDependenciesExceeded                 The maximum number of input data dependencies exceeded the limit.
      ReturnedValueLengthExceeded                         The returned value length exceeded the limit.
      ContractSizeExceeded                                The contract size for DeployContract action exceeded the limit.
    CompilationError 
      CodeDoesNotExist 
      WasmerCompileError 
      PrepareError                                        Error that can occur while preparing or executing Wasm smart-contract
        Serialization                                     Error happened while serializing the module
        Deserialization                                   Error happened while deserializing the module
        InternalMemoryDeclared                            Internal memory declaration has been found in the module
        GasInstrumentation                                Gas instrumentation failed.  This most likely indicates the module isn't valid
        StackHeightInstrumentation                        Stack instrumentation failed.  This  most likely indicates the module isn't valid
        Instantiate                                       Error happened during instantiation.  This might indicate that `start` function trapped, or module isn't instantiable and/or unlinkable
        Memory                                            Error creating memory
```

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/errors/token-loss.md 

 ---
id: token-loss
title: Avoiding Token Loss
sidebar_label: Avoiding Token Loss
---

:::warning
Careful! Losing tokens means losing money!
:::


Token loss is possible under multiple scenarios. These scenarios can be grouped into a few related classes:

1. Improper key management
2. Refunding deleted accounts
3. Failed function calls in batches

---

## Improper key management

Improper key management may lead to token loss. Mitigating such scenarios may be done by issuing backup keys
allowing for recovery of accounts whose keys have been lost or deleted.

### Loss of `FullAccess` key

A user may lose their private key of a `FullAccess` key pair for an account with no other keys.
No one will be able to recover the funds. Funds will remain locked in the account forever.

### Loss of `FunctionCall` access key

An account may have its one and only `FunctionCall` access key deleted.
No one will be able to recover the funds. Funds will remain locked in the account forever.

---
## Refunding deleted accounts

When a refund receipt is issued for an account, if that account no longer exists, the funds will be dispersed among
validators proportional to their stake in the current epoch.

### Deleting account with non-existent beneficiary

When you delete an account, you must assign a beneficiary.
Once deleted, a transfer receipt is generated and sent to the beneficiary account.
If the beneficiary account does not exist, a refund receipt will be generated and sent back to the original account.
Since the original account has already been deleted, the funds will be dispersed among validators.

### Account with zero balance is garbage-collected, just before it receives refund

If an account `A` transfers all of its funds to another account `B` and account `B` does not exist,
a refund receipt will be generated for account `A`. During the period of this round trip,
account `A` is vulnerable to deletion by garbage collection activities on the network.
If account `A` is deleted before the refund receipt arrives, the funds will be dispersed among validators.

---
## Failed function calls in batches

:::warning
When designing a smart contract, you should always consider the asynchronous nature of NEAR Protocol.
:::

If a contract function `f1` calls two (or more) other functions `f2` and `f3`, and at least one of these functions, `f2` and `f3` fails, then tokens will be refunded from the function that failed, but tokens will be appropriately credited to the function(s) which succeed.

The successful call's tokens may be considered lost depending on your use case if a single failure in the batch means the whole batch failed.



 This is the content for the doc docs/6.integrations/exchange-integration.md 

 ---
id: exchange-integration
title: Exchange Integration
sidebar_label: Exchange Integration
---

## Integration Reference {#integration-reference}

- [Balance Changes](/integrations/balance-changes)
- [Accounts](/integrations/accounts)
- [Fungible Tokens](/integrations/fungible-tokens)
- [Implicit Accounts](/integrations/implicit-accounts)

### Transaction Reference Links {#transaction-reference-links}

 - [Basics](/concepts/protocol/transactions)
 - [Specifications](https://nomicon.io/RuntimeSpec/Transactions)
 - [Constructing Transactions](/integrations/create-transactions)

## Blocks and Finality {#blocks-and-finality}

Some important pieces of information regarding blocks and finality include:

- Expected block time is around 1s and expected time to finality is around 2s. The last final block can be queried by
  specifying `{"finality": "final"}` in the block query. For example, to get the latest final block on mainnet, one can run

```bash
http post https://rpc.mainnet.near.org method=block params:='{"finality":"final"}' id=123 jsonrpc=2.0
```

- Block height are not necessarily continuous and certain heights may be skipped if, for example, a block producer for that height is offline. For example, after a block at height 100 is produced, the block at height 101 may be skipped. When block at height 102 is produced, its previous block is the block at height 100.

- Some blocks may not include new chunks if, for example, the previous chunk producer is offline. Even though in the RPC
  return result every block will have non-empty `chunks` field, it does not imply that there is a new chunk included in the block.
  The way to tell whether the chunk is included in the block is to check whether `height_included` in the chunk is the same
  as the height of the block.

## Running an Archival Node {#running-an-archival-node}
Please refer to configuration changes required in `config.json` for archival node by referring to the documentation on [Run an Archival Node](https://near-nodes.io/archival/run-archival-node-with-nearup).

## Staking and Delegation {#staking-and-delegation}

- [https://github.com/nearprotocol/stakewars](https://github.com/nearprotocol/stakewars)
- [https://github.com/near/core-contracts](https://github.com/near/core-contracts)

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/faq.md 

 ---
id: faq
title: Integrator FAQ
sidebar_label: Integrator FAQ
---

## Orientation

### What is a good project summary for NEAR?

NEAR is a sharded, public, proof-of-stake blockchain and smart contract platform. It is built in Rust and contracts compile to WASM. It is conceptually similar to Ethereum 2.0.

### What's special about NEAR?

NEAR is the blockchain for builders.

If you understand the basics of web development, you can write, test and deploy scalable decentralized applications in minutes on the most developer-friendly blockchain without having to learn new tools or languages.

### Is NEAR open source?

Yes. Have a look at our [GitHub organization](https://github.com/near).

### How are cryptographic functions used?

We support both `secp256k1` and `ed25519` for account keys and `ed25519` for signing transactions. We currently use the `ed25519_dalek` and `sha2` libraries for crypto.

### Do you have any on-chain governance mechanisms?

NEAR does not have any on-chain governance at the moment. Any changes to state or state transition function must be done through a hard fork.

### Do you have a bug-bounty program?

Our plan is to have a transparent Bug Bounty program with clear guidelines for paying out to those reporting issues. Payments will likely be based on publicly available rankings provided by protocol developers based on issue severity.

### What contracts should we be aware of right now?

We have developed a number of [initial contracts](https://github.com/near/core-contracts) with **ones in bold** being most mature at time of writing

- **Staking Pool / Delegation contract**
- **Lockup / Vesting contract**
- Whitelist Contract
- Staking Pool Factory
- Multisig contract

### Do you have a cold wallet implementation (ie. Ledger)?

https://github.com/near/near-ledger-app

## Validators

### What is the process for becoming a validator?

Validation is permissionless and determined via auction. Parties who want to become a validator submit a special transaction to the chain one day ahead which indicates how many tokens they want to stake. An auction is run which determines the minimum necessary stake to get a validation seat during the next epoch and, if the amount submitted is greater than the minimum threshold, the submitter will validate at least one shard during the next epoch.

### How long does a validator remain a validator?

A validator will stop being a validator for the following reasons:

- Not producing enough blocks or chunks.
- Not getting elected in the auction for next epoch because their stake is not large enough.
- Getting slashed.
  Otherwise a validator will remain a validator indefinitely.

Validator election happens in epochs. The [Nightshade whitepaper](/docs/Nightshade.pdf) introduces epochs this way: "the maintenance of the network is done in epochs" where an epoch is a period of time on the order of half a day.

At the beginning of each epoch, some computation produces a list of validators for the _very next epoch_.
The input to this computation includes all accounts that have "raised their hand to be a validator"
by submitting a special transaction ([`StakeAction`](https://nomicon.io/RuntimeSpec/Actions.html#stakeaction))
expressing the commitment of some amount of tokens over the system's staking threshold,
as well as validators from the previous epoch.
The output of this computation is a list of the validators for the very next epoch.

### What is the penalty for misbehaving validators?

Validators are not slashed for being offline but they do miss out on the rewards of validating. Validators who miss too many blocks or chunks will be removed from the validation set in the next auction and not get any reward (but, again, without slashing).

Any foul play on the part of the validator that is detected by the system may result in a "slashing event" where the validator is marked as out of integrity and forfeits their stake (according to some formula of progressive severity). The slashed stake is burnt.

### What is the mechanism for delegating stake to validators?

NEAR supports separate validation keys that can be used in smart contracts to delegate stake. Delegation is done via smart contract which allows for a validator to define a custom way to collect stake, manage it and split rewards. This also allows validators to provide leverage or derivatives on stake. Delegated stake will be slashed like any other stake if the node misbehaves.

If a validator misbehaves the funds of the delegators are also slashed. There is no waiting period for delegators to withdraw their stake.

### Does a validator control funds that have been delegated to them?

Delegation is custodial (you are transferring funds to a different account, the smart contract that implements staking pool). We provide a reference implementation being security reviewed and tested by 100 validators at time of writing.

We allow validators to write and deploy new contracts but it is up to users to decide if they want to delegate. Validators can compete for delegation by choosing different logic and conditions around tax optimization, etc.

Currently no slashing but will be added as we add shards into the system. At some point validators will be able to add an option to shield delegators from slashing (similar to Tezos model).

### How do we get the balance of an account after it has delegated funds?

One would need to query the staking pool contract to get balance.

## Nodes

### Can a node be configured to archive all blockchain data since genesis?

v
Yes. Start the node using the following command:

```sh
./target/release/near run --archive
```

### Can a node be configured to expose an RPC (ex: HTTP) interface?

Yes. All nodes expose this interface by default which can be configured by setting the value of `listen_addr:port` in the node's `config.json` file.

### Can a node be gracefully terminated and restarted (using archived data on disk to continue syncing)?

Yes.

### Does a node expose an interface for retrieving health telemetry in a structured format (ex: JSON) over RPC?

Yes. `GET /status` and `GET /health` provide this interface.

- `/status`: block height, syncing status, peer count, etc
- `/health`: success/failure if node is up running & progressing

### Can a node be started using a Dockerfile without human supervision?

Yes.

```sh
docker run <port mapping> <mount data folder> <ENV vars> nearprotocol/nearcore:latest
```

See `nearcore/scripts/nodelib.py` for different examples of configuration.

### What is the source of truth for current block height exposed via API?

- MainNet
  - https://nearblocks.io
  - `https://rpc.mainnet.near.org/status`
- TestNet
  - https://testnet.nearblocks.io
  - `https://rpc.testnet.near.org/status`

### How old can the referenced block hash be before it's invalid?

There is a genesis parameter which can be discovered for any network using:

```sh
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_genesis_config
# in the line above, testnet may be replaced with mainnet or betanet
```

It's `43200` seconds or `~12` hours. You can view the live configuration for `epoch_length` using the [`protocol_config` RPC endpoint](/api/rpc/protocol#protocol-config).

In the response we find `transaction_validity_period": 86400` (and since it takes about 1 second to produce a block, this period is about 24 hrs)

## Blockchain

### How will the network will be bootstrapped?

Distribution at genesis will be spread among the NEAR team, our contributors, project partners (ie. contributor, beta applications, infrastructure developers, etc.) and the NEAR foundation (with many portions of that segregated for post-MainNet distribution activity and unavailable to stake so the foundation isn‚Äôt able to control the network).

There will be auctions occurring on the platform after launch which will allocate large amounts of tokens over the next 2 years. Additionally we are planning to run TestNet where any validator who participates will receive rewards in real tokens. We are planning to onboard at least 50 separate entities to be validators at launch.

### What is the network upgrade process?

We are currently upgrading via restarting with a new genesis block.

### Which consensus algorithm does NEAR use?

NEAR is a sharded **proof-of-stake** blockchain.

_You can read more in our [Nightshade whitepaper](/docs/Nightshade.pdf)._

> _A few relevant details have been extracted here for convenience:_
>
> [Since NEAR is a sharded blockchain, there are challenges that need to be overcome] including state validity and data
> availability problems. _Nightshade_ is the solution NEAR Protocol is built upon that addresses these issues.
>
> Nightshade uses the heaviest chain consensus. Specifically when a block producer produces a block (see section 3.3), they can collect signatures from other block producers and validators attesting to the previous block. The weight of a block is then the cumulative stake of all the signers whose signatures are included in the block. The weight of a chain is the sum of the block weights.
>
> On top of the heaviest chain consensus we use a finality gadget that uses the attestations to finalize the blocks. To reduce the complexity of the system, we use a finality gadget that doesn‚Äôt influence the fork choice rule in any way, and instead only introduces extra slashing conditions, such that once a block is finalized by the finality gadget, a fork is impossible unless a very large percentage of the total stake is slashed.

### How does on-chain transaction finality work?

Finality is deterministic, and requires at least 3 blocks as well as (2/3 +1) signatures of the current validator set.

In a normal operation, we expect this to happen right at 3 blocks but it is not guaranteed.

Finality will be exposed via RPC when querying block or transaction.

Our definition of finality is BOTH:

- Block has quorum pre-commit from the finality gadget. See details of the finality gadget [[here]](/docs/PoST.pdf)
- At least 120 blocks (2-3 minutes) built on top of the block of interest. This is relevant in case of invalid state transition in some shard and provides enough time for state change challenges. In case all shards are tracked and some mechanics to pause across nodes is employed, this is not needed. We recommend exchanges track all shards.

## Accounts

### How are addresses generated?

Please check out the spec here on accounts https://nomicon.io/DataStructures/Account.html.

### What is the balance record-keeping model on the NEAR platform?

NEAR uses an `Account`-based model. All users and contracts are associated with at least 1 account. Each account lives on a single shard. Each account can have multiple keys for signing transactions.

_You can read [more about NEAR accounts here](https://nomicon.io/DataStructures/Account.html)_

### How are user accounts represented on-chain?

Users create accounts with human-readable names (eg `alice`) which can contain multiple keypairs with individual permissions. Accounts can be atomically and securely transferred between parties as a native transaction on the network. Permissions are programmable with smart contracts as well. For example, a lock up contract is just an account with permission on the key that does not allow to transfer funds greater than those unlocked.

### Is there a minimum account balance?

To limit on-chain "dust", accounts (and contracts) are charged a refundable deposit for storing data on the chain. This means that if the balance of the account does not have enough balance to cover an increased deposit for additional storage of data, storing additional data will fail. Also, any user can remove their own account and transfer left over balance to another (beneficiary) account.

There will be a restoration mechanism for accounts removed (or slept) in this way implemented in the future.

### How many keys are used?

An account can have arbitrarily many keys, as long as it has enough tokens for their storage.

### Which balance look-ups exist? What is required?

We have an [RPC method for viewing account](/api/rpc/contracts#view-account).

The [JS implementation is here](https://github.com/near/near-api-js/blob/d7f0cb87ec320b723734045a4ee9d17d94574a19/src/providers/json-rpc-provider.ts#L73). Note that in this RPC interface you can specify the finality requirement (whether to query the latest state or finalized state).

For custody purposes, it is recommended not to rely on latest state but only what is finalized.

## Fees

### What is the fee structure for on-chain transactions?

NEAR uses a gas-based model where prices are generally deterministically adjusted based on congestion of the network.

We avoid making changes that are too large through re-sharding by changing number of available shards (and thus throughput).

Accounts don‚Äôt have associated resources. Gas amount is predetermined for all transactions except function calls. For function call transactions the user (or more likely the developer) attaches the required amount of gas. If some gas is left over after the function call, it is converted back to NEAR and refunded to the original funding account.

### How do we know how much gas to add to a transaction?

- See reference documentation here: https://nomicon.io/Economics/Economic
- See API documentation for [discovering gas price via RPC here](/api/rpc/gas#gas-price).

The issuer of a transaction should attach some amount of gas by taking a guess at budget which will get the transaction processed. The contract knows how much to fund different cross contract calls. Gas price is calculated and fixed per block, but may change from block to block depending on how full / busy the block is. If blocks become more than half full then gas price increases.

We're also considering adding a max gas price limit.

## Transactions

### How do we follow Tx status?

See related [RPC interface for fetching transaction status here](/api/rpc/transactions#transaction-status).

### How are transactions constructed and signed?

Transactions are a collection of related data that is composed and cryptographically signed by the sender using their private key. The related public key is part of the transaction and used for signature verification. Only signed transactions may be sent to the network for processing.

Transactions can be constructed and signed offline. Nodes are not required for signing. We are planning to add optional recent block hash to help prevent various replay attacks.

See [transactions](/concepts/protocol/transactions) in the concepts section of our documentation.

### How is the hash preimage generated? Which fields does the raw transaction consist of?

For a transaction, we sign the hash of the transaction. More specifically, what is signed is the `sha256` of the transaction object serialized in borsh (https://github.com/near/borsh).

### How do transactions work on the NEAR platform?

A `Transaction` is made up of one or more `Action`s. An action can (currently) be one of 8 types: `CreateAccount`,
`DeployContract`, `FunctionCall`, `Transfer`, `Stake`, `AddKey`, `DeleteKey` and `DeleteAccount`. Transactions are composed by a sender and then signed using the private keys of a valid NEAR account to create a `SignedTransaction`. This signed transaction is considered ready to send to the network for processing.

Transactions are received via our JSON-RPC endpoint and routed to the shared where the `sender` account lives. This "home shard" for the sender account is then responsible for processing the transaction and generating related receipts to be applied across the network.

Once received by the network, signed transactions are verified (using the embedded public key of the signer) and transformed into a collection of `Receipt`s, one per action. Receipts are of two types: `Action Receipt` is the most common and represents almost all actions on the network while `Data Receipt` handles the very special case of "a `FunctionCallAction` which includes a Promise". These receipts are then propagated and applied across the network according to the "home shard" rule for all affected receiver accounts.

These receipts are then propagated around the network using the receiver account's "home shard" since each account lives on one and only one shard. Once located on the correct shard, receipts are pulled from a nonce-based [queue](https://nomicon.io/ChainSpec/Transactions#pool-iterator).

Receipts may generate other, new receipts which in turn are propagated around the network until all receipts have been applied. If any action within a transaction fails, the entire transaction is rolled back and any unburnt fees are refunded to the proper accounts.

For more detail, see specs on [`Transactions`](https://nomicon.io/RuntimeSpec/Transactions), [`Actions`](https://nomicon.io/RuntimeSpec/Actions.html), [`Receipts`](https://nomicon.io/RuntimeSpec/Receipts)

### How does NEAR serialize transactions?

We use a simple binary serialization format that's deterministic: https://borsh.io

## Additional Resources

- Whitepaper

  - General overview at [The Beginner's Guide to the NEAR Blockchain](https://near.org/blog/the-beginners-guide-to-the-near-blockchain)
  - [NEAR Whitepaper](https://near.org/papers/the-official-near-white-paper/)

- Github
  - https://www.github.com/near

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/implicit-accounts.md 

 ---
id: implicit-accounts
title: Implicit Accounts
sidebar_label: Implicit Accounts
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Background {#background}

Implicit accounts work similarly to Bitcoin/Ethereum accounts.
 - They allow you to reserve an account ID before it's created by generating a ED25519 key-pair locally.
 - This key-pair has a public key that maps to the account ID.
 - The account ID is a lowercase hex representation of the public key.
 - An ED25519 Public key contains 32 bytes that maps to 64 characters account ID.
 - The corresponding secret key allows you to sign transactions on behalf of this account once it's created on chain.

:::info
You can find the implicit accounts specification [here](https://nomicon.io/DataStructures/Account.html#implicit-account-ids).
:::

## Creating an account locally {#creating-an-account-locally}

For the purpose of this demo, we'll use the `betanet` network.

## Set `betanet` network {#set-betanet-network}

```bash
export NEAR_ENV=betanet
```

## Generating the Implicit account

```bash
near account create-account fund-later use-auto-generation save-to-folder ~/.near-credentials/implicit
```

Example Output
```
The file "~/.near-credentials/testnet/8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8.json" was saved successfully

Here is your console command if you need to script it or re-run:
    near account create-account fund-later use-auto-generation save-to-folder ~/.near-credentials/implicit
```

## Using the Implicit Account
We can export our account ID to a bash env variable:
```bash
export ACCOUNT="8bca86065be487de45e795b2c3154fe834d53ffa07e0a44f29e76a2a5f075df8"
```

Assuming you've received tokens on your new account, you can transfer from it using the following command:

<Tabs groupId="cli-tabs">

  <TabItem value="short" label="Short">

  ```bash
  near send $ACCOUNT <receiver> <amount>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near tokens $ACCOUNT send-near <receiver> '<amount> NEAR' network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

## Transferring to the implicit account {#transferring-to-the-implicit-account}

Let's say someone gives you their account ID `0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223`. You can just transfer to it by running:

<Tabs groupId="cli-tabs">

  <TabItem value="short" label="Short">

  ```bash
  near send <your_account_id> 0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223 <amount>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

  ```bash
  near tokens<your_account_id> send-near 0861ea8ddd696525696ccf3148dd706c4fda981c64d8a597490472594400c223 '<amount> NEAR' network-config testnet sign-with-keychain send
  ```
  </TabItem>
</Tabs>

## BONUS: Converting public key using python (for learning purposes) {#bonus-converting-public-key-using-python-for-learning-purposes}

For this flow we'll use `python3` (with version `3.5+`) with `base58` library.

You can install this library with `pip3`:
```bash
pip3 install --user base58
```

Start python3 interpreter:
```bash
python3
```

The first thing is to get the data part from the public key (without `ed25519:` prefix). Let's store it in a variable `pk58`:
```python
pk58 = 'BGCCDDHfysuuVnaNVtEhhqeT4k9Muyem3Kpgq2U1m9HX'
```

Now let's import base58:
```python
import base58
```

Finally, let's convert our base58 public key representation to bytes and then to hex:
```python
base58.b58decode(pk58).hex()
```

Output:
```
'98793cd91a3f870fb126f66285808c7e094afcfc4eda8a970f6648cdf0dbd6de'
```

This gives us the same account ID as `near-cli`, so this is encouraging.

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/6.integrations/tokens.md 

 ---
id: fungible-tokens
title: Fungible tokens
sidebar_label: Fungible Tokens
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Introduction {#introduction}

Please see the [spec for the fungible token standard](https://nomicon.io/Standards/FungibleToken/) and an [example implementation](https://github.com/near-examples/FT) for reference details.

One notable aspect of the standard is that method names are prefixed with `ft_`. This will be a helpful convention when querying for transactions related to fungible tokens.

## Get balance {#get-balance}

Using the abstraction of the [NEAR CLI](/tools/near-cli) tool, we can check the balance of a user's account with [`near view`](/tools/near-cli#call):

`near view ft.demo.testnet ft_balance_of '{"account_id": "mike.testnet"}'`

Returns:

```
View call: ft.demo.testnet.ft_balance_of({"account_id": "mike.testnet"})
'1000000'
```

Alternatively, you can [call a contract function](/api/rpc/contracts#call-a-contract-function) using the `query` RPC endpoint. Below is an example using HTTPie:

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=ftbalance method=query \
params:='{
  "request_type": "call_function",
  "finality": "final",
  "account_id": "ft.demo.testnet",
  "method_name": "ft_balance_of",
  "args_base64": "eyJhY2NvdW50X2lkIjogIm1pa2UudGVzdG5ldCJ9"
}'
```

Returns:

```bash
HTTP/1.1 200 OK
Alt-Svc: clear
Via: 1.1 google
access-control-allow-origin:
content-length: 176
content-type: application/json
date: Thu, 27 May 2021 12:53:38 GMT

{
    "id": "dontcare",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "3mvNHpZAsXiJ6SuHU1mbLVB4iXCfh5i5d41pnkaSoaJ5",
        "block_height": 49282350,
        "logs": [],
        "result": [ 34, 49, 48, 48, 48, 48, 48, 48, 34 ]
    }
}
```

As mentioned earlier, the `result` is an array of bytes. There are various ways to convert bytes into a more human-readable form such as the [dtool CLI](https://github.com/guoxbin/dtool#installation).

`dtool a2h '[34,49,48,48,48,48,48,48,34]' | dtool h2s`

Returns:

`"1000000"`

**Note:** The fungible token balance of the account `mike.testnet` is `1000000` wrapped in double-quotes. This is because of an issue with JSON serialization. Amounts given in arguments and results must be serialized as Base-10 strings, e.g. "100". This is done to avoid JSON limitation of max integer value of 2**53, which can certainly happen with fungible tokens.

## Get info about the FT {#get-info-about-the-ft}

You can get `name`, `decimals`, `icon` and other parameters by calling the next function:
  - using NEAR CLI:

```bash
near view <contract_account_id> ft_metadata
```

Result:

```bash
View call: ft.demo.testnet.ft_metadata()
{
  spec: 'ft-1.0.0',
  name: 'Example Token Name',
  symbol: 'MOCHI',
  icon: null,
  reference: null,
  reference_hash: null,
  decimals: 24
}
```

  - with JSON RPC call:

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=ftmetadata method=query \
  params:='{
    "request_type": "call_function",
    "finality": "final",
    "account_id": "<contract_account_id>",
    "method_name": "ft_metadata",
    "args_base64": ""
  }'
```

Example response:

```bash
HTTP/1.1 200 OK
Alt-Svc: clear
Via: 1.1 google
access-control-allow-origin:
content-length: 604
content-type: application/json
date: Wed, 02 Jun 2021 15:51:17 GMT

{
  "id": "ftmetadata",
  "jsonrpc": "2.0",
  "result": {
      "block_hash": "B3fu3v4dmn19B6oqjHUXN3k5NhdP9EW5kkjyuFUDpa1r",
      "block_height": 50061565,
      "logs": [],
      "result": [ 123, 34, 115, 112, 101, 99, 34, 58, 34, 102, 116, 45, 49, 46, 48, 46, 48, 34, 44, 34, 110, 97, 109, 101, 34, 58, 34, 69, 120, 97, 109, 112, 108, 101, 32, 84, 111, 107, 101, 110, 32, 78, 97, 109, 101, 34, 44, 34, 115, 121, 109, 98, 111, 108, 34, 58, 34, 77, 79, 67, 72, 73, 34, 44, 34, 105, 99, 111, 110, 34, 58, 110, 117, 108, 108, 44, 34, 114, 101, 102, 101, 114, 101, 110, 99, 101, 34, 58, 110, 117, 108, 108, 44, 34, 114, 101, 102, 101, 114, 101, 110, 99, 101, 95, 104, 97, 115, 104, 34, 58, 110, 117, 108, 108, 44, 34, 100, 101, 99, 105, 109, 97, 108, 115, 34, 58, 50, 52, 125 ]
  }
}
```

Decoded result in this case is:

```json
{
    "spec": "ft-1.0.0",
    "name": "Example Token Name",
    "symbol": "MOCHI",
    "icon": null,
    "reference": null,
    "reference_hash": null,
    "decimals": 24
}
```

## Simple transfer {#simple-transfer}

To follow this guide, please check the [step by step instructions](/integrations/create-transactions#low-level----create-a-transaction) on how to create a transaction first.

In order to send a fungible token to an account, the receiver must have a storage deposit. This is because each smart contract on NEAR must account for storage used, and each account on a fungible token contract is a key-value pair, taking up a small amount of storage. For more information, please see [how storage works in NEAR](/concepts/storage/storage-staking). To check if account has deposited the storage for this FT do the following:

Get storage balance of the account. `storage_balance_of` function returns the amount of deposited storage or `null` if there is no deposit.
  - using NEAR CLI:

```bash
near view <contract_account_id> storage_balance_of '{"account_id": "<user_account_id>"}'
```

    Result:

```bash
View call: ft.demo.testnet.storage_balance_of({"account_id": "serhii.testnet"})
null
```

  - with JSON RPC call:

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=storagebalanceof method=query \
  params:='{
     "request_type": "call_function",
     "finality": "final",
     "account_id": "ft.demo.testnet",
     "method_name": "storage_balance_of",
     "args_base64": "eyJhY2NvdW50X2lkIjogInNlcmhpaS50ZXN0bmV0In0K"
  }'
```

Example response:

```bash
HTTP/1.1 200 OK
Alt-Svc: clear
Via: 1.1 google
access-control-allow-origin:
content-length: 173
content-type: application/json
date: Wed, 02 Jun 2021 14:22:01 GMT
{
  "id": "storagebalanceof",
  "jsonrpc": "2.0",
  "result": {
      "block_hash": "EkM2j4yxRVoQ1TCqF2KUb7J4w5G1VsWtMLiycq6k3f53",
      "block_height": 50054247,
      "logs": [],
      "result": [ 110, 117, 108, 108 ]
  }
}
```

Decoded result in this case is `null`.

Get the minimum storage required for FT. (The storage used for an account's key-value pair.)

  - using NEAR CLI:

```bash
near view <contract_account_id> storage_balance_bounds`
```

Result:

```bash
View call: ft.demo.testnet.storage_balance_bounds()
{ min: '1250000000000000000000', max: '1250000000000000000000' }
```

  - with JSON RPC call

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=storagebalancebounds method=query \
  params:='{
      "request_type": "call_function",
      "finality": "final",
      "account_id": "<contract_account_id>",
      "method_name": "storage_balance_bounds",
      "args_base64": ""
  }'
```

Example response:

```bash
HTTP/1.1 200 OK
Alt-Svc: clear
Via: 1.1 google
access-control-allow-origin:
content-length: 357
content-type: application/json
date: Wed, 02 Jun 2021 15:42:49 GMT

{
  "id": "storagebalancebounds",
  "jsonrpc": "2.0",
  "result": {
      "block_hash": "Fy3mBqwj5nvUDha3X7G61kmUeituHASEX12oCASrChEE",
      "block_height": 50060878,
      "logs": [],
      "result": [ 123, 34, 109, 105, 110, 34, 58, 34, 49, 50, 53, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 34, 44, 34, 109, 97, 120, 34, 58, 34, 49, 50, 53, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 34, 125 ]
  }
}
```

Decoded result should look similar to:

```json
  {
    "min": "1250000000000000000000",
    "max": "1250000000000000000000"
  }
```

Basic fungible tokens are simple smart contracts that don't have variable storage as compared to a smart contract that might store free-form text, for instance. The only storage needed is for an accounts key-value pair, which will always be covered by the `1250000000000000000000` yocto‚ìÉ storage balance.

If there is not enough deposit for the storage or returned value is `null` - you should deposit more storage with the next command:
  - using NEAR CLI, don't forget to convert from yocto‚ìÉ to ‚ìÉ:


<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call <contract_account_id> storage_deposit '{"account_id": "<user_account_id>"}' --accountId <sender_account_id> --deposit <deposit in ‚ìÉ>
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction <contract_account_id> storage_deposit json-args '{"account_id": "<user_account_id>"}' prepaid-gas '100.0 Tgas' attached-deposit '<deposit in ‚ìÉ> NEAR' sign-as <sender_account_id> network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Result example:

```bash
Scheduling a call: ft.demo.testnet.storage_deposit() with attached 0.125 NEAR
Transaction Id 9CMrMMt3UzeU63FFrUyFb1gNGuHXxvKfHqYJzyFTAk6z
To see the transaction in the transaction explorer, please open this url in your browser
https://testnet.nearblocks.io/txns/9CMrMMt3UzeU63FFrUyFb1gNGuHXxvKfHqYJzyFTAk6z
{ total: '1250000000000000000000', available: '0' }
```

  - with JSON RPC call:

  At the top of this section is a link detailing how to [construct a transaction](/integrations/create-transactions#low-level----create-a-transaction) without the full abstraction of the [`near-api-js` library](https://www.npmjs.com/package/near-api-js). For this and future examples that use the [RPC method `broadcast_tx_commit`](https://docs.near.org/api/rpc/setup#send-transaction-await) we will provide a JSON-like object meant to act similar to [pseudocode](https://en.wikipedia.org/wiki/Pseudocode), only imparting high-level details of a transaction. This code block below is the first example of this, detailing what goes into the transaction discussed currently, involving the method `storage_deposit`.

```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.testnet",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "ft.demo.testnet",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: storage_deposit,
				args: `{"account_id": "robertyan.near"}`,
				gas: 300000000000000,
				deposit: 1250000000000000000000,
			},
		),
	]
}
```

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
  params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZi/qoVEgrAAAPAAAAZnQuZGVtby50ZXN0bmV0JYbWPOu0P9T32vtUKnZSh+EaoboQqg0/De2i8Y+AjHIBAAAAAg8AAABzdG9yYWdlX2RlcG9zaXQCAAAAe30AQHoQ81oAAAAAILSd2XlDeBoAAAAAAAAAZF7+s4lcHOzy+re59VErt7LcZkPMMUVgOJV8LH5TsLBBv+8h/5tZ6+HFwxSp605A4c46oS9Jw4KBRXZD07lKCg=="]'
```

<details>

<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "e30=",
                  "deposit": "125000000000000000000000",
                  "gas": 100000000000000,
                  "method_name": "storage_deposit"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7",
        "receiver_id": "ft.demo.testnet"
      },
      {
        "predecessor_id": "ft.demo.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "123750000000000000000000"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "7neJYE45vXnQia1LQqWuAfyTRXHy4vv88JaULa5DnNBd",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "19200274886926125000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "2c59u2zYj41JuhMfPUCKjNucmYfz2Jt83JLWP6VyQn1S",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18587201427159524319124"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "kaYatRKxcC1NXac69WwTqg6K13oXq2yEuy4LLZtsV2G",
        "receiver_id": "serhii.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "6Gz6P8N3F447kRc7kkxEhuZRZTzfuTUEagye65bPVGb",
        "id": "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7",
        "outcome": {
          "executor_id": "ft.demo.testnet",
          "gas_burnt": 4258977405434,
          "logs": [],
          "receipt_ids": [
            "7neJYE45vXnQia1LQqWuAfyTRXHy4vv88JaULa5DnNBd",
            "kaYatRKxcC1NXac69WwTqg6K13oXq2yEuy4LLZtsV2G"
          ],
          "status": {
            "SuccessValue": "eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0="
          },
          "tokens_burnt": "425897740543400000000"
        },
        "proof": []
      },
      {
        "block_hash": "J6YXMnLPfLEPyvL3fWdhWPzpWAeW8zNY2CwAFwAg9tfr",
        "id": "7neJYE45vXnQia1LQqWuAfyTRXHy4vv88JaULa5DnNBd",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 223182562500,
          "logs": [],
          "receipt_ids": [
            "2c59u2zYj41JuhMfPUCKjNucmYfz2Jt83JLWP6VyQn1S"
          ],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "22318256250000000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "D6tGfHwKh21PqzhBTsdKCsTtZvXFDkmH39dQiQBoGN3w"
          }
        ]
      },
      {
        "block_hash": "HRRF7N1PphZ46eN5g4DjqEgYHBYM76yGiXSTYWsfMGoy",
        "id": "2c59u2zYj41JuhMfPUCKjNucmYfz2Jt83JLWP6VyQn1S",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "J6YXMnLPfLEPyvL3fWdhWPzpWAeW8zNY2CwAFwAg9tfr",
        "id": "kaYatRKxcC1NXac69WwTqg6K13oXq2yEuy4LLZtsV2G",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "1uVJZ8vNQpHMwPA38DYJjk9PpvnHDhsDcMxrTXcwf1s"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": "eyJ0b3RhbCI6IjEyNTAwMDAwMDAwMDAwMDAwMDAwMDAiLCJhdmFpbGFibGUiOiIwIn0="
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "e30=",
            "deposit": "125000000000000000000000",
            "gas": 100000000000000,
            "method_name": "storage_deposit"
          }
        }
      ],
      "hash": "6sDUF1f5hebpybUbipNJer5ez13EY4HW1VBJEBqZjCEm",
      "nonce": 47589658000011,
      "public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN",
      "receiver_id": "ft.demo.testnet",
      "signature": "ed25519:31PfuinsVvM1o2CmiZbSguFkZKYqAtkf5PHerfexhDbC3SsJWDzRFBpoUYTNDJddhKeqs93GQ3SHtUyqaSYhhQ9X",
      "signer_id": "serhii.testnet"
    },
    "transaction_outcome": {
      "block_hash": "5XiuxzTpyw6p2NTD5AqrZYNW7SHvpj8MhUCyn1x2KSQR",
      "id": "6sDUF1f5hebpybUbipNJer5ez13EY4HW1VBJEBqZjCEm",
      "outcome": {
        "executor_id": "serhii.testnet",
        "gas_burnt": 2427959010878,
        "logs": [],
        "receipt_ids": [
          "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7"
        ],
        "status": {
          "SuccessReceiptId": "4urgFabknn1myZkjTYdb1BFSoEimP21k9smCUWoSggA7"
        },
        "tokens_burnt": "242795901087800000000"
      },
      "proof": []
    }
  }
}
```

</details>

Transfer the tokens:
  - using NEAR CLI:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call <contract_account_id> ft_transfer '{"receiver_id": "<receiver_account_id>", "amount": "1"}' --accountId <sender_account_id> --amount 0.000000000000000000000001
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction <contract_account_id> ft_transfer json-args '{"receiver_id": "<receiver_account_id>", "amount": "1"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as <sender_account_id> network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Result example:

```bash
Scheduling a call: berryclub.ek.near.ft_transfer({"receiver_id": "volovyk.near", "amount": "1"}) with attached 0.000000000000000000000001 NEAR
Receipt: GDeE3Kv1JHgs71A22NEUbgq55r2Hvcnis8gCMyJtQ2mx
	Log [berryclub.ek.near]: Transfer 1 from serhii.near to volovyk.near
Transaction Id 3MkWKbXVP8wyy4pBofELqiE1pwx7ie2v3SKCwaobNcEe
To see the transaction in the transaction explorer, please open this url in your browser
https://nearblocks.io/txns/3MkWKbXVP8wyy4pBofELqiE1pwx7ie2v3SKCwaobNcEe
''
```

  - with JSON RPC call:

Transaction representation:

```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.near",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "berryclub.ek.near",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer,
				args: `{"receiver_id": "volovyk.near", "amount": "1"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

```bash
http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
  params:='["CwAAAHNlcmhpaS5uZWFyAAmQpgZcJM5nMc6f3tqmw/YI4eAvc84ZgsKMRRRzhY/6CQAAAAAAAAARAAAAYmVycnljbHViLmVrLm5lYXLLWPIiUOElkDF3u4hLAMJ0Sjeo1V338pDdHIp70va3ewEAAAACCwAAAGZ0X3RyYW5zZmVyKwAAAHsicmVjZWl2ZXJfaWQiOiJ2b2xvdnlrLm5lYXIiLCJhbW91bnQiOiIxIn0AQHoQ81oAAAEAAAAAAAAAAAAAAAAAAAAA7fDOZQt3zCtdS05Y8XaZFlwO/Gd5wkkNAHShzDiLQXk4Q4ixpraLPMJivs35PZD0gocXl1iGFbQ46NG3VllzCA=="]'
```

To get details of this transaction:

```bash
http post https://archival-rpc.mainnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
  params:='["2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX", "serhii.near"]' id=myid
```

<details>

<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEifQ==",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur",
        "receiver_id": "berryclub.ek.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18418055677558685763688"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "EAPh8XrBMqm6iuVH5jsfemz4YqUxWsV8Mz241cw5tjvE",
        "receiver_id": "serhii.near"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "6Re4NTkKzD7maKx3MuoxzYVHQKqjgnXW8rNjGjeVx8YC",
        "id": "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur",
        "outcome": {
          "executor_id": "berryclub.ek.near",
          "gas_burnt": 6365774114160,
          "logs": [
            "Transfer 1 from serhii.near to volovyk.near"
          ],
          "receipt_ids": [
            "EAPh8XrBMqm6iuVH5jsfemz4YqUxWsV8Mz241cw5tjvE"
          ],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "636577411416000000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "2eUmWnLExsH5jb6mALY9jTC8FiQH4FcuxQ16tn7RfkYr"
          },
          {
            "direction": "Right",
            "hash": "266d5QfDKXNbAWJgXMJXgLP97VwoMiC4Qyt8wH7xcs1Q"
          },
          {
            "direction": "Right",
            "hash": "EkJAuJigdVSZj41yGXSZYAtDV7Xwe2Hv9Xsqcv6LUZvq"
          }
        ]
      },
      {
        "block_hash": "3XMoeEdm1zE64aByFuWCrZaxfbvsjMHRFcL8Wsp95vyt",
        "id": "EAPh8XrBMqm6iuVH5jsfemz4YqUxWsV8Mz241cw5tjvE",
        "outcome": {
          "executor_id": "serhii.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "EGC9ZPJHTbmCs3aQDuCkFQboGLBxU2uzrSZMsp8WonDu"
          },
          {
            "direction": "Right",
            "hash": "EsBd1n7bDAphA3HY84DrrKd1GP1VugeNiqFCET2S5sNG"
          },
          {
            "direction": "Left",
            "hash": "H4q3ByfNB7QH9QEuHN3tcGay7tjhsZwjXx3sq3Vm3Lza"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEifQ==",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer"
          }
        }
      ],
      "hash": "2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX",
      "nonce": 10,
      "public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM",
      "receiver_id": "berryclub.ek.near",
      "signature": "ed25519:5eJPGirNkBUbMeyRfEA4fgi1FtkgGk8pmbbkmiz3Faf6zrANpBsCs5bZd5heSTvQ6b3fEPLSPCPi2iwD2XJT93As",
      "signer_id": "serhii.near"
    },
    "transaction_outcome": {
      "block_hash": "EAcwavyaeNWZnfhYP2nAWzeDgMiuiyRHfaprFqhXgCRF",
      "id": "2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX",
      "outcome": {
        "executor_id": "serhii.near",
        "gas_burnt": 2428041740436,
        "logs": [],
        "receipt_ids": [
          "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur"
        ],
        "status": {
          "SuccessReceiptId": "ExhYcvwAUb3Jpm38pSQ5oobwJAouBqqDZjbhavKrZtur"
        },
        "tokens_burnt": "242804174043600000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "GatQmy7fW5uXRJRSg7A315CWzWWcQCGk4GJXyW3cjw4j"
        },
        {
          "direction": "Right",
          "hash": "89WJwAetivZLvAkVLXUt862o7zJX7YYt6ZixdWebq3xv"
        },
        {
          "direction": "Right",
          "hash": "CH3wHSqYPJp35krLjSgJTgCFYnv1ymhd9bJpjXA31VVD"
        }
      ]
    }
  }
}
```

</details>

You can get the same info later by the transaction hash from the previous call:

  - using NEAR Explorer: https://nearblocks.io

<!--
- using NEAR CLI:
near tx-status <transaction_hash> --accountId <transaction_signer>
-->

  - with JSON RPC call

```bash
  http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=EXPERIMENTAL_tx_status \
  params:='[ "2Fy4714idMCoja7QLdGAbQZHzV2XEnUdwZX6yGa46VMX", "sender.testnet"]'
```

Let's create test transaction that should fail and investigate the response. We will try to send more tokens that are available on this account:
  - using NEAR CLI:

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call <contract_account_id> ft_transfer '{"receiver_id": "<user_account_id>", "amount": "10000000000"}' --accountId <sender_account_id> --amount 0.000000000000000000000001
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction <contract_account_id> ft_transfer json-args '{"receiver_id": "<user_account_id>", "amount": "1"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as <sender_account_id> network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

  - with JSON RPC call:

Transaction representation:

```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.near",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "berryclub.ek.near",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer,
				args: `{"receiver_id":"volovyk.near","amount":"10000000000000000000"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

```bash
  http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
  params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZofqoVEgrAAAgAAAAZGV2LTE2MjMzMzM3OTU2MjMtMjEzOTk5NTk3NzgxNTm8Xq8BTIi6utG0424Gg7CknYzLH8RH/A409jq5o0zi7gEAAAACCwAAAGZ0X3RyYW5zZmVyPwAAAHsicmVjZWl2ZXJfaWQiOiJkZXYtMTYyMzMzMzkxNjM2OC01ODcwNzQzNDg3ODUzMyIsImFtb3VudCI6IjEifQBAehDzWgAAAQAAAAAAAAAAAAAAAAAAAABCwjqayKdpWgM6PE0ixzm/Gy0EtdpxVn0xehMTBReVfVAKIBTDPoPSaOdT8fAhk343F5uOMfSijhTqU2mWV3oD"]'
```

To get details of this transaction:

```bash
http post https://archival-rpc.mainnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
  params:='["CKHzodHvFw4C87PazsniycYZZHm37CEWLE2u8VUUMU7r", "serhii.near"]' id=myid
```

<details>

<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.near",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwIn0=",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d",
        "receiver_id": "berryclub.ek.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "system",
            "signer_public_key": "ed25519:11111111111111111111111111111111"
          }
        },
        "receipt_id": "Td3QxpKhMdi8bfVeMiQZwNS1VzPXceQdn6xdftoC8k6",
        "receiver_id": "serhii.near"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18653463364152698495356"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.near",
            "signer_public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM"
          }
        },
        "receipt_id": "DwLMVTdqv9Z4g9QC4AthTXHqqeJVAH4s1tFXHQYMArW7",
        "receiver_id": "serhii.near"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "DTruWLgm5Y56yDrxUipvYqKKm8F7hxVQTarNQqe147zs",
        "id": "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d",
        "outcome": {
          "executor_id": "berryclub.ek.near",
          "gas_burnt": 4011776278642,
          "logs": [],
          "receipt_ids": [
            "Td3QxpKhMdi8bfVeMiQZwNS1VzPXceQdn6xdftoC8k6",
            "DwLMVTdqv9Z4g9QC4AthTXHqqeJVAH4s1tFXHQYMArW7"
          ],
          "status": {
            "Failure": {
              "ActionError": {
                "index": 0,
                "kind": {
                  "FunctionCallError": {
                    "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
                  }
                }
              }
            }
          },
          "tokens_burnt": "401177627864200000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "6GHrA42oMEF4g7YCBpPw9EakkLiepTHnQBvaKtmsenEY"
          },
          {
            "direction": "Right",
            "hash": "DCG3qZAzf415twXfHmgBUdB129g2iZoQ4v8dawwBzhSh"
          }
        ]
      },
      {
        "block_hash": "F9xNWGhJuYW336f3qVaDDAipsyfpudJHYbmt5in3MeMT",
        "id": "Td3QxpKhMdi8bfVeMiQZwNS1VzPXceQdn6xdftoC8k6",
        "outcome": {
          "executor_id": "serhii.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "CJNvis1CoJmccshDpPBrk3a7fdZ5HnMQuy3p2Kd2GCdS"
          },
          {
            "direction": "Left",
            "hash": "4vHM3fbdNwXGMp9uYzVKB13abEM6qdPUuZ9rfrdsaDzc"
          }
        ]
      },
      {
        "block_hash": "F9xNWGhJuYW336f3qVaDDAipsyfpudJHYbmt5in3MeMT",
        "id": "DwLMVTdqv9Z4g9QC4AthTXHqqeJVAH4s1tFXHQYMArW7",
        "outcome": {
          "executor_id": "serhii.near",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "BR3R7tjziEgXMiHaJ7VuuXCo2yBHB2ZzsoxobPhPjFeJ"
          },
          {
            "direction": "Left",
            "hash": "4vHM3fbdNwXGMp9uYzVKB13abEM6qdPUuZ9rfrdsaDzc"
          }
        ]
      }
    ],
    "status": {
      "Failure": {
        "ActionError": {
          "index": 0,
          "kind": {
            "FunctionCallError": {
              "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
            }
          }
        }
      }
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6InZvbG92eWsubmVhciIsImFtb3VudCI6IjEwMDAwMDAwMDAwMDAwMDAwMDAwIn0=",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer"
          }
        }
      ],
      "hash": "CKHzodHvFw4C87PazsniycYZZHm37CEWLE2u8VUUMU7r",
      "nonce": 12,
      "public_key": "ed25519:eLbduR3uJGaAHLXeGKEfo1fYmYFKkLyR1R8ZPCxrJAM",
      "receiver_id": "berryclub.ek.near",
      "signature": "ed25519:63MC3f8m5jeycpy97G9XaCwmJLx4YHRn2x5AEJDiYYzZ3TzdzWsrz8dgaz2kHR2jsWh35aZoL97tw1RRTHK6ZQYq",
      "signer_id": "serhii.near"
    },
    "transaction_outcome": {
      "block_hash": "7YUgyBHgmbGy1edhaWRZeBVq9zzbnzrRGtVRQS5PpooW",
      "id": "CKHzodHvFw4C87PazsniycYZZHm37CEWLE2u8VUUMU7r",
      "outcome": {
        "executor_id": "serhii.near",
        "gas_burnt": 2428084223182,
        "logs": [],
        "receipt_ids": [
          "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d"
        ],
        "status": {
          "SuccessReceiptId": "5bdBKwS1RH7wm8eoG6ZeESdhNpj9HffUcf8RoP6Ng5d"
        },
        "tokens_burnt": "242808422318200000000"
      },
      "proof": [
        {
          "direction": "Right",
          "hash": "Agyg5P46kSVa4ptG9spteHpZ5c8XkvfbmDN5EUXhC1Wr"
        },
        {
          "direction": "Right",
          "hash": "3JDKkLCy5bJaAU3exa66sotTwJyGwyChxeNJgKReKw34"
        },
        {
          "direction": "Right",
          "hash": "7GXEmeQEJdd4c2kgN7NoYiF2bkjzV4bNkMmkhpK14NTz"
        }
      ]
    }
  }
}
```

</details>

Was the fungible token transfer successful?
  - Look for `result` ¬ª `transaction_outcome` ¬ª `outcome` ¬ª see if `SuccessReceiptId` is a key
  - if `SuccessReceiptId` is not a key, this fungible token transfer has `failed`.
  - If it does have that key, get the value, which is a `receipt ID`
  - Loop through `result` ¬ª `receipts_outcome` until you find an object that ID (from above) under the id key
  - in that object check `outcome` ¬ª `status` ¬ª (see if SuccessValue is a key)
  - If SuccessValue is a key, fungible token transfer succeeded, if not, it failed.

To determine how many fungible tokens were transferred, look at:
  - `result` ¬ª `transaction` ¬ª `actions` ¬ª `FunctionCall` ¬ª `args`
  - then take the args and `base64` decode it, that will give you a JSON payload and look for the `amount` key
  - It will contain a stringified number that represents the number of fungible tokens that were successfully transferred

## Transfer and call {#transfer-and-call}

If the idea of a fungible token using "transfer and call" is new, please review the comments above the function in [the Nomicon spec](https://nomicon.io/Standards/Tokens/FungibleToken/Core#reference-level-explanation). Also, see a similar idea [from EIP-677](https://github.com/ethereum/EIPs/issues/677).

For this example we will build and deploy FT contracts from [near-sdk-rs/examples/fungible-token](https://github.com/near/near-sdk-rs/tree/master/examples/fungible-token).

Let's call `ft_transfer_call` function on `ft` contract (receiver) and examine successful and unsuccessful scenarios.

### Successful transfer and call {#successful-transfer-and-call}
  Let's send 10 N to `DEFI` contract that requires only 9 N.

  - using NEAR CLI

    <Tabs groupId="cli-tabs">
      <TabItem value="short" label="Short">

      ```bash
      near call <ft_contract_id> ft_transfer_call '{"receiver_id": "<defi_contract_id>", "amount": "10", "msg": "take-my-money"}' --accountId <user_account_id> --amount 0.000000000000000000000001
      ```
      </TabItem>

      <TabItem value="full" label="Full">

        ```bash
        near contract call-function as-transaction <ft_contract_id> ft_transfer_call json-args '{"receiver_id": "<defi_contract_id>", "amount": "10", "msg": "take-my-money"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as <user_account_id> network-config testnet sign-with-keychain send
        ```
      </TabItem>
    </Tabs>

  - with JSON RPC call

Transaction representation:

```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.testnet",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "dev-1623333795623-21399959778159",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer_call,
				args: `{"receiver_id":"dev-1623693121955-71667632531176","amount":"10","msg":"take-my-money"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

```bash
  http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
  params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZqPqoVEgrAAAgAAAAZGV2LTE2MjMzMzM3OTU2MjMtMjEzOTk5NTk3NzgxNTn9j4g2IJ8nGQ38i3+k+4WBAeJL1xP7ygQhC7CrvEG4NQEAAAACEAAAAGZ0X3RyYW5zZmVyX2NhbGxWAAAAeyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzNjkzMTIxOTU1LTcxNjY3NjMyNTMxMTc2IiwiYW1vdW50IjoiMTAiLCJtc2ciOiJ0YWtlLW15LW1vbmV5In0AQHoQ81oAAAEAAAAAAAAAAAAAAAAAAAAANY2lHqJlAJYNDGEQiUNnmfiBV44Q1sdg45xNlNvlROOM+AtN1z3PSJqM6M6jAKXUwANoQTzFqXhIMHIjIPbTAA=="]'
```

To get details of this transaction:

```bash
http post https://archival-rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
    params:='["5n1kwA3TQQyFTkddR2Jau3H1Pt8ebQNGaov6aCQ6TDp1", "serhii.testnet"]' id=myid
```

<details>

<summary>**Example Response:**</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzNjkzMTIxOTU1LTcxNjY3NjMyNTMxMTc2IiwiYW1vdW50IjoiMTAiLCJtc2ciOiJ0YWtlLW15LW1vbmV5In0=",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer_call"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk",
        "receiver_id": "dev-1623333795623-21399959778159"
      },
      {
        "predecessor_id": "dev-1623333795623-21399959778159",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJzZW5kZXJfaWQiOiJzZXJoaWkudGVzdG5ldCIsImFtb3VudCI6IjEwIiwibXNnIjoidGFrZS1teS1tb25leSJ9",
                  "deposit": "0",
                  "gas": 70000000000000,
                  "method_name": "ft_on_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [
              {
                "data_id": "EiDQi54XHfdD1KEcgiNzogXxXuwTpzeQfmyqVwbq7H4D",
                "receiver_id": "dev-1623333795623-21399959778159"
              }
            ],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5",
        "receiver_id": "dev-1623693121955-71667632531176"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "13116953530949529501760"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "AkwgvxUspRgy255fef2hrEWMbrMWFtnTRGduSgDRdSW1",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "dev-1623333795623-21399959778159",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJzZW5kZXJfaWQiOiJzZXJoaWkudGVzdG5ldCIsInJlY2VpdmVyX2lkIjoiZGV2LTE2MjM2OTMxMjE5NTUtNzE2Njc2MzI1MzExNzYiLCJhbW91bnQiOiIxMCJ9",
                  "deposit": "0",
                  "gas": 5000000000000,
                  "method_name": "ft_resolve_transfer"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [
              "EiDQi54XHfdD1KEcgiNzogXxXuwTpzeQfmyqVwbq7H4D"
            ],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR",
        "receiver_id": "dev-1623333795623-21399959778159"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "761030677610514102464"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "9rxcC9o8x4RX7ftsDCfxK8qnisYv45rA1HGPxhuukWUL",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "2137766093631769060520"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "H7YWFkvx16Efy2keCQ7BQ67BMEsdgdYLqJ99G4H3dR1D",
        "receiver_id": "serhii.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "B9yZz1w3yzrqQnfBFAf17S4TLaHakXJWqmFDBbFxaEiZ",
        "id": "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk",
        "outcome": {
          "executor_id": "dev-1623333795623-21399959778159",
          "gas_burnt": 20612680932083,
          "logs": [
            "Transfer 10 from serhii.testnet to dev-1623693121955-71667632531176"
          ],
          "receipt_ids": [
            "EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5",
            "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR",
            "H7YWFkvx16Efy2keCQ7BQ67BMEsdgdYLqJ99G4H3dR1D"
          ],
          "status": {
            "SuccessReceiptId": "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR"
          },
          "tokens_burnt": "2061268093208300000000"
        },
        "proof": []
      },
      {
        "block_hash": "7Z4LHWksvw7sKYKwpQfjEMG8oigjtRXKa3EopN7hS2v7",
        "id": "EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5",
        "outcome": {
          "executor_id": "dev-1623693121955-71667632531176",
          "gas_burnt": 3568066327145,
          "logs": [
            "Sender @serhii.testnet is transferring 10 tokens using ft_on_transfer, msg = take-my-money"
          ],
          "receipt_ids": [
            "AkwgvxUspRgy255fef2hrEWMbrMWFtnTRGduSgDRdSW1"
          ],
          "status": {
            "SuccessValue": "IjEi"
          },
          "tokens_burnt": "356806632714500000000"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "5X2agUKpqmk7QkUZsDQ4R4HdX7zXeuPYpVAfvbmF5Gav"
          }
        ]
      },
      {
        "block_hash": "CrSDhQNn72K2Qr1mmoM9j3YHCo3wfZdmHjpHJs74WnPk",
        "id": "AkwgvxUspRgy255fef2hrEWMbrMWFtnTRGduSgDRdSW1",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "4WG6hF5fTAtM7GSqU8mprrFwRVbChGMCV2NPZEjEdnc1"
          }
        ]
      },
      {
        "block_hash": "CrSDhQNn72K2Qr1mmoM9j3YHCo3wfZdmHjpHJs74WnPk",
        "id": "4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR",
        "outcome": {
          "executor_id": "dev-1623333795623-21399959778159",
          "gas_burnt": 6208280264404,
          "logs": [
            "Refund 1 from dev-1623693121955-71667632531176 to serhii.testnet"
          ],
          "receipt_ids": [
            "9rxcC9o8x4RX7ftsDCfxK8qnisYv45rA1HGPxhuukWUL"
          ],
          "status": {
            "SuccessValue": "Ijki"
          },
          "tokens_burnt": "620828026440400000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "BzT8YhEDDWSuoGGTBzH2Cj5GC4c56uAQxk41by4KVnXi"
          }
        ]
      },
      {
        "block_hash": "3Q2Zyscj6vG5nC2vdoYfcBHU9RVaAwoxHsHzAKVcAHZ6",
        "id": "9rxcC9o8x4RX7ftsDCfxK8qnisYv45rA1HGPxhuukWUL",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": []
      },
      {
        "block_hash": "7Z4LHWksvw7sKYKwpQfjEMG8oigjtRXKa3EopN7hS2v7",
        "id": "H7YWFkvx16Efy2keCQ7BQ67BMEsdgdYLqJ99G4H3dR1D",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "61ak42D3duBBunCz3w4xXxoEeR2N7oav5e938TnmGFGN"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": "Ijki"
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzNjkzMTIxOTU1LTcxNjY3NjMyNTMxMTc2IiwiYW1vdW50IjoiMTAiLCJtc2ciOiJ0YWtlLW15LW1vbmV5In0=",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer_call"
          }
        }
      ],
      "hash": "5n1kwA3TQQyFTkddR2Jau3H1Pt8ebQNGaov6aCQ6TDp1",
      "nonce": 47589658000040,
      "public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN",
      "receiver_id": "dev-1623333795623-21399959778159",
      "signature": "ed25519:256qp2jAGXhhw2t2XfUAjWwzz3XcD83DH2v9THwDPsZjCLWHU8QJd6cuA773NP9yBmTd2ZyYiFHuxVEkYqnbsaSb",
      "signer_id": "serhii.testnet"
    },
    "transaction_outcome": {
      "block_hash": "96k8kKzFuZWxyiUnT774Rg7DC3XDZNuxhxD1qEViFupd",
      "id": "5n1kwA3TQQyFTkddR2Jau3H1Pt8ebQNGaov6aCQ6TDp1",
      "outcome": {
        "executor_id": "serhii.testnet",
        "gas_burnt": 2428149065268,
        "logs": [],
        "receipt_ids": [
          "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk"
        ],
        "status": {
          "SuccessReceiptId": "Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk"
        },
        "tokens_burnt": "242814906526800000000"
      },
      "proof": []
    }
  }
}
```

</details>

Now, let's try to follow the steps described in the previous section and determine if these transactions was successful. In addition to being successful, let's analyze the various receipts in the series of cross-contract calls to determine how many fungible tokens were transferred. This will be the most complex case we'll look at.

  1. Check that `result` ¬ª `transaction_outcome` ¬ª `outcome` ¬ª `status` has `SuccessReceiptId` as a key. If not, no fungible tokens were transferred.
  2. Take the value of the `SuccessReceiptId` key. In the case above it's `Hw6z8kJ7CSaC6SgyQzcmXzNX9gq1gaAnLS169qgyZ2Vk`.
  3. Now, under `result` ¬ª `receipts` loop through the array until you find a receipt where the `receipt_id` matches the value from step 2. (Note that in the receipt, under `Actions` there's an element mentioning calling the `method_name: "ft_transfer_call"`.) On the same level of JSON, there's an `args` key. That's a base64-encoded value of the arguments passed to the method. When decoded it is:

```json
{"receiver_id":"dev-1623693121955-71667632531176","amount":"10","msg":"take-my-money"}
```

  4. Loop through `result` ¬ª `receipts_outcome` until finding the object where `id` is equal to the value from step 2. Similar to step 1, this object will also contain a `status` field that should contain the key `SuccessReceiptId`. Again, if this isn't there no fungible tokens were transferred, otherwise get the value of the `SuccessReceiptId`. In the above example, this value is `4Tc8MsrJZSMpNZx7u4jSqxr3WhRzqxaNHxLJFqz8tUPR`.
  5. Similar to the previous step, loop through the `result` ¬ª `receipts_outcome` until you find the object where the `id` matches the value from step 4. In that object check that `outcome` ¬ª `status` has the `SuccessValue` field. This `SuccessValue` represents how many fungible tokens the receiving contract is "returning" to the fungible token contract. Note that in the example above the value is `Ijki`, which is the base64-encoded version of `"9"`. At this point, we know that 10 fungible tokens were sent (from step 3) and 9 were taken.

For additional clarity, let's take a look at one more optional aspect. In step 4 we isolated an object in `result` ¬ª `receipts_outcome`. There's an array of `receipt_ids` that's particularly interesting. The first element in the array is the receipt ID `EB69xtJiLRh9RNzAHgBGmom8551hrK2xSRreqbjvJgu5`. If we loop through the `result` ¬ª `receipts_outcome` and find this as the value for the `id` key, we'll see what happened in the function `ft_on_transfer` which takes place in the contract receiving the fungible tokens. In this object the `status` ¬ª `SuccessValue` is `IjEi` which is the base64-encoded value of `"1"`.

In summary:
1. A user called the fungible token contract with the method `ft_transfer_call` specifying the receiver account, how many tokens to send, and custom info.
2. The receiver account implemented `ft_on_transfer`, returning `"1"` to the callback function on the fungible token contract.
3. The fungible token contract's callback is `ft_resolve_transfer` and receives this value of `"1"`. It knows that 1 token was returned, so subtracts that from the 10 it intended to send. It then returns to the user how many tokens were used in this back-and-forth series of cross-contract calls: `"9"`.

### Failed transfer and call {#failed-transfer-and-call}
Let's try to send more tokens than the account has:

  - using NEAR CLI

<Tabs groupId="cli-tabs">
  <TabItem value="short" label="Short">

  ```bash
  near call <ft_contract_id> ft_transfer_call '{"receiver_id": "<defi_contract_id>", "amount": "1000000000", "msg": "take-my-money"}' --accountId <user_account_id> --amount 0.000000000000000000000001
  ```
  </TabItem>

  <TabItem value="full" label="Full">

    ```bash
    near contract call-function as-transaction <ft_contract_id> ft_transfer_call json-args '{"receiver_id": "<defi_contract_id>", "amount": "1000000000", "msg": "take-my-money"}' prepaid-gas '100.0 Tgas' attached-deposit '1 yoctoNEAR' sign-as <user_account_id> network-config testnet sign-with-keychain send
    ```
  </TabItem>
</Tabs>

Transaction representation:

```yaml
Transaction: {
	block_hash: `456‚Ä¶abc`,
	signer_id: "serhii.testnet",
	public_key: "ed25519:789‚Ä¶def",
	nonce: 123,
	receiver_id: "dev-1623333795623-21399959778159",
	actions: [
		FunctionCall(
			FunctionCallAction {
				method_name: ft_transfer_call,
				args: `{"receiver_id":"dev-1623333916368-58707434878533","amount":"1000000000","msg":"take-my-money"}`,
				gas: 300000000000000,
				deposit: 1,
			},
		),
	]
}
```

  - with JSON RPC call

```bash
  http post https://rpc.testnet.near.org jsonrpc=2.0 id=dontcare method=broadcast_tx_commit \
  params:='["DgAAAHNlcmhpaS50ZXN0bmV0AEKEp54fyVkp8dJE2l/m1ErjdhDGodBK8ZF6JLeHFMeZn/qoVEgrAAAgAAAAZGV2LTE2MjMzMzM3OTU2MjMtMjEzOTk5NTk3NzgxNTnrbOQ93Wv9xxBwmq4yDYrssCpwKSI2bzjNNCCCHMZKNwEAAAACEAAAAGZ0X3RyYW5zZmVyX2NhbGxeAAAAeyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzMzMzOTE2MzY4LTU4NzA3NDM0ODc4NTMzIiwiYW1vdW50IjoiMTAwMDAwMDAwMCIsIm1zZyI6InRha2UtbXktbW9uZXkifQBAehDzWgAAAQAAAAAAAAAAAAAAAAAAAABQh3k+7zG2m/Yz3O/FBrvLaBwR/5YRB5FbFnb27Nfu6BW/Wh77RFH7+ktBwGLBwFbJGxiumIcsqBiGXgg1EPMN"]'
```

To get details of this transaction:

```bash
http post https://archival-rpc.testnet.near.org jsonrpc=2.0 method=EXPERIMENTAL_tx_status \
    params:='["FQsh44pvEsK8RS9AbK868CmGwfhUU2pUrizkQ6wCWTsB", "serhii.testnet"]' id=myid
```

<details>

<summary>**Example response**:</summary>

```json
{
  "id": "myid",
  "jsonrpc": "2.0",
  "result": {
    "receipts": [
      {
        "predecessor_id": "serhii.testnet",
        "receipt": {
          "Action": {
            "actions": [
              {
                "FunctionCall": {
                  "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzMzMzOTE2MzY4LTU4NzA3NDM0ODc4NTMzIiwiYW1vdW50IjoiMTAwMDAwMDAwMCIsIm1zZyI6InRha2UtbXktbW9uZXkifQ==",
                  "deposit": "1",
                  "gas": 100000000000000,
                  "method_name": "ft_transfer_call"
                }
              }
            ],
            "gas_price": "186029458",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo",
        "receiver_id": "dev-1623333795623-21399959778159"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "1"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "system",
            "signer_public_key": "ed25519:11111111111111111111111111111111"
          }
        },
        "receipt_id": "Euy4Q33DfvJTXD8HirE5ACoXnw9PMTQ2Hq47aGyD1spc",
        "receiver_id": "serhii.testnet"
      },
      {
        "predecessor_id": "system",
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "18681184841157733814920"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "output_data_receivers": [],
            "signer_id": "serhii.testnet",
            "signer_public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN"
          }
        },
        "receipt_id": "6ZDoSeV3gLFS2NXqMCJGEUR3VwBpSxBEPjnEEaAQfmXL",
        "receiver_id": "serhii.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "BohRBwqjRHssDVS9Gt9dj3SYuipxHA81xXFjRVLqgGeb",
        "id": "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo",
        "outcome": {
          "executor_id": "dev-1623333795623-21399959778159",
          "gas_burnt": 3734715409940,
          "logs": [],
          "receipt_ids": [
            "Euy4Q33DfvJTXD8HirE5ACoXnw9PMTQ2Hq47aGyD1spc",
            "6ZDoSeV3gLFS2NXqMCJGEUR3VwBpSxBEPjnEEaAQfmXL"
          ],
          "status": {
            "Failure": {
              "ActionError": {
                "index": 0,
                "kind": {
                  "FunctionCallError": {
                    "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
                  }
                }
              }
            }
          },
          "tokens_burnt": "373471540994000000000"
        },
        "proof": []
      },
      {
        "block_hash": "4BzTmMmTjKvfs6ANS5gmJ6GQzhqianEGWq7SaxSfPbdC",
        "id": "Euy4Q33DfvJTXD8HirE5ACoXnw9PMTQ2Hq47aGyD1spc",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Right",
            "hash": "5ipmcdgTieQqFXWQFCwcbZhFtkHE4PL4nW3mknBchpG6"
          }
        ]
      },
      {
        "block_hash": "4BzTmMmTjKvfs6ANS5gmJ6GQzhqianEGWq7SaxSfPbdC",
        "id": "6ZDoSeV3gLFS2NXqMCJGEUR3VwBpSxBEPjnEEaAQfmXL",
        "outcome": {
          "executor_id": "serhii.testnet",
          "gas_burnt": 0,
          "logs": [],
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "9tcjij6M8Ge4aJcAa97He5nw8pH7PF8ZjRHVahBZD2VW"
          }
        ]
      }
    ],
    "status": {
      "Failure": {
        "ActionError": {
          "index": 0,
          "kind": {
            "FunctionCallError": {
              "ExecutionError": "Smart contract panicked: The account doesn't have enough balance"
            }
          }
        }
      }
    },
    "transaction": {
      "actions": [
        {
          "FunctionCall": {
            "args": "eyJyZWNlaXZlcl9pZCI6ImRldi0xNjIzMzMzOTE2MzY4LTU4NzA3NDM0ODc4NTMzIiwiYW1vdW50IjoiMTAwMDAwMDAwMCIsIm1zZyI6InRha2UtbXktbW9uZXkifQ==",
            "deposit": "1",
            "gas": 100000000000000,
            "method_name": "ft_transfer_call"
          }
        }
      ],
      "hash": "FQsh44pvEsK8RS9AbK868CmGwfhUU2pUrizkQ6wCWTsB",
      "nonce": 47589658000031,
      "public_key": "ed25519:5UfEFyve3RdqKkWtALMreA9jzsAGDgCtwEXGNtkGeruN",
      "receiver_id": "dev-1623333795623-21399959778159",
      "signature": "ed25519:2cPASnxKtCoQtZ9NFq63fg8RzpjvmmE8hL4s2jk8zuhnBCD3AnYQ6chZZrUBGwu7WrsGuWUyohP1bEca4vfbsorC",
      "signer_id": "serhii.testnet"
    },
    "transaction_outcome": {
      "block_hash": "FwHUeqmYpvgkL7eBrUUAEMCuaQshcSy5vm4AHchebhK1",
      "id": "FQsh44pvEsK8RS9AbK868CmGwfhUU2pUrizkQ6wCWTsB",
      "outcome": {
        "executor_id": "serhii.testnet",
        "gas_burnt": 2428166952740,
        "logs": [],
        "receipt_ids": [
          "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo"
        ],
        "status": {
          "SuccessReceiptId": "83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo"
        },
        "tokens_burnt": "242816695274000000000"
      },
      "proof": []
    }
  }
}
```

</details>


Let's examine this response.

  * `result` ¬ª `transaction_outcome` ¬ª `outcome` ¬ª `status` ¬ª `SuccessReceiptId` is `83AdQ16bpAC7BEUyF7zoRsAgeNW7HHmjhZLvytEsrygo`
  * check `result` ¬ª `receipts_outcome` ¬ª `0` ¬ª `outcome` ¬ª `status` and find `Failure` status there

:::tip Got a question?
<a href="https://stackoverflow.com/questions/tagged/nearprotocol" target="_blank" rel="noopener noreferrer"> Ask it on StackOverflow! </a>
:::


 This is the content for the doc docs/chain-abstraction/chain-signatures.md 

 ---
id: chain-signatures
title: What are Chain Signatures?
sidebar_label: What are Chain Signatures?
---


Chain signatures enable NEAR accounts, including smart contracts, to sign and execute transactions across many blockchain protocols.

This unlocks the next level of blockchain interoperability by giving ownership of diverse assets, cross-chain accounts, and data to every single NEAR account.

![chain-signatures](/docs/assets/welcome-pages/chain-signatures-overview.png)
_Diagram of a chain signature in NEAR_

## Benefits

Integration with Chain Signatures brings many benefits to Web3 developers:

- Single Account, Multi-Chain Operations: Developers can manage interactions with external blockchains from one NEAR account. This simplifies key management and reduces the need for multiple wallets or addresses, enhancing user experience and security.

- Reduced Overhead in Cross-Chain Development: Chain Signatures eliminate the complexity of managing transactions across different blockchains. Developers can write smart contracts on NEAR that directly sign for cross-chain transactions, cutting down on code redundancy and potential points of failure.

- Secure Transaction Signing: Using [Multi-Party Computation (MPC)](#multi-party-computation-service), developers gain access to a decentralized signing process for multi-chain transactions. This means no single entity controls the signing key, reducing risks associated with centralized custodianship.

:::tip

Keep in mind that Chain Signatures is a ‚Äúone way‚Äù solution to sign and execute outbound transactions happening on other blockchains.
If you're looking to access states on external blockchains, you should check out Omnibridge.

:::

## Interoperability

NEAR's chain abstraction stack allows developers to leverage powerful interoperability options across different blockchains. Developers can execute their business logic and deploy smart contracts on NEAR‚Äôs scalable blockchain infrastructure, while maintaining control over external accounts (such as Bitcoin, Ethereum, Base) and assets natively.

This integrated approach combines external blockchain assets with NEAR‚Äôs scalability, enabling the development of native dApps that offer superior performance and an optimized user experience. By combining the strengths of different ecosystems, NEAR Protocol unlocks an array of transformative possibilities without compromising on decentralization or scalability.

## Use Cases

The Chain Signatures architecture provides a decentralized method to interact with multiple blockchains from one NEAR account. With Chain Signatures, blockchain use cases expands to new levels.

### Bitcoin DeFi

Developers can build decentralized finance (DeFi) applications on NEAR, such as decentralized exchanges (DEXs), lending platforms, or yield farming protocols, while directly leveraging Bitcoin liquidity. The business logic resides on NEAR, while BTC is used for actual payments.

#### Examples

- Atomic Swaps: Facilitate trustless, instant exchanges between Bitcoin and other cryptocurrencies, enhancing liquidity and reducing counterparty risk.
- Receive Bitcoin payments with a native transfer to a Chain Signature derived account.
- Use Chain Signatures to control the payment flow and execute Bitcoin transactions, such as locking or transferring assets.
- Use smart contracts on NEAR to encapsulate business logic such as interest calculations, borrowing, order processing, reward distribution, and repayments.

### Cross-Chain NFT Platforms

Developers can create a NFT marketplace on NEAR where users purchase NFTs using external cryptocurrencies such as Bitcoin. The marketplace could handle:

- BTC payments via Chain Signatures and Omnibridge.
- NFT minting and trading logic on NEAR. (_NFTs could also be minted on multiple blockchains thanks to Chain Signatures_)

---

## How It Works

Controlling accounts and their assets on other blockchain platforms is made possible thanks to the interaction between three elements:

1. [**Derivation Paths**](#derivation-paths-one-account-multiple-chains) - A deterministic way to derive foreign addresses from one NEAR account
2. [**Multichain Smart Contract**](#multichain-smart-contract) - Receives requests to sign a transaction for other blockchains
3. [**Multiparty Computation Service**](#multi-party-computation-service) - Third-party service providing signatures to the contract

![Chain Signatures](/docs/assets/chain-abstract-2.svg)
_Chain signatures flow_

<hr class="subsection" />

### Derivation Paths: One Account, Multiple Chains

Chain Signatures link NEAR accounts to addresses in other blockchain using [Additive Key Derivation](https://eprint.iacr.org/2021/1330) (a simple mechanism for deriving many subkeys from a single master key). These keys are generated using `derivation paths` (or `paths` for short).

A `derivation path` is simply a string (e.g. `ethereum-1`, `ethereum-2`, etc) that in conjunction with the NEAR account derives a unique address on the target blockchain.

For example, we can derive multiple Ethereum addresses from `example.near` by using different paths:

  1. `example.near` + `ethereum-1` = `0x1b48b83a308ea4beb845db088180dc3389f8aa3b`
  2. `example.near` + `ethereum-2` = `0x99c5d3025dc736541f2d97c3ef3c90de4d221315`
  3. `example.near` + `...` = `0x...`

It is important to note that this allows us to discover the **public address** of the foreign account that we can control. To actually control the foreign account, we need to request signatures from the MPC service.

:::tip
In practice, the external address is deterministically derived using the NEAR address (`example.near`), the path (`ethereum-1`) and the MPC service's public key
:::

<hr class="subsection" />

### Multichain Smart Contract

A deployed multichain smart contract is used to request signatures for transactions on other blockchains.

This contract has a `sign` method that takes two parameters:

  1. The `payload` (transaction) to be signed for the target blockchain
  2. The `path` that identifies the account you want to use to sign the transaction.

For example, a user could request a signature to `send 0.1 ETH to 0x060f1...` **(transaction)** using the `ethereum-1` account **(path)**.


After a request is made, the `sign` method will [yield execution](/blog/yield-resume) waiting while the [MPC signing service](#multi-party-computation-service) signs the transaction.

Once the signature is ready, the contract resumes computation and returns it to the user. This signature is a valid signed transaction that can be readily sent to the target blockchain to be executed.

<hr class="subsection" />

### Multi-Party Computation Service

The essence of Multi-Party Computation (MPC) is to enable independent parties to perform shared computations on private information without revealing secrets to each other. In practice, this system can be used with blockchain platforms to safely sign a transaction on behalf of a user without ever having to expose a private key.

NEAR's MPC service is comprised of several independent nodes, **none of which can sign by itself**, but instead create **signature-shares** that are **aggregated through multiple rounds** to **jointly** sign a transaction.

This service continuously listens for signature requests (i.e. users calling the `sign` method on the `v1.signer` smart contract) and when a call is detected the MPC service:

  1. Asks its nodes to jointly derive a signature for the `payload` using the account identified by the `path`
  2. Once complete, call the `v1.signer` contract to store the resulting `Signature`

:::info A Custom MPC Service
Generally, MPC signing services work by sharing a master key, which needs to be re-created each time a node joins or leaves.

NEAR's MPC service allows for nodes to safely join and leave, without needing to re-derive a master key.
:::

:::tip
Want to learn more about the mathematics that enable MPC? [**Check this awesome article**](https://www.zellic.io/blog/mpc-from-scratch/).
:::

---

## Concluding Remarks

Chain Signatures are a powerful tool that allows NEAR accounts to control accounts on other blockchains. This is a fundamental step towards enabling true ownership of cross-chain data and assets.

For the user, the process is made completely **on chain**, since they only need to make a call to a smart contract and wait for the response.

Thanks to `derivation paths`, a single NEAR account can control **multiple accounts** on different blockchains, and thanks to the MPC service, the user can be sure that **nobody but themselves** can request signatures for those accounts.


 This is the content for the doc docs/chain-abstraction/chain-signatures/getting-started.md 

 ---
id: getting-started
title: Getting Started with Chain Signatures
---

Chain Signatures is a groundbreaking technology built on NEAR that enables all accounts, including smart contracts, to sign and execute transactions across multiple blockchains.

![img](https://pages.near.org/wp-content/uploads/2024/02/acct-abstraction-blog-1.png)

This innovation leverages Multi-Party Computation (MPC) and a distributed network of node operators to create joint signatures from arbitrary payloads, allowing NEAR accounts to control external blockchain accounts.

Chain Signatures enhances blockchain interoperability, giving ownership of diverse assets, cross-chain accounts, and data to a single NEAR account.

---

## How does it work?

When a NEAR account - could be a user or a **smart contract** - wants to interact with a foreign blockchain, it just need to follow four simple steps.

![Chain Signatures](/docs/assets/chain-abstract-2.svg)
_Chain signatures flow_

#### 1. Deriving Foreign Addresses

Chain Signatures uses [derivation paths](../chain-signatures.md#derivation-paths-one-account-multiple-chains) to represent accounts on foreign blockchains

The NEAR account‚Äôs name and the derivation path are used to mathematically derive a unique address for the user on the foreign blockchain

<details>

<summary> Derivation Paths </summary>

A NEAR account will always derive the same address on the foreign blockchain using the same derivation path

Notice that, since the foreign address is derived from the NEAR account name, it is not possible for another NEAR account to control the same address

</details>


#### 2. Creating the Transaction

The client constructs the foreign transaction to be signed, which varies depending on the target blockchain

:::tip

You can use the [Omni Transaction](https://github.com/near/omni-transaction-rs) Rust library to build transactions easily for different blockchains (like Bitcoin and Ethereum) inside NEAR contracts and Rust clients.

:::

#### 3. Requesting the Signature

A NEAR account or contract calls the sign method of the MPC smart contract ([v1.signer](https://nearblocks.io/address/v1.signer)) to sign the transaction and waits while our MPC service generates the signature

#### 4. Relaying the Signature

Once the signature is ready, the client reconstructs the signed transaction using the signature and broadcasts it to the destination blockchain

:::tip

Using Chain Signatures, developers can build cross-chain DeFi applications with seamless user experiences, eliminating the need for traditional bridges. This process eliminates the need for traditional bridges and enables developers to build innovative cross-chain DeFi applications with seamless user experiences.

:::

---

## Use Cases

Chain Signatures can be used to build a wide range of applications that leverage blockchain interoperability. Here are some examples:

1. **DeFi on Bitcoin (and other chain without smart contracts)**
   * Chain signatures allow NEAR smart contract to program assets on Bitcoin
   * Build lending, swaps, runes launchpads, passkey-based Bitcoin wallets, and more
2. **Chain agnostic applications**
   * Since chain signatures can sign transactions for all blockchains, developers can support every single chain with just one smart contract
   * Multichain DEXs, lending protocols, oracles, derivatives, and more
3. **Multichain account abstraction**
   * Users can control assets on all chains with just their NEAR account, and can utilize account abstraction features on any chain including passkeys, key rotation, etc
   * Using the multichain gas relayer, users can pay for gas fees on any chain using USDC
4. **Privacy**
   * Chain signatures can be used to encrypt and decrypt information in a programmatic way
   * This enables privacy applications, and even decrypting information based on ownership of assets/NFTs

---

## How to Get Started?

1. **Familiarize Yourself with Chain Signatures:**
   * Understand the [basics of Chain Signatures](https://docs.near.org/concepts/abstraction/chain-signatures) and how they simplify blockchain interactions.
   * Review the technical [explainer](https://near.org/blog/unlocking-web3-usability-with-account-aggregation).
2. **Explore the Use Cases:**
   * Review [examples of use cases for Chain Signatures](https://pages.near.org/blog/unlocking-multichain-web3-with-near-chain-signatures/), such as Multichain DAO, Multichain NFT Minter, and Bitcoin Runes Airdrop.
3. **Access Resources and Documentation:**
   * Visit the [Chain Signatures documentation](https://docs.near.org/build/chain-abstraction/chain-signatures) for detailed technical information and code snippets.
   * Check out the [Linktree for Chain Signatures](https://linktr.ee/chainsignatures) for various resources, including demos and tutorials.
4. **Try the Demos:**
   * Use the [command-line-based demo](https://github.com/near-examples/chainsig-script) to derive accounts and send transactions on Bitcoin, Ethereum, Doge, and Ripple.
   * Check out the [web app demo](https://github.com/near-examples/near-multichain/tree/main).
5. **Engage with the Community:**
   * Join the [Chain Abstraction developers‚Äô channel on Telegram](https://t.me/chain\_abstraction) to connect with other developers and get support.

---

## Where to Learn More?

To dive deeper into Chain Signatures and its applications, you can explore the following resources:

- **Technical Blogs and Deep Dives:** Read [high-level use cases](https://pages.near.org/blog/unlocking-multichain-web3-with-near-chain-signatures) and technical [explainer](https://near.org/blog/unlocking-web3-usability-with-account-aggregation) posts on the NEAR blog
* **Community and Support:** Engage with the NEAR community on social media platforms like Twitter and participate in discussions to stay updated on the latest developments


 This is the content for the doc docs/chain-abstraction/chain-signatures/implementation.md 

 ---
id: implementation
title: Implementing Chain Signatures
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Chain signatures enable NEAR accounts, including smart contracts, to sign and execute transactions across many blockchain protocols.

This unlocks the next level of blockchain interoperability by giving ownership of diverse assets, cross-chain accounts, and data to a single NEAR account.

:::info

This guide will take you through a step by step process for creating a Chain Signature.

‚≠êÔ∏è For complete examples of a NEAR account performing transactions in other chains:

- [CLI script](https://github.com/mattlockyer/mpc-script)
- [web-app example](https://github.com/near-examples/near-multichain)
- [component example](https://test.near.social/bot.testnet/widget/chainsig-sign-eth-tx)

:::

---

## Create a Chain Signature

There are five steps to create a Chain Signature:

1. [Deriving the Foreign Address](#1-deriving-the-foreign-address) - Construct the address that will be controlled on the target blockchain
2. [Creating a Transaction](#2-creating-the-transaction) - Create the transaction or message to be signed
3. [Requesting a Signature](#3-requesting-the-signature) - Call the NEAR `v1.signer` contract requesting it to sign the transaction
4. [Formatting the Signature](#4-formatting-the-signature) - Reconstruct the signature from the MPC service's response
5. [Relaying the Signed Transaction](#5-relaying-the-signature) - Send the signed transaction to the destination chain for execution

![chain-signatures](/docs/assets/welcome-pages/chain-signatures-overview.png)
_Diagram of a chain signature in NEAR_

:::info MPC Contracts

If you want to try things out, these are the smart contracts available on `testnet`:

- `v1.signer-prod.testnet`: [MPC signer](https://github.com/near/mpc/tree/v0.2.0/contract) contract, latest release, made up of 8 MPC nodes

:::

:::info MPC mainnet contracts

- `v1.signer`: [MPC signer](https://github.com/near/mpc/tree/v0.2.0/contract) contract, latest release, made up of 8 MPC nodes
:::

---

## 1. Deriving the Foreign Address

Chain Signatures use [`derivation paths`](../chain-signatures.md#derivation-paths-one-account-multiple-chains) to represent accounts on the target blockchain. The external address to be controlled can be deterministically derived from:

- The NEAR address (e.g., `example.near`, `example.testnet`, etc.)
- A derivation path (a string such as `ethereum-1`, `ethereum-2`, etc.)
- The MPC service's public key (see the tip below for the MPC service public keys)

We provide code to derive the address, as it's a complex process that involves multiple steps of hashing and encoding:

<Tabs groupId="code-tabs">
  <TabItem value="Œû EVM">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/EVM/EVM.jsx" start="89" end="92" />

</TabItem>

<TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/Bitcoin.jsx" start="43" end="46" />

</TabItem>

</Tabs>

We recommend hardcoding the derivation paths in your application to ensure the signature request is made to the correct account

:::tip

Here you can find MPC service public keys:

- **v1.signer-prod.testnet** ([testnet](https://testnet.nearblocks.io/address/v1.signer-prod.testnet)): `secp256k1:4NfTiv3UsGahebgTaHyD9vF8KYKMBnfd6kh94mK6xv8fGBiJB8TBtFMP5WWXz6B89Ac1fbpzPwAvoyQebemHFwx3`

- **v1.signer** ([mainnet](https://nearblocks.io/address/v1.signer)): `secp256k1:3tFRbMqmoa6AAALMrEFAYCEoHcqKxeW38YptwowBVBtXK1vo36HDbUWuR6EZmoK4JcH6HDkNMGGqP1ouV7VZUWya`

:::

:::info

The same NEAR account and path will always produce the same address on the target blockchain.

- `example.near` + `ethereum-1` = `0x1b48b83a308ea4beb845db088180dc3389f8aa3b`
- `example.near` + `ethereum-2` = `0x99c5d3025dc736541f2d97c3ef3c90de4d221315`

:::

---

## 2. Creating the Transaction

Constructing the transaction to be signed (transaction, message, data, etc.) varies depending on the target blockchain, but generally it's the hash of the message or transaction to be signed.


<CodeTabs>

  <Language value="Œû EVM" language="js">
  <!-- In Ethereum, constructing the transaction is simple since you only need to specify the address of the receiver, and any necessary data for the transaction. -->
      <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/EVM/FunctionCall.jsx"
      start="30" end="39"
      fname="FunctionCall.jsx"/>
       <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/EVM/Transfer.jsx"
      start="16" end="23"
      fname="Transfer.jsx" />
  </Language>
 
      
 <Language value="‚Çø Bitcoin" language="js">

<!-- In bitcoin, you construct a new transaction by using all the Unspent Transaction Outputs (UTXOs) of the account as input, and then specify the output address and amount you want to send. -->
        <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/Bitcoin.jsx"
      start="62" end="67"
      fname="Bitcoin.jsx"
       />
  </Language>
</CodeTabs>

:::tip
If you're a Rust developer, you can use the [Omni Transaction](https://github.com/near/omni-transaction-rs) Rust library to build transactions easily for different blockchains (like Bitcoin and Ethereum) inside NEAR contracts.
:::

---

## 3. Requesting the Signature

Once the transaction is created and ready to be signed, a signature request is made by calling `sign` on the [MPC smart contract](https://github.com/near/mpc-recovery/blob/f31e39f710f2fb76706e7bb638a13cf1fa1dbf26/contract/src/lib.rs#L298).

The method requires two parameters:

  1. The `transaction` to be signed for the target blockchain
  2. The derivation `path` for the account we want to use to sign the transaction

<Tabs groupId="code-tabs">
  <TabItem value="Œû EVM">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/EVM/EVM.jsx"
      start="110" end="125" />

</TabItem>

  <TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/Bitcoin.jsx"
      start="74" end="97" />

For bitcoin, all UTXOs are signed independently and then combined into a single transaction.

</TabItem>

</Tabs>

<details>

  <summary> Deposit amount </summary>

  In this example, we attach a deposit of 0.05 $NEAR for the signature request. The transaction may fail if the network is congested since the deposit required by the MPC service scales linearly with the number of pending requests, from 1 yoctoNEAR to a maximum of 0.65 $NEAR. Any unused deposit will be refunded and if the signature fails, the user will be refunded the full deposit.

  As an alternative, the MPC contract provides an [`experimental_signature_deposit()`](https://github.com/near/mpc/blob/develop/API.md#experimantal_signature_deposit) method to check the current deposit required.
  Keep in mind that this could provide an unreliable value, since the amount will likely change between the time of the check and the time of the request.

</details>

:::info

The contract will take some time to respond, as the `sign` method [yields execution](/blog/yield-resume), waiting for the MPC service to sign the transaction.

:::

---

## 4. Formatting the Signature

The MPC contract will not return the signature of the transaction itself, but the elements needed to rebuild the signature matching the target blockchain's format.

This allows the contract to generalize the signing process for multiple blockchains.

<Tabs groupId="code-tabs">
  <TabItem value="Œû EVM">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/EVM/EVM.jsx"
      start="126" end="132" />

In Ethereum, the signature is formatted by concatenating the `r`, `s`, and `v` values returned by the contract.

</TabItem>

<TabItem value="‚Çø Bitcoin">
        <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/Bitcoin.jsx"
      start="98" end="104" />

In Bitcoin, the signature is formatted by concatenating the `r` and `s` values returned by the contract.

</TabItem>

</Tabs>

---

## 5. Relaying the Signature

Once we have reconstructed the signature, we can relay it to the corresponding network. This will once again vary depending on the target blockchain.

<Tabs groupId="code-tabs">
  <TabItem value="Œû EVM">
      <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/EVM/EVM.jsx"
      start="150" end="150" />

</TabItem>

<TabItem value="‚Çø Bitcoin">
    <Github language="js"
      url="https://github.com/near-examples/near-multichain/blob/main/src/components/Bitcoin.jsx"
      start="124" end="124" />

</TabItem>

</Tabs>

:::info
‚≠êÔ∏è For a deep dive into the concepts of Chain Signatures see [What are Chain Signatures?](../chain-signatures.md)

‚≠êÔ∏è For complete examples of a NEAR account performing Eth transactions:

- [web-app example](https://github.com/near-examples/near-multichain)
- [component example](https://test.near.social/bot.testnet/widget/chainsig-sign-eth-tx)

:::


 This is the content for the doc docs/chain-abstraction/data-availability.md 

 ---
id: data-availability
title: Rollup Data Availability
---

Every monolithic blockchain has a data availability layer. NEAR's Data Availability (DA) represents a pioneering initiative to modularize the data availability layer from the NEAR blockchain to make it available as a roll-up solution for builders on other chains. 

This infrastructure consists of a smart contract, a light client, and a Remote Procedure Call (RPC) node. The smart contract is designed to accept blob data, which is then processed through NEAR's consensus. The RPC node functions as the serving node, where users can transmit their data. Lastly, the light client operates as a node that rollups can verify to ensure the availability of data.

- [Blob Store Contract](#blob-store-contract): A contract that provides the store for arbitrary DA blobs.
- [Light Client](#light-client): A trustless off-chain light client for NEAR with DA-enabled features.
- [RPC Client](#da-rpc): The defacto client for submitting data blobs to NEAR.
- [Integrations](#integrations): Proof of concept works for integrating with L2 rollups.

NEAR DA is notably inexpensive due to several key factors:
- NEAR offers a substantial amount of block space per shard, ensuring efficient utilization.
- NEAR optimizes this space by avoiding unnecessary cryptographic bloat, ensuring that each 4MB allocated equals precisely 4MB of usable data.
- NEAR's scalability is unmatched, as it can readily reshard and scale in response to increasing demand, unlike competitors who would need to resort to constructing rollups or sidechains, thus maintaining a consistently ample and cost-effective data availability solution.

:::tip
For the latest information, please check the [Near DA](https://github.com/near/rollup-data-availability/) repository.
:::

---

## System Context

This outlines the system components that we build and how it interacts with external components.

Red lines denote external flow of commitments.
White lines denote flow of blob data.


:::note
`Fisherman` is just an example how a rollup can work with the light client in the initial stage of DA, until we implement a more non-interactive approach, such as KZG.
:::

```mermaid 
C4Context
    title NEAR Data Availability System Context

    Enterprise_Boundary(b1, "Ethereum") {
        System_Ext(SystemEth, "Ethereum")

        System_Boundary(b2, "Rollup") {
            System_Ext(SystemRollup, "Rollup", "Derives blocks, execute transactions, posts commitments & sequence data")
            System(SystemNearDa, "NEAR DA Client", "Submits/Gets blob data, creates commitments")
        }
        BiRel(SystemRollup, SystemEth, "Posts sequences, proofs of execution, DA frame references")
        BiRel(SystemRollup, SystemNearDa, "Post batches, retrieves commitments")
        Rel(fisherman, SystemEth, "Looks for commitments, posts results")
    }      
    
    Enterprise_Boundary(b0, "NEAR") {
        
        System(SystemLc, "Light Client", "Syncs headers, provides inclusion proofs")
        System(SystemNear, "NEAR Protocol", "NEAR validators, archival nodes")
        
        Rel(SystemLc, SystemNear, "Syncs headers")    
        Rel(SystemNearDa, SystemNear, "Submits/Gets blob")

        %% This doesn't exist yet
        %% System(SystemDas, "Data Availability Sampling", "Data redundancy, retrieval, sample responses")
        %% BiRel(SystemDas, SystemLc, "Commitments")
    }
     
    Person_Ext(fisherman, "Fisherman")
    Rel(fisherman, SystemLc, "Requests inclusion proofs, validates inclusion proofs")
      

    UpdateRelStyle(fisherman, SystemEth, $offsetY="-10" $lineColor="red")
    UpdateRelStyle(fisherman, SystemLc, $offsetY="-10", $lineColor="red")
    UpdateRelStyle(SystemRollup, SystemEth, $offsetY="-30", $lineColor="white")
    UpdateElementStyle(fisherman, $bgColor="grey", $borderColor="red")

    UpdateRelStyle(SystemRollup, SystemNearDa, $offsetX="-200", $lineColor="white", $textColor="white")
    UpdateRelStyle(SystemNearDa, SystemNear, $textColor="white", $lineColor="white", $offsetY="10")
    UpdateRelStyle(SystemNearLc, SystemNear, $offsetX="30")
```

---

## [Blob Store Contract](https://github.com/near/rollup-data-availability/tree/main/contracts/blob-store)

The [blob store contract](https://github.com/near/rollup-data-availability/tree/main/contracts/blob-store) provides the store for arbitrary DA blobs. In practice, these "blobs" are sequencing data from rollups, but they can be any data.

NEAR blockchain state storage is pretty cheap. At the time of writing, 100KiB is a flat fee of 1NEAR. To limit the costs of NEAR storage even more, we don't store the blob data in the blockchain state.

It works by taking advantage of NEAR consensus around receipts. When a chunk producer processes a receipt, there is consensus around the receipt. However, once the chunk has been processed and included in the block, the receipt is no longer required for consensus and can be pruned. The pruning time is at least 3 NEAR epochs, where each epoch is 12 Hours; in practice, this is around five epochs. Once the receipt has been pruned, it is the responsibility of archival nodes to retain the transaction data, and we can even get the data from indexers.

We can validate that the blob was retrieved from ecosystem actors in the format submitted by checking the blob commitment. The blob commitment currently needs to be more efficient and will be improved, but it benefits us because anybody can build this with limited expertise and tooling. It is created by taking a blob, chunking it into 256-byte pieces, and creating a Merkle tree, where each leaf is a Sha-256 hash of the shard. The root of the Merkle tree is the blob commitment, which is provided as [transaction_id ++ commitment] to the L1 contract, which is 64 bytes.

What this means:
- Consensus is provided around the submission of a blob by NEAR validators
- The function input data is stored by full nodes for at least three days
- Archival nodes can store the data for longer
- We don't occupy consensus with more data than needs to be
- Indexers can also be used, and this Data is currently indexed by all significant explorers in NEAR
- The commitment is available for a long time, and the commitment is straightforward to create

---

## [Light Client](https://github.com/near/rollup-data-availability/tree/main/)

A trustless off-chain light client for NEAR with DA-enabled features, Such as KZG commitments, Reed-Solomon erasure coding & storage connectors.

The light client provides easy access to transaction and receipt inclusion proofs within a block or chunk. This is useful for checking any dubious blobs which may not have been submitted or validating that a blob has been submitted to NEAR.

A blob submission can be verified by:

- Taking the NEAR transaction ID from Ethereum for the blob commitment.
- Ask the light client for an inclusion proof for the transaction ID or the receipt ID if you're feeling specific; this will give you a Merkle inclusion proof for the transaction/receipt.
- Once you have the inclusion proof, you can ask the light client to verify the proof for you, or advanced users can manually verify it themselves.
- Armed with this knowledge, rollup providers can have advanced integration with light clients and build proving systems around it.

In the future, we will provide extensions to light clients such that non-interactive proofs can be supplied for blob commitments and other data availability features.

It's also possible that the light client may be on-chain for the header syncing and inclusion proof verification, but this is a low priority right now.

---

## DA RPC
This client is the defacto client for submitting blobs to NEAR. These crates allow a client to interact with the blob store. It can be treated as a "black box", where blobs go in, and `[transaction_id ++ commitment]` emerges.

There are multiple versions:
- The [`da-rpc` crate](https://github.com/near/rollup-data-availability/tree/main/crates/da-rpc) is the rust client, which anyone can use if they prefer rust in their application.
The responsibility of this client is to provide a simple interface for interacting with NEAR DA.
- The [`da-rpc-sys` crate](https://github.com/near/rollup-data-availability/tree/main/crates/da-rpc-sys) is the FFI client binding for use by non-rust applications. This calls through to `da-rpc` to interact with the blob store, with some additional black box functionality for dealing with pointers wrangling and such.
- The [`da-rpc-go` package](https://github.com/near/rollup-data-availability/tree/main/gopkg/da-rpc) is the go client bindings for use by non-rust applications, and this calls through to `da-rpc-sys`, which provides another application-level layer for easy interaction with the bindings.

:::info
See also [the diagram](https://github.com/near/rollup-data-availability/blob/main/docs/da_rpc_client.md)
:::

---

## Integrations

We have developed some proof of concept works for integrating with L2 rollups:

- [CDK Stack](https://github.com/firatNEAR/cdk-validium-node/tree/near): We have integrated with the Polygon CDK stack. Using the Sequence Sender for submissions to NEAR.
- [Optimism](https://github.com/near/optimism): We have integrated with the Optimism OP stack. Using the `Batcher` for submissions to NEAR and the proposer for submitting NEAR commitment data to Ethereum.

- [Arbitrum Nitro](https://github.com/near/nitro): We have integrated a small plugin into the DAC daserver. This is much like our http sidecar and provides a very modular integration into NEAR DA whilst supporting arbitrum DACs.

:::info
In the future, the `Arbitrum Nitro` integration will likely be the easiest way to support NEAR DA as it acts as an independent sidecar which can be scaled as needed. This also means that the DAC can opt-in and out of NEAR DA, lowering their infrastructure burden. With this approach, the DAC committee members just need to have a "dumb" signing service, with the store backed by NEAR.
:::


 This is the content for the doc docs/chain-abstraction/fastauth-sdk.md 

 ---
id: fastauth-sdk
title: FastAuth SDK
sidebar_label: FastAuth (Email Login)
---

FastAuth is a key management system that allows users to **recover or sign-up for** a NEAR account using their **email address**.

:::warning

FastAuth is being deprecated, stay tuned for updates

:::

 This is the content for the doc docs/chain-abstraction/intents/faq.md 

 ---
description: Frequently Asked Questions
---

# FAQs

### Is there a testnet deployment?

There's no `testnet` deployment and no plans for it. We recommend testing on NEAR `mainnet` with using separate dev/test NEAR accounts.

### Is there support for native NEAR deposits?

Only  `ft_transfer_call` can be used to deposit NEP-141 tokens from Near to `intents.near`:


```
<TOKEN_ACCOUNT_ID>::ft_transfer_call({
  "receiver_id": "intents.near",
  "amount": "1234",
  "msg": "{\"receiver_id\": \"<ACCOUNT_ID>\"}"
})
```

Here is an example [receipt](https://nearblocks.io/txns/EwmeXzZJStA6e5JB49vgxNYJDemqeYCFGvPH7zapP1Fw#execution#4tyaF4MnMcNQVqrg3kXzsH9277ErDeCXS9g3c2keV38G) for that.\
Parameter `msg` can also be empty, so that funds will be deposited to `sender_id` (i.e. caller of `ft_transfer_call`). Here is an example of such [transaction](https://nearblocks.io/txns/HoWpAR8dF5azsUVaQWrBW5VsRve5X4dwr9GGiHWj3R1P#execution).

### `tx_hash` in the `recent_deposit` response for all SOL deposits is empty

This information is not available for Solana because the mechanism of deposit tracking works a bit differently there.

### Is there a reason why my UTXOs aren't being swept on the BTC ? I sent 5,000 sats

This is a very small amount that is considered to be "dust" and there is a special business logic to process such small amount.

### How does the deposit process work?

The deposit process begins once the transfer transaction on the foreign network has been completed.  When the balance of the user's unique deposit address has become positive our indexer generates a deposit event and assigns it a `PENDING` status.

The next step is collecting the current tokens in storage. The result of this process will be either a `COMPLETED` or `FAILED` status. Deposits with a `FAILED` status are currently handled manually and eventually updated to the `COMPLETED` status.

On EVM networks, deposits can bypass the `PENDING` status due to faster processing and transfer completion times.

The data structure for the `PENDING` and `FAILED` statuses is identical to that of the `COMPLETED` status.

Regarding BTC deposits: If you want to make a deposit to an account that hasn‚Äôt yet been connected to the application - this is possible but requires extreme caution. You can request a deposit address by calling the bridge API (`deposit_address`) and specifying the `account_id` parameter. The `account_id` can be a NEAR account, an EVM address, or a SOL address to which you have access.

It is recommended starting with a small amount for experimentation. After the deposit is completed, you can connect wallet and check the tokens.


 This is the content for the doc docs/chain-abstraction/intents/intents-bridge.md 

 ---
id: intents-bridge
title: Intents Bridge
sidebar_label: Intents Bridge
---


NEAR Intents utilizes multichain bridges for cross-chain settlement. Currently the following bridges are supported:

1. [Omni Bridge](#omni-bridge)
2. [PoA Bridge](#poa-bridge)

---

## Omni Bridge

<!-- TODO: incoming omnibridge docs that will be added after this PR is merged. Once those are merged update this section. -->

The [Omni Bridge](../omnibridge/overview.md) is the primary bridge solution supporting multiple networks and deposit options.

### Supported Networks

- Bitcoin
- Ethereum
- Arbitrum
- Base
- Solana
- TON

### Features
- Support for `ft_transfer_call()` with `msg` field (active deposit)
- Passive deposit functionality through:
  - NEAR-side smart contract owning deposit addresses
  - Protocol for bridging type correspondence (`ft_transfer` or `ft_transfer_call`)
  - Parameter-based derivation paths for deposit addresses

### Deposits & Withdrawals

The Omni Bridge handles deposits and withdrawals between other chains and NEAR FTs. For assets not yet supported by Omni Bridge, the [PoA Bridge](#poa-bridge) serves as an alternative.

#### Why Deposits are Required
Users need to deposit funds into NEAR Intents accounts to trade, which differs from traditional AMMs. This design choice is based on:

1. The necessity of bridging external crypto to NEAR
2. Single-transaction atomic settlement benefits
3. Centralized risk comparable to existing NEP-141 tokens

Future migration to a fully sharded architecture will occur once sharded FT standards are developed.

---

## PoA Bridge

The Proof of Authority (PoA) Bridge provides an alternative solution for transferring assets between blockchain networks and NEAR Intents.

![bridge diagram](/docs/assets/intents/poa-bridge-user-docs.jpg)

### Usage Guide

The PoA Bridge API provides a JSON-RPC interface for managing deposits and withdrawals between supported networks and NEAR Intents. See the [official documentation](https://docs.near-intents.org/near-intents/poa-bridge#json-rpc-endpoint) for more details.

1. **Check Asset Support**: Verify your token is supported
2. **Get Deposit Address**: Request a deposit address and transfer tokens
3. **Monitor Deposits**: Track recent deposits via API
4. **Manage Withdrawals**: Initiate and monitor withdrawals through contract or frontend



 This is the content for the doc docs/chain-abstraction/intents/overview.md 

 ---
id: overview
title: Intents
sidebar_label: Overview
---

In NEAR, an `intent` is a high level declaration of what a user wants to achieve. Think of it as telling the blockchain "what" you want to do, not "how" to do it. For example, instead of manually:
- Finding the best DEX for a token swap
- Calculating optimal routes
- Executing multiple transactions

You simply express: "I want to swap Token A for Token B at the best price."

[NEAR Intents](https://near.org/blog/introducing-near-intents/) is a revolutionary transaction framework that simplifies blockchain interactions for:
- Users
- Services
- AI agents

The key innovation is that users & developers no longer need to handle complex cross-chain transactions themselves. Instead, they declare their desired outcome, and a specialized network of solvers (including both AI agents and traditional market participants) competes to execute that intent in the most optimal way possible.

:::info
The NEAR intents protocol and the documentation are under active development.

The protocol has been renamed from _Defuse_ to **NEAR Intents**.
Any mentions of _Defuse_ in the source code and documentation are to be replaced.
:::

## How It Works

1. [**Intent Creation**:](#intent-creation) A user or AI agent expresses a desired outcome _(ex: Swap Token A for Token B)_ and broadcasts the intent to a Solver Network of their choice.

2. [**Solvers Compete**:](#solvers) A off-chain decentralized network of solvers compete to fulfill the request in the most optimal way. When the solver network finds the best solution, it presents it as a quote to the originating user/agent for approval.

4. [**Intent Execution**:](#intent-execution) If the quote from the Solver Network is accepted, the intent begins execution. This is done by the solver performing a contract call (`execute_intents`) to the Intents smart contract on NEAR ([`intents.near`](https://nearblocks.io/address/intents.near)) and passing the intent details. This contract then fulfills the request and (if needed) uses a [cross-chain bridge](intents-bridge.md) to broadcast the intent to the destination chain. The NEAR Intent smart contract also verifies state changes and ensures the intent is settled correctly, reporting the outcome to the originating user/agent.

Here is a sequence diagram of the intent flow:

```mermaid
sequenceDiagram
    participant User/Agent
    participant Solver Network
    participant NEAR Blockchain

    User/Agent->>Solver Network: Broadcasts intent
    note right of Solver Network: Solvers compete to <br> find the best solution
    Solver Network-->>Solver Network: 
    Solver Network-->>User/Agent: Return quote from a solver
    User/Agent->>Solver Network: User accepts quote and <br> solver executes intent
    Solver Network->>NEAR Blockchain: Solver calls NEAR <br> Intent smart contract


    note over NEAR Blockchain: NEAR smart contract <br> verifies and settles intent
    NEAR Blockchain->>User/Agent: 
    note right of User/Agent: Intent Fulfilled! ‚úÖ
```

---

## Intent Creation

Users and AI agents can create various types of intents to interact with assets across different chains. Each intent represents a specific desired outcome while abstracting away the complexity of execution.

The main intent types supported by the `intents.near` contract are:

1. **Swap Intent**: Exchange one token for another at the best available rate
2. **Transfer Intent**: Move tokens between addresses or chains
3. **FT Withdraw Intent**: Withdraw fungible tokens from the protocol
4. **NFT Withdraw Intent**: Withdraw non-fungible tokens from the protocol
5. **MT Withdraw Intent**: Withdraw multiple tokens in a single transaction
6. **Native Withdraw Intent**: Withdraw native blockchain tokens (e.g., NEAR)

Each intent follows a standard structure that includes:
- The NEAR account ID of the initatior
- Type of intent they want to execute
- Source assets and amounts
- Desired outcome parameters
- Unique identifiers for tracking and authentication
- Optional constraints (e.g., minimum output amount, deadline)

Here is an example of a native NEAR swap intent structure ready to be broadcasted to a Solver Network:

```js
{
  intent_type: "atomic_near", // Type of intent - in this case for atomic swaps on NEAR
  intent_creation_hash: "Hx7b2270616...", // Unique hash of the intent for authenticity
  intent_id: "intent_1234567890", // Unique identifier for this specific intent
  intent_initiator: "alice.near", // The NEAR account ID of the user initiating the swap
  defuse_asset_identifier_in: "near:wrap.near",  // inpute token (what you are swapping)
  defuse_asset_identifier_out: "near:usdc.near", // output token (what you want to receive)
  amount_in: "1000000000000000000000000",  // Numbber of $NEAR in yoctoNEAR (1 NEAR = 10^24 yoctoNEAR)
  amount_out_desired: "1000000"            // Number of desired USDC (6 decimals)
}
```

<!-- TODO: add example of a cross-chain swap intent & and where to get the asset identifiers -->

---

## Solvers

NEAR Intents uses decentralized networks of solvers to fulfill intents. Each solver network is an off-chain message bus that facilitates:

1. Communication between users and solvers
2. Exchange of `permits` (signed state changes) between participants
3. Competition between solvers to provide the best quote possible for the intent originator

When an intent is broadcast, the solver network communicates with multiple solvers simultaneously. Each solver analyzes the intent and proposes their solution, including execution path and pricing. The solver network then aggregates these responses and selects the most optimal solution before presenting a final quote to the intent originator.

<!-- TODO: add diagram of the solver network -->

Solver networks are typically specific to a single distribution channel (like a DeFi application) and may contain authorized/trusted solvers for that channel. These solvers:

- Monitor for new intent broadcasts
- Calculate optimal execution paths
- Compete to provide the best quotes
- Execute approved intents through the NEAR smart contract
- Handle cross-chain coordination when needed

The decentralized nature of solver networks ensures:

- Competitive pricing through solver competition
- Redundancy and reliability
- Specialized solvers for different types of intents

:::tip
See [Create a Solver](solvers.md) for more details on how these solvers work.
:::
---

## Intent Execution

When a user accepts a quote from the Solver Network, the intent begins execution. This is done by the solver performing a contract call (`execute_intents`) to the Intents smart contract on NEAR ([`intents.near`](https://nearblocks.io/address/intents.near)) and passing the intent details. 

The NEAR Intents contract fullfills the request and (if needed) uses multi-chain bridge to settle an intent cross-chain. The Intent smart contract also verifies state changes and ensures the intent is settled correctly, reporting the outcome to the originating user/agent.

<!-- TODO: add link to smart contract docs -->

---

## Examples

Here are examples of NEAR Intents in action. Please note that this protocol is still under development and source code is available for learning purposes.

- [Defuse Frontend](https://github.com/defuse-protocol/defuse-frontend): `near-intents.org` fronted sourcecode
- [Defuse SDK](https://github.com/defuse-protocol/defuse-sdk): Typescript SDK powering `near-intents.org` [WIP]  
- [AMM Solver](https://github.com/defuse-protocol/near-intents-amm-solver): Sample solver with AMM functionality
- [Python Client](https://github.com/referencedev/test-intent): A Python example of interacting with the Solver Bus
- [NEAR Intents AI Agent Example](https://github.com/near-examples/near-intents-agent-example): A Python example of an AI agent that uses NEAR Intents

:::warning
Currently there is no `testnet` deployment.
:::


 This is the content for the doc docs/chain-abstraction/intents/solvers.md 

 ---
description: Example of signing solver intent
title: Create a Solver
sidebar_label: Create a Solver
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

Here is an example of how to create solver response for quote using TypeScript:

Steps:
1. Build a message response based on the `params`
2. Generate a nonce
3. Serialize the intent
4. Sign the message

Here `params`  has same type as what you receive from a relay in the [**"quote"** event](https://docs.near-intents.org/near-intents/solver-bus/api#solver-ws-endpoint):


```typescript
params: {
  defuse_asset_identifier_in: string;
  defuse_asset_identifier_out: string;
  exact_amount_in: string | undefined;
  exact_amount_out: string | undefined;
  min_deadline_ms: number;
},
```

## Methods

<Tabs>
<TabItem value="generateNonce" label="generateNonce()">

You can generate the nonce with the `generateNonce()` method:

```typescript
const generateNonce = async (): Promise<string> => {
    const randomArray = randomBytes(32);
    return randomArray.toString('base64');
    if (await this.isNonceUsed(nonceString)) { //this step can be skipped but if nonce is already used quote wont be taken into account
      return this.generateNonce();
    } else {
     return nonceString;
    }
}
const isNonceUsed = async (nonce: string) => {
    const account = getAccount(); //function that will return Account instance(from "near-api-js") of solver Near account
    return await account.viewFunction({
      contractId: defuseContract,
      methodName: 'is_nonce_used',
      args: {
        account_id: account.accountId,
        nonce,
      },
    });
}
```

</TabItem>
<TabItem value="serializeIntent" label="serializeIntent()">

You can serialize the response message with the `serializeIntent()` method:

```typescript
import { BorshSchema, borshSerialize } from 'borsher';

const standardNumber = {
    ["nep413"]: 413,
  };
const Nep413PayloadSchema = BorshSchema.Struct({
  message: BorshSchema.String,
  nonce: BorshSchema.Array(BorshSchema.u8, 32),
  recipient: BorshSchema.String,
  callback_url: BorshSchema.Option(BorshSchema.String),
});
const serializeIntent = (
  intentMessage: any,
  recipient: string,
  nonce: string,
  standard: string,
): Buffer => {
  const payload = {
    message: intentMessage,
    nonce: base64ToUint8Array(nonce),
    recipient,
  };
  const payloadSerialized = borshSerialize(Nep413PayloadSchema, payload);
  const baseInt = 2 ** 31 + standardNumber[standard];
  const baseIntSerialized = borshSerialize(BorshSchema.u32, baseInt);
  const combinedData = Buffer.concat([baseIntSerialized, payloadSerialized]);
  return crypto.createHash('sha256').update(combinedData).digest();
}

const base64ToUint8Array = (base64: string): Uint8Array => {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
```

</TabItem>
<TabItem value="signMessage" label="signMessage()">

You can sign the response message using the `signMessage()` method:

```typescript
const signMessage = async (message: Uint8Array) { //you can implement your own way to sign message with near wallet
  return (await keyStore.getKey(nearNetworkId, accountId)).sign(message); //keyStore is instance of KeyStore(from "near-api-js")
}
```

</TabItem>
</Tabs>


## Example

```typescript
import bs58 from 'bs58';

const amount = "1000" //calculated amount solver want to propose
const standard = "nep413";
const message = {
  signer_id: "...", //account id of solver account that will be used for signing
  deadline: {
    timestamp: 10000, //timestamp deadline in seconds
  },
  intents: [
    {
      intent: 'token_diff',
      diff: {
        [params.defuse_asset_identifier_in]: !!params.exact_amount_in
          ? params.exact_amount_in
          : amount,
        [params.defuse_asset_identifier_out]: `-${
          !!params.exact_amount_out ? params.exact_amount_out : amount
        }`,
      },
    },
  ],
};
const messageStr = JSON.stringify(message);
const nonce = await generateNonce();
const recipient = defuseContract; //for example "intents.near"
const quoteHash = serializeIntent(messageStr, recipient, nonce, standard);
const signature = signMessage(quoteHash);

const resp: IQuoteObject = {
  quote_id,
  quote_output: {},
  signed_data: {
    standard,
    payload: {
      message: messageStr,
      nonce,
      recipient,
    },
    signature: `ed25519:${bs58.encode(signature.signature)}`,
    public_key: `ed25519:${bs58.encode(signature.publicKey.data)}`,
  },
};
if (!params.exact_amount_in) {
  resp.quote_output.amount_in = amount;
} else {
  resp.quote_output.amount_out = amount;
}
```


 This is the content for the doc docs/chain-abstraction/meta-transactions.md 

 ---
id: meta-transactions-relayer
title: Building a Meta Transaction Relayer
sidebar_label: Building a Relayer
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs"

Relayers serve to delegate gas fees to a web service, allowing users to transact on NEAR without the need to acquire the token themselves while still retaining the security of signing their own transactions. This guide will lead you through the components necessary to construct a relayer capable of handling meta transactions.

:::tip

If you're already acquainted with the technology and you just want to run your own Relayer, you can fast track to a complete [Rust Relayer server](#rust-relayer-server) open-source implementation.

:::

## How it works

A basic relayer consists of a web server housing a funded NEAR account. This account receives an encoded signed transaction, which can subsequently be decoded into a `SignedDelegate` format and transmitted on-chain.

The client can then generate a `SignedDelegateAction` (a signed message that hasn't yet been sent), encode it, and transmit it to this server, where it will be relayed onto the blockchain.

![relayer-overview-technical](/docs/assets/welcome-pages/relayer-overview-technical.png)

## Relayer (server)

<Tabs groupId="code-tabs">

<TabItem value="near-api-js">

Here's a simple express endpoint that deserializes the body, instantiates the relayer account and then sends the transaction.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay-example/blob/main/server.ts' start='16' end='27'/>

You can easily get the account object used to send the transactions from its private key using this snippet

<Github language='typescript' url='https://github.com/SurgeCode/near-relay-example/blob/main/util.ts' start='5' end='17'/>


:::info

 The code in the example only works from the following versions onwards

```
"near-api-js": "3.0.4"
"@near-js/transactions": "1.1.2",
"@near-js/accounts": "1.0.4"
```

:::


</TabItem>

<TabItem value="@near-relay/server">

`@near-relay` simplifies meta transactions making it easier to get started for a beginner.

To start, call the relay method inside an endpoint to automatically deserialize the transaction and send it with the account defined in the environment variables.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/server/server.ts' start='8' end='12'/>

If you're interested in relaying account creation as well, it's quite straightforward. Simply create another endpoint and directly call the createAccount method with the accountId and publicKey. These parameters are automatically included in the body when using the corresponding client library.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/server/server.ts' start='14' end='18'/>
  
</TabItem>

</Tabs>


## Client

<Tabs groupId="code-tabs">

<TabItem value="near-api-js">

In this method we are creating an arbitrary smart contract call, instantiating an account and using it to sign but not send the transaction. We can then serialize it and send it to the relayer where it will be delegated via the previously created endpoint.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay-example/blob/main/client.ts' start='10' end='30'/>

</TabItem>

<TabItem value="@near-relay/client">

As mentioned in the above note in order to be able to relay on the client side it's necessary to have access to signing transactions directly on the client. Luckily leveraging the near biometric library it's possible to do so in a non custodial way.

By calling this method and passing in the URL for the account creation endpoint (mentioned in the server section) as well as the `accountId` everything is handled under the hood to successfully create an account.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/example/src/app/page.tsx' start='17' end='23'/>

On the client side, you just need to create an `Action` and pass it into the `relayTransaction` method along with the URL of the relayer endpoint discussed in the server section and the id of the `receiverId`.

<Github language='typescript' url='https://github.com/SurgeCode/near-relay/blob/main/example/src/app/page.tsx' start='25' end='36'/>

</TabItem>

</Tabs>

<details>
<summary> Relaying with wallets </summary>

At the moment, wallet selector standard doesn't support signing transactions without immediately sending them. This functionality is essential for routing transactions to a relayer. Therefore, to smoothly integrate relaying on the client side, it's necessary to be able to sign transactions without relying on wallets.
Progress is being made to make this possible in the future.

</details>

### High volume parallel processing

When running a relayer that handles a large number of transactions, you will quickly run into a `nonce` collision problem. At the protocol level, transactions have a unique number that identifies them (nonce) that helps to mitigate reply attacks. Each key on an account has its own nonce, and the nonce is expected to increase with each signature the key creates.

When multiple transactions are sent from the same access key simultaneously, their nonces might collide. Imagine the relayer creates 3 transactions `Tx1`, `Tx2`, `Tx3` and send them in very short distance from each other, and lets assume that `Tx3` has the largest nonce. If `Tx3` ends up being processed before `Tx1` (because of network delays, or a node picks `Tx3` first), then `Tx3` will execute, but `Tx1` and `Tx2` will fail, because they have smaller nonce!

One way to mitigate this is to sign each transaction with a different key. Adding multiple full access keys to the NEAR account used for relaying (up to 20 keys can make a significant difference) will help.

<details>
<summary> Adding keys </summary>

```js
const keyPair = nearAPI.KeyPair.fromRandom("ed25519");

const receipt = await account.addKey(keyPair.getPublicKey().toString())
```

After saving these keys, its possible to rotate the private keys randomly when instantiating accounts before relaying ensuring you won't create a nonce collision.

</details>

### Gating the relayer

In most production applications it's expected that you want to be able to gate the relayer to only be used in certain cases.
This can be easily accomplished by specifying constraints inside the `SignedDelegate.delegateAction` object.

```typescript
export declare class DelegateAction extends Assignable {
    senderId: string;
    receiverId: string;
    actions: Array<Action>;
    nonce: BN;
    maxBlockHeight: BN;
    publicKey: PublicKey;
}
```

You can, for example, gate by some particular user or contract:

```typescript
  const serializedTx: Buffer = req.body;
  const deserializedTx: SignedDelegate = deserialize(SCHEMA.SignedDelegate, Buffer.from(serializedTx)) as SignedDelegate;
  const relayerAccount: Account = await getAccount(NETWORK_ID, RELAYER_ID, RELAYER_PRIVATE_KEY);
  const delegateAction = deserializedTx?.delegateAction

  if(delegateAction.senderId == 'someUserId' || delegateAction.receiverId == 'someContractId' ){
       const receipt = await relayerAccount.signAndSendTransaction({
       actions: [actionCreators.signedDelegate(deserializedTx)],
       receiverId: deserializedTx.delegateAction.senderId
  });
  }
```

Other examples could be looking into the actions and seeing if there is deposit or gas and limiting them, gating by particular smart contract methods or even args.

You can decode the args using:

```
JSON.parse(Buffer.from(args_base64 || "", "base64").toString())
```

---

## Rust Relayer Server

The open-source Rust [reference implementation of a Relayer server](https://github.com/near/pagoda-relayer-rs/) offers the following features:

:::info
Features can be combined as needed. Use of one feature does not preclude the use of any other feature unless specified.
:::

1. Sign and send Meta Transactions to the RPC to cover the gas costs of end users while allowing them to maintain custody of their funds and approve transactions (`/relay`, `/send_meta_tx`, `/send_meta_tx_async`, `/send_meta_tx_nopoll`)
2. Sign Meta Transactions returning a Signed Meta Transaction to be sent to the RPC later - (`/sign_meta_tx`, `/sign_meta_tx_no_filter`)
3. Only pay for users interacting with certain contracts by whitelisting contracts addresses (`whitelisted_contracts` in `config.toml`)
4. Specify gas cost allowances for all accounts (`/update_all_allowances`) or on a per-user account basis (`/create_account_atomic`, `/register_account`, `/update_allowance`) and keep track of allowances (`/get_allowance`)
5. Specify the accounts for which the relayer will cover gas fees (`whitelisted_delegate_action_receiver_ids` in `config.toml`)
6. Only allow users to register if they have a unique Oauth Token (`/create_account_atomic`, `/register_account`)
7. Relayer Key Rotation: `keys_filenames` in `config.toml`
8. Integrate with [FastAuth SDK](fastauth-sdk.md)
9. Mix and Match configuration options

:::tip
Check the [Use cases section](#use-cases) for example configuration files corresponding to different usage scenarios.
:::

### Basic Setup

You can follow these steps to set up your local Relayer server development environment:

1. [Install Rust for NEAR Development](../2.build/2.smart-contracts/quickstart.md#prerequisites)
2. If you don't have a NEAR account, [create one](../1.concepts/protocol/account-model.md)
3. With the account from step 2, create a JSON file in this directory in the format
   ```js
   [{"account_id":"example.testnet","public_key":"ed25519:98GtfFzez3opomVpwa7i4m3nptHtc7Ha514XHMWszLtQ","private_key":"ed25519:YWuyKVQHE3rJQYRC3pRGV56o1qEtA1PnMYPDEtroc5kX4A4mWrJwF7XkzGe7JWNMABbtY4XFDBJEzgLyfPkwpzC"}]
   ```
   using a [Full Access Key](../1.concepts/protocol/access-keys.md#full-access-keys) from an account that has enough NEAR to cover the gas costs of transactions your server will be relaying. Usually, this will be a copy of the json file found in the `.near-credentials` directory.
4. Update values in `config.toml`
5. Open up the `port` from `config.toml` in your machine's network settings
6. Run the server using `cargo run`.
   > **(OPTIONAL)** To run with logs (tracing) enabled run `RUST_LOG=tower_http=debug cargo run`

:::info Optional setup

If you're integrating with [FastAuth](fastauth-sdk.md) make sure to enable feature flags:
```
cargo build --features fastauth_features,shared_storage
```
If you're using shared storage, make sure to enable feature flags:
```
cargo build --features shared_storage
```

:::

### Redis Setup

:::tip
This is only needed if you intend to use whitelisting, allowances, and OAuth functionality.
:::

1. [Install Redis](https://redis.io/docs/latest/get-started/).
   > Steps 2 & 3 assume Redis was installed on machine instead of a Docker setup. If you're connecting to a Redis instance running in GCP, follow the above steps to connect to a VM that will forward requests from your local relayer server to [Redis running in GCP](https://cloud.google.com/memorystore/docs/redis/connect-redis-instance#connecting_from_a_local_machine_with_port_forwarding)
2. Run `redis-server --bind 127.0.0.1 --port 6379` - make sure the port matches the `redis_url` in the `config.toml`.
3. Run `redis-cli -h 127.0.0.1 -p 6379`


### Advanced setup

- [Multiple Key Generation](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#multiple-key-generation---optional-but-recommended-for-high-throughput-to-prevent-nonce-race-conditions): this is optional, but recommended for high throughput to prevent nonce race conditions. Check
- [Docker Deployment](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#docker-deployment): instructions to deploy with Docker
- [Cloud Deployment](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#cloud-deployment): instructions to deploy on Cloud providers

### API Specifications

You can find the complete Relayer server API specification on the [GitHub repository](https://github.com/near/pagoda-relayer-rs/tree/main?tab=readme-ov-file#api-spec-).

### Use cases

The [examples folder](https://github.com/near/pagoda-relayer-rs/tree/main/examples) on the GitHub repository contains example configuration files corresponding to different use cases.

:::info
These files are for reference only and you should update the `config.toml` values before using it on your development environment.
:::

#### No filters

This is a config for a relayer that covers gas for all user transactions to all contracts with no filters. To prevent abuse, this should only be used if there's only a secure backend calling the relayer
- [`no_filters.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/no_filters.toml)

#### Basic whitelist

This is a configuration for a basic relayer that covers gas for user transactions to interact with a whitelisted set of contracts
- [`basic_whitelist.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/basic_whitelist.toml)

#### Redis

This is a configuration for a relayer that covers gas for user transactions up to a allowance specified in Redis to interact with a whitelisted set of contracts.
- Allowances are on a per-account id basis and on signup (account creation in Redis and on-chain) an OAuth token is required to help with sybil resistance
- [`redis.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/redis.toml)

#### FastAuth

:::info Closed access beta

[FastAuth](fastauth-sdk.md) is currently in a private beta stage. If you want to try it out during this early development stage, please [contact us on Telegram](https://t.me/neardev).

:::

This is a configuration for use if you intend to integrate with [FastAuth SDK](fastauth-sdk.md)
- It covers gas for user transactions up to a allowance specified in Redis to interact with a whitelisted set of contracts.
- Allowances are on a per-account id basis and on signup (account creation in Redis and on-chain) an OAuth token is required to help with sybil resistance
- This also makes use of a shared storage functionality on the Near Social DB contract
- and a whitelisted sender (`whitelisted_delegate_action_receiver_ids`)
- [`fastauth.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/fastauth.toml)

#### Pay with fungible tokens

This is a configuration for a relayer that ensures there's FTs sent to a burn address used to cover the equivalent amount of gas for user transactions to interact with a whitelisted set of contracts
- [`pay_with_ft.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/pay_with_ft.toml)

#### Whitelist senders

This is a config for a relayer that covers gas for a whitelisted set of users' transactions to interact with a whitelisted set of contracts
- [`whitelist_senders.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/whitelist_senders.toml) (`whitelisted_delegate_action_receiver_ids`)

#### Shared storage

This is a configuration for a relayer that covers BOTH gas AND storage fees for user transactions to interact with a whitelisted set of contracts

- be sure to include shared storage logic based on [`shared_storage.rs`](https://github.com/NearSocial/social-db/blob/master/contract/src/shared_storage.rs) in your contract that is being whitelisted
- [`shared_storage.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/shared_storage.toml)

#### Exchange withdraw

This is a configuration for a relayer where an exchange running the relayer covers user withdraw fees when they are withdrawing stablecoins on NEAR (e.g., `USDT` or `USDC`)

- [`exchange_withdraw.toml`](https://github.com/near/pagoda-relayer-rs/blob/main/examples/configs/exchange_withdraw.toml)


 This is the content for the doc docs/chain-abstraction/meta-tx.md 

 ---
id: meta-transactions
title: Meta Transactions
sidebar_label: NEP-366
---

[NEP-366](https://github.com/near/NEPs/pull/366) introduced the concept of meta
transactions to Near Protocol. This feature allows users to execute transactions
on NEAR without owning any gas or tokens. In order to enable this, users
construct and sign transactions off-chain. A third party (the relayer) is used
to cover the fees of submitting and executing the transaction.

---

## Overview

![Flow chart of meta
transactions](https://raw.githubusercontent.com/near/NEPs/003e589e6aba24fc70dd91c9cf7ef0007ca50735/neps/assets/nep-0366/NEP-DelegateAction.png)
_Credits for the diagram go to the NEP authors Alexander Fadeev and Egor
Uleyskiy._

The graphic shows an example use case for meta transactions. Alice owns an
amount of the fungible token `$FT`. She wants to transfer some to John. To do
that, she needs to call `ft_transfer("john", 10)` on an account named `FT`.

The problem is, Alice has no NEAR tokens. She only has a NEAR account that
someone else funded for her and she owns the private keys. She could create a
signed transaction that would make the `ft_transfer("john", 10)` call. But
validator nodes will not accept it, because she does not have the necessary Near
token balance to purchase the gas.

With meta transactions, Alice can create a `DelegateAction`, which is very
similar to a transaction. It also contains a list of actions to execute and a
single receiver for those actions. She signs the `DelegateAction` and forwards
it (off-chain) to a relayer. The relayer wraps it in a transaction, of which the
relayer is the signer and therefore pays the gas costs. If the inner actions
have an attached token balance, this is also paid for by the relayer.

On chain, the `SignedDelegateAction` inside the transaction is converted to an
action receipt with the same `SignedDelegateAction` on the relayer's shard. The
receipt is forwarded to the account from `Alice`, which will unpacked the
`SignedDelegateAction` and verify that it is signed by Alice with a valid Nonce,
etc. If all checks are successful, a new action receipt with the inner actions
as body is sent to `FT`. There, the `ft_transfer` call finally executes.

---

## Relayer

Meta transactions only work with a [relayer](relayers.md), an off-chain service. Think of it as a server that accepts a `SignedDelegateAction`, does some checks on them and eventually forwards it inside a transaction to the network.

A relayer may choose to offer their service for free but that's not going to be
financially viable long-term. But they could easily have the user pay using
other means, outside of Near blockchain. And with some tricks, it can even be
paid using fungible tokens on Near.

In the example visualized above, the payment is done using $FT. Together with
the transfer to John, Alice also adds an action to pay 0.1 $FT to the relayer.
The relayer checks the content of the `SignedDelegateAction` and only processes
it if this payment is included as the first action. In this way, the relayer
will be paid in the same transaction as John.

:::warning Keep in mind
The payment to the relayer is still not guaranteed. It could be that
Alice does not have sufficient `$FT` and the transfer fails. To mitigate, the
relayer should check the `$FT` balance of Alice first.
:::

Unfortunately, this still does not guarantee that the balance will be high
enough once the meta transaction executes. The relayer could waste NEAR gas
without compensation if Alice somehow reduces her $FT balance in just the right
moment. Some level of trust between the relayer and its user is therefore
required.

---

## Limitations

### Single receiver

A meta transaction, like a normal transaction, can only have one receiver. It's
possible to chain additional receipts afterwards. But crucially, there is no
atomicity guarantee and no roll-back mechanism.

<hr class="subsection" />

### Accounts must be initialized

Any transaction, including meta transactions, must use NONCEs to avoid replay
attacks. The NONCE must be chosen by Alice and compared to a NONCE stored on
chain. This NONCE is stored on the access key information that gets initialized
when creating an account.

---

## Constraints on the actions inside a meta transaction

A transaction is only allowed to contain one single delegate action. Nested
delegate actions are disallowed and so are delegate actions next to each other
in the same receipt.

---

## Gas costs for meta transactions

Meta transactions challenge the traditional ways of charging gas for actions.
Let's assume Alice uses a relayer to
execute actions with Bob as the receiver.

1. The relayer purchases the gas for all inner actions, plus the gas for the
   delegate action wrapping them.
2. The cost of sending the inner actions and the delegate action from the
   relayer to Alice's shard will be burned immediately. The condition `relayer
   == Alice` determines which action `SEND` cost is taken (`sir` or `not_sir`).
   Let's call this `SEND(1)`.
3. On Alice's shard, the delegate action is executed, thus the `EXEC` gas cost
   for it is burned. Alice sends the inner actions to Bob's shard. Therefore, we
   burn the `SEND` fee again. This time based on `Alice == Bob` to figure out
   `sir` or `not_sir`. Let's call this `SEND(2)`.
4. On Bob's shard, we execute all inner actions and burn their `EXEC` cost.

Each of these steps should make sense and not be too surprising. But the
consequence is that the implicit costs paid at the relayer's shard are
`SEND(1)` + `SEND(2)` + `EXEC` for all inner actions plus `SEND(1)` + `EXEC` for
the delegate action. This might be surprising but hopefully with this
explanation it makes sense now!

---

## Gas refunds in meta transactions

Gas refund receipts work exactly like for normal transaction. At every step, the
difference between the pessimistic gas price and the actual gas price at that
height is computed and refunded. At the end of the last step, additionally all
remaining gas is also refunded at the original purchasing price. The gas refunds
go to the signer of the original transaction, in this case the relayer. This is
only fair, since the relayer also paid for it.

---

## Balance refunds in meta transactions

Unlike gas refunds, the protocol sends balance refunds to the predecessor
(a.k.a. sender) of the receipt. This makes sense, as we deposit the attached
balance to the receiver, who has to explicitly reattach a new balance to new
receipts they might spawn.

In the world of meta transactions, this assumption is also challenged. If an
inner action requires an attached balance (for example a transfer action) then
this balance is taken from the relayer.

The relayer can see what the cost will be before submitting the meta transaction
and agrees to pay for it, so nothing wrong so far. But what if the transaction
fails execution on Bob's shard? At this point, the predecessor is `Alice` and
therefore she receives the token balance refunded, not the relayer. This is
something relayer implementations must be aware of since there is a financial
incentive for Alice to submit meta transactions that have high balances attached
but will fail on Bob's shard.

---

## Function Call Access Keys in Meta Transactions

[Function Call Access Keys](../1.concepts/protocol/access-keys.md#function-call-keys)
are limited to signing transactions for specific methods on a specific contract.


Additionally, they can have an allowance, which limits the amount of tokens that
can be spent on GAS fees. This limit however can be circumvented by using meta
transactions.

When a `DelegateAction` is processed in the network, the access key of the sender
is checked against the receiver and the methods called. If the access key is allowed to
make the call, the action is executed.

The allowance however is not checked, as all costs have been covered by the
relayer. Hence, the action will be executed even if the allowance is insufficient
to cover the costs.


 This is the content for the doc docs/chain-abstraction/nft-keys.md 

 ---
id: nft-chain-keys
title: NFT Chain Keys Smart Contract
sidebar_label: NFT Chain Keys Contract
---

The NFT Chain Keys smart contract makes the ownership of remote accounts both provable and transferrable. This new paradigm allows you to create new end-user experiences that leverage provable and transferrable remote accounts as a core primitive.

## Contract overview

The [MPC Account Recovery smart contract](https://github.com/near/mpc-recovery) provides a [`sign`](https://github.com/near/mpc-recovery#sign) method that accepts a `path` parameter. This allows one predecessor account to have access to an effectively unlimited number of MPC keys.

The NFT Chain Keys contract takes advantage of this property and allows secure transfers of MPC keys between users, using the [NEP-171 NFT contract standard](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core).
The contract also implements new functionality to enable chain key management features.

:::info

The essence of Multi-Party Computation (MPC) is to enable independent parties to perform shared computations on private information without revealing secrets to each other.

:::

### Standards

Besides the NEP-171 contract standard, the NFT Chain Keys contract complies with a full suite of NEP standards:

- [NEP-145: Storage Management](https://nomicon.io/Standards/StorageManagement)
- [NEP-171: NFT Core](https://nomicon.io/Standards/Tokens/NonFungibleToken/Core)
- [NEP-177: Metadata](https://nomicon.io/Standards/Tokens/NonFungibleToken/Metadata)
- [NEP-178: Approval Management](https://nomicon.io/Standards/Tokens/NonFungibleToken/ApprovalManagement)
- [NEP-181: Enumeration](https://nomicon.io/Standards/Tokens/NonFungibleToken/Enumeration)

## Usage

Please refer to the smart contract [GitHub documentation](https://github.com/near/multichain-gas-station-contract/blob/master/nft_key/README.md) for usage information:

- [Creating new key tokens](https://github.com/near/multichain-gas-station-contract/tree/master/nft_key#creating-new-key-tokens): mint unlimited new NFT chain keys, as long as the account has sufficient storage.
- [Issuing signatures](https://github.com/near/multichain-gas-station-contract/tree/master/nft_key#issuing-signatures): generate new signatures based on a submitted payload.
- [Approvals](https://github.com/near/multichain-gas-station-contract/tree/master/nft_key#approvals): implement a separate set of approval management functions for using NFTs, which operate similarly to NEP-178.

:::tip testnet contract

If you want to try things out, this smart contract is available on `nft.kagi.testnet`.

:::

---

## Use Cases for NFT Keys

:::info Disclaimer
The ideas presented in this section are just initial concepts, and shouldn‚Äôt be considered as fully fledged solutions.
:::

### Remote Account Marketplace

NFT Keys enable users to buy, sell, and trade remote accounts within a marketplace-style application.
For instance, _Alice_, possessing a set of remote accounts with value and history, can mint an NFT key and list these accounts for sale on the marketplace.
Potential buyers, like _Bob_, can browse the value of _Alice‚Äôs_ accounts and choose to make a purchase.
If _Bob_ decides to proceed, they would simply need to acquire ownership of the original NFT key from _Alice_ in exchange for payment, such as in `$NEAR`.
Once the transaction is completed, ownership of the accounts transfers to _Bob_.

### Bridgeless Multi-Chain DEX

You can create a Multi-chain DEX without bridging by combining Chain Signatures with NFT Keys.
Users wishing to swap asset `$A` for asset `$B` would initiate the swap on the bridgeless DEX.
Supported by liquidity providers (Automated Market Makers) across multiple chains, the DEX facilitates these swaps.
Here's how it works:

- A user proposes the swap, specifying asset `$A` in remote `account X` for asset `$B` in remote `account Y`.
- The liquidity provider receives asset `$A` from the user and sends the equivalent amount of asset `$B` to a newly created remote `account Y`, along with a minted NFT key.
- The NFT key is then sent to the user to complete the swap.

Although liquidity providers still need to leverage bridging to settle assets between different pools, users of this exchange type are exposed to reduced bridge risk.


 This is the content for the doc docs/chain-abstraction/omnibridge/how-it-works.md 

 ---
id: how-it-works
sidebar_label: How It Works
title: How Omni Bridge Works
---

## Background

The journey toward truly trustless cross-chain communication took a significant leap forward when the NEAR team [created the first trustless bridge with Ethereum](https://near.org/blog/the-rainbow-bridge-is-live) (Rainbow Bridge). This pioneering achievement demonstrated that completely trustless cross-chain communication was possible, marking a crucial step toward the vision of chain abstraction. However, this approach relied on implementing a NEAR light client directly on Ethereum - essentially requiring Ethereum to understand and verify NEAR's complex blockchain rules.

Omni Bridge introduces a more elegant solution using Chain Signatures. Instead of running light clients on each destination chain, it leverages Chain Signature's MPC Service to enable secure cross-chain message verification without the overhead of light client verification. This new approach reduces verification times from hours to minutes while significantly reducing gas costs across all supported chains.

### Issues with Light Clients

A light client is a smart contract that lets one blockchain verify events happening on another blockchain. In Rainbow Bridge's case, the Ethereum light client needs to track NEAR's blocks, verify its validators' signatures, and confirm transactions. This comes with major technical challenges: it requires storing two weeks of Ethereum block data, maintaining an updated list of NEAR validators and their stakes, and most crucially, verifying NEAR's ED25519 signatures - a process Ethereum wasn't built for. This verification is computationally expensive, making the whole process slow, costly, and ultimately a major bottleneck.

For example, with Rainbow Bridge, transactions from NEAR to Ethereum take between 4 and 8 hours due to the 4-hour challenge period and block submission intervals driven by Ethereum's high gas costs. More importantly, this approach becomes increasingly impractical when connecting to multiple chains, as each chain would require its own light client implementation. Some chains, such as Bitcoin, don't even support smart contracts, making it technically impossible to implement a NEAR light client.

While we still need to support light clients of different networks on NEAR (which is significantly easier to implement), a different approach is needed for verifying NEAR state on foreign chains.

### Token Standards and Cross-Chain Communication

Before exploring how Chain Signatures solves these issues, it's important to understand how tokens work on NEAR. [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core), NEAR's fungible token standard, has a key feature that sets it apart from Ethereum's ERC-20: built-in composability through transfer-and-call functionality.

When a token transfer happens on NEAR using `ft_transfer_call`, the token contract first transfers the tokens and then automatically calls the specified `ft_on_transfer` method on the receiver contract. While these operations happen in sequence within the same transaction, the receiver contract has the ability to reject the transfer, causing the tokens to be refunded. This atomic behavior ensures the integrity and safety of bridge operations by preventing partial execution states.

For more information see [Fungible Tokens](../../2.build/5.primitives/ft.md).

## Enter Chain Signatures

Instead of maintaining complex light clients on destination chains, Chain Signatures introduces a fundamentally different approach based on three core components:

1. **Deterministic Address Derivation** - Every NEAR account can mathematically derive addresses on other chains through derivation paths. This isn't just a mapping - it's a cryptographic derivation that ensures the same NEAR account always controls the same set of addresses across all supported chains.

2. **Bridge Smart Contract** - A central contract on NEAR coordinates with the MPC network to generate secure signatures for cross-chain transactions. This contract handles the token locking and requesting of signatures for outbound transfers

3. **MPC Service** - A decentralized network of nodes that jointly sign transactions without ever reconstructing a full private key. The security comes from threshold cryptography - no single node or small group of nodes can create valid signatures alone.

## Putting It All Together

As we've learned, Chain Signatures fundamentally changes the verification mechanism for cross-chain messages. Here's what this means in practice:

The light client approach requires destination chains to verify ED25519 signatures from NEAR validators. Chain Signatures replaces this with a single MPC signature verification. Destination chains only need to verify one signature using their native signature verification schemes - typically ECDSA for EVM chains.

NEP-141's transaction guarantees handle the security of token locking. A transfer creates two operations within a **single transaction**:
1. Lock tokens and record the transfer state
2. Request MPC signature for the destination chain

The Locker contract requests signatures from the MPC network, which then generates signatures for valid transfer requests. This replaces the need for challenge periods - the security derives from the MPC threshold guarantees rather than optimistic assumptions.

Adding new chains becomes a matter of implementing three standard components:
1. Chain-specific address derivation
2. MPC signature verification (or transaction signing for chains like Bitcoin)
3. Bridge contract deployment
4. Communication path for transfers back to NEAR (currently using Wormhole for newer chains)

While we still need light clients on NEAR for receiving transfers from other chains, this approach makes it feasible to support a wider range of chains without implementing complex verification logic on each destination chain.


```mermaid
sequenceDiagram
   title: High-Level Overview of NEAR to External Chain Transfer
   participant User as User Account
   participant Bridge as Omni Bridge <br> Locker Contract
   participant MPC as MPC Service <br> (off-chain)
   participant Other as Destination Chain

   note over User, Bridge: NEAR Blockchain
 
    User->>Bridge:1. Submits transfer <br> token request
    Bridge->>Bridge: 2. Locks tokens
    Bridge->>MPC: 3. Request signature
    MPC->>MPC: 3. Signs message
    MPC-->>Bridge: 4. Return signed msg
    Bridge->>Other: 5. Broadcast signed msg to destination chain
    Other->>Other: 4. Mint/release tokens
```

To get started building with Omni Bridge, see:

- [Bridge SDK JS](https://github.com/near-one/bridge-sdk-js) Omni Bridge implementation in JavaScript
- [Bridge SDK Rust](https://github.com/near-one/bridge-sdk-rs) Omni Bridge implementation in Rust

 This is the content for the doc docs/chain-abstraction/omnibridge/implementation.md 

 ---
id: implementation-details
sidebar_label: Implementation Details
title: Implementation Details
---

The Omni Bridge is a sophisticated cross-chain bridge infrastructure that enables secure and efficient token transfers between NEAR Protocol and various other blockchain networks. This document provides a detailed technical overview of the bridge's architecture, covering its core components, security model, and operational mechanisms. By leveraging a combination of Multi-Party Computation (MPC), chain-specific light clients, and a permissionless relayer network, the bridge achieves a robust balance of security, decentralization, and user experience.

For referece code implementations, see:

- [Bridge SDK JS](https://github.com/near-one/bridge-sdk-js) Omni Bridge implementation in JavaScript
- [Bridge SDK Rust](https://github.com/near-one/bridge-sdk-rs) Omni Bridge implementation in Rust

---

## The Bridge Token Factory Pattern

At the core of Omni Bridge is the Bridge Token Factory contract on NEAR that serves as both a token factory and custodian. This unified contract handles both native tokens from the source chain and bridged tokens created by the factory itself. This design simplifies maintenance and reduces complexity compared to having separate contracts.

The contract has several key responsibilities:

### For bridged tokens (tokens originally from other chains):

* Deploys new token contracts when bridging tokens for the first time
* Mints tokens when receiving valid transfer messages
* Burns tokens when initiating transfers back to the origin chain

### For native NEAR tokens:

* Acts as a custodian by locking tokens during transfers
* Releases tokens when receiving valid transfer messages
* Manages token operations through the NEP-141 standard

### Transfer Lifecycle

A transfer's lifecycle includes several states, shown below for a NEAR to Ethereum transfer of native NEAR tokens:

```mermaid
stateDiagram-v2
    [*] --> Initiated: User calls transfer
    Initiated --> Locked: Tokens locked in bridge
    Locked --> Signed: MPC signature generated
    Signed --> Completed: Tokens released on Ethereum
    Completed --> [*]
```

---

## Message Signing and Verification

For most chains, the bridge uses a payload-based message signing system (with Bitcoin being a notable exception requiring full transaction signing).

### Message Types

The bridge supports several types of signed messages:

* **Transfer Messages**
  * Initiation messages
  * Finalization messages
* **Token Messages**
  * Deployment messages
  * Metadata update messages

### Payload Structure

Messages are encoded using Borsh serialization and contain:

| Component | Description |
|-----------|-------------|
| Message Type | Identifier for the message category |
| Chain Info | Chain IDs and relevant addresses |
| Operation Data | Amounts, recipients, fees, etc. |

### Signature Process

1. NEAR contract creates and stores the message payload
2. MPC network observers detect valid payloads
3. Nodes jointly sign the payload
4. Signature is verified on destination chains

:::tip Key Benefits
* Clearer message intent through structured payloads
* More efficient signature verification on destination chains
* Standardized message format across chains
:::

## Transaction Flow: NEAR to Other Chains

Here's an overview of how transfers are processed from NEAR to different destination chains:

```mermaid
flowchart TD
    Start[User Initiates Transfer] --> TokenCheck{Token Type?}
    
    TokenCheck -->|NEAR Native| Lock[Lock in Bridge Contract]
    TokenCheck -->|Bridged Token| Burn[Burn Token]
    
    Lock --> MPCSign[Request MPC Signature]
    Burn --> MPCSign
    
    MPCSign --> Chain{Destination Chain}
    
    Chain -->|Bitcoin| BTCBridge[Bitcoin Script]
    Chain -->|Other| OtherBridge[Verify MPC Signature]
    
    BTCBridge --> Mint[Mint/Release Tokens]
    OtherBridge --> Mint
    
    Mint --> End[Transfer Complete]
```

### Transfer Process

Let's follow what happens when a user wants to transfer tokens from NEAR to another chain:

#### 1. Initiation

The user starts by calling the token contract with:

* Amount to transfer
* Destination chain and address
* Fee preferences (whether to pay fees in the token being transferred or in NEAR)
* Fees are minted on NEAR side for relayers

#### 2. Token Lock

The token contract transfers tokens to the locker contract, which:

* Validates the transfer message
* Assigns a unique nonce
* Records the pending transfer
* Emits a transfer event

#### 3. MPC Signing

The bridge contract:

* Requests signature generation
* MPC nodes jointly generate and aggregate signature
* Maintains threshold security throughout process

#### 4. Destination Chain

The Bridge Token Factory on the destination chain:

* Verifies the MPC signature
* Mints equivalent tokens

---

## Transaction Flow: Other Chains to NEAR

The reverse flow varies based on the source chain:

### 1. Ethereum

Uses NEAR light client for maximum security:

* Burning tokens on source chain
* Submitting proof to NEAR
* Verifying proof through light client
* Releasing tokens to recipient

### 2. Solana

Currently using Wormhole for:

* Message passing between chains
* Transaction verification
* Integration with NEAR token factory system

### 3. Other Chains

Initially using Wormhole for:

* Message passing between chains
* Transaction verification
* Will transition to Chain Signatures

---

## Security Model

### Trust Assumptions

Omni Bridge requires different trust assumptions depending on the chain connection:

#### For Chain Signatures:

* NEAR Protocol security (2/3+ honest validators)
* MPC network security (2/3+ honest nodes)
* No single entity controls enough MPC nodes to forge signatures
* Correct implementation of the signing protocol

#### For Ethereum/Bitcoin connections:

* Light client security
* Finality assumptions (e.g., sufficient block confirmations)
* Chain-specific consensus assumptions

#### For interim Wormhole connections:

* Wormhole Guardian network security
* We acknowledge this is a temporary trust assumption until Chain Signatures integration is complete

---

## Relayer Network

Relayers are permissionless infrastructure operators who monitor for bridge events and execute cross-chain transactions. Unlike many bridge designs, our relayers cannot:

* Forge transfers
* Steal funds
* Censor transactions (users can self-relay)
* Front-run transactions for profit
* Do not create additional security assumptions

:::info
The relayer's role is purely operational - executing valid transfers and collecting predetermined fees. Multiple relayers can operate simultaneously, creating competition for faster execution and lower fees.
:::

---

## Fee Structure

Bridge fees are unified and processed on NEAR, with components including:

### Execution Fees

* Destination chain gas costs
* Source chain storage costs
* Relayer operational costs
* MPC signing costs

### Fee Payment Options

* Native tokens of source chain
* The token being transferred 

:::note
Fees dynamically adjust based on gas prices across different chains to ensure reliable execution.
:::

### Design Goals

The fee structure is designed to:

* Ensure relayer economic viability
* Prevent economic attacks
* Allow fee market competition
* Cover worst-case execution costs

:::tip
Users can bypass relayers entirely by executing their own transfers, paying only the necessary gas fees on each chain. This creates a natural ceiling on relayer fees.
:::



 This is the content for the doc docs/chain-abstraction/omnibridge/overview.md 

 ---
id: overview
sidebar_label: Overview
title: Omni Bridge Overview
---

The [Omni Bridge](https://github.com/Near-One/omni-bridge) is a multi-chain asset bridge that facilitates secure and efficient asset transfers between different blockchain networks. It solves key challenges in cross-chain communication by leveraging [Chain Signatures](https://docs.near.org/concepts/abstraction/chain-signatures) and its decentralized [Multi-Party Computation (MPC) service](https://docs.near.org/concepts/abstraction/chain-signatures#multi-party-computation-service) to enable trustless cross-chain asset transfers. 

:::tip
To learn more see [How Omni Bridge Works](./how-it-works.md).
:::

## Supported Chains

Omni Bridge launches with a hybrid architecture, utilizing different verification methods based on chain-specific requirements and technical constraints. This approach allows us to support multiple chains from day one while progressively transitioning to full Chain Signatures integration.

Initial launch includes:

- **Ethereum** - _(Light client + Chain Signatures)_
- **Bitcoin** - _(Light client + Chain Signatures)_
- **Solana** - _(Currently Wormhole, transitioning to Chain Signatures)_
- **Base** - _(Currently Wormhole, transitioning to Chain Signatures)_
- **Arbitrum** - _(Currently Wormhole, transitioning to Chain Signatures)_

:::info
See [Omni Bridge Roadmap](./roadmap.md) for more details.
:::

## Resources

- [Near-One/omni-bridge](https://github.com/Near-One/omni-bridge) - Omni Bridge repository
- [Near-One/bridge-sdk-js](https://github.com/Near-One/bridge-sdk-js) - JavaScript SDK
- [Near-One/bridge-sdk-rs](https://github.com/Near-One/bridge-sdk-rs) - Rust SDK



 This is the content for the doc docs/chain-abstraction/omnibridge/roadmap.md 

 ---
id: roadmap
sidebar_label: Roadmap
title: Omni Bridge Roadmap
---

Omni Bridge launches with a hybrid architecture, utilizing different verification methods based on chain-specific requirements and technical constraints. This approach allows us to support multiple chains from day one while progressively transitioning to full Chain Signatures integration.

## Supported Chains
Initial launch includes:

- **Ethereum** - _(Light client + Chain Signatures)_
- **Bitcoin** - _(Light client + Chain Signatures)_
- **Solana** - _(Currently Wormhole, transitioning to Chain Signatures)_
- **Base** - _(Currently Wormhole, transitioning to Chain Signatures)_
- **Arbitrum** - _(Currently Wormhole, transitioning to Chain Signatures)_

## Migration Path

1. **Phase 1: Hybrid Operation**
- ETH/BTC: Light client verification
- Other chains: Wormhole message passing
- All NEAR outbound: Chain Signatures

During this phase, cross-chain messages follow different verification paths depending on direction and chain. NEAR outbound transfers already utilize Chain Signatures, while inbound transfers vary by source chain.

2. **Phase 2: Full Chain Signatures**
- Progressive transition of all chains
- Removal of Wormhole dependency
- Enhanced decentralization

Phase 2 represents our move to a unified verification model. Each chain will transition to Chain Signatures verification as implementation and audits complete, gradually removing the hybrid architecture's complexity.

## Future Development
1. **Protocol Improvements**
- Enhanced fee mechanisms
- Cross-chain contract calls
- New token standards support

Beyond basic asset transfers, we're expanding the bridge's capabilities. Enhanced fee mechanisms will better handle gas price volatility, while cross-chain contract calls will enable more complex interactions.

2. **Infrastructure**
- Expanded relayer network
- Improved monitoring tools
- Enhanced developer tooling

Infrastructure development focuses on reliability and usability. An expanded relayer network improves transfer speeds and reliability, while better monitoring and developer tools make integration and maintenance easier.

## Get Involved

### Areas for Contribution
- Chain integrations
- Performance optimization
- Security analysis
- Developer tools

- [Near-One/omni-bridge](https://github.com/Near-One/omni-bridge) - Omni Bridge repository
- [Near-One/bridge-sdk-js](https://github.com/Near-One/bridge-sdk-js) - JavaScript SDK
- [Near-One/bridge-sdk-rs](https://github.com/Near-One/bridge-sdk-rs) - Rust SDK

The code is open source and we welcome contributions from the community. Whether you're interested in adding support for new chains, optimizing performance, or building developer tools, there's room for meaningful contribution.

Bridge infrastructure is a fundamental component of a multi-chain future. Through Chain Signatures, we're creating a more efficient, secure, and scalable approach to cross-chain communication. Join us in building it.




 This is the content for the doc docs/chain-abstraction/relayers.md 

 ---
id: relayers
title: Relayers
---

A relayer is a simple web service that receives signed transactions from NEAR users, and relays them to the network while attaching tokens to sponsor their GAS expenses. This can be useful to create applications in which the users are not required to purchase NEAR in order to be able to transact. In this document we present a high-level overview on how relayers work. Please check the [build a relayer](meta-transactions.md) page if you want to learn how to build your own relayer.

---

## How it works

![relayer-overview](/docs/assets/welcome-pages/relayer-overview.png)

Relayers are a natural consequence of [Meta Transactions](meta-tx.md) ([NEP-366](https://github.com/near/NEPs/blob/master/neps/nep-0366.md)), a special type of transaction that can be best understood as an intent.

The user expresses: _"I want to do a specific action on chain"_ and signs this intent **off-chain**, but does not send it to the network. Instead, they send the intent to a `Relayer`, which wraps the message into an actual transaction, attaches the necessary funds, and sends it to the network.

<details>
<summary> Technical Details </summary>

Technically, the end user (client) creates a `SignedDelegateAction` that contains the data necessary to construct a `Transaction`, signs the `SignedDelegateAction` using their key, and send it to  the relayer service.

When the request is received, the relayer uses its own key to sign a `Transaction` using the fields in the `SignedDelegateAction` as input to create a `SignedTransaction`.

The `SignedTransaction` is then sent to the network via RPC call, and the result is sent back to the client. The `Transaction` is executed in such a way that the relayer pays the GAS fees, but all actions are executed as if the user had sent the transaction.
</details>

---

## Why use a Relayer?

There are multiple reasons to use a relayer:
1. Your users are new to NEAR and don't have any gas to cover transactions
2. Your users have an account on NEAR, but only have a Fungible Token Balance. They can now use the FT to pay for gas
3. As an enterprise or a large startup you want to seamlessly onboard your existing users onto NEAR without needing them to worry about gas costs and seed phrases
4. As an enterprise or large startup you have a user base that can generate large spikes of user activity that would congest the network. In this case, the relayer acts as a queue for low urgency transactions
5. In exchange for covering the gas fee costs, relayer operators can limit where users spend their assets while allowing users to have custody and ownership of their assets
6. Capital Efficiency: Without relayer if your business has 1M users they would have to be allocated 0.25 NEAR to cover their gas costs totalling 250k NEAR. However, only ~10% of the users would actually use the full allowance and a large amount of the 250k NEAR is just sitting there unused. So using the relayer, you can allocate 50k NEAR as a global pool of capital for your users, which can refilled on an as needed basis. 

 This is the content for the doc docs/chain-abstraction/wallet.md 

 ---
id: wallet
title: Wallet Chain Key Rules 
---

## Overview

In this article you'll find details on how to parse and present multichain transactions to the user so they can take an informed decision about their wallet's assets, while minimizing the number of times the user has to consent.
You'll also learn how to ensure that a signature on one chain is not used to take a meaningful action on another chain.

### Key derivation

When signing using [chain signatures](./chain-signatures/implementation.md) each account has an unlimited number of keys. Each key's public key is derived from the account name and the key extension which is an arbitrary string.

User's keys can be described as follow:

```
"david.near,"              A key with no extension
"david.near, "             A key with an extension of " "
"david.near,cold_wallet"   A key with an extension of "cold_wallet"
```

:::tip
If the keys aren't identical they have no relationship.
:::

### Ambiguous signatures

You're going to be potentially storing keys for users who hold assets on many chains. Different chains have different ways of serializing and signing transactions. Many chains take steps to ensure that their signatures are not valid signatures on other chains. EVM chains use `ChainID` to disambiguate signatures between different EVM chains. Dfinity uses a unique salt on the hash of the transaction.

Unfortunately, while this is a best practice, you can't guarantee that all chains do this. As such, a user could receive an innocent looking transaction on one chain that could be used to take a destructive action on another chain.

An apocryphal example:

```
Transaction: "7b73656e643a2022313030222c206e6f74652022227d"
Parsed SOL: claim free NFT
Parsed BTC: send 100 BTC to Attacker
```

The user would approve the `SOL` transaction but the attacker would also get the `BTC` transaction.

This can be solved by having unique keys for different chains. That way, even if an attacker makes you sign a transaction that is also valid in a foreign chain, no assets will be compromised.


## Serialization format

We're using the following format for our derivations paths.

```typescript
{
   chain: number, // SLIP-44 coin type unsigned integer
   domain: String, // The domain that owns this key
   meta: any, // Catch all data structure
}
```

This is encoded in canonical [JSON RFC 8785](https://www.rfc-editor.org/rfc/rfc8785).

:::info
If you are not using a field don't make it `null`, don't include the key instead.
:::

### User-defined fields

For user-defined fields, the `meta` field can include any data you like. 

:::tip
Do not add any extra fields at the top level, as that may clash with future versions of this specification. If needed, put them in the `meta` field instead.
:::

For example, a simple way of selecting alternate keys will be using an object with an `ID` field:

```typescript
{
    meta: {id: 10}, // Pick the tenth bitcoin key
    chain: 0,
}
```

### Examples

| Key | Description |
|-----|-------------|
| `{chain: 0, domain: "near.org"}` |  A bitcoin key used on `near.org` |
| `{chain: 0, meta: {id: 3}}`      |  Use the third bitcoin key |


## Example user flows

In the following examples, the messages are coming from the user's wallet frontend.

- [Using a domains bitcoin key](#using-a-domains-bitcoin-key)
- [Using a personal Bitcoin key](#using-a-personal-bitcoin-key)
- [Using a personal EVM key to sign a Binance transaction](#using-a-personal-evm-key-to-sign-a-binance-transaction)
- [Using an untyped domain key](#using-an-untyped-domain-key)
- [Using another domain's Bitcoin key](#using-another-domains-bitcoin-key)

:::tip
Wallet developers should follow this user flow format.
:::

### Using a domains bitcoin key

An application at `near.org` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,bitcoin,near.org,`.

```
Signed ‚úÖ
```

We sign the transaction without confirmation because the key is owned by `near.org`.

### Using a personal Bitcoin key

An application at `near.org` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,bitcoin,`.

```
near.org would like to run the following Bitcoin transaction:

Send 100 BTC
[Accept] [Reject]
```

The user must make an informed decision about whether this is an action they would like to take.

```
Signed ‚úÖ
```

### Using a personal EVM key to sign a Binance transaction

An application at `near.org` wants to sign the Binance Smart Chain transaction `Send 100 BNB, ChainID 56` using the key `david.near,evm,`. The wallet knows this is a BSC transaction because of the corresponding `ChainID` (56) and because the `evm` key is being used.

```
near.org would like to run the following Binance Smart Chain transaction:

Send 100 BNB
[Accept] [Reject]
```

The user must make an informed decision about whether this is an action they would like to take.

```
Signed ‚úÖ
```

### Using an untyped domain key

An application at `near.org` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,,near.org,`.

```
Signed ‚úÖ
```

While this is ill advised, it's still the domains key so the domain can still choose whether to sign something using it.

### Using another domains Bitcoin key

An application at `attacker.com` wants to sign the Bitcoin transaction `Send 100 BTC` using the key `david.near,bitcoin,near.org,`.

```
Attacker.com would like to sign a transaction using your credentials from near.org

Send 100 BTC

This is a suspicious transaction and likely not one you should accept
[Reject] [Accept (Are you sure!)]
```

The user must make an explicit decision to do something that is ill advised.

```
Signed ‚úÖ
```

The correct way for `attacker.com` to make this request is to somehow redirect the user to `near.org` and get the user to make a decision there.


 This is the content for the doc docs/chain-abstraction/what-is.md 

 ---
id: what-is
title: What is Chain Abstraction?
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import {CodeTabs, Language, Github} from "@site/src/components/codetabs";

![img](/docs/assets/welcome-pages/chain-abstraction-landing.png)

# What is Chain Abstraction?

Blockchain development today faces a critical challenge: users need to understand complex blockchain concepts, manage multiple wallets, and deal with different networks just to use basic applications. Chain abstraction solves this by making blockchain technology invisible to end users while preserving all of the underlying benefits.

## Why Chain Abstraction Matters

For **developers**, chain abstraction means:

- Building cross-chain applications without managing multiple blockchain integrations
- Focusing on application logic instead of blockchain complexity
- Reaching users regardless of their preferred blockchain network

For **users**, it means:

- Using blockchain applications as easily as traditional web apps
- No need to understand which blockchain they're interacting with or if they are even using one
- A seamless experience across different networks and tokens

:::info Example
Imagine building a digital art marketplace where users can purchase NFTs from different blockchains (Ethereum, Solana, etc.). Without chain abstraction, you'd need to:

- Implement multiple blockchain connections
- Handle different wallet types
- Manage cross-chain transfers
- Build complex UIs to explain blockchain concepts

With chain abstraction, both you and your users just focus on the core experience: browsing and trading art. All blockchain complexity is handled automatically behind the scenes.
:::

## Overview

NEAR's chain abstraction framework consists of three core technologies that work together to create seamless cross-chain experiences:

1. [**NEAR Intents**](#near-intents): A decentralized system where users express desired outcomes (like "swap Token A for Token B at the best price") without specifying technical details. A network of solvers then competes to fulfill these intents optimally, handling complex cross-chain operations behind the scenes.

2. [**Chain Signatures**](#chain-signatures): Enables NEAR accounts, including smart contracts, to sign and execute transactions on other blockchains (like Bitcoin or Ethereum), allowing cross-chain interactions.

3. [**OmniBridge**](#omnibridge): A multi-chain asset bridge that combines Chain Signatures with chain-specific verification methods for secure and efficient cross-chain transfers. Using a hybrid approach of MPC-based signatures and light clients, it significantly reduces verification times from hours to minutes while lowering gas costs across supported chains. The bridge serves as both a token factory and custodian, managing native and bridged tokens through a unified interface.

### NEAR Intents

[NEAR Intents](intents/overview.md) are a new transaction type that allows information, requests, assets, and actions to be exchanged between users, services, and AI agents.

This represents a paradigm shift in how users and AI agents interact with blockchain networks. Instead of directly executing complex transactions across multiple chains, users simply declare what they want to achieve, and the network determines how to make it happen.

Here's how it works:

1. **Users/Agents Submit Intents**: Express desired outcomes without specifying the technical details (e.g., "Get the best price for my Bitcoin across all DEXs and CEXs")
2. **Solver Network Competes**: A decentralized network of solvers (both AI agents and traditional market makers) compete to fulfill these intents optimally
3. **Cross-Chain Execution**: The best solution is automatically executed, potentially spanning multiple chains and services

:::info Example
Instead of a user having to:

1. Bridge assets between chains
2. Find the best trading venues
3. Execute multiple transactions
4. Handle different wallet requirements

They simply submit an intent: "Swap Token A for Token B at the best price"
The Intent Layer handles all complexity across Web2 and Web3 behind the scenes.
:::

For developers, the Intent Layer provides:

- A unified framework for building cross-chain applications
- Access to both AI agents and traditional solvers for transaction optimization
- Built-in liquidity aggregation across DeFi and CeFi
- Support for complex use cases beyond simple swaps, including:
  - Cross-chain stablecoin operations
  - DeFi programmability for non-smart contract assets
  - Account-based trading (AccountFi)
  - AI agent interactions and negotiations

:::info
NEAR Intents are designed to power both traditional DeFi operations and the emerging AI economy, creating a unified transaction framework for Web2 and Web3 interactions.
:::

### Chain Signatures

Chain Signatures enable NEAR accounts, including smart contracts, to sign and execute transactions across many blockchain protocols. By using [Multi-Party Computation (MPC)](chain-signatures.md#multi-party-computation-service), this technology allows a single NEAR account to control accounts and assets on external chains like Bitcoin, Ethereum, and Base.

Key benefits include:

- Single Account, Multi-Chain Operations: Manage multiple blockchain interactions from one NEAR account
- Reduced Development Overhead: Write smart contracts on NEAR that directly sign cross-chain transactions
- Secure Transaction Signing: Leverage decentralized MPC for trustless signature generation

For example, this enables dApps built on NEAR to interact with Bitcoin's UTXO model or Ethereum's account model, powering use cases like cross-chain DeFi protocols, atomic swaps, and NFT marketplaces.

:::tip
To learn more about Chain Signatures, the concepts, and how to implement it, check these articles:

- [What are Chain Signatures?](chain-signatures.md)
- [Getting started with Chain Signatures](chain-signatures/getting-started.md)
- [Implementing Chain Signatures](chain-signatures/implementation.md)

:::

### OmniBridge

The [OmniBridge](omnibridge/overview.md) is a multi-chain asset bridge that combines Chain Signatures with chain-specific verification methods to enable secure and efficient cross-chain asset transfers. It consists of three core components:

1. **Chain Signatures Integration**:
   - Enables NEAR smart contracts to generate and control accounts on other blockchains
   - Allows direct signing and execution of transactions on external chains
   - Provides secure message signing through MPC network

2. **Verification Layer**:
   - Hybrid verification approach combining MPC signatures and light clients
   - Chain-specific verification methods based on target chain requirements
   - Significantly reduces verification times from hours to minutes
   - Lowers gas costs across all supported chains

3. **Bridge Token Factory**:
   - Unified contract serving as both token factory and custodian
   - Manages both native and bridged tokens through NEP-141 standard
   - Handles token locking, minting, and burning operations
   - Supports permissionless relayer network for efficient processing

This architecture creates a robust bridge system that combines NEAR's ability to execute transactions on foreign chains with secure verification methods, while maintaining high efficiency and security through MPC threshold guarantees.

:::info
For detailed implementation information and current status, see the [OmniBridge documentation](omnibridge/overview.md).
:::


 This is the content for the doc docs/help.md 

 ---
id: help
title: NEAR - Your Gateway to an Open Web
---


# Developer Help & Resources

[![DEVHUB](https://img.shields.io/badge/DEV_HUB-03BE09)](https://neardevhub.org/)
[![CALENDAR](https://img.shields.io/badge/CALENDAR-F9F502)](https://bit.ly/near-dev-calendar)
[![DEV SUPPORT](https://img.shields.io/badge/DEV_SUPPORT-BE0303)](https://t.me/addlist/VyVjNaP190JlOGMx)
[![NEWSLETTER](https://img.shields.io/badge/NEWSLETTER-0087E5)](https://newsletter.neardevhub.org/)
[![FEEDBACK](https://img.shields.io/badge/FEEDBACK-purple)](https://github.com/orgs/near/discussions/new?category=dev-feedback)

NEAR is dedicated to providing the best developer experience possible for building an open web. This mission is next to impossible to achieve without feedback and contributions from **people like you**. ü´µ

**Get involved!** üëâ please select one of the options above or contribute to one of the essential developer repositories listed below üôè

---

### üí¨ Support Channels

If you‚Äôre new or unsure where to start, these are the main support channels to connect with the NEAR community. They are great entry points for general questions and discussions.

| Channel                 | Description                                                                                                                                       | Link                                    |
| ----------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------- |
| **Telegram (Near Dev)** | NEAR Developers community chat                                                                                                                    | [Join](https://t.me/neardev)            |
| **Discord**             | Primary discussion and support forum. Weekly Q&A sessions: Thursdays at 11 AM UTC & 6 PM UTC. Also accessible via [near.chat](https://near.chat). | [Join](https://discord.gg/nearprotocol) |
| **X (Twitter)**         | Official Twitter account for NEAR Protocol.                                                                                                       | [Visit](https://x.com/nearprotocol)     |
| **Zulip**               | Topic-based discussions for detailed conversations.                                                                                               | [Join](https://near.zulipchat.com)      |
| **Developer Hub**       | Centralized developer resources for NEAR, including announcements, blog and discussions.                                                          | [Visit](https://neardevhub.org/)        |
| **Telegram (General)**  | General discussions for anyone interested in NEAR Protocol.                                                                                       | [Join](https://t.me/cryptonear)         |

<hr class="subsection" />

The Telegram chats are organized into two groups to make it easier to navigate and find the right discussions:

#### Group 1: Telegram Folder (21 chats)

Discover 21 NEAR-related in this [Telegram groups folder](https://t.me/addlist/VWPcqJDOmXdkZTQ5), or explore and join individual chats below based on your interests.

| #   | Topic                | Chat                              | Link                                               |
| --- | -------------------- | --------------------------------- | -------------------------------------------------- |
| 1   | General              | Near Dev                          | [Join](https://t.me/neardev)                       |
| 2   |                      | NEAR Protocol Community Group     | [Join](https://t.me/NEAR_Protocol_Community_Group) |
| 3   | Tools & Tech         | NEAR Tools Community Group        | [Join](https://t.me/NEAR_Tools_Community_Group)    |
| 4   |                      | NEAR Python Tooling Community     | [Join](https://t.me/nearpythontooling)             |
| 5   | Development          | Aurora Dev                        | [Join](https://t.me/auroraisneardev)               |
| 6   |                      | Bitte Dev                         | [Join](https://t.me/mintdev)                       |
| 7   |                      | NEAR Chain Abstraction Dev Group  | [Join](https://t.me/chain_abstraction)             |
| 8   | Social Protocol      | Near Social (near.social)         | [Join](https://t.me/NearSocialDev)                 |
| 9   |                      | BOS VM Dev (near.social)          | [Join](https://t.me/NearSocialDev)                 |
| 10  | Frontend Development | BOS Decentralized Frontends       | [Join](https://t.me/NEARisBOS)                     |
| 11  | Technical Resources  | NEAR Docs Community Group         | [Join](https://t.me/neardocscg)                    |
| 12  |                      | BOS Web Engine Testing            | [Join](https://t.me/bos_web_testing)               |
| 13  |                      | NEAR Validators                   | [Join](https://t.me/near_validators)               |
| 14  | Finance & DeFi       | NEAR DeFi Founders                | [Join](https://t.me/+Lu68Q6V-T2AxNDkx)             |
| 15  | Announcements        | NEAR DevHub                       | [Join](https://t.me/NEARDevHub)                    |
| 16  | Indexing & Data      | NEAR Indexer Builder Group        | [Join](https://t.me/+tZps5gkh17RmNTZh)             |
| 17  |                      | NEAR Data Guild                   | [Join](https://t.me/NEARdata)                      |
| 18  | Wallets & Standards  | NEAR Wallet Builder Group         | [Join](https://t.me/+8s315V2dlYFkMmUx)             |
| 19  |                      | NEAR Contract Standards Community | [Join](https://t.me/nearnft)                       |
| 20  | NFTs & Creative Tech | NEAR NFT Builder Group            | [Join](https://t.me/+_odQLYGusEU0MzAx)             |

<hr class="subsection" />

#### Group 2: NearBuilders Only (15 chats)

These community groups are part of the 31 chats from [nearbuilders.com](https://nearbuilders.com) and do not overlap with the previous group. They offer great collaboration opportunities. Verify external links to stay safe.

| #   | Topic                | Chat                                | Link                                            |
| --- | -------------------- | ----------------------------------- | ----------------------------------------------- |
| 1   | General              | Near DevHub Hacks                   | [Join](https://t.me/neardevhubhacks)            |
| 2   | AI & Advanced Topics | NEAR AI Builder Group               | [Join](https://t.me/+iN9e_WZntCE3YTU5)          |
| 3   |                      | NEAR Zero Knowledge Community Group | [Join](https://t.me/NearZeroKnowledge)          |
| 4   | DAO & Community      | NEAR DAO Builder Group              | [Join](https://t.me/+94DGFAazvdpiMDZh)          |
| 5   |                      | Onboard DAO                         | [Join](https://t.me/+TYGncu1CaAc4YjAx)          |
| 6   |                      | Build DAO                           | [Join](https://t.me/+bQmGfDqcAT9iYTcx)          |
| 7   |                      | NEAR Impact Collective üå±           | [Join](https://t.me/+crolW0imGSQ4NjYx)          |
| 8   |                      | Creatives DAO Builder Group         | [Join](https://t.me/+OG7gOkgjc6M3ZDAx)          |
| 9   | Tools & Tech         | NEAR Tools Community Group          | [Join](https://t.me/NEAR_Tools_Community_Group) |
| 10  |                      | NEAR Python Tooling Community       | [Join](https://t.me/nearpythontooling)          |
| 11  |                      | NEAR x IBC (Cosmos)                 | [Join](https://t.me/+0NKv1RrSeY42Yzdh)          |
| 12  | Gaming & NFTs        | NEAR Games Community                | [Join](https://t.me/NearGamesChat)              |
| 13  |                      | Bridging NFTs ‚ãà                     | [Join](https://t.me/+lCgwUHprzhQ2YmE5)          |
| 14  |                      | NEAR Multitoken Standard Discussion | [Join](https://t.me/+-pduFDM84hFmMGU5)          |
| 15  | Privacy              | Privacy on NEAR                     | [Join](https://t.me/+lf7vb2MAEgdjOGQx)          |

---

### üìù Docs

| Website      | Description | Repo |
| ----------- | ----------- | --- |
|[docs.near.org](https://docs.near.org) | NEAR Developer Documentation |[near/docs](https://github.com/near/docs)
|[nomicon.io](https://nomicon.io)| NEAR Protocol Specification Documentation | [near/neps](https://github.com/near/neps)
|[near-nodes.io](https://near-nodes.io)| NEAR Node Documentation _(Validator, RPC, Archival)_ |[near/node-docs](https://github.com/near/node-docs)

---

### ‚õìÔ∏è Protocol

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| nearcore | Reference implementation of NEAR Protocol  |[near/nearcore](https://github.com/near/nearcore)|[![Latest Release](https://img.shields.io/github/v/release/near/nearcore?label=)](https://github.com/near/nearcore/releases)
| NEPs | NEAR Protocol Specifications and Standards  |[near/neps](https://github.com/near/neps)| ‚ûñ

---

### üõ†Ô∏è Dev Tools

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |--|
| create-near-app | Easy fullstack dApp deployment tool | [near/create-near-app](https://github.com/near/create-near-app) | [![Latest Release](https://img.shields.io/github/v/release/near/create-near-app?label=)](https://github.com/near/create-near-app/releases)
| cargo-near | Cargo extension for building smart contracts and ABI schemas on NEAR | [near/cargo-near](https://github.com/near/cargo-near) | [![Latest Release](https://img.shields.io/github/v/release/near/cargo-near?label=)](https://github.com/near/cargo-near/releases)

### üíª CLI

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |--|
| near-cli-rs| Rust based CLI for interacting w/ NEAR | [near/near-cli-rs](https://github.com/near/near-cli-rs)| [![Latest Release](https://img.shields.io/github/v/release/near/near-cli-rs?label=)](https://github.com/near/near-cli-rs/releases)

### üîë Wallet / Auth

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| wallet-selector |Wallet integration tool for NEAR|[near/wallet-selector](https://github.com/near/wallet-selector)|[![Latest Release](https://img.shields.io/github/v/release/near/wallet-selector?label=)](https://github.com/near/wallet-selector/releases)
| web3-onboard | Wallet integration tool for multichain |[blocknative/web3-onboard](https://github.com/blocknative/web3-onboard)|[![Latest Release](https://img.shields.io/github/v/release/blocknative/web3-onboard?label=)](https://github.com/blocknative/web3-onboard/releases)
| FastAuth Signer | Authenticate and sign transactions w/ FastAuth |[near/fast-auth-signer](https://github.com/near/fast-auth-signer)|‚ûñ
| mpc-recovery | Create and restore accounts w/ OIDC protocol|[near/mpc-recovery](https://github.com/near/mpc-recovery)|‚ûñ
| iDOS | Decentralized identity, storage, and verification | [idos-network/idos-sdk-js](https://github.com/idos-network/idos-sdk-js)|‚ûñ

### üîå API

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| near-api-js | API tool for frontend & backend JS libraries |[near/near-api-js](https://github.com/near/near-api-js)|[![Latest Release](https://img.shields.io/github/v/release/near/near-api-js?label=)](https://github.com/near/near-api-js/releases)

### üìù Smart Contracts

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- |---|
| near-sdk-js|Create smart contracts w/ JavaScript | [near/near-sdk-js](https://github.com/near/near-sdk-js) | [![Latest Release](https://img.shields.io/github/v/release/near/near-sdk-js?label=)](https://github.com/near/near-sdk-js/releases)
| near-sdk-rs|Create smart contracts w/ Rust | [near/near-sdk-rs](https://github.com/near/near-sdk-rs)| [![Latest Release](https://img.shields.io/github/v/release/near/near-sdk-rs?label=)](https://github.com/near/near-sdk-rs/releases)
| Keypom | Customizable key creation for NFT/FT drops  |[keypom/keypom](https://github.com/keypom/keypom)|[![Latest Release](https://img.shields.io/github/v/release/keypom/keypom?label=)](https://github.com/keypom/keypom/releases)

### üß™ Testing

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| workspaces-js| Testing sandbox written in JS  |[near/workspaces-js](https://github.com/near/workspaces-js)|[![Latest Release](https://img.shields.io/github/v/release/near/near-workspaces-js?label=)](https://github.com/near/near-workspaces-js/releases)
| workspaces-rs| Testing sandbox written in Rust |[near/workspaces-rs](https://github.com/near/workspaces-rs)|[![Latest Release](https://img.shields.io/github/v/release/near/near-workspaces-rs?label=)](https://github.com/near/near-workspaces-rs/releases)

### üîé Blockchain Data Indexing

| Name      | Description | Repo | Latest Release |
| ----------- | ----------- | --- | --- |
| QueryApi | Build custom indexers and query with GraphQL endpoints|[near/queryapi](https://github.com/near/queryapi)|‚ûñ
| near-lake-indexer | Built on [NEAR Indexer](https://github.com/near/nearcore/tree/master/chain/indexer) that stores JSON in AWS S3 bucket  |[near/near-lake-indexer](https://github.com/near/near-lake-indexer)|[![Latest Release](https://img.shields.io/github/v/release/near/near-lake-indexer?label=)](https://github.com/near/near-lake-indexer/releases)
| near-lake-framework-rs | Stream blocks from NEAR Lake into your server |[near/near-lake-framework-rs](https://github.com/near/near-lake-framework-rs)|[![Latest Release](https://img.shields.io/github/v/release/near/near-lake-framework-rs?label=)](https://github.com/near/near-lake-framework-rs/releases)
| near-lake-framework-js | Stream blocks from NEAR Lake into your server |[near/near-lake-framework-js](https://github.com/near/near-lake-framework-js)| ‚ûñ


 This is the content for the doc docs/welcome.md 

 ---
id: welcome
title: Welcome to NEAR
sidebar_label: Home
hide_table_of_contents: true
---

import {FeatureList, Column, Feature} from "@site/src/components/featurelist";
import {Container, Card} from "@site/src/components/cards";

Imagine a place where you can build Web3 apps with the simplicity of Web2. Imagine a place where you can empower communities, supercharge AI, and easily integrate your app with other chains. Welcome to NEAR; you're going to like it here.

<Container>
    <Card img={require("@site/static/docs/assets/welcome-pages/protocol.png").default}
          title="NEAR Protocol"
          text="Learn what NEAR is and how it works"
          links={{
            "What is NEAR?": "/concepts/basics/protocol",
            "Named Accounts": "/concepts/protocol/account-id",
            "Access Keys": "/concepts/protocol/access-keys",
            "Transactions": "/concepts/protocol/transactions"
          }}
    />
    <Card img={require("@site/static/docs/assets/welcome-pages/chain-abstraction-landing.png").default}
          title="Chain Abstraction"
          text="Forget about the chain, focus on usability"
          links={{
            "What is Chain Abstraction?": "/chain-abstraction/what-is",
            "Chain Signatures ‚ú®": "/chain-abstraction/chain-signatures",
            "Meta-transactions": "/chain-abstraction/meta-transactions",
            "NEAR Intents": "/chain-abstraction/intents/overview",
          }}
    />
    <Card img={require("@site/static/docs/assets/welcome-pages/examples-landing.png").default}
          title="Web3 Applications"
          text="Supercharge your App using NEAR"
          links={{
            "What are Web3 Applications?": "/build/web3-apps/what-is",
            "Quickstart ‚ú®": "/build/web3-apps/quickstart",
            "Create an AI Assistant ü§ñ‚ú®": "/build/web3-apps/ai/ai-assistant",
            "Use a Contract in Your Frontend": "/build/web3-apps/integrate-contracts",
          }}
    />
    <Card img={require("@site/static/docs/assets/welcome-pages/contracts.png").default}
          title="Smart Contracts"
          text="NEAR accounts can host small programs"
          links={{
            "What is a Contract?": "/build/smart-contracts/what-is",
            "Quickstart ‚ú®": "/build/smart-contracts/quickstart",
            "Contract's Anatomy": "/build/smart-contracts/anatomy/",
            "Sandbox Testing": "/build/smart-contracts/testing/integration-test"
          }}
    />
    <Card img={require("@site/static/docs/assets/welcome-pages/primitives-landing.png").default}
          title="Primitives"
          text="FTs, NFTs, and everything your app needs"
          links={{
            "What are Primitives?": "/build/primitives/what-is",
            "Fungible Tokens (FT)": "/build/primitives/ft",
            "Non-Fungible Tokens (NFT)": "/build/primitives/nft",
            "Autonomous Organizations": "/build/primitives/dao",
            "Decentralized Exchanges": "/build/primitives/dex",
            "Linkdrops": "/build/primitives/linkdrop",
          }}
    />
    <Card img={require("@site/static/docs/assets/welcome-pages/data-lake-landing.png").default}
          title="Data Infrastructure"
          text="Easily extract and analyze on-chain data"
          links={{
            "What is Data Infrastructure?": "/build/data-infrastructure/what-is",
            "BigQuery": "/build/data-infrastructure/big-query",
            "Data APIs": "/build/data-infrastructure/data-apis",
            "Lake Framework": "/build/data-infrastructure/lake-framework/near-lake-framework",
          }}
    />
</Container>

---

## External Resources

Here are more sources from our ecosystem that can help you to learn more about NEAR.

<div className="row cards">
  <div className="col col--6">
    <a href="https://dev.near.org/applications" target="_blank" rel="noopener noreferrer">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/awesomenear.jpg").default} alt="Discover" />
        </div>
        <div className="card__body">
          <h3>
          Discover
          </h3>
          Discover awesome apps in the Near ecosystem
        </div>
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a href="https://near.github.io/nearcore/" target="_blank" rel="noopener noreferrer">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/nomicon.png").default} alt="NEAR Core" />
        </div>
        <div className="card__body">
          <h3>
          NEAR Core
          </h3>
          Learn the official protocol documentation
        </div>
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a href="https://near-nodes.io" target="_blank" rel="noopener noreferrer">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/validate.png").default} alt="Validate" />
        </div>
        <div className="card__body">
          <h3>
          Running a Node
          </h3>
          Become a validator, help keeping the blockchain safe
        </div>
      </div>
    </a>
  </div>
  <div className="col col--6">
    <a href="https://templates.mintbase.xyz/" target="_blank" rel="noopener noreferrer">
      <div className="card">
        <div className="card__image">
          <img src={require("@site/static/docs/assets/welcome-pages/mintbase-templates.png").default} alt="Templates" />
        </div>
        <div className="card__body">
          <h3>
          Templates
          </h3>
          Templates for creating web3 applications
        </div>
      </div>
    </a>
  </div>
</div>


 This is the content for the doc website/src/components/ContactUs.mdx 

 ## Contact us

If you have any questions, or simply would want to chat with us, please do through one of our official channels.

<div class="row">
  <div class="col col--3">
    <div className="avatar">
      <img
        className="avatar__photo avatar__photo--sm"
        src={require("@site/static/docs/assets/home/twitter.png").default} />
      <div className="avatar__intro">
        <div className="avatar__name">Twitter</div>
        <small className="avatar__subtitle"><a href="https://twitter.com/@nearprotocol" target="_blank" rel="noopener noreferrer">@nearprotocol</a></small>
      </div>
    </div>
  </div>
  <div class="col col--3">
    <div className="avatar">
      <img
        className="avatar__photo avatar__photo--sm"
        src={require("@site/static/docs/assets/home/telegram.png").default} />
      <div className="avatar__intro">
        <div className="avatar__name">Telegram</div>
        <small className="avatar__subtitle"><a href="https://t.me/neardev" target="_blank" rel="noopener noreferrer">NEAR Dev</a></small>
      </div>
    </div>
  </div>
  <div class="col col--3">
    <div className="avatar">
      <img
        className="avatar__photo"
        src={require("@site/static/docs/assets/home/discord.png").default} />
      <div className="avatar__intro">
        <div className="avatar__name">Discord</div>
        <small className="avatar__subtitle"><a href="https://near.chat" target="_blank" rel="noopener noreferrer">NEAR Protocol</a></small>
      </div>
    </div>
  </div>
  <div class="col col--3">
    <div className="avatar">
      <img
        className="avatar__photo"
        src={require("@site/static/docs/assets/home/zulip.png").default} />
      <div className="avatar__intro">
        <div className="avatar__name">Zulip</div>
        <small className="avatar__subtitle"><a href="https://near.zulipchat.com/" target="_blank" rel="noopener noreferrer">Near Chat</a></small>
      </div>
    </div>
  </div>
</div>

 This is the content for the doc website/src/components/docs/5.api/rpc/_general/error-schema-description.mdx 

 When API request fails, RPC server returns a structured error response with a
limited number of well-defined error variants, so client code can exhaustively
handle all the possible error cases. Our JSON-RPC errors follow
[verror](https://github.com/joyent/node-verror) convention for structuring
the error response:

```json
{
  "error": {
    "name": <ERROR_TYPE>,
    "cause": {
      "info": {..},
      "name": <ERROR_CAUSE>
    },
    "code": -32000,
    "data": String,
    "message": "Server error"
  },
  "id": "dontcare",
  "jsonrpc": "2.0"
}
```

> **Heads up**
>
> The fields `code`, `data`, and `message` in the structure above are considered
> legacy ones and might be deprecated in the future. Please, don't rely on them.


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## View access key changes (all) {#view-access-key-changes-all}

Returns changes to <strong>all</strong> access keys of a specific block.
Multiple accounts can be quereied by passing an array of `account_ids`.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `all_access_key_changes`
  - `account_ids`: `[ "example.testnet", "example2.testnet"]`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/access-keys/get-changes-for-account-keys.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What Could Go Wrong?{#what-could-go-wrong-3}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned
by `EXPERIMENTAL_changes` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "all_access_key_changes",
    "account_ids": ["account.rpc-examples.testnet"],
    "block_id": 187309655
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/request-js.mdx 

 ```js
const response = await near.connection.provider.accessKeyChanges(
  ["account.rpc-examples.testnet"],
  { blockId: 187309655 },
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "all_access_key_changes",
    "account_ids": ["account.rpc-examples.testnet"],
    "block_id": 187309655
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-all/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "6EDgS3zF9aoBMfdHqthQTQtudt7JzdLBbkTb6Jn4wfP9",
    "changes": [
      {
        "cause": {
          "receipt_hash": "9meU2ibDyJS2ga4se7j5knsWetKrXaw5qBpwrYgN1Qeh",
          "type": "receipt_processing"
        },
        "change": {
          "access_key": {
            "nonce": 187309654000000,
            "permission": "FullAccess"
          },
          "account_id": "account.rpc-examples.testnet",
          "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
        },
        "type": "access_key_update"
      },
      {
        "cause": {
          "receipt_hash": "9meU2ibDyJS2ga4se7j5knsWetKrXaw5qBpwrYgN1Qeh",
          "type": "receipt_processing"
        },
        "change": {
          "access_key": {
            "nonce": 187309654000000,
            "permission": {
              "FunctionCall": {
                "allowance": "150000000000000000000000",
                "method_names": [
                  "write_record",
                  "get_record",
                  "get_greeting",
                  "__contract_abi",
                  "contract_source_metadata"
                ],
                "receiver_id": "contract.rpc-examples.testnet"
              }
            }
          },
          "account_id": "account.rpc-examples.testnet",
          "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
        },
        "type": "access_key_update"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## View access key changes (single) {#view-access-key-changes-single}

Returns individual access key changes in a specific block. You can query multiple
keys by passing an array of objects containing the `account_id` and `public_key`.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `single_access_key_changes`
  - `keys`: `[{ account_id, public_key }]`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/access-keys/get-changes-for-account-key.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What Could Go Wrong?{#what-could-go-wrong-2}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned
by `EXPERIMENTAL_changes_in_block` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "single_access_key_changes",
    "keys": [
      {
        "account_id": "account.rpc-examples.testnet",
        "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
      }
    ],
    "block_id": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/request-js.mdx 

 ```js
const response = await near.connection.provider.singleAccessKeyChanges(
  [
    {
      account_id: "account.rpc-examples.testnet",
      public_key: "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd",
    },
  ],
  { blockId: "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w" },
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "single_access_key_changes",
    "keys": [
      {
        "account_id": "account.rpc-examples.testnet",
        "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
      }
    ],
    "block_id": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-changes-single/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w",
    "changes": [
      {
        "cause": {
          "tx_hash": "J3KbUXF9YPu2eGnbDCACxGvmMDZMdP7acGYhVLHGu9y2",
          "type": "transaction_processing"
        },
        "change": {
          "access_key": {
            "nonce": 187309654000001,
            "permission": {
              "FunctionCall": {
                "allowance": "142924791772640836536480",
                "method_names": [
                  "write_record",
                  "get_record",
                  "get_greeting",
                  "__contract_abi",
                  "contract_source_metadata"
                ],
                "receiver_id": "contract.rpc-examples.testnet"
              }
            }
          },
          "account_id": "account.rpc-examples.testnet",
          "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
        },
        "type": "access_key_update"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-list/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="5">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> is invalid
      </td>
      <td>
        <ul>
          <li>
            Provide a valid <code>account_id</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> has not been found while viewing
        since the account has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>account_id</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>200</td>
      <td>
        The node was unable to find the requested data because it does not track
        the shard where data is present
      </td>
      <td>
        <ul>
          <li>
            Send a request to a different node which might track the shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-list/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## View access key list {#view-access-key-list}

You can query <strong>all</strong> access keys for a given account.

- method: `query`
- params:
  - `request_type`: `view_access_key_list`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/access-keys/get-account-keys.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What Could Go Wrong?

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned
by `view_access_key_list` request type:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-list/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id="dontcare" \
  method=query \
  params:='{
    "request_type": "view_access_key_list",
    "finality": "final",
    "account_id": "account.rpc-examples.testnet"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-list/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "view_access_key_list",
  finality: "final",
  account_id: "account.rpc-examples.testnet",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-list/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_access_key_list",
    "finality": "final",
    "account_id": "account.rpc-examples.testnet"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key-list/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "29G6xeV4ufkVsY24YZPfiRwLMTNoKrAMitrjg6nvVZqq",
    "block_height": 187319080,
    "keys": [
      {
        "access_key": {
          "nonce": 187309654000000,
          "permission": "FullAccess"
        },
        "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
      },
      {
        "access_key": {
          "nonce": 187309654000001,
          "permission": {
            "FunctionCall": {
              "allowance": "149788200694421800000000",
              "method_names": [
                "write_record",
                "get_record",
                "get_greeting",
                "__contract_abi",
                "contract_source_metadata"
              ],
              "receiver_id": "contract.rpc-examples.testnet"
            }
          }
        },
        "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="6">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> is invalid
      </td>
      <td>
        <ul>
          <li>
            Provide a valid <code>account_id</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> has not been found while viewing
        since the account has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>account_id</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCESS_KEY</td>
      <td>200</td>
      <td>
        The requested <code>public_key</code> has not been found while viewing
        since the public key has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>public_key</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>200</td>
      <td>
        The node was unable to found the requested data because it does not
        track the shard where data is present
      </td>
      <td>
        <ul>
          <li>
            Send a request to a different node which might track the shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## View access key {#view-access-key}

Returns information about a single access key for given account.

If `permission` of the key is `FunctionCall`, it will return more details such
as the `allowance`, `receiver_id`, and `method_names`.

- method: `query`
- params:
  - `request_type`: `view_access_key`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_
  - `public_key`: _`"example.testnet's public key"`_

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/access-keys/get-account-key.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What Could Go Wrong?

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by
`view_access_key` request type:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=query \
  params:='{
    "request_type": "view_access_key",
    "finality": "final",
    "account_id": "account.rpc-examples.testnet",
    "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "view_access_key",
  finality: "final",
  account_id: "account.rpc-examples.testnet",
  public_key: "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_access_key",
    "finality": "final",
    "account_id": "account.rpc-examples.testnet",
    "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/access-keys/view-access-key/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "J1zkrK8sHuzzV8pkXsEPrZH7SQZeJ2NSEs9L1hSWzVgg",
    "block_height": 187316844,
    "nonce": 187309654000001,
    "permission": {
      "FunctionCall": {
        "allowance": "149788200694421800000000",
        "method_names": [
          "write_record",
          "get_record",
          "get_greeting",
          "__contract_abi",
          "contract_source_metadata"
        ],
        "receiver_id": "contract.rpc-examples.testnet"
      }
    }
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/block-hash/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=block \
  params:='{
    "block_id": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/block-hash/request-js.mdx 

 ```js
const response = await near.connection.provider.block({
  blockId: "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/block-hash/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "block",
  "params": {
    "block_id": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/block-height/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=block \
  params:='{
    "block_id": 187310138
  }'
````


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/block-height/request-js.mdx 

 ```js
const response = await near.connection.provider.block({
  blockId: 187310138,
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/block-height/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "block",
  "params": {
    "block_id": 187310138
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/finality/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=block \
  params:='{
    "finality": "final"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/finality/request-js.mdx 

 ```js
const response = await near.connection.provider.block({
  finality: "final",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/finality/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "block",
  "params": {
    "finality": "final"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import FinalityRequestJson from "./finality/request-json.mdx";
import FinalityRequestJs from "./finality/request-js.mdx";
import FinalityRequestBash from "./finality/request-bash.mdx";
import BlockHeightRequestJson from "./block-height/request-json.mdx";
import BlockHeightRequestJs from "./block-height/request-js.mdx";
import BlockHeightRequestBash from "./block-height/request-bash.mdx";
import BlockHashRequestJson from "./block-hash/request-json.mdx";
import BlockHashRequestJs from "./block-hash/request-js.mdx";
import BlockHashRequestBash from "./block-hash/request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## Block details {#block-details}

> Queries network and returns block for given height or hash. You can also use
> `finality` param to return latest block details.

**Note**: You may choose to search by a specific block _or_ finality, you can not choose both.

- method: `block`
- params:
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

`finality` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <FinalityRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <FinalityRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <FinalityRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-latest-block.json" />
  </TabItem>
</Tabs>

`block_height` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockHeightRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockHeightRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockHeightRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-block-by-bloch-height.json" />
  </TabItem>
</Tabs>

`block_hash` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockHashRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockHashRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockHashRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-block-by-bloch-hash.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What Could Go Wrong?? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `block` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/block-details/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "author": "node2",
    "chunks": [
      {
        "balance_burnt": "0",
        "bandwidth_requests": null,
        "chunk_hash": "CzPafxtJmM1FnRoasKWAVhceJzZzkz9RKUBQQ4kY9V1v",
        "congestion_info": {
          "allowed_shard": 1,
          "buffered_receipts_gas": "0",
          "delayed_receipts_gas": "0",
          "receipt_bytes": 0
        },
        "encoded_length": 308,
        "encoded_merkle_root": "6z9JwwtVfS5nRKcKeJxgzThRRs2wCNvbH88T3cuARe6W",
        "gas_limit": 1000000000000000,
        "gas_used": 0,
        "height_created": 187310138,
        "height_included": 187310138,
        "outcome_root": "11111111111111111111111111111111",
        "outgoing_receipts_root": "AChfy3dXeJjgD2w5zXkUTFb6w8kg3AYGnyyjsvc7hXLv",
        "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
        "prev_state_root": "cRMk2zd2bWC1oBfGowgMTpqW9L5SNG2FeE72yT1wpQA",
        "rent_paid": "0",
        "shard_id": 0,
        "signature": "ed25519:L1iCopW8gY5rqwfuZT8Y3bHHXvuvWT87X9rwdY6LmFi8LGZdMhj2CkQCXLGrzdfYXD8B54wPTM9TqJAHcKfFDyW",
        "tx_root": "CMwUsP8q4DTBUYxXm12jVwC8xTD8L1T1n3jdKLQVh6bm",
        "validator_proposals": [],
        "validator_reward": "0"
      },
      {
        "balance_burnt": "0",
        "bandwidth_requests": null,
        "chunk_hash": "44MZBWmPgXszAyojsffzozvNEdRsJcsq7RrdAV4Y7CLm",
        "congestion_info": {
          "allowed_shard": 2,
          "buffered_receipts_gas": "0",
          "delayed_receipts_gas": "0",
          "receipt_bytes": 0
        },
        "encoded_length": 8,
        "encoded_merkle_root": "5TxYudsfZd2FZoMyJEZAP19ASov2ZD43N8ZWv8mKzWgx",
        "gas_limit": 1000000000000000,
        "gas_used": 0,
        "height_created": 187310138,
        "height_included": 187310138,
        "outcome_root": "11111111111111111111111111111111",
        "outgoing_receipts_root": "AChfy3dXeJjgD2w5zXkUTFb6w8kg3AYGnyyjsvc7hXLv",
        "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
        "prev_state_root": "EQ5mcUAzJA4du33f9g9YzKvdte2ukyRHMMHbbqdazZvU",
        "rent_paid": "0",
        "shard_id": 1,
        "signature": "ed25519:4ktZTtEfxXSXPVj6Kii52d2T684HKKtEMzrd3dNc7UyxmgkKcLtxD1fawtbj8KsmjbZPGj8YMzanDeViEhxRJtDX",
        "tx_root": "11111111111111111111111111111111",
        "validator_proposals": [],
        "validator_reward": "0"
      },
      {
        "balance_burnt": "38449649514500000000",
        "bandwidth_requests": null,
        "chunk_hash": "7eB8V8zMmNp9GxfRt3oHA3DS7YTgPvZ761pBzoziLay8",
        "congestion_info": {
          "allowed_shard": 3,
          "buffered_receipts_gas": "0",
          "delayed_receipts_gas": "0",
          "receipt_bytes": 0
        },
        "encoded_length": 1804,
        "encoded_merkle_root": "6aZKpB3jZbhAq3kDtXaM6s1hYRLYEM624yiKkKvd957m",
        "gas_limit": 1000000000000000,
        "gas_used": 384496495145,
        "height_created": 187310138,
        "height_included": 187310138,
        "outcome_root": "D7ojhJ8UAgWf8A51Ekcundn3Kzdc577p5LFxqxcZurdB",
        "outgoing_receipts_root": "3CK2q73iJmWa36EbaceqGcTz7pD7pia8BsUDE3gixwnF",
        "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
        "prev_state_root": "7bSk4ev8EhZFSjb8Zb6ftkEZAUYQdbyPPz2ZkrvjLPuK",
        "rent_paid": "0",
        "shard_id": 2,
        "signature": "ed25519:2sQ4JfYSMFcwpjbmonk67mMCMvuQyCNzvvk3iqCLMR7mnHauy3i7aTbySXwoqnrDjdmNjQ3gJMaA53LSRxYmoyAD",
        "tx_root": "11111111111111111111111111111111",
        "validator_proposals": [],
        "validator_reward": "0"
      },
      {
        "balance_burnt": "0",
        "bandwidth_requests": null,
        "chunk_hash": "9pTjB74BgVSoP4Wb68BjkgnyABvZQUzAvv54YiVgse1B",
        "congestion_info": {
          "allowed_shard": 4,
          "buffered_receipts_gas": "0",
          "delayed_receipts_gas": "0",
          "receipt_bytes": 0
        },
        "encoded_length": 8,
        "encoded_merkle_root": "5TxYudsfZd2FZoMyJEZAP19ASov2ZD43N8ZWv8mKzWgx",
        "gas_limit": 1000000000000000,
        "gas_used": 0,
        "height_created": 187310138,
        "height_included": 187310138,
        "outcome_root": "11111111111111111111111111111111",
        "outgoing_receipts_root": "AChfy3dXeJjgD2w5zXkUTFb6w8kg3AYGnyyjsvc7hXLv",
        "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
        "prev_state_root": "JDHeuYmX4kvsTPKyJYtJTrm7UK3JHTf4rw7hcHXYEfCn",
        "rent_paid": "0",
        "shard_id": 3,
        "signature": "ed25519:5AejTPwZGWqdZjGCUbhLCcgasNDtsYKRJhS33uYR5Psu6NcCiaeLZnV8Q7dtWK4hLJ1iA48DA2WeqEeUyGhqWAGT",
        "tx_root": "11111111111111111111111111111111",
        "validator_proposals": [],
        "validator_reward": "0"
      },
      {
        "balance_burnt": "32741908829000000000",
        "bandwidth_requests": null,
        "chunk_hash": "2xQwSvBiCb1mkoPxBJhSRg7pjmnrmKMEffatDz73Y8Jj",
        "congestion_info": {
          "allowed_shard": 5,
          "buffered_receipts_gas": "0",
          "delayed_receipts_gas": "0",
          "receipt_bytes": 0
        },
        "encoded_length": 1042,
        "encoded_merkle_root": "5XpktxfgMp6thB2nH3PxdSg3K84p2wmpihHxUCqeQA6c",
        "gas_limit": 1000000000000000,
        "gas_used": 327419088290,
        "height_created": 187310138,
        "height_included": 187310138,
        "outcome_root": "69ZXwcYi41NY6cx1rZog8YavBPQvN75pmkNHZsFjWfUW",
        "outgoing_receipts_root": "FqGVK8H8x2P3BbvuFMo7VCTy8cCNTzT1jd5JoLXfYRNG",
        "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
        "prev_state_root": "BJePbZUt8VzJBwKf1j1sRUJJJEx4D2fUu4SCHiWs331o",
        "rent_paid": "0",
        "shard_id": 4,
        "signature": "ed25519:2QSda4eMn25hmmTY31wN6RnBpBLjamSLrQRoVZ1yEoWyhtMhtg8rUv9Ko1tEdSftwhNEhL1ETixaAz4qcmvHUvD1",
        "tx_root": "6qbqA8B9oyeVG33JXH25xbA2DiqvHRnxipurYUBJ9D8B",
        "validator_proposals": [],
        "validator_reward": "0"
      },
      {
        "balance_burnt": "0",
        "bandwidth_requests": null,
        "chunk_hash": "EVkgySRKpB9HrEJz8f18p9pWmJzhtL9WeYMwDSeY1827",
        "congestion_info": {
          "allowed_shard": 0,
          "buffered_receipts_gas": "0",
          "delayed_receipts_gas": "0",
          "receipt_bytes": 0
        },
        "encoded_length": 8,
        "encoded_merkle_root": "5TxYudsfZd2FZoMyJEZAP19ASov2ZD43N8ZWv8mKzWgx",
        "gas_limit": 1000000000000000,
        "gas_used": 0,
        "height_created": 187310138,
        "height_included": 187310138,
        "outcome_root": "11111111111111111111111111111111",
        "outgoing_receipts_root": "AChfy3dXeJjgD2w5zXkUTFb6w8kg3AYGnyyjsvc7hXLv",
        "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
        "prev_state_root": "GkcYxyvnet4nvL7LFdbKxiscFBpe5WSzy5g2pW58LSRs",
        "rent_paid": "0",
        "shard_id": 5,
        "signature": "ed25519:573WUDx8Sm4Fi16PFQkELXYq2SYezcbQP4CuhseqNizDtSTf2c2TKMWf2ZuACiWCSa8ARw8eWB2ZKWaY1uy7xd14",
        "tx_root": "11111111111111111111111111111111",
        "validator_proposals": [],
        "validator_reward": "0"
      }
    ],
    "header": {
      "approvals": [
        null,
        "ed25519:5GhoQTPXsWpgGPq2ZHZCfP9iY9GSmHMNsnydzxBxnibGvC43PFUAD58aUSNyfepRY4dAMbjbf8CduMyQU83HBxAt",
        "ed25519:3Vc7sgrrgvpFXRr94mx3CD32Std1MRprR7igChZUisJvUm6f2yJmUGaXk38CYbh2wT1gfsKJ2UHf9icRome3jFYw",
        "ed25519:3DZqMDGrk3eNUcZ8FiTtdw2piMXVcmVDDs89kHdRdDDgTr88GnQPEym4kfX9FUE81MnbytmotPry2sXD6MvbVprp",
        "ed25519:5qtN8dU2iCtZxqPNszhPJ2Rgio88QL2wseLPhLH5Ev56WuxcNsmFZbNREvA6cKAKz4aDwQFFmmj888h6EEZuS2TV",
        "ed25519:3gKUWzXU7Am5xdZqgMN3TC5wGVrf1kp6WQoqqtLFaF9JtBQKqqpZ67CKBm6KfejHPhiRkp1PbDJbppiNCpN3spr6",
        "ed25519:3wgeF9tcjx1vX2bLpXfm8fYUQnai524XjTNb3Wt2LHMZnNoXzW4D2XBynj8sK41H5wtSbeVYpN3vGY1r23y56BaY",
        "ed25519:ek5uvofwn5ZJidjYwiqS8Xpd1Y521FAUWrPyU9w3F8UT9yhviWuzPBCJUyMFVKnYUW6k6tZSZxT3NZibGfrGWA4",
        "ed25519:4UcHZyKNzGDsMSNfQjLA9EE8yXiq3aroLUz4WJATzkKkUfMNVRkWxGc5tih2jDwzKfY3Ni5YiPoBbPzPCxNrusLf",
        "ed25519:2hXaGXtAxngCjEWvnUUEgnnPCsXYzPzDadGHdw9sz6ng5oDQDPhnTm1MCG37xvv7xgCVhj3tqRZy8v74uap7WFC5",
        "ed25519:kLuyqcTUynL1P77uMaaRs2MzxiaE1uyVGPjAVxpufK9A19G6LDUfK2GcbFXkqCgvKBJEGZKFPUbBqs7EmDdLPD7",
        "ed25519:5ebABgQGk7idMAQgiEgc9a78v6fsD1nKXfevdBRJPFCn8bRuuFpthzzCp3NQXcr2XgSpNo6HJp8EZzzZHkSLfTDc",
        "ed25519:4hTb2qFydXaiMKfv1pCxU4S9TQYQTHhqUPuGy8dejqxt2FFHD2sdFsYCv8Mf8qWRSob77QMuQbj37aQfEuJR2hH4",
        null,
        "ed25519:65jkXVzQ8pGsRDApBvVFx4xR7j4gruJaL2wumRHEHWib61M5Ztvtt7TTkz2DMN1nrRy6C7Pfhe3U3KpdSVEKKYAN",
        null,
        "ed25519:3kNRvMnpP8t4D9Dgs1YDAXyPNg7V3fpNa3GEWyCNNq5EvXxnyEoXRyPtbrZQM2FbapKsL2DnaNGvewHwBRQz5DbD",
        "ed25519:5JQugH24LahiK7sn85akbprCtpAWfnZ2ffazxQ61kt9f6pe8b8s2LrHVKV3Wf4Sg3xHuP7fuUZJRyA4MWz3EQ83i",
        "ed25519:2zXba2vAyGEq1fWauB3Kj6HbExTZG1S9KXKe6xcLxEpJHP9JHE6P3mJzpc765WpNsP21evNGj6mffJAwRHtwRny4",
        null
      ],
      "block_body_hash": "6oSbpNUWcAUuaKWx79qTwyRPDLukg9hZ1RCa2PS5rcGt",
      "block_merkle_root": "DWK6gpunDXHgxU1KJi3Dx8o2HcKqQmUQJEaisK4M3ovD",
      "block_ordinal": 139413603,
      "challenges_result": [],
      "challenges_root": "11111111111111111111111111111111",
      "chunk_endorsements": [
        [255, 255],
        [251, 127],
        [255, 31],
        [255, 247],
        [255, 239, 1],
        [255, 63]
      ],
      "chunk_headers_root": "4MjChqi5JChDhaiU4zkhN1jeygZiMd66KeHe3Gz9Vs7s",
      "chunk_mask": [true, true, true, true, true, true],
      "chunk_receipts_root": "7nEtD9XsDbRJy7MwvUg4QX5zDUktiEVRP9nM6hHpsHmX",
      "chunk_tx_root": "44YKYmcG1JTocmPSMGpriLwN8CTi29sD8z5FcocMZAKo",
      "chunks_included": 6,
      "epoch_id": "HkFsp3sn9K3KDWVoWPCfUSQocgf5bH4icgjHijePc2aX",
      "epoch_sync_data_hash": null,
      "gas_price": "100000000",
      "hash": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w",
      "height": 187310138,
      "last_ds_final_block": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
      "last_final_block": "71qgTQCVFfjQkimSdnhxR8iWSP6o9jqumLcZ9k5g25mT",
      "latest_protocol_version": 73,
      "next_bp_hash": "AWcwcDPWUjcW9zGiAt7UEUZzZ5Ue77537turbvBLbsiB",
      "next_epoch_id": "FQBXgdi9oWKanYBXPP1sNUD93KMquocjT5mVrjQ4PH7E",
      "outcome_root": "7Qkowo41AoiMdNfyiT83DwvwyReMeqhrkpqTzGm4Z19T",
      "prev_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
      "prev_height": 187310137,
      "prev_state_root": "AiApSbMNq9kPPEiLLWhFpSrX5HoPToaBXztM9fePX2ap",
      "random_value": "Br6a6tgEhNBZm9iPtxCLhwqwCr2eoEAGGMeVYZnU6fVF",
      "rent_paid": "0",
      "signature": "ed25519:YSuWifP5B3VBPuEVJppWt13AShXsWZ64Qus8uHmtddE2mY6u4jnZVv6Gz4tFvWXfBAkZDk5xtd95rUterEdQm5t",
      "timestamp": 1739254177539033760,
      "timestamp_nanosec": "1739254177539033760",
      "total_supply": "2515615267787707740507051994761921",
      "validator_proposals": [],
      "validator_reward": "0"
    }
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/block-hash/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes_in_block \
  params:='{
    "block_id": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/block-hash/request-js.mdx 

 ```js
const response = await near.connection.provider.blockChanges({
  blockId: "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/block-hash/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes_in_block",
  "params": {
    "block_id": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/block-height/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes_in_block \
  params:='{
    "block_id": 187310138
  }'
````


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/block-height/request-js.mdx 

 ```js
const response = await near.connection.provider.blockChanges({
  blockId: 187310138,
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/block-height/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes_in_block",
  "params": {
    "block_id": 187310138
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/finality/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes_in_block \
  params:='{
    "finality": "final"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/finality/request-js.mdx 

 ```js
const response = await near.connection.provider.blockChanges({
  finality: "final",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/finality/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes_in_block",
  "params": {
    "finality": "final"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import FinalityRequestJson from "./finality/request-json.mdx";
import FinalityRequestJs from "./finality/request-js.mdx";
import FinalityRequestBash from "./finality/request-bash.mdx";
import BlockHeightRequestJson from "./block-height/request-json.mdx";
import BlockHeightRequestJs from "./block-height/request-js.mdx";
import BlockHeightRequestBash from "./block-height/request-bash.mdx";
import BlockHashRequestJson from "./block-hash/request-json.mdx";
import BlockHashRequestJs from "./block-hash/request-js.mdx";
import BlockHashRequestBash from "./block-hash/request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## Changes in Block {#changes-in-block}

> Returns changes in block for given block height or hash. You can also use
> `finality` param to return latest block details.

**Note**: You may choose to search by a specific block _or_ finality, you can not choose both.

- method: `EXPERIMENTAL_changes_in_block`
- params:
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

`finality` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <FinalityRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <FinalityRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <FinalityRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-latest-block-changes.json" />
  </TabItem>
</Tabs>

`block_height` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockHeightRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockHeightRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockHeightRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-block-changes-by-block-height.json" />
  </TabItem>
</Tabs>

`block_hash` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockHashRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockHashRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockHashRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-block-changes-by-block-hash.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What Could Go Wrong? {#what-could-go-wrong-1}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by
`EXPERIMENTAL_changes_in_block` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/changes-in-block/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w",
    "changes": [
      {
        "account_id": "account.rpc-examples.testnet",
        "type": "account_touched"
      },
      {
        "account_id": "dev2-nsp.testnet",
        "type": "account_touched"
      },
      {
        "account_id": "ping-account.testnet",
        "type": "account_touched"
      },
      {
        "account_id": "v1.signer-dev.testnet",
        "type": "account_touched"
      },
      {
        "account_id": "account.rpc-examples.testnet",
        "type": "access_key_touched"
      },
      {
        "account_id": "ping-account.testnet",
        "type": "access_key_touched"
      },
      {
        "account_id": "dev2-nsp.testnet",
        "type": "data_touched"
      },
      {
        "account_id": "dev2-nsp.testnet",
        "type": "data_touched"
      },
      {
        "account_id": "v1.signer-dev.testnet",
        "type": "data_touched"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/block-id-shard-id/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=chunk \
  params:='{
    "block_id": 187310138,
    "shard_id": 0
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/block-id-shard-id/request-js.mdx 

 ```js
const response = await near.connection.provider.chunk([187310138, 0]);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/block-id-shard-id/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "chunk",
  "params": {
    "block_id": 187310138,
    "shard_id": 0
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/chunk-id/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=chunk \
  params:='{
    "chunk_id": "CzPafxtJmM1FnRoasKWAVhceJzZzkz9RKUBQQ4kY9V1v"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/chunk-id/request-js.mdx 

 ```js
const response = await near.connection.provider.chunk(
  "CzPafxtJmM1FnRoasKWAVhceJzZzkz9RKUBQQ4kY9V1v",
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/chunk-id/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "chunk",
  "params": {
    "chunk_id": "CzPafxtJmM1FnRoasKWAVhceJzZzkz9RKUBQQ4kY9V1v"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="4">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_CHUNK</td>
      <td>200</td>
      <td>The requested chunk can't be found in a database</td>
      <td>
        <ul>
          <li>Check that the requested chunk is legit</li>
          <li>
            If the chunk had been produced more than 5 epochs ago, try to send
            your request to an archival node
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_SHARD_ID</td>
      <td>200</td>
      <td>
        Provided <code>shard_id</code> does not exist
      </td>
      <td>
        <ul>
          <li>
            Provide <code>shard_id</code> for an existing shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested chunk is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import ChunkIdRequestJson from "./chunk-id/request-json.mdx";
import ChunkIdRequestJs from "./chunk-id/request-js.mdx";
import ChunkIdRequestBash from "./chunk-id/request-bash.mdx";
import BlockIdShardIdRequestJson from "./block-id-shard-id/request-json.mdx";
import BlockIdShardIdRequestJs from "./block-id-shard-id/request-js.mdx";
import BlockIdShardIdRequestBash from "./block-id-shard-id/request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## Chunk Details {#chunk-details}

> Returns details of a specific chunk. You can run a [block details](/api/rpc/block-chunk#block-details)
> query to get a valid chunk hash.

- method: `chunk`
- params:
  - `chunk_id` _OR_ [`block_id`, `shard_id`](/api/rpc/setup#using-block_id-param)

`chunk_id` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <ChunkIdRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <ChunkIdRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <ChunkIdRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-chunk-by-chunk-id.json" />
  </TabItem>
</Tabs>

`[block_id, shard_id]` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockIdShardIdRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockIdShardIdRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockIdShardIdRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/block-chunk/get-chunk-by-block-shard.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What Could Go Wrong?? {#what-could-go-wrong-2}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `chunk` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/block-chunk/chunk-details/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "author": "kiln.pool.f863973.m0",
    "header": {
      "balance_burnt": "0",
      "bandwidth_requests": null,
      "chunk_hash": "CzPafxtJmM1FnRoasKWAVhceJzZzkz9RKUBQQ4kY9V1v",
      "congestion_info": {
        "allowed_shard": 1,
        "buffered_receipts_gas": "0",
        "delayed_receipts_gas": "0",
        "receipt_bytes": 0
      },
      "encoded_length": 308,
      "encoded_merkle_root": "6z9JwwtVfS5nRKcKeJxgzThRRs2wCNvbH88T3cuARe6W",
      "gas_limit": 1000000000000000,
      "gas_used": 0,
      "height_created": 187310138,
      "height_included": 187310138,
      "outcome_root": "11111111111111111111111111111111",
      "outgoing_receipts_root": "AChfy3dXeJjgD2w5zXkUTFb6w8kg3AYGnyyjsvc7hXLv",
      "prev_block_hash": "Wj6B3RTv73EWDNbSammRDeA9315RaPyRrJYmiP4nG4X",
      "prev_state_root": "cRMk2zd2bWC1oBfGowgMTpqW9L5SNG2FeE72yT1wpQA",
      "rent_paid": "0",
      "shard_id": 0,
      "signature": "ed25519:L1iCopW8gY5rqwfuZT8Y3bHHXvuvWT87X9rwdY6LmFi8LGZdMhj2CkQCXLGrzdfYXD8B54wPTM9TqJAHcKfFDyW",
      "tx_root": "CMwUsP8q4DTBUYxXm12jVwC8xTD8L1T1n3jdKLQVh6bm",
      "validator_proposals": [],
      "validator_reward": "0"
    },
    "receipts": [],
    "transactions": [
      {
        "actions": [
          {
            "FunctionCall": {
              "args": "eyJyZWNvcmRfaWQiOjEsInJlY29yZCI6IkhlbGxvLCBOZWFyIFByb3RvY29sISJ9",
              "deposit": "0",
              "gas": 50000000000000,
              "method_name": "write_record"
            }
          }
        ],
        "hash": "J3KbUXF9YPu2eGnbDCACxGvmMDZMdP7acGYhVLHGu9y2",
        "nonce": 187309654000001,
        "priority_fee": 0,
        "public_key": "ed25519:EddTahJwZpJjYPPmat7DBm1m2vdrFBzVv7e3T4hzkENd",
        "receiver_id": "contract.rpc-examples.testnet",
        "signature": "ed25519:3opUQgg5eNQmE2LJ8zJiitBAVLDFR3svk8LC5VtVGorQuq8jWLocKAt7B4xb6n7DhH8zSVCWcRRrmVL9f1wHiVXa",
        "signer_id": "account.rpc-examples.testnet"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/complex-call/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=query \
  params:='{
    "request_type": "call_function",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet",
    "method_name": "get_record",
    "args_base64": "ewogICJyZWNvcmRfaWQiOiAxCn0="
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/complex-call/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "call_function",
  finality: "final",
  account_id: "contract.rpc-examples.testnet",
  method_name: "get_record",
  args_base64: "ewogICJyZWNvcmRfaWQiOiAxCn0=",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/complex-call/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "call_function",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet",
    "method_name": "get_record",
    "args_base64": "ewogICJyZWNvcmRfaWQiOiAxCn0="
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/complex-call/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "8Gp8x1ZcanL3C2ris9rgk1nY8v6MuickLWeM6Gj2jGKs",
    "block_height": 187445443,
    "logs": [],
    "result": [
      34, 72, 101, 108, 108, 111, 44, 32, 78, 101, 97, 114, 32, 80, 114, 111,
      116, 111, 99, 111, 108, 33, 34
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="7">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> is invalid
      </td>
      <td>
        <ul>
          <li>
            Provide a valid <code>account_id</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> has not been found while viewing
        since the account has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>account_id</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_CONTRACT_CODE</td>
      <td>200</td>
      <td>
        The requested <code>contract_code</code> has not been found while
        viewing
      </td>
      <td>
        <ul>
          <li>
            Check the <code>public_key</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>CONTRACT_EXECUTION_ERROR</td>
      <td>200</td>
      <td>
        The execution of the view function call failed (crashed, run out of the
        default 200 TGas limit, etc)
      </td>
      <td>
        <ul>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>200</td>
      <td>
        The node was unable to find the requested data because it does not track
        the shard where data is present
      </td>
      <td>
        <ul>
          <li>
            Send a request to a different node which might track the shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import SimpleCallRequestJson from "./simple-call/request-json.mdx";
import SimpleCallRequestJs from "./simple-call/request-js.mdx";
import SimpleCallRequestBash from "./simple-call/request-bash.mdx";
import SimpleCallResponseJson from "./simple-call/response-json.mdx";
import ComplexCallRequestJson from "./complex-call/request-json.mdx";
import ComplexCallRequestJs from "./complex-call/request-js.mdx";
import ComplexCallRequestBash from "./complex-call/request-bash.mdx";
import ComplexCallResponseJson from "./complex-call/response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Call a contract function {#call-a-contract-function}

> Allows you to call a contract method as a [view function](../../tools/near-cli#contract).

- method: `query`
- params:
  - `request_type`: `call_function`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_
  - `method_name`: `get_method_name` (example [`view` methods](https://github.com/near/core-contracts/blob/master/staking-pool/src/lib.rs#L317))
  - `args_base64`: `method_arguments_base_64_encoded`

`get_greeting` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <SimpleCallRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <SimpleCallRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <SimpleCallRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/call-get_greeting.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <p>
    <SimpleCallResponseJson />
    **Note**: `[34, 71, ..., 33, 34]`
    is an array of bytes, to be specific it is an ASCII code of
    `"Greetings from NEAR Protocol!"`. `near-sdk-rs` and `near-sdk-js`
    return JSON-serialized results.
  </p>
</details>

---

`get_record` example :

The `args_base64` in this example can be decoded as
``` json
{
  "record_id": 1
}
```

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <ComplexCallRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <ComplexCallRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <ComplexCallRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/call-get_record.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <p>
    <ComplexCallResponseJson />
    **Note**: `[34, 72, ..., 108, 33, 34]` is an array of bytes, to be specific it is an ASCII code of
    `"Hello, Near Protocol!"`. `near-sdk-rs` and `near-sdk-js` return JSON-serialized results.
  </p>
</details>

#### What Could Go Wrong? {#what-could-go-wrong-6}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `call_function` request type:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/simple-call/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=query \
  params:='{
    "request_type": "call_function",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet",
    "method_name": "get_greeting",
    "args_base64": ""
  }'
```



 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/simple-call/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "call_function",
  finality: "final",
  account_id: "contract.rpc-examples.testnet",
  method_name: "get_greeting",
  args_base64: "",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/simple-call/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "call_function",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet",
    "method_name": "get_greeting",
    "args_base64": ""
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/call-a-contract-function/simple-call/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "GTZdXfNmnL6TkJFdBeVMHCadgLuKChVfRNCSVsEQoJ7L",
    "block_height": 187444191,
    "logs": [],
    "result": [
      34, 71, 114, 101, 101, 116, 105, 110, 103, 115, 32, 102, 114, 111, 109,
      32, 78, 69, 65, 82, 32, 80, 114, 111, 116, 111, 99, 111, 108, 33, 34
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account-changes/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account-changes/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## View account changes {#view-account-changes}

> Returns account changes from transactions in a given account.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `account_changes`
  - `account_ids`: [`"example.testnet"`]
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/get-account-changes.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What Could Go Wrong? {#what-could-go-wrong-1}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by
`EXPERIMENTAL_changes` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account-changes/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "account_changes",
    "account_ids": ["contract.rpc-examples.testnet"],
    "block_id": 187310139
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account-changes/request-js.mdx 

 ```js
const response = await near.connection.provider.accountChanges(
  ["contract.rpc-examples.testnet"],
  { blockId: 187310139 },
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account-changes/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "account_changes",
    "account_ids": ["contract.rpc-examples.testnet"],
    "block_id": 187310139
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account-changes/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "8woqfx6kyjgfgU1S2L6Kur27h5jpBtDTmG8vQ8vpAUut",
    "changes": [
      {
        "cause": {
          "receipt_hash": "FseKd4rmjPSAuEz9zh9b5PfUS4jJV4rB6XkeHwVkyXkk",
          "type": "receipt_processing"
        },
        "change": {
          "account_id": "contract.rpc-examples.testnet",
          "amount": "4999184472524996100000000",
          "code_hash": "GVvBFWDPNmomMwXH4LvQW2cRaZJ8N6gxsdBhbJ8ReVJf",
          "locked": "0",
          "storage_paid_at": 0,
          "storage_usage": 81621
        },
        "type": "account_update"
      },
      {
        "cause": {
          "receipt_hash": "FseKd4rmjPSAuEz9zh9b5PfUS4jJV4rB6XkeHwVkyXkk",
          "type": "action_receipt_gas_reward"
        },
        "change": {
          "account_id": "contract.rpc-examples.testnet",
          "amount": "4999212038891301300000000",
          "code_hash": "GVvBFWDPNmomMwXH4LvQW2cRaZJ8N6gxsdBhbJ8ReVJf",
          "locked": "0",
          "storage_paid_at": 0,
          "storage_usage": 81621
        },
        "type": "account_update"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="5">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> is invalid
      </td>
      <td>
        <ul>
          <li>
            Provide a valid <code>account_id</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> has not been found while viewing
        since the account has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>account_id</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>200</td>
      <td>
        The node was unable to find the requested data because it does not track
        the shard where data is present
      </td>
      <td>
        <ul>
          <li>
            Send a request to a different node which might track the shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## View account {#view-account}

> Returns basic account information.

- method: `query`
- params:
  - `request_type`: `view_account`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: _`"example.testnet"`_

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/get-account.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What Could Go Wrong? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `view_account` request type:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=query \
  params:='{
    "request_type": "view_account",
    "finality": "final",
    "account_id": "account.rpc-examples.testnet"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "view_account",
  finality: "final",
  account_id: "account.rpc-examples.testnet",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_account",
    "finality": "final",
    "account_id": "account.rpc-examples.testnet"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-account/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "amount": "999788200694421800000000",
    "block_hash": "56xEo2LorUFVNbkFhCncFSWNiobdp1kzm14nZ47b5JVW",
    "block_height": 187440904,
    "code_hash": "11111111111111111111111111111111",
    "locked": "0",
    "storage_paid_at": 0,
    "storage_usage": 410
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## View contract code changes {#view-contract-code-changes}

> Returns code changes made when deploying a contract. Change is returned is a
> base64 encoded WASM file.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `contract_code_changes`
  - `account_ids`: `["example.testnet"]`,
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/get-contract-wasm-changes.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What Could Go Wrong? {#what-could-go-wrong-5}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "contract_code_changes",
    "account_ids": ["contract.rpc-examples.testnet"],
    "block_id": 187309439
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/request-js.mdx 

 ```js
const response = await near.connection.provider.contractCodeChanges(
  ["contract.rpc-examples.testnet"],
  { blockId: 187309439 },
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "contract_code_changes",
    "account_ids": ["contract.rpc-examples.testnet"],
    "block_id": 187309439
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code-changes/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "D1ZY3y51Z2v5tXq2nZPmXHgA3zZsPBzbtwHXjCvAEuLV",
    "changes": [
      {
        "cause": {
          "receipt_hash": "AR4cxtxc52WfnZcGEZHmPfQ1Dk3vQNb7vjSyicykfJWZ",
          "type": "receipt_processing"
        },
        "change": {
          "account_id": "contract.rpc-examples.testnet",
          "code_base64": "AGFzbQEAAAABugEbYAJ/fwF/YAN/f38Bf2ACf38AYAN/..."
        },
        "type": "contract_code_update"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="6">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> is invalid
      </td>
      <td>
        <ul>
          <li>
            Provide a valid <code>account_id</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> has not been found while viewing
        since the account has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>account_id</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_CONTRACT_CODE</td>
      <td>200</td>
      <td>
        The account does not have any <code>contract</code> deployed on it
      </td>
      <td>
        <ul>
          <li>Use different account</li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>200</td>
      <td>
        The node was unable to find the requested data because it does not track
        the shard where data is present
      </td>
      <td>
        <ul>
          <li>
            Send a request to a different node which might track the shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## View contract code {#view-contract-code}

> Returns the contract code (Wasm binary) deployed to the account.
> Please note that the returned code will be encoded in base64.

- method: `query`
- params:
  - `request_type`: `view_code`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: `"example.testnet"`,

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/get-contract-wasm.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What Could Go Wrong? {#what-could-go-wrong-2}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `view_code` request type:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=query \
  params:='{
    "request_type": "view_code",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "view_code",
  finality: "final",
  account_id: "contract.rpc-examples.testnet",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_code",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-code/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "bxucHpnP8VsiB3pLvA7DpBwri9x1DCZxVfBNkrdWbqn",
    "block_height": 187441984,
    "code_base64": "AGFzbQEAAAABugEbYAJ/fwF/YAN/f38Bf2ACf38AYAN/...",
    "hash": "GVvBFWDPNmomMwXH4LvQW2cRaZJ8N6gxsdBhbJ8ReVJf"
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NOT_SYNCED_YET</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## View contract state changes {#view-contract-state-changes}

> Returns the state change details of a contract based on the key prefix
> (encoded to base64). Pass an empty string for this param if you would like
> to return all state changes.

- method: `EXPERIMENTAL_changes`
- params:
  - `changes_type`: `data_changes`
  - `account_ids`: `["example.testnet"]`,
  - `key_prefix_base64`: `"base64 encoded key value"`,
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/get-contract-state-changes.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What Could Go Wrong? {#what-could-go-wrong-4}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_changes` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_changes \
  params:='{
    "changes_type": "data_changes",
    "account_ids": ["contract.rpc-examples.testnet"],
    "key_prefix_base64": "",
    "block_id": 187310139
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/request-js.mdx 

 ```js
const response = await near.connection.provider.contractStateChanges(
  ["contract.rpc-examples.testnet"],
  { blockId: 187310139 },
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_changes",
  "params": {
    "changes_type": "data_changes",
    "account_ids": ["contract.rpc-examples.testnet"],
    "key_prefix_base64": "",
    "block_id": 187310139
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state-changes/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "8woqfx6kyjgfgU1S2L6Kur27h5jpBtDTmG8vQ8vpAUut",
    "changes": [
      {
        "cause": {
          "receipt_hash": "FseKd4rmjPSAuEz9zh9b5PfUS4jJV4rB6XkeHwVkyXkk",
          "type": "receipt_processing"
        },
        "change": {
          "account_id": "contract.rpc-examples.testnet",
          "key_base64": "U1RBVEU=",
          "value_base64": "HQAAAEdyZWV0aW5ncyBmcm9tIE5FQVIgUHJvdG9jb2whAQAAAHI="
        },
        "type": "data_update"
      },
      {
        "cause": {
          "receipt_hash": "FseKd4rmjPSAuEz9zh9b5PfUS4jJV4rB6XkeHwVkyXkk",
          "type": "receipt_processing"
        },
        "change": {
          "account_id": "contract.rpc-examples.testnet",
          "key_base64": "cgEAAAAAAAAA",
          "value_base64": "FQAAAEhlbGxvLCBOZWFyIFByb3RvY29sIQ=="
        },
        "type": "data_update"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="7">HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INVALID_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> is invalid
      </td>
      <td>
        <ul>
          <li>
            Provide a valid <code>account_id</code>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_ACCOUNT</td>
      <td>200</td>
      <td>
        The requested <code>account_id</code> has not been found while viewing
        since the account has not been created or has been already deleted
      </td>
      <td>
        <ul>
          <li>
            Check the <code>account_id</code>
          </li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_CONTRACT_CODE</td>
      <td>200</td>
      <td>
        The account does not have any <code>contract</code> deployed on it
      </td>
      <td>
        <ul>
          <li>Query and account with contract deployed</li>
          <li>
            Specify a different block or retry if you request the latest state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TOO_LARGE_CONTRACT_STATE</td>
      <td>200</td>
      <td>
        The requested contract state is too large to be returned from this node
        (the default limit is 50kb of state size)
      </td>
      <td>
        <ul>
          <li>
            Send the request to a node with larger limits in order to view the
            requested state
          </li>
          <li>
            Spin up your own node where you can increase the limits to view
            state
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNAVAILABLE_SHARD</td>
      <td>200</td>
      <td>
        The node was unable to find the requested data because it does not track
        the shard where data is present
      </td>
      <td>
        <ul>
          <li>
            Send a request to a different node which might track the shard
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>NO_SYNCED_BLOCKS</td>
      <td>200</td>
      <td>
        The node is still syncing and the requested block is not in the database
        yet
      </td>
      <td>
        <ul>
          <li>Wait until the node finish syncing</li>
          <li>Send a request to a different node which is synced</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## View contract state {#view-contract-state}

> Returns the state (key value pairs) of a contract based on the key prefix
> (base64 encoded). Pass an empty string for `prefix_base64` if you would like
> to return the entire state. Please note that the returned state will be base64
> encoded as well.

- method: `query`
- params:
  - `request_type`: `view_state`
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)
  - `account_id`: `"example.testnet"`,
  - `prefix_base64`: `""`

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/contracts/get-contract-state.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />

  **Note**: Currently, the response includes a `proof` field directly in the
  `result`, and a `proof` fields on each element of the `values` list. In
  the future, the `result.proof` will be included only if the result is **not empty**,
  and the `proof` field will be removed from all `values`. When parsing the result, you
  should accept objects with or without these fields set.
</details>

> **Heads up**
>
> There is a limitation on default RPC nodes. You won't be able to get the
> contract state if it is too big. The default limit of for contract state is 50kb
> of state size. You're able to change the limits if you
> [run your own RPC node](https://near-nodes.io/validator/compile-and-run-a-node)
> with adjusted `trie_viewer_state_size_limit` value in `config.json`

#### What Could Go Wrong? {#what-could-go-wrong-3}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `view_state` request type:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=query \
  params:='{
    "request_type": "view_state",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet",
    "prefix_base64": ""
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state/request-js.mdx 

 ```js
const response = await near.connection.provider.query({
  request_type: "view_state",
  finality: "final",
  account_id: "contract.rpc-examples.testnet",
  prefix_base64: "",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "query",
  "params": {
    "request_type": "view_state",
    "finality": "final",
    "account_id": "contract.rpc-examples.testnet",
    "prefix_base64": ""
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/contracts/view-contract-state/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "block_hash": "GN5R7S8mMTEkUT1njWu9jARV29G7izVDjdSNs976BJVw",
    "block_height": 187442491,
    "values": [
      {
        "key": "U1RBVEU=",
        "value": "HQAAAEdyZWV0aW5ncyBmcm9tIE5FQVIgUHJvdG9jb2whAQAAAHI="
      },
      {
        "key": "cgEAAAAAAAAA",
        "value": "FQAAAEhlbGxvLCBOZWFyIFByb3RvY29sIQ=="
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/block-hash/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=gas_price \
  params:='["6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/block-hash/request-js.mdx 

 ```js
const response = await near.connection.provider.gasPrice(
  "6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w",
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/block-hash/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "gas_price",
  "params": ["6RWmTYhXCzjMjoY3Mz1rfFcnBm8E6XeDDbFEPUA4sv1w"]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/block-height/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=gas_price \
  params:='[187310138]'
````


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/block-height/request-js.mdx 

 ```js
const response = await near.connection.provider.gasPrice(187310138);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/block-height/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "gas_price",
  "params": [187310138]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to an archival node
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import BlockHeightRequestJson from "./block-height/request-json.mdx";
import BlockHeightRequestJs from "./block-height/request-js.mdx";
import BlockHeightRequestBash from "./block-height/request-bash.mdx";
import BlockHashRequestJson from "./block-hash/request-json.mdx";
import BlockHashRequestJs from "./block-hash/request-js.mdx";
import BlockHashRequestBash from "./block-hash/request-bash.mdx";
import LatestRequestJson from "./latest/request-json.mdx";
import LatestRequestJs from "./latest/request-js.mdx";
import LatestRequestBash from "./latest/request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Gas Price {#gas-price}

> Returns gas price for a specific `block_height` or `block_hash`.
>
> - Using `[null]` will return the most recent block's gas price.

- method: `gas_price`
- params: `[block_height]`, `["block_hash"]`, or `[null]`

`null` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <LatestRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <LatestRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <LatestRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/gas/get-latest-gas-price.json" />
  </TabItem>
</Tabs>

`block_height` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockHeightRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockHeightRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockHeightRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/gas/get-gas-price-by-block-height.json" />
  </TabItem>
</Tabs>

`block_hash` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <BlockHashRequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <BlockHashRequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <BlockHashRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/gas/get-gas-price-by-block-hash.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `gas_price` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/latest/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=gas_price \
  params:='[null]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/latest/request-js.mdx 

 ```js
const response = await near.connection.provider.gasPrice(null);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/latest/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "gas_price",
  "params": [null]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/gas/gas-price/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "result": {
    "gas_price": "100000000"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/maintenance-windows/maintenance-windows/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/maintenance-windows/maintenance-windows/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Maintenance windows {#maintenance-windows}

> The maintenance windows for a specific validator are future block height
> ranges in current epoch, in which the validator does not need produce block or chunk
> If the provided account is not a validator, then it will return the range
> from now to the end of the epoch.

- method: `EXPERIMENTAL_maintenance_windows`
- params:
  - `account_id`

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/maintenance-windows/get-maintenance-windows.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <p>
    The result will be a list of future maintenance windows in current epoch.
    For example a window `[1028, 1031]` includes 1028, 1029 and 1030.
    <ResponseJson />
  </p>
</details>

#### What Could Go Wrong?? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `maintenance_windows` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/maintenance-windows/maintenance-windows/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_maintenance_windows \
  params:='{
    "account_id": "node0"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/maintenance-windows/maintenance-windows/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_maintenance_windows",
  "params": {
    "account_id": "node0"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/maintenance-windows/maintenance-windows/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "result": [
    [1028, 1031],
    [1034, 1038]
  ]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/network-info/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/network/network-info/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Network Info {#network-info}

> Returns the current state of node network connections (active peers, transmitted data, etc.)

- method: `network_info`
- params: _none_

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/network/get-network-info.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-1}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `network_info` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/network/network-info/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=network_info \
  params:='[]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/network-info/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "network_info",
  "params": []
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/network-info/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "active_peers": [
      {
        "id": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "addr": "35.193.24.121:24567",
        "account_id": null
      }
    ],
    "num_active_peers": 34,
    "peer_max_count": 40,
    "sent_bytes_per_sec": 17754754,
    "received_bytes_per_sec": 492116,
    "known_producers": [
      {
        "account_id": "node0",
        "addr": null,
        "peer_id": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/node-status/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/network/node-status/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Node Status {#node-status}

> Returns general status of a given node (sync status, nearcore node version,
> protocol version, etc.), and the current set of validators.

- method: `status`
- params: `[]`

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/network/get-node-status.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `status` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/network/node-status/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=status \
  params:='[]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/node-status/request-js.mdx 

 ```js
const response = await near.connection.provider.status();
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/node-status/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "status",
  "params": []
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/node-status/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "chain_id": "testnet",
    "genesis_hash": "FWJ9kR6KFWoyMoNjpLXXGHeuiy7tEY6GmoFeCA5yuc6b",
    "latest_protocol_version": 73,
    "node_key": null,
    "node_public_key": "ed25519:DC7DbfZq4dkPqUKaKpWNimgtRBxnD9rja2KcZRs4e3DL",
    "protocol_version": 73,
    "rpc_addr": "0.0.0.0:3030",
    "sync_info": {
      "earliest_block_hash": "uz2gwgYxpx8dHsjgiPQefbwAhWk41CCvEmHU7ktYE2C",
      "earliest_block_height": 187251995,
      "earliest_block_time": "2025-02-10T13:54:22.616904144Z",
      "epoch_id": "94jeudySZcxGBSVgKXn3xPT3P5iFF6YcnxC43F15QtkQ",
      "epoch_start_height": 187443633,
      "latest_block_hash": "EfL8Rc1EH13UxgbJB4skt8xSF8vojNQPcAX1opf6RFab",
      "latest_block_height": 187456272,
      "latest_block_time": "2025-02-12T22:10:10.530341781Z",
      "latest_state_root": "3Vpebx4DuKAYmMjL96XMmLqWYUfuS2raZWoAbxFxeqBm",
      "syncing": false
    },
    "uptime_sec": 6020117,
    "validator_account_id": null,
    "validator_public_key": null,
    "validators": [
      {
        "account_id": "kiln.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "node2",
        "is_slashed": false
      },
      {
        "account_id": "node3",
        "is_slashed": false
      },
      {
        "account_id": "node0",
        "is_slashed": false
      },
      {
        "account_id": "node1",
        "is_slashed": false
      },
      {
        "account_id": "legends.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "aurora.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "01node.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "stakely_v2.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "chorusone.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "ni.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "foundryusa.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "lunanova2.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "everstake.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "fastnear.testnet",
        "is_slashed": false
      },
      {
        "account_id": "pionear-0.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "stakesstone.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "stakeway.pool.f863973.m0",
        "is_slashed": false
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "is_slashed": false
      }
    ],
    "version": {
      "build": "2.4.0-rc.1",
      "rustc_version": "1.82.0",
      "version": "2.4.0-rc.1"
    }
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/epoch-hash/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=validators \
  params:='{
    "epoch_id": "94jeudySZcxGBSVgKXn3xPT3P5iFF6YcnxC43F15QtkQ"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/epoch-hash/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": {
    "epoch_id": "94jeudySZcxGBSVgKXn3xPT3P5iFF6YcnxC43F15QtkQ"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_EPOCH</td>
      <td>200</td>
      <td>An epoch for the provided block can't be found in a database</td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to an archival node
          </li>
          <li>
            Check that the requested block is the last block of some epoch
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import EpochHashRequestJson from "./epoch-hash/request-json.mdx";
import EpochHashRequestBash from "./epoch-hash/request-bash.mdx";
import LatestRequestJson from "./latest/request-json.mdx";
import LatestRequestBash from "./latest/request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Validation Status {#validation-status}

> Queries active validators on the network returning details and the state of
> validation on the blockchain.

- method: `validators`
- params:
  - `epoch_id` _OR_ `[null]`

**Note:**
You can obtain the `epoch_id` from a block that belongs to a specific epoch. <br />
If you want to retrieve the current list of validators, pass `null` as the parameter. <br />
Additionally, you can query validators for past epochs by providing the `epoch_id`
of the desired past epoch.

`null` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <LatestRequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <LatestRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/network/get-latest-validators.json" />
  </TabItem>
</Tabs>

`epoch_id` example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <EpochHashRequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <EpochHashRequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/network/get-validators-by-epoch-id.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-2}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `validators` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/latest/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=validators \
  params:='[null]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/latest/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "validators",
  "params": [null]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/network/validation-status/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "current_fishermen": [],
    "current_proposals": [
      {
        "account_id": "01node.pool.f863973.m0",
        "public_key": "ed25519:3iNqnvBgxJPXCxu6hNdvJso1PEAc1miAD35KQMBCA3aL",
        "stake": "14508308808748255650142126217547",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "aurora.pool.f863973.m0",
        "public_key": "ed25519:9c7mczZpNzJz98V1sDeGybfD4gMybP4JKHotH8RrrHTm",
        "stake": "17826847625047324847852411794769",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "bee1stake.pool.f863973.m0",
        "public_key": "ed25519:B7Mwy3sCCJ6GZzEojsKFXMjLQfVXPDC4Q1LjuHoZcyM6",
        "stake": "471694761517302606589435816113",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "bg-1.pool.f863973.m0",
        "public_key": "ed25519:BWaBJ1hYmZsarajYwt8VdKineUWza5fSd2mnoMdMSZAP",
        "stake": "193323957787516169318606113781",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "public_key": "ed25519:8g4P5EXyp2b2pfVMHY1QLfkRcY59hjPfWrFCKUWX3RmR",
        "stake": "865214562736652423187753081175",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "colossus.pool.f863973.m0",
        "public_key": "ed25519:FFoMFmpBb7Z4jJE6xivyBRRFP3CDmkWeMrQ7W3jqVBAJ",
        "stake": "131506697068344803997879646937",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "everstake.pool.f863973.m0",
        "public_key": "ed25519:4LDN8tZUTRRc4siGmYCPA67tRyxStACDchdGDZYKdFsw",
        "stake": "3162752192329673966382166073862",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "lavenderfive.pool.f863973.m0",
        "public_key": "ed25519:AzwAiLDqprZKpDjhsH7dfyvFdfSasmPTjuJUAHfX1Pg4",
        "stake": "31016698022520444934810183598",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "pionear-0.pool.f863973.m0",
        "public_key": "ed25519:315y78D1DURpek1qZgp2vZSEkvWaLpgCmNj3YyVRBupW",
        "stake": "2458138661861406384369486851832",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "pool01b.carlo01.testnet",
        "public_key": "ed25519:GNiQR9xKfwqQLckbfuHo2yRnMnbdCapxK74LTBQxB3DP",
        "stake": "5625085084130210554951106454",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "stakely_v2.pool.f863973.m0",
        "public_key": "ed25519:7BanKZKGvFjK5Yy83gfJ71vPhqRwsDDyVHrV2FMJCUWr",
        "stake": "12258015381474151302438412883474",
        "validator_stake_struct_version": "V1"
      },
      {
        "account_id": "stakeway.pool.f863973.m0",
        "public_key": "ed25519:CUzUvC55STwBYCM9rCjPXVC9P9n771QsexigcaV9FzQE",
        "stake": "2323231977216618436691170859463",
        "validator_stake_struct_version": "V1"
      }
    ],
    "current_validators": [
      {
        "account_id": "kiln.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 2622,
        "num_expected_chunks": 9298,
        "num_expected_chunks_per_shard": [9298],
        "num_expected_endorsements": 79788,
        "num_expected_endorsements_per_shard": [13298],
        "num_produced_blocks": 2622,
        "num_produced_chunks": 9288,
        "num_produced_chunks_per_shard": [9288],
        "num_produced_endorsements": 79625,
        "num_produced_endorsements_per_shard": [13274],
        "public_key": "ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W",
        "shards": [0],
        "stake": "92891729926051855086331836750992"
      },
      {
        "account_id": "node2",
        "is_slashed": false,
        "num_expected_blocks": 2043,
        "num_expected_chunks": 12205,
        "num_expected_chunks_per_shard": [12205],
        "num_expected_endorsements": 79788,
        "num_expected_endorsements_per_shard": [13298],
        "num_produced_blocks": 2043,
        "num_produced_chunks": 12201,
        "num_produced_chunks_per_shard": [12201],
        "num_produced_endorsements": 79726,
        "num_produced_endorsements_per_shard": [13292],
        "public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "shards": [2],
        "stake": "70078722808826224703158216890648"
      },
      {
        "account_id": "node3",
        "is_slashed": false,
        "num_expected_blocks": 2021,
        "num_expected_chunks": 6701,
        "num_expected_chunks_per_shard": [6701],
        "num_expected_endorsements": 79786,
        "num_expected_endorsements_per_shard": [13298],
        "num_produced_blocks": 2021,
        "num_produced_chunks": 6699,
        "num_produced_chunks_per_shard": [6699],
        "num_produced_endorsements": 79694,
        "num_produced_endorsements_per_shard": [13291],
        "public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
        "shards": [3],
        "stake": "69920729382306083222333791762346"
      },
      {
        "account_id": "node0",
        "is_slashed": false,
        "num_expected_blocks": 1865,
        "num_expected_chunks": 6227,
        "num_expected_chunks_per_shard": [6227],
        "num_expected_endorsements": 79787,
        "num_expected_endorsements_per_shard": [13298],
        "num_produced_blocks": 1865,
        "num_produced_chunks": 6226,
        "num_produced_chunks_per_shard": [6226],
        "num_produced_endorsements": 79704,
        "num_produced_endorsements_per_shard": [13292],
        "public_key": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX",
        "shards": [3],
        "stake": "65137754608752835889247541026299"
      },
      {
        "account_id": "node1",
        "is_slashed": false,
        "num_expected_blocks": 1815,
        "num_expected_chunks": 11080,
        "num_expected_chunks_per_shard": [11080],
        "num_expected_endorsements": 79788,
        "num_expected_endorsements_per_shard": [13298],
        "num_produced_blocks": 1815,
        "num_produced_chunks": 11075,
        "num_produced_chunks_per_shard": [11075],
        "num_produced_endorsements": 79730,
        "num_produced_endorsements_per_shard": [13291],
        "public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
        "shards": [1],
        "stake": "63263814354522829877199449732381"
      },
      {
        "account_id": "legends.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 658,
        "num_expected_chunks": 2226,
        "num_expected_chunks_per_shard": [2226],
        "num_expected_endorsements": 77942,
        "num_expected_endorsements_per_shard": [12991],
        "num_produced_blocks": 658,
        "num_produced_chunks": 2224,
        "num_produced_chunks_per_shard": [2224],
        "num_produced_endorsements": 77796,
        "num_produced_endorsements_per_shard": [12963],
        "public_key": "ed25519:AhQ6sUifJYgjqarXSAzdDZU9ZixpUesP9JEH1Vr7NbaF",
        "shards": [0],
        "stake": "21699960146196584008369593130963"
      },
      {
        "account_id": "aurora.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 526,
        "num_expected_chunks": 7605,
        "num_expected_chunks_per_shard": [7605],
        "num_expected_endorsements": 76454,
        "num_expected_endorsements_per_shard": [12737],
        "num_produced_blocks": 526,
        "num_produced_chunks": 7603,
        "num_produced_chunks_per_shard": [7603],
        "num_produced_endorsements": 76389,
        "num_produced_endorsements_per_shard": [12728],
        "public_key": "ed25519:9c7mczZpNzJz98V1sDeGybfD4gMybP4JKHotH8RrrHTm",
        "shards": [4],
        "stake": "17821019225873468551948241890887"
      },
      {
        "account_id": "01node.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 423,
        "num_expected_chunks": 1503,
        "num_expected_chunks_per_shard": [1503],
        "num_expected_endorsements": 73729,
        "num_expected_endorsements_per_shard": [12329],
        "num_produced_blocks": 423,
        "num_produced_chunks": 1502,
        "num_produced_chunks_per_shard": [1502],
        "num_produced_endorsements": 73577,
        "num_produced_endorsements_per_shard": [12301],
        "public_key": "ed25519:3iNqnvBgxJPXCxu6hNdvJso1PEAc1miAD35KQMBCA3aL",
        "shards": [0],
        "stake": "14503585729080627951824567828719"
      },
      {
        "account_id": "stakely_v2.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 334,
        "num_expected_chunks": 5337,
        "num_expected_chunks_per_shard": [5337],
        "num_expected_endorsements": 70936,
        "num_expected_endorsements_per_shard": [11814],
        "num_produced_blocks": 334,
        "num_produced_chunks": 5331,
        "num_produced_chunks_per_shard": [5331],
        "num_produced_endorsements": 70854,
        "num_produced_endorsements_per_shard": [11797],
        "public_key": "ed25519:7BanKZKGvFjK5Yy83gfJ71vPhqRwsDDyVHrV2FMJCUWr",
        "shards": [4],
        "stake": "12254024869278462134131091911403"
      },
      {
        "account_id": "chorusone.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 164,
        "num_expected_chunks": 871,
        "num_expected_chunks_per_shard": [871],
        "num_expected_endorsements": 47978,
        "num_expected_endorsements_per_shard": [7926],
        "num_produced_blocks": 164,
        "num_produced_chunks": 871,
        "num_produced_chunks_per_shard": [871],
        "num_produced_endorsements": 47915,
        "num_produced_endorsements_per_shard": [7913],
        "public_key": "ed25519:3TkUuDpzrq75KtJhkuLfNNJBPHR5QEWpDxrter3znwto",
        "shards": [1],
        "stake": "5021605065953771080058901060214"
      },
      {
        "account_id": "ni.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 130,
        "num_expected_chunks": 700,
        "num_expected_chunks_per_shard": [700],
        "num_expected_endorsements": 41432,
        "num_expected_endorsements_per_shard": [6864],
        "num_produced_blocks": 130,
        "num_produced_chunks": 700,
        "num_produced_chunks_per_shard": [700],
        "num_produced_endorsements": 41317,
        "num_produced_endorsements_per_shard": [6843],
        "public_key": "ed25519:GfCfFkLk2twbAWdsS3tr7C2eaiHN3znSfbshS5e8NqBS",
        "shards": [2],
        "stake": "4171300662937553143029051488796"
      },
      {
        "account_id": "foundryusa.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 129,
        "num_expected_chunks": 727,
        "num_expected_chunks_per_shard": [727],
        "num_expected_endorsements": 41314,
        "num_expected_endorsements_per_shard": [6832],
        "num_produced_blocks": 129,
        "num_produced_chunks": 727,
        "num_produced_chunks_per_shard": [727],
        "num_produced_endorsements": 38980,
        "num_produced_endorsements_per_shard": [6705],
        "public_key": "ed25519:ABGnMW8c87ZKWxvZLLWgvrNe72HN7UoSf4cTBxCHbEE5",
        "shards": [1],
        "stake": "4002828237905742589189924266507"
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 99,
        "num_expected_chunks": 370,
        "num_expected_chunks_per_shard": [370],
        "num_expected_endorsements": 41252,
        "num_expected_endorsements_per_shard": [6869],
        "num_produced_blocks": 99,
        "num_produced_chunks": 370,
        "num_produced_chunks_per_shard": [370],
        "num_produced_endorsements": 41189,
        "num_produced_endorsements_per_shard": [6858],
        "public_key": "ed25519:6LFwyEEsqhuDxorWfsKcPPs324zLWTaoqk4o6RDXN7Qc",
        "shards": [3],
        "stake": "3540207403371800913697591351067"
      },
      {
        "account_id": "lunanova2.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 88,
        "num_expected_chunks": 620,
        "num_expected_chunks_per_shard": [620],
        "num_expected_endorsements": 41311,
        "num_expected_endorsements_per_shard": [6932],
        "num_produced_blocks": 88,
        "num_produced_chunks": 620,
        "num_produced_chunks_per_shard": [620],
        "num_produced_endorsements": 41267,
        "num_produced_endorsements_per_shard": [6926],
        "public_key": "ed25519:9Jv6e9Kye4wM9EL1XJvXY8CYsLi1HLdRKnTzXBQY44w9",
        "shards": [1],
        "stake": "3482601242374916990980148061500"
      },
      {
        "account_id": "everstake.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 86,
        "num_expected_chunks": 5154,
        "num_expected_chunks_per_shard": [5154],
        "num_expected_endorsements": 33613,
        "num_expected_endorsements_per_shard": [5662],
        "num_produced_blocks": 86,
        "num_produced_chunks": 5152,
        "num_produced_chunks_per_shard": [5152],
        "num_produced_endorsements": 33576,
        "num_produced_endorsements_per_shard": [5652],
        "public_key": "ed25519:4LDN8tZUTRRc4siGmYCPA67tRyxStACDchdGDZYKdFsw",
        "shards": [5],
        "stake": "3161722580047357404436371465448"
      },
      {
        "account_id": "fastnear.testnet",
        "is_slashed": false,
        "num_expected_blocks": 69,
        "num_expected_chunks": 4219,
        "num_expected_chunks_per_shard": [4219],
        "num_expected_endorsements": 33662,
        "num_expected_endorsements_per_shard": [5583],
        "num_produced_blocks": 69,
        "num_produced_chunks": 4216,
        "num_produced_chunks_per_shard": [4216],
        "num_produced_endorsements": 33275,
        "num_produced_endorsements_per_shard": [5534],
        "public_key": "ed25519:FUSbEhRG22AiQEUr8PgRJJjdYqnsBbzTmquLchZ3EuaJ",
        "shards": [5],
        "stake": "2537831618716734010878317070489"
      },
      {
        "account_id": "pionear-0.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 64,
        "num_expected_chunks": 271,
        "num_expected_chunks_per_shard": [271],
        "num_expected_endorsements": 33604,
        "num_expected_endorsements_per_shard": [5575],
        "num_produced_blocks": 64,
        "num_produced_chunks": 271,
        "num_produced_chunks_per_shard": [271],
        "num_produced_endorsements": 33552,
        "num_produced_endorsements_per_shard": [5567],
        "public_key": "ed25519:315y78D1DURpek1qZgp2vZSEkvWaLpgCmNj3YyVRBupW",
        "shards": [0],
        "stake": "2457338431580190425147558948590"
      },
      {
        "account_id": "stakesstone.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 67,
        "num_expected_chunks": 3925,
        "num_expected_chunks_per_shard": [3925],
        "num_expected_endorsements": 33622,
        "num_expected_endorsements_per_shard": [5604],
        "num_produced_blocks": 67,
        "num_produced_chunks": 3924,
        "num_produced_chunks_per_shard": [3924],
        "num_produced_endorsements": 33575,
        "num_produced_endorsements_per_shard": [5595],
        "public_key": "ed25519:3aAdsKUuzZbjW9hHnmLWFRKwXjmcxsnLNLfNL4gP1wJ8",
        "shards": [5],
        "stake": "2392729489880088390499500312797"
      },
      {
        "account_id": "stakeway.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 72,
        "num_expected_chunks": 393,
        "num_expected_chunks_per_shard": [393],
        "num_expected_endorsements": 33705,
        "num_expected_endorsements_per_shard": [5701],
        "num_produced_blocks": 72,
        "num_produced_chunks": 393,
        "num_produced_chunks_per_shard": [393],
        "num_produced_endorsements": 32290,
        "num_produced_endorsements_per_shard": [5686],
        "public_key": "ed25519:CUzUvC55STwBYCM9rCjPXVC9P9n771QsexigcaV9FzQE",
        "shards": [2],
        "stake": "2322475664929977341656713227424"
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 23,
        "num_expected_chunks": 356,
        "num_expected_chunks_per_shard": [356],
        "num_expected_endorsements": 13298,
        "num_expected_endorsements_per_shard": [2206],
        "num_produced_blocks": 23,
        "num_produced_chunks": 356,
        "num_produced_chunks_per_shard": [356],
        "num_produced_endorsements": 12619,
        "num_produced_endorsements_per_shard": [2177],
        "public_key": "ed25519:8g4P5EXyp2b2pfVMHY1QLfkRcY59hjPfWrFCKUWX3RmR",
        "shards": [4],
        "stake": "864932897923367748455848113029"
      },
      {
        "account_id": "bee1stake.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "num_produced_endorsements": 12590,
        "public_key": "ed25519:B7Mwy3sCCJ6GZzEojsKFXMjLQfVXPDC4Q1LjuHoZcyM6",
        "shards": [],
        "stake": "471541204349192086717416391804"
      },
      {
        "account_id": "bg-1.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "num_produced_endorsements": 13059,
        "public_key": "ed25519:BWaBJ1hYmZsarajYwt8VdKineUWza5fSd2mnoMdMSZAP",
        "shards": [],
        "stake": "193261022264150168446871422383"
      },
      {
        "account_id": "bdcnear.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "num_produced_endorsements": 11657,
        "public_key": "ed25519:38XzZgGzXkVU1WGPmAebVgKUS7TNoTQ4BbwYmSaJtB5E",
        "shards": [],
        "stake": "152253956367503132443302137897"
      },
      {
        "account_id": "colossus.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "num_produced_endorsements": 12525,
        "public_key": "ed25519:FFoMFmpBb7Z4jJE6xivyBRRFP3CDmkWeMrQ7W3jqVBAJ",
        "shards": [],
        "stake": "131463885701606478224024595560"
      },
      {
        "account_id": "do0k13.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "public_key": "ed25519:BNZEVQLfRVQ6kRDtSiehn5VCdsDfvnmPP6PFEfEF4Kyc",
        "shards": [],
        "stake": "20052755347209554047688885272"
      },
      {
        "account_id": "m340i.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "num_produced_endorsements": 12171,
        "public_key": "ed25519:AAmV17bBMV1AwigkfRXJjZeW45bncxg6Mh3wDD312CxS",
        "shards": [],
        "stake": "12791380004559238408090666856"
      },
      {
        "account_id": "smcvalidator.pool.f863973.m0",
        "is_slashed": false,
        "num_expected_blocks": 0,
        "num_expected_chunks": 0,
        "num_expected_chunks_per_shard": [],
        "num_expected_endorsements": 13298,
        "num_produced_blocks": 0,
        "num_produced_chunks": 0,
        "num_produced_chunks_per_shard": [],
        "public_key": "ed25519:pG4LYsyoAa8yWYG9nsTQ5yBcwke51i3VqeRcMVbE9Q7",
        "shards": [],
        "stake": "11572234249650586892415305619"
      }
    ],
    "epoch_height": 3358,
    "epoch_start_height": 187443633,
    "next_fishermen": [],
    "next_validators": [
      {
        "account_id": "kiln.pool.f863973.m0",
        "public_key": "ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W",
        "shards": [0],
        "stake": "92921980033422214461941381687070"
      },
      {
        "account_id": "node2",
        "public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
        "shards": [2],
        "stake": "70101543880843059439753643153179"
      },
      {
        "account_id": "node3",
        "public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
        "shards": [3],
        "stake": "69943499004029400432138935046376"
      },
      {
        "account_id": "node0",
        "public_key": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX",
        "shards": [3],
        "stake": "65158966659105429729981574314821"
      },
      {
        "account_id": "node1",
        "public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
        "shards": [1],
        "stake": "63284416157941533583511983074616"
      },
      {
        "account_id": "legends.pool.f863973.m0",
        "public_key": "ed25519:AhQ6sUifJYgjqarXSAzdDZU9ZixpUesP9JEH1Vr7NbaF",
        "shards": [0],
        "stake": "21707026718417797003552971028171"
      },
      {
        "account_id": "aurora.pool.f863973.m0",
        "public_key": "ed25519:9c7mczZpNzJz98V1sDeGybfD4gMybP4JKHotH8RrrHTm",
        "shards": [4],
        "stake": "17826847624645549774838011794769"
      },
      {
        "account_id": "01node.pool.f863973.m0",
        "public_key": "ed25519:3iNqnvBgxJPXCxu6hNdvJso1PEAc1miAD35KQMBCA3aL",
        "shards": [0],
        "stake": "14508308808643776172456926217547"
      },
      {
        "account_id": "stakely_v2.pool.f863973.m0",
        "public_key": "ed25519:7BanKZKGvFjK5Yy83gfJ71vPhqRwsDDyVHrV2FMJCUWr",
        "shards": [4],
        "stake": "12258015381384133457889212883474"
      },
      {
        "account_id": "chorusone.pool.f863973.m0",
        "public_key": "ed25519:3TkUuDpzrq75KtJhkuLfNNJBPHR5QEWpDxrter3znwto",
        "shards": [1],
        "stake": "5023240357275531194839534425974"
      },
      {
        "account_id": "ni.pool.f863973.m0",
        "public_key": "ed25519:GfCfFkLk2twbAWdsS3tr7C2eaiHN3znSfbshS5e8NqBS",
        "shards": [2],
        "stake": "4172659043272273212430060733803"
      },
      {
        "account_id": "foundryusa.pool.f863973.m0",
        "public_key": "ed25519:ABGnMW8c87ZKWxvZLLWgvrNe72HN7UoSf4cTBxCHbEE5",
        "shards": [1],
        "stake": "4004136212576286646267651480193"
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "public_key": "ed25519:6LFwyEEsqhuDxorWfsKcPPs324zLWTaoqk4o6RDXN7Qc",
        "shards": [3],
        "stake": "3541360268682365851956864933197"
      },
      {
        "account_id": "lunanova2.pool.f863973.m0",
        "public_key": "ed25519:9Jv6e9Kye4wM9EL1XJvXY8CYsLi1HLdRKnTzXBQY44w9",
        "shards": [1],
        "stake": "3483735348291753982514724379044"
      },
      {
        "account_id": "everstake.pool.f863973.m0",
        "public_key": "ed25519:4LDN8tZUTRRc4siGmYCPA67tRyxStACDchdGDZYKdFsw",
        "shards": [5],
        "stake": "3162752192225120518455066073862"
      },
      {
        "account_id": "fastnear.testnet",
        "public_key": "ed25519:FUSbEhRG22AiQEUr8PgRJJjdYqnsBbzTmquLchZ3EuaJ",
        "shards": [5],
        "stake": "2538658061267693395333896919744"
      },
      {
        "account_id": "pionear-0.pool.f863973.m0",
        "public_key": "ed25519:315y78D1DURpek1qZgp2vZSEkvWaLpgCmNj3YyVRBupW",
        "shards": [0],
        "stake": "2458138661730825288726186851832"
      },
      {
        "account_id": "stakesstone.pool.f863973.m0",
        "public_key": "ed25519:3aAdsKUuzZbjW9hHnmLWFRKwXjmcxsnLNLfNL4gP1wJ8",
        "shards": [5],
        "stake": "2393508680167151178654927962933"
      },
      {
        "account_id": "stakeway.pool.f863973.m0",
        "public_key": "ed25519:CUzUvC55STwBYCM9rCjPXVC9P9n771QsexigcaV9FzQE",
        "shards": [2],
        "stake": "2323231977126165123038870859463"
      },
      {
        "account_id": "bisontrails.pool.f863973.m0",
        "public_key": "ed25519:8g4P5EXyp2b2pfVMHY1QLfkRcY59hjPfWrFCKUWX3RmR",
        "shards": [4],
        "stake": "865214562646576811861753081175"
      },
      {
        "account_id": "bee1stake.pool.f863973.m0",
        "public_key": "ed25519:B7Mwy3sCCJ6GZzEojsKFXMjLQfVXPDC4Q1LjuHoZcyM6",
        "shards": [],
        "stake": "471694761414887680568035816113"
      },
      {
        "account_id": "bg-1.pool.f863973.m0",
        "public_key": "ed25519:BWaBJ1hYmZsarajYwt8VdKineUWza5fSd2mnoMdMSZAP",
        "shards": [],
        "stake": "193323957663594316022106113781"
      },
      {
        "account_id": "bdcnear.pool.f863973.m0",
        "public_key": "ed25519:38XzZgGzXkVU1WGPmAebVgKUS7TNoTQ4BbwYmSaJtB5E",
        "shards": [],
        "stake": "152303537729468030960543152051"
      },
      {
        "account_id": "colossus.pool.f863973.m0",
        "public_key": "ed25519:FFoMFmpBb7Z4jJE6xivyBRRFP3CDmkWeMrQ7W3jqVBAJ",
        "shards": [],
        "stake": "131506696932997797323679646937"
      },
      {
        "account_id": "lavenderfive.pool.f863973.m0",
        "public_key": "ed25519:AzwAiLDqprZKpDjhsH7dfyvFdfSasmPTjuJUAHfX1Pg4",
        "shards": [],
        "stake": "31016697830847968307510183598"
      },
      {
        "account_id": "do0k13.pool.f863973.m0",
        "public_key": "ed25519:BNZEVQLfRVQ6kRDtSiehn5VCdsDfvnmPP6PFEfEF4Kyc",
        "shards": [],
        "stake": "20052755432372793140688885272"
      },
      {
        "account_id": "m340i.pool.f863973.m0",
        "public_key": "ed25519:AAmV17bBMV1AwigkfRXJjZeW45bncxg6Mh3wDD312CxS",
        "shards": [],
        "stake": "12795545505786070882425535528"
      }
    ],
    "prev_epoch_kickout": [
      {
        "account_id": "smcvalidator.pool.f863973.m0",
        "reason": {
          "NotEnoughChunkEndorsements": {
            "expected": 43196,
            "produced": 0
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/genesis-config/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/genesis-config/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Genesis Config {#genesis-config}

> Returns current genesis configuration.

- method: `EXPERIMENTAL_genesis_config`
- params: _none_

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/protocol/get-genesis-config.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_genesis_config` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/genesis-config/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_genesis_config
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/genesis-config/request-js.mdx 

 ```js
const response = await near.connection.provider.experimental_protocolConfig({
  sync_checkpoint: "genesis",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/genesis-config/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_genesis_config"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/genesis-config/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "avg_hidden_validator_seats_per_shard": [0],
    "block_producer_kickout_threshold": 80,
    "chain_id": "testnet",
    "chunk_producer_assignment_changes_limit": 5,
    "chunk_producer_kickout_threshold": 90,
    "chunk_validator_only_kickout_threshold": 80,
    "dynamic_resharding": false,
    "epoch_length": 43200,
    "fishermen_threshold": "340282366920938463463374607431768211455",
    "gas_limit": 1000000000000000,
    "gas_price_adjustment_rate": [1, 100],
    "genesis_height": 42376888,
    "genesis_time": "2020-07-31T03:39:42.911378Z",
    "max_gas_price": "10000000000000000000000",
    "max_inflation_rate": [1, 20],
    "max_kickout_stake_perc": 100,
    "min_gas_price": "5000",
    "minimum_stake_divisor": 10,
    "minimum_stake_ratio": [1, 6250],
    "minimum_validators_per_shard": 1,
    "num_block_producer_seats": 200,
    "num_block_producer_seats_per_shard": [200],
    "num_blocks_per_year": 31536000,
    "num_chunk_only_producer_seats": 300,
    "num_chunk_producer_seats": 100,
    "num_chunk_validator_seats": 300,
    "online_max_threshold": [99, 100],
    "online_min_threshold": [90, 100],
    "protocol_reward_rate": [1, 10],
    "protocol_treasury_account": "near",
    "protocol_upgrade_stake_threshold": [4, 5],
    "protocol_version": 29,
    "shard_layout": {
      "V0": {
        "num_shards": 1,
        "version": 0
      }
    },
    "shuffle_shard_assignment_for_chunk_producers": false,
    "target_validator_mandates_per_shard": 68,
    "total_supply": "2089646653180081825096998107194444",
    "transaction_validity_period": 86400,
    "use_production_config": false,
    "validators": [
      {
        "account_id": "masternode24.pool.f863973.m0",
        "amount": "2096547887468158804726149840014",
        "public_key": "ed25519:9E3JvrQN6VGDGg1WJ3TjBsNyfmrU6kncBcDvvJLj6qHr"
      },
      {
        "account_id": "lunanova.pool.f863973.m0",
        "amount": "6023592217250515747116857534108",
        "public_key": "ed25519:2fZ59qfo9QHNLijoht9cwUb9enSNcnRmXbQn1gKZxvkw"
      },
      {
        "account_id": "node0",
        "amount": "7017386808510582905904716139001",
        "public_key": "ed25519:7PGseFbWxvYVgZ89K1uTJKYoKetWs7BJtbyXDzfbAcqX"
      },
      {
        "account_id": "node1",
        "amount": "7021733510638228632380895173752",
        "public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e"
      },
      {
        "account_id": "nodeasy.pool.f863973.m0",
        "amount": "350028003459257633077889642325",
        "public_key": "ed25519:25Dhg8NBvQhsVTuugav3t1To1X1zKiomDmnh8yN9hHMb"
      },
      {
        "account_id": "valeraverim.pool.f863973.m0",
        "amount": "2460437541222457077732687804254",
        "public_key": "ed25519:3686ABqNUZc1qhLWLHg5xZpBzrWPiUCMNZxcCNmg3e2s"
      },
      {
        "account_id": "node2",
        "amount": "7022280566885326956797181813724",
        "public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5"
      },
      {
        "account_id": "orangeclub.pool.f863973.m0",
        "amount": "3073208665436498671483798256985",
        "public_key": "ed25519:HezFeSzcwuR5wvkqccgMCMnpf1eQkVCfk52tXZEdKZHz"
      },
      {
        "account_id": "tribe-pool.pool.f863973.m0",
        "amount": "502021509894008520748060961431",
        "public_key": "ed25519:CRS4HTSAeiP8FKD3c3ZrCL5pC92Mu1LQaWj22keThwFY"
      },
      {
        "account_id": "staked.pool.f863973.m0",
        "amount": "1835541810883701332840668361355",
        "public_key": "ed25519:D2afKYVaKQ1LGiWbMAZRfkKLgqimTR74wvtESvjx5Ft2"
      },
      {
        "account_id": "node3",
        "amount": "7025309465335462891886410729905",
        "public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su"
      },
      {
        "account_id": "moonlet.pool.f863973.m0",
        "amount": "396044187712024170314465720781",
        "public_key": "ed25519:3e1nVCVGNS3yr6CcUvpDAs3BhiWtyM9uTBWkyVR5Xn3K"
      },
      {
        "account_id": "sweden.pool.f863973.m0",
        "amount": "385869819054217573549654420144",
        "public_key": "ed25519:2RVUnsMEZhGCj1A3vLZBGjj3i9SQ2L46Z1Z41aEgBzXg"
      },
      {
        "account_id": "shawnpool.pool.f863973.m0",
        "amount": "326196336737920044305254508558",
        "public_key": "ed25519:6dfAfW3oy1kp4u9ePuticHy3Y2WDcHwx8yKSdyLNMPSr"
      },
      {
        "account_id": "chorus-one.pool.f863973.m0",
        "amount": "1318859742119402879751178031888",
        "public_key": "ed25519:6LFwyEEsqhuDxorWfsKcPPs324zLWTaoqk4o6RDXN7Qc"
      },
      {
        "account_id": "inotel.pool.f863973.m0",
        "amount": "4945759122706953812641339874642",
        "public_key": "ed25519:C55jH1MCHYGa3tzUyZZdGrJmmCLP22Aa4v88KYpn2xwZ"
      },
      {
        "account_id": "p2p.pool.f863973.m0",
        "amount": "991547852404615467434919132596",
        "public_key": "ed25519:4ie5979JdSR4f7MRAG58eghRxndVoKnAYAKa1PLoMYSS"
      },
      {
        "account_id": "dokia.pool.f863973.m0",
        "amount": "4004628852742744225484204285260",
        "public_key": "ed25519:935JMz1vLcJxFApG3TY4MA4RHhvResvoGwCrQoJxHPn9"
      },
      {
        "account_id": "01node.pool.f863973.m0",
        "amount": "1416856356232757387343764992394",
        "public_key": "ed25519:3iNqnvBgxJPXCxu6hNdvJso1PEAc1miAD35KQMBCA3aL"
      },
      {
        "account_id": "legends.pool.f863973.m0",
        "amount": "303006135607766172564337480878",
        "public_key": "ed25519:AhQ6sUifJYgjqarXSAzdDZU9ZixpUesP9JEH1Vr7NbaF"
      },
      {
        "account_id": "blazenet.pool.f863973.m0",
        "amount": "1892937440977093265954787297596",
        "public_key": "ed25519:DiogP36wBXKFpFeqirrxN8G2Mq9vnakgBvgnHdL9CcN3"
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/protocol-config/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_BLOCK</td>
      <td>200</td>
      <td>
        The requested block has not been produced yet or it has been
        garbage-collected (cleaned up to save space on the RPC node)
      </td>
      <td>
        <ul>
          <li>Check that the requested block is legit</li>
          <li>
            If the block had been produced more than 5 epochs ago, try to send
            your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/protocol-config/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Protocol Config {#protocol-config}

> Returns most recent protocol configuration or a specific queried block.
Useful for finding current storage and transaction costs.

- method: `EXPERIMENTAL_protocol_config`
- params:
  - [`finality`](/api/rpc/setup#using-finality-param) _OR_ [`block_id`](/api/rpc/setup#using-block_id-param)

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/protocol/get-protocol-config.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-1}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_protocol_config` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/protocol-config/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_protocol_config \
  params:='{
    "finality": "final"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/protocol-config/request-js.mdx 

 ```js
const response = await near.connection.provider.experimental_protocolConfig({
  finality: "final",
});
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/protocol-config/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_protocol_config",
  "params": {
    "finality": "final"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/protocol/protocol-config/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "avg_hidden_validator_seats_per_shard": [0, 0, 0, 0, 0, 0],
    "block_producer_kickout_threshold": 80,
    "chain_id": "testnet",
    "chunk_producer_kickout_threshold": 80,
    "chunk_validator_only_kickout_threshold": 70,
    "dynamic_resharding": false,
    "epoch_length": 43200,
    "fishermen_threshold": "340282366920938463463374607431768211455",
    "gas_limit": 1000000000000000,
    "gas_price_adjustment_rate": [1, 100],
    "genesis_height": 42376888,
    "genesis_time": "2020-07-31T03:39:42.911378Z",
    "max_gas_price": "10000000000000000000000",
    "max_inflation_rate": [1, 20],
    "max_kickout_stake_perc": 30,
    "min_gas_price": "5000",
    "minimum_stake_divisor": 10,
    "minimum_stake_ratio": [1, 62500],
    "minimum_validators_per_shard": 1,
    "num_block_producer_seats": 20,
    "num_block_producer_seats_per_shard": [20, 20, 20, 20, 20, 20],
    "num_blocks_per_year": 31536000,
    "num_chunk_only_producer_seats": 0,
    "online_max_threshold": [99, 100],
    "online_min_threshold": [90, 100],
    "protocol_reward_rate": [1, 10],
    "protocol_treasury_account": "near",
    "protocol_upgrade_stake_threshold": [4, 5],
    "protocol_version": 73,
    "runtime_config": {
      "account_creation_config": {
        "min_allowed_top_level_account_length": 65,
        "registrar_account_id": "registrar"
      },
      "congestion_control_config": {
        "allowed_shard_outgoing_gas": 1000000000000000,
        "max_congestion_incoming_gas": 400000000000000000,
        "max_congestion_memory_consumption": 1000000000,
        "max_congestion_missed_chunks": 5,
        "max_congestion_outgoing_gas": 10000000000000000,
        "max_outgoing_gas": 300000000000000000,
        "max_tx_gas": 500000000000000,
        "min_outgoing_gas": 1000000000000000,
        "min_tx_gas": 20000000000000,
        "outgoing_receipts_big_size_limit": 4718592,
        "outgoing_receipts_usual_size_limit": 102400,
        "reject_tx_congestion_threshold": 0.8
      },
      "storage_amount_per_byte": "10000000000000000000",
      "transaction_costs": {
        "action_creation_config": {
          "add_key_cost": {
            "full_access_cost": {
              "execution": 101765125000,
              "send_not_sir": 101765125000,
              "send_sir": 101765125000
            },
            "function_call_cost": {
              "execution": 102217625000,
              "send_not_sir": 102217625000,
              "send_sir": 102217625000
            },
            "function_call_cost_per_byte": {
              "execution": 1925331,
              "send_not_sir": 47683715,
              "send_sir": 1925331
            }
          },
          "create_account_cost": {
            "execution": 3850000000000,
            "send_not_sir": 3850000000000,
            "send_sir": 3850000000000
          },
          "delegate_cost": {
            "execution": 200000000000,
            "send_not_sir": 200000000000,
            "send_sir": 200000000000
          },
          "delete_account_cost": {
            "execution": 147489000000,
            "send_not_sir": 147489000000,
            "send_sir": 147489000000
          },
          "delete_key_cost": {
            "execution": 94946625000,
            "send_not_sir": 94946625000,
            "send_sir": 94946625000
          },
          "deploy_contract_cost": {
            "execution": 184765750000,
            "send_not_sir": 184765750000,
            "send_sir": 184765750000
          },
          "deploy_contract_cost_per_byte": {
            "execution": 64572944,
            "send_not_sir": 47683715,
            "send_sir": 6812999
          },
          "function_call_cost": {
            "execution": 780000000000,
            "send_not_sir": 200000000000,
            "send_sir": 200000000000
          },
          "function_call_cost_per_byte": {
            "execution": 2235934,
            "send_not_sir": 47683715,
            "send_sir": 2235934
          },
          "stake_cost": {
            "execution": 102217625000,
            "send_not_sir": 141715687500,
            "send_sir": 141715687500
          },
          "transfer_cost": {
            "execution": 115123062500,
            "send_not_sir": 115123062500,
            "send_sir": 115123062500
          }
        },
        "action_receipt_creation_config": {
          "execution": 108059500000,
          "send_not_sir": 108059500000,
          "send_sir": 108059500000
        },
        "burnt_gas_reward": [3, 10],
        "data_receipt_creation_config": {
          "base_cost": {
            "execution": 36486732312,
            "send_not_sir": 36486732312,
            "send_sir": 36486732312
          },
          "cost_per_byte": {
            "execution": 17212011,
            "send_not_sir": 47683715,
            "send_sir": 17212011
          }
        },
        "pessimistic_gas_price_inflation_ratio": [103, 100],
        "storage_usage_config": {
          "num_bytes_account": 100,
          "num_extra_bytes_record": 40
        }
      },
      "wasm_config": {
        "alt_bn128": true,
        "disable_9393_fix": false,
        "discard_custom_sections": true,
        "ed25519_verify": true,
        "eth_implicit_accounts": true,
        "ext_costs": {
          "alt_bn128_g1_multiexp_base": 713000000000,
          "alt_bn128_g1_multiexp_element": 320000000000,
          "alt_bn128_g1_sum_base": 3000000000,
          "alt_bn128_g1_sum_element": 5000000000,
          "alt_bn128_pairing_check_base": 9686000000000,
          "alt_bn128_pairing_check_element": 5102000000000,
          "base": 264768111,
          "bls12381_g1_multiexp_base": 16500000000,
          "bls12381_g1_multiexp_element": 930000000000,
          "bls12381_g2_multiexp_base": 18600000000,
          "bls12381_g2_multiexp_element": 1995000000000,
          "bls12381_map_fp2_to_g2_base": 1500000000,
          "bls12381_map_fp2_to_g2_element": 900000000000,
          "bls12381_map_fp_to_g1_base": 1500000000,
          "bls12381_map_fp_to_g1_element": 252000000000,
          "bls12381_p1_decompress_base": 15000000000,
          "bls12381_p1_decompress_element": 81000000000,
          "bls12381_p1_sum_base": 16500000000,
          "bls12381_p1_sum_element": 6000000000,
          "bls12381_p2_decompress_base": 15000000000,
          "bls12381_p2_decompress_element": 165000000000,
          "bls12381_p2_sum_base": 18600000000,
          "bls12381_p2_sum_element": 15000000000,
          "bls12381_pairing_base": 2130000000000,
          "bls12381_pairing_element": 2130000000000,
          "contract_compile_base": 0,
          "contract_compile_bytes": 0,
          "contract_loading_base": 35445963,
          "contract_loading_bytes": 1089295,
          "ecrecover_base": 278821988457,
          "ed25519_verify_base": 210000000000,
          "ed25519_verify_byte": 9000000,
          "keccak256_base": 5879491275,
          "keccak256_byte": 21471105,
          "keccak512_base": 5811388236,
          "keccak512_byte": 36649701,
          "log_base": 3543313050,
          "log_byte": 13198791,
          "promise_and_base": 1465013400,
          "promise_and_per_promise": 5452176,
          "promise_return": 560152386,
          "read_cached_trie_node": 2280000000,
          "read_memory_base": 2609863200,
          "read_memory_byte": 3801333,
          "read_register_base": 2517165186,
          "read_register_byte": 98562,
          "ripemd160_base": 853675086,
          "ripemd160_block": 680107584,
          "sha256_base": 4540970250,
          "sha256_byte": 24117351,
          "storage_has_key_base": 54039896625,
          "storage_has_key_byte": 30790845,
          "storage_iter_create_from_byte": 0,
          "storage_iter_create_prefix_base": 0,
          "storage_iter_create_prefix_byte": 0,
          "storage_iter_create_range_base": 0,
          "storage_iter_create_to_byte": 0,
          "storage_iter_next_base": 0,
          "storage_iter_next_key_byte": 0,
          "storage_iter_next_value_byte": 0,
          "storage_large_read_overhead_base": 1,
          "storage_large_read_overhead_byte": 1,
          "storage_read_base": 56356845749,
          "storage_read_key_byte": 30952533,
          "storage_read_value_byte": 5611004,
          "storage_remove_base": 53473030500,
          "storage_remove_key_byte": 38220384,
          "storage_remove_ret_value_byte": 11531556,
          "storage_write_base": 64196736000,
          "storage_write_evicted_byte": 32117307,
          "storage_write_key_byte": 70482867,
          "storage_write_value_byte": 31018539,
          "touching_trie_node": 16101955926,
          "utf16_decoding_base": 3543313050,
          "utf16_decoding_byte": 163577493,
          "utf8_decoding_base": 3111779061,
          "utf8_decoding_byte": 291580479,
          "validator_stake_base": 911834726400,
          "validator_total_stake_base": 911834726400,
          "write_memory_base": 2803794861,
          "write_memory_byte": 2723772,
          "write_register_base": 2865522486,
          "write_register_byte": 3801564,
          "yield_create_base": 153411779276,
          "yield_create_byte": 15643988,
          "yield_resume_base": 1195627285210,
          "yield_resume_byte": 47683715
        },
        "fix_contract_loading_cost": false,
        "function_call_weight": true,
        "grow_mem_cost": 1,
        "implicit_account_creation": true,
        "limit_config": {
          "account_id_validity_rules_version": 1,
          "contract_prepare_version": 2,
          "initial_memory_pages": 1024,
          "max_actions_per_receipt": 100,
          "max_arguments_length": 4194304,
          "max_contract_size": 4194304,
          "max_functions_number_per_contract": 10000,
          "max_gas_burnt": 300000000000000,
          "max_length_method_name": 256,
          "max_length_returned_data": 4194304,
          "max_length_storage_key": 2048,
          "max_length_storage_value": 4194304,
          "max_locals_per_contract": 1000000,
          "max_memory_pages": 2048,
          "max_number_bytes_method_names": 2000,
          "max_number_input_data_dependencies": 128,
          "max_number_logs": 100,
          "max_number_registers": 100,
          "max_promises_per_function_call_action": 1024,
          "max_receipt_size": 4194304,
          "max_register_size": 104857600,
          "max_stack_height": 262144,
          "max_total_log_length": 16384,
          "max_total_prepaid_gas": 300000000000000,
          "max_transaction_size": 1572864,
          "max_yield_payload_size": 1024,
          "per_receipt_storage_proof_size_limit": 4000000,
          "registers_memory_limit": 1073741824,
          "wasmer2_stack_limit": 204800,
          "yield_timeout_length_in_blocks": 200
        },
        "math_extension": true,
        "regular_op_cost": 822756,
        "storage_get_mode": "FlatStorage",
        "vm_kind": "NearVm",
        "yield_resume_host_functions": true
      },
      "witness_config": {
        "combined_transactions_size_limit": 4194304,
        "main_storage_proof_size_soft_limit": 4000000,
        "new_transactions_validation_state_size_soft_limit": 572864
      }
    },
    "shard_layout": {
      "V1": {
        "boundary_accounts": [
          "aurora",
          "aurora-0",
          "game.hot.tg",
          "kkuuue2akv_1630967379.near",
          "tge-lockup.sweat"
        ],
        "shards_split_map": [[0], [1], [2, 3], [4], [5]],
        "to_parent_shard_map": [0, 1, 2, 2, 3, 4],
        "version": 3
      }
    },
    "shuffle_shard_assignment_for_chunk_producers": false,
    "target_validator_mandates_per_shard": 68,
    "transaction_validity_period": 86400
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/receipt-by-id/error-schema-table.mdx 

 <table>
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HANDLER_ERROR</td>
      <td>UNKNOWN_RECEIPT</td>
      <td>200</td>
      <td>
        The receipt with the given <code>receipt_id</code> was never observed on
        the node
      </td>
      <td>
        <ul>
          <li>
            Check the provided <code>receipt_id</code> is correct
          </li>
          <li>Send a request on a different node</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/receipt-by-id/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";

## Receipt by ID {#receipt-by-id}

> Fetches a receipt by its ID (as is, without a status or execution outcome)

- method: `EXPERIMENTAL_receipt`
- params:
  - `receipt_id` _(see [NearBlocks Explorer](https://testnet.nearblocks.io) for a valid receipt id)_

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash/>
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/transactions/get-receipt.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-4}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_receipt` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/receipt-by-id/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_receipt \
  params:='{
    "receipt_id": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/receipt-by-id/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_receipt",
  "params": {
    "receipt_id": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/receipt-by-id/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "predecessor_id": "rpc-examples.testnet",
    "priority": 0,
    "receipt": {
      "Action": {
        "actions": [
          "CreateAccount",
          {
            "Transfer": {
              "deposit": "5000000000000000000000000"
            }
          },
          {
            "AddKey": {
              "access_key": {
                "nonce": 0,
                "permission": "FullAccess"
              },
              "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
            }
          }
        ],
        "gas_price": "103000000",
        "input_data_ids": [],
        "is_promise_yield": false,
        "output_data_receivers": [],
        "signer_id": "rpc-examples.testnet",
        "signer_public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
      }
    },
    "receipt_id": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE",
    "receiver_id": "contract.rpc-examples.testnet"
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-async/error-schema-table.mdx 

 <table class="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr class="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-async/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import RequestJson from "./request-json.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## [deprecated] Send transaction (async) {#send-transaction-async}

> Consider using [`send_tx`](/api/rpc/transactions#send-tx) instead

> Sends a transaction and immediately returns transaction hash.

- method: `broadcast_tx_async`
- params: [SignedTransaction encoded in base64]

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

Final transaction results can be queried using [Transaction Status](#transaction-status)
or [NearBlocks Explorer](https://testnet.nearblocks.io/) using the above
`result` hash returning a result similar to the example below.

![NEAR-Explorer-transactionHash](/docs/assets/NEAR-Explorer-transactionHash.png)

#### What could go wrong? {#what-could-go-wrong}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `broadcast_tx_async` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-async/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=broadcast_tx_async \
  params:='[
    "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE="
  ]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-async/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "broadcast_tx_async",
  "params": [
    "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE="
  ]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-async/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": "6zgh2u9DqHHiXzdy9ouTP7oGky2T4nugqzqt9wJZwNFm",
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-await/error-schema-table.mdx 

 <table class="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>200</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>
            See <code>error.cause.info</code> for details, likely a field in the
            transaction was invalid
          </li>
          <li>
            If <code>error.cause.info</code> is <code>ShardCongested</code>,
            resubmit the identical transaction after a delay. (Consider adding a
            priority fee once [NEP-541](https://github.com/near/NEPs/pull/541)
            is released.)
          </li>
          <li>
            If <code>error.cause.info</code> is <code>ShardStuck</code>, you may
            also resubmit the identical transaction after a delay
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>408</td>
      <td>
        Transaction was routed, but has not been recorded on chain in 10
        seconds.
      </td>
      <td>
        <ul>
          <li>
            {" "}
            Resubmit the request with the identical transaction (in NEAR
            Protocol unique transactions apply exactly once, so if the
            previously sent transaction gets applied, this request will just
            return the known result, otherwise, it will route the transaction to
            the chain once again)
          </li>
          <li>Check that your transaction is valid</li>
          <li>
            Check that the signer account id has enough tokens to cover the
            transaction fees (keep in mind that some tokens on each account are
            locked to cover the storage cost)
          </li>
        </ul>
      </td>
    </tr>
    <tr class="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-await/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import RequestJson from "./request-json.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## [deprecated] Send transaction (await) {#send-transaction-await}

> Consider using [`send_tx`](/api/rpc/transactions#send-tx) instead

> Sends a transaction and waits until transaction is fully complete. _(Has a 10 second timeout)_

- method: `broadcast_tx_commit`
- params: `[SignedTransaction encoded in base64]`

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-1}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `broadcast_tx_commit` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-await/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=broadcast_tx_commit \
  params:='[
    "DwAAAG5lYXJrYXQudGVzdG5ldABuTi5L1rwnlb35hc9tn5WELkxfiGfGh1Q5aeGNQDejo0QAAAAAAAAAEAAAAGpvc2hmb3JkLnRlc3RuZXSiWAc6W9KlqXS5fK+vjFRDV5pAxHRKU0srKX/cmdRTBgEAAAADAAAAoe3MzhvC0wAAAAAAAAB9rOE9zc5zQYLL1j6VTh3I4fQbERs6I07gJfrAC6jo8DB4HolR9Xps3v4qrZxkgZjwv6wB0QOROM4UEbeOaBoB"
  ]'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-await/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "broadcast_tx_commit",
  "params": [
    "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDQAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldIODI4YfV/QS++blXpQYT+bOsRblTRW4f547y/LkvMQ9AQAAAAMAAACh7czOG8LTAAAAAAAAAAXcaTJzu9GviPT7AD4mNJGY79jxTrjFLoyPBiLGHgBi8JK1AnhK8QknJ1ourxlvOYJA2xEZE8UR24THmSJcLQw="
  ]
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-transaction-await/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "signer_id": "sender.testnet",
      "public_key": "ed25519:Gowpa4kXNyTMRKgt5W7147pmcc2PxiFic8UHW9rsNvJ6",
      "nonce": 13,
      "receiver_id": "receiver.testnet",
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "signature": "ed25519:7oCBMfSHrZkT7tzPDBxxCd3tWFhTES38eks3MCZMpYPJRfPWKxJsvmwQiVBBxRLoxPTnXVaMU2jPV3MdFKZTobH",
      "hash": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR"
    },
    "transaction_outcome": {
      "proof": [],
      "block_hash": "9MzuZrRPW1BGpFnZJUJg6SzCrixPpJDfjsNeUobRXsLe",
      "id": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR",
      "outcome": {
        "logs": [],
        "receipt_ids": ["BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"],
        "gas_burnt": 223182562500,
        "tokens_burnt": "22318256250000000000",
        "executor_id": "sender.testnet",
        "status": {
          "SuccessReceiptId": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"
        }
      }
    },
    "receipts_outcome": [
      {
        "proof": [],
        "block_hash": "5Hpj1PeCi32ZkNXgiD1DrW4wvW4Xtic74DJKfyJ9XL3a",
        "id": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh",
        "outcome": {
          "logs": [],
          "receipt_ids": ["3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR"],
          "gas_burnt": 223182562500,
          "tokens_burnt": "22318256250000000000",
          "executor_id": "receiver.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      },
      {
        "proof": [],
        "block_hash": "CbwEqMpPcu6KwqVpBM3Ry83k6M4H1FrJjES9kBXThcRd",
        "id": "3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR",
        "outcome": {
          "logs": [],
          "receipt_ids": [],
          "gas_burnt": 0,
          "tokens_burnt": "0",
          "executor_id": "sender.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-tx/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="2">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>200</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>
            See <code>error.cause.info</code> for details, likely a field in the
            transaction was invalid
          </li>
          <li>
            If <code>error.cause.info</code> is <code>ShardCongested</code>,
            resubmit the identical transaction after a delay. (Consider adding a
            priority fee once [NEP-541](https://github.com/near/NEPs/pull/541)
            is released.)
          </li>
          <li>
            If <code>error.cause.info</code> is <code>ShardStuck</code>, you may
            also resubmit the identical transaction after a delay
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>408</td>
      <td>
        Transaction was routed, but has not been recorded on chain in 10
        seconds.
      </td>
      <td>
        <ul>
          <li>
            {" "}
            Resubmit the request with the identical transaction (in NEAR
            Protocol unique transactions apply exactly once, so if the
            previously sent transaction gets applied, this request will just
            return the known result, otherwise, it will route the transaction to
            the chain once again)
          </li>
          <li>Check that your transaction is valid</li>
          <li>
            Check that the signer account id has enough tokens to cover the
            transaction fees (keep in mind that some tokens on each account are
            locked to cover the storage cost)
          </li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-tx/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import RequestJson from "./request-json.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Send transaction {#send-tx}

> Sends transaction.
> Returns the guaranteed execution status and the results the blockchain can provide at the moment.

- method: `send_tx`
- params:
  - `signed_tx_base64`: SignedTransaction encoded in base64
  - [Optional] `wait_until`: the required minimal execution level.
    The default value is `EXECUTED_OPTIMISTIC`.
    [Read more here](#tx-status-result).

Using `send_tx` with `wait_until = NONE` is equal to legacy `broadcast_tx_async` method. <br />
Using `send_tx` with finality `wait_until = EXECUTED_OPTIMISTIC` is equal to legacy `broadcast_tx_commit` method.

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
</Tabs>

<details>
  <summary>Example response: </summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-send-tx}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `broadcast_tx_commit` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-tx/request-bash.mdx 

 ```bash
http POST https://rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=send_tx \
  params:='{
    "signed_tx_base64": "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE=",
    "wait_until": "EXECUTED"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-tx/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "send_tx",
  "params": {
    "signed_tx_base64": "DgAAAHNlbmRlci50ZXN0bmV0AOrmAai64SZOv9e/naX4W15pJx0GAap35wTT1T/DwcbbDwAAAAAAAAAQAAAAcmVjZWl2ZXIudGVzdG5ldNMnL7URB1cxPOu3G8jTqlEwlcasagIbKlAJlF5ywVFLAQAAAAMAAACh7czOG8LTAAAAAAAAAGQcOG03xVSFQFjoagOb4NBBqWhERnnz45LY4+52JgZhm1iQKz7qAdPByrGFDQhQ2Mfga8RlbysuQ8D8LlA6bQE=",
    "wait_until": "INCLUDED_FINAL"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/send-tx/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "signer_id": "sender.testnet",
      "public_key": "ed25519:Gowpa4kXNyTMRKgt5W7147pmcc2PxiFic8UHW9rsNvJ6",
      "nonce": 13,
      "receiver_id": "receiver.testnet",
      "actions": [
        {
          "Transfer": {
            "deposit": "1000000000000000000000000"
          }
        }
      ],
      "signature": "ed25519:7oCBMfSHrZkT7tzPDBxxCd3tWFhTES38eks3MCZMpYPJRfPWKxJsvmwQiVBBxRLoxPTnXVaMU2jPV3MdFKZTobH",
      "hash": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR"
    },
    "transaction_outcome": {
      "proof": [],
      "block_hash": "9MzuZrRPW1BGpFnZJUJg6SzCrixPpJDfjsNeUobRXsLe",
      "id": "ASS7oYwGiem9HaNwJe6vS2kznx2CxueKDvU9BAYJRjNR",
      "outcome": {
        "logs": [],
        "receipt_ids": ["BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"],
        "gas_burnt": 223182562500,
        "tokens_burnt": "22318256250000000000",
        "executor_id": "sender.testnet",
        "status": {
          "SuccessReceiptId": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh"
        }
      }
    },
    "receipts_outcome": [
      {
        "proof": [],
        "block_hash": "5Hpj1PeCi32ZkNXgiD1DrW4wvW4Xtic74DJKfyJ9XL3a",
        "id": "BLV2q6p8DX7pVgXRtGtBkyUNrnqkNyU7iSksXG7BjVZh",
        "outcome": {
          "logs": [],
          "receipt_ids": ["3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR"],
          "gas_burnt": 223182562500,
          "tokens_burnt": "22318256250000000000",
          "executor_id": "receiver.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      },
      {
        "proof": [],
        "block_hash": "CbwEqMpPcu6KwqVpBM3Ry83k6M4H1FrJjES9kBXThcRd",
        "id": "3sawynPNP8UkeCviGqJGwiwEacfPyxDKRxsEWPpaUqtR",
        "outcome": {
          "logs": [],
          "receipt_ids": [],
          "gas_burnt": 0,
          "tokens_burnt": "0",
          "executor_id": "sender.testnet",
          "status": {
            "SuccessValue": ""
          }
        }
      }
    ]
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>200</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>
            See <code>error.cause.info</code> for details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_TRANSACTION</td>
      <td>200</td>
      <td>
        The requested transaction is not available on the node since it might
        have not been recorded on the chain yet or has been garbage-collected
      </td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>
            If the transaction had been submitted more than 5 epochs ago, try to
            send your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
          <li>Check the transaction hash</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>408</td>
      <td>
        It was unable to wait for the transaction status for reasonable time
      </td>
      <td>
        <ul>
          <li>Send a request to a different node</li>
          <li>Try again later</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Transaction Status with Receipts {#transaction-status-with-receipts}

> Queries status of a transaction by hash, returning the final transaction
> result _and_ details of all receipts.

- method: `EXPERIMENTAL_tx_status`
- params:
  - `tx_hash` _(see [NearBlocks Explorer](https://testnet.nearblocks.io) for a valid transaction hash)_
  - `sender_account_id` _(used to determine which shard to query for transaction)_
  - [Optional] `wait_until`: the required minimal execution level.
    The default value is `EXECUTED_OPTIMISTIC`.
    Read more [here](/api/rpc/transactions#tx-status-result).

A Transaction status request with `wait_until != NONE` will wait until the
transaction appears on the blockchain. If the transaction does not exist,
the method will wait until the timeout is reached. If you only need to check
whether the transaction exists, use `wait_until = NONE`, it will return the response immediately.

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/transactions/get-detailed-transaction.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example response:</summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-3}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `EXPERIMENTAL_tx_status` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=EXPERIMENTAL_tx_status \
  params:='{
    "tx_hash": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
    "sender_account_id": "rpc-examples.testnet",
    "wait_until": "FINAL"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/request-js.mdx 

 ```js
const response = await near.connection.provider.txStatusReceipts(
  "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
  "rpc-examples.testnet",
  "FINAL",
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "EXPERIMENTAL_tx_status",
  "params": {
    "tx_hash": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
    "sender_account_id": "rpc-examples.testnet",
    "wait_until": "FINAL"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status-with-receipts/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "receipts": [
      {
        "predecessor_id": "rpc-examples.testnet",
        "priority": 0,
        "receipt": {
          "Action": {
            "actions": [
              "CreateAccount",
              {
                "Transfer": {
                  "deposit": "5000000000000000000000000"
                }
              },
              {
                "AddKey": {
                  "access_key": {
                    "nonce": 0,
                    "permission": "FullAccess"
                  },
                  "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
                }
              }
            ],
            "gas_price": "103000000",
            "input_data_ids": [],
            "is_promise_yield": false,
            "output_data_receivers": [],
            "signer_id": "rpc-examples.testnet",
            "signer_public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
          }
        },
        "receipt_id": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE",
        "receiver_id": "contract.rpc-examples.testnet"
      },
      {
        "predecessor_id": "system",
        "priority": 0,
        "receipt": {
          "Action": {
            "actions": [
              {
                "Transfer": {
                  "deposit": "12524843062500000000"
                }
              }
            ],
            "gas_price": "0",
            "input_data_ids": [],
            "is_promise_yield": false,
            "output_data_receivers": [],
            "signer_id": "rpc-examples.testnet",
            "signer_public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
          }
        },
        "receipt_id": "AZz7tN4cSK9Ngeq7KUFWSm8yi9WLsVjqYiohNYzW8Pc4",
        "receiver_id": "rpc-examples.testnet"
      }
    ],
    "receipts_outcome": [
      {
        "block_hash": "ApNYvBCU3Nnn8TeESvJ7Anfw8vfbmwcXmavypAWtKv6p",
        "id": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE",
        "outcome": {
          "executor_id": "contract.rpc-examples.testnet",
          "gas_burnt": 4174947687500,
          "logs": [],
          "metadata": {
            "gas_profile": [],
            "version": 3
          },
          "receipt_ids": ["AZz7tN4cSK9Ngeq7KUFWSm8yi9WLsVjqYiohNYzW8Pc4"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "417494768750000000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "CuLK7PnND8x1XooFysdUbG9VqG2yzKKjPSFXSGsuKzn4"
          }
        ]
      },
      {
        "block_hash": "4C1384HReTY7NR7jVk2aMDyccCNVM5zeQDQ6z84cj1N4",
        "id": "AZz7tN4cSK9Ngeq7KUFWSm8yi9WLsVjqYiohNYzW8Pc4",
        "outcome": {
          "executor_id": "rpc-examples.testnet",
          "gas_burnt": 223182562500,
          "logs": [],
          "metadata": {
            "gas_profile": [],
            "version": 3
          },
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "7agjDTstRCDmAn4LvPnHDu8yxhbSWCD7VNhzr7nLq37N"
          },
          {
            "direction": "Left",
            "hash": "54QAYN39nMUp6uz6vhNbDNRbvAmk16mw7R1WvxnmG1Xr"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        "CreateAccount",
        {
          "Transfer": {
            "deposit": "5000000000000000000000000"
          }
        },
        {
          "AddKey": {
            "access_key": {
              "nonce": 0,
              "permission": "FullAccess"
            },
            "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
          }
        }
      ],
      "hash": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
      "nonce": 187307146000001,
      "priority_fee": 0,
      "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M",
      "receiver_id": "contract.rpc-examples.testnet",
      "signature": "ed25519:34NgQAukvyKajXFDB6XzKpfd2YDUo3QyTdkUeCgwm24J3dkju7Ejm71VRkRsJwdpKwH1HQWqSV2frnF26yQYEZpJ",
      "signer_id": "rpc-examples.testnet"
    },
    "transaction_outcome": {
      "block_hash": "G1xSnhtrDiaEZNef41kiY8ePQCAwsF2gyVcRNa7B6xaP",
      "id": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
      "outcome": {
        "executor_id": "rpc-examples.testnet",
        "gas_burnt": 4174947687500,
        "logs": [],
        "metadata": {
          "gas_profile": null,
          "version": 1
        },
        "receipt_ids": ["23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE"],
        "status": {
          "SuccessReceiptId": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE"
        },
        "tokens_burnt": "417494768750000000000"
      },
      "proof": [
        {
          "direction": "Left",
          "hash": "Ft2GVFu6zuQGbUU7DB7opgshYLPvuvfNnGqMAny1kgPj"
        },
        {
          "direction": "Left",
          "hash": "39hCSJBs64y18wcM8qtasQQnkfXYBhvHau3bEbULgV3E"
        },
        {
          "direction": "Right",
          "hash": "GkZCCuNqu2qpwd5Xwo2g4qwRvXXmgV2k71YM7EYhg5HK"
        }
      ]
    }
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status/error-schema-table.mdx 

 <table className="custom-stripe">
  <thead>
    <tr>
      <th>ERROR_TYPE<br /><code>error.name</code></th>
      <th>ERROR_CAUSE<br /><code>error.cause.name</code></th>
      <th>Status Code</th>
      <th>Reason</th>
      <th>Solution</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td rowspan="3">HANDLER_ERROR</td>
      <td>INVALID_TRANSACTION</td>
      <td>200</td>
      <td>An error happened during transaction execution</td>
      <td>
        <ul>
          <li>
            See <code>error.cause.info</code> for details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>UNKNOWN_TRANSACTION</td>
      <td>200</td>
      <td>
        The requested transaction is not available on the node since it might
        have not been recorded on the chain yet or has been garbage-collected
      </td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>
            If the transaction had been submitted more than 5 epochs ago, try to
            send your request to{" "}
            <a
              href="https://near-nodes.io/intro/node-types#archival-node"
              target="_blank"
              rel="noopener noreferrer"
            >
              an archival node
            </a>
          </li>
          <li>Check the transaction hash</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>TIMEOUT_ERROR</td>
      <td>408</td>
      <td>
        It was unable to wait for the transaction status for reasonable time
      </td>
      <td>
        <ul>
          <li>Send a request to a different node</li>
          <li>Try again later</li>
        </ul>
      </td>
    </tr>
    <tr className="stripe">
      <td>REQUEST_VALIDATION_ERROR</td>
      <td>PARSE_ERROR</td>
      <td>400</td>
      <td>
        Passed arguments can't be parsed by JSON RPC server (missing arguments,
        wrong format, etc.)
      </td>
      <td>
        <ul>
          <li>Check the arguments passed and pass the correct ones</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td>INTERNAL_ERROR</td>
      <td>INTERNAL_ERROR</td>
      <td>500</td>
      <td>Something went wrong with the node itself or overloaded</td>
      <td>
        <ul>
          <li>Try again later</li>
          <li>Send a request to a different node</li>
          <li>
            Check <code>error.cause.info</code> for more details
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status/index.mdx 

 import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { LantstoolLabel } from "@site/src/components/lantstool/LantstoolLabel/LantstoolLabel";
import { TryOutOnLantstool } from "@site/src/components/lantstool/TryOutOnLantstool";
import RequestJson from "./request-json.mdx";
import RequestJs from "./request-js.mdx";
import RequestBash from "./request-bash.mdx";
import ResponseJson from "./response-json.mdx";
import ErrorSchemaTable from "./error-schema-table.mdx";
import ErrorSchemaDescription from "../../_general/error-schema-description.mdx";

## Transaction Status {#transaction-status}

> Queries status of a transaction by hash and returns the final transaction result.

- method: `tx`
- params:
  - `tx_hash` _(see [NearBlocks Explorer](https://testnet.nearblocks.io) for a valid transaction hash)_
  - `sender_account_id` _(used to determine which shard to query for transaction)_
  - [Optional] `wait_until`: the required minimal execution level.
    The default value is `EXECUTED_OPTIMISTIC`.
    Read more [here](/api/rpc/transactions#tx-status-result).

A Transaction status request with `wait_until != NONE` will wait until the
transaction appears on the blockchain. If the transaction does not exist,
the method will wait until the timeout is reached. If you only need to check
whether the transaction exists, use `wait_until = NONE`, it will return
the response immediately.

Example:

<Tabs groupId="code-tabs">
  <TabItem value="json" label="JSON" default>
    <RequestJson />
  </TabItem>
  <TabItem value="js" label="JavaScript">
    <RequestJs />
  </TabItem>
  <TabItem value="http" label="HTTPie">
    <RequestBash />
  </TabItem>
  <TabItem value="Lantstool" label={<LantstoolLabel />}>
    <TryOutOnLantstool path="docs/5.api/rpc/transactions/get-transaction.json" />
  </TabItem>
</Tabs>

<details>
  <summary>Example Result:</summary>
  <ResponseJson />
</details>

#### What could go wrong? {#what-could-go-wrong-2}

<ErrorSchemaDescription />

Here is the exhaustive list of the error variants that can be returned by `tx` method:

<ErrorSchemaTable />


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status/request-bash.mdx 

 ```bash
http POST https://archival-rpc.testnet.near.org \
  jsonrpc=2.0 \
  id=dontcare \
  method=tx \
  params:='{
    "tx_hash": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
    "sender_account_id": "rpc-examples.testnet",
    "wait_until": "FINAL"
  }'
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status/request-js.mdx 

 ```js
const response = await near.connection.provider.txStatus(
  "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
  "rpc-examples.testnet",
  "FINAL",
);
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status/request-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "id": "dontcare",
  "method": "tx",
  "params": {
    "tx_hash": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
    "sender_account_id": "rpc-examples.testnet",
    "wait_until": "FINAL"
  }
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/transaction-status/response-json.mdx 

 ```json
{
  "jsonrpc": "2.0",
  "result": {
    "final_execution_status": "FINAL",
    "receipts_outcome": [
      {
        "block_hash": "ApNYvBCU3Nnn8TeESvJ7Anfw8vfbmwcXmavypAWtKv6p",
        "id": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE",
        "outcome": {
          "executor_id": "contract.rpc-examples.testnet",
          "gas_burnt": 4174947687500,
          "logs": [],
          "metadata": {
            "gas_profile": [],
            "version": 3
          },
          "receipt_ids": ["AZz7tN4cSK9Ngeq7KUFWSm8yi9WLsVjqYiohNYzW8Pc4"],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "417494768750000000000"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "CuLK7PnND8x1XooFysdUbG9VqG2yzKKjPSFXSGsuKzn4"
          }
        ]
      },
      {
        "block_hash": "4C1384HReTY7NR7jVk2aMDyccCNVM5zeQDQ6z84cj1N4",
        "id": "AZz7tN4cSK9Ngeq7KUFWSm8yi9WLsVjqYiohNYzW8Pc4",
        "outcome": {
          "executor_id": "rpc-examples.testnet",
          "gas_burnt": 223182562500,
          "logs": [],
          "metadata": {
            "gas_profile": [],
            "version": 3
          },
          "receipt_ids": [],
          "status": {
            "SuccessValue": ""
          },
          "tokens_burnt": "0"
        },
        "proof": [
          {
            "direction": "Left",
            "hash": "7agjDTstRCDmAn4LvPnHDu8yxhbSWCD7VNhzr7nLq37N"
          },
          {
            "direction": "Left",
            "hash": "54QAYN39nMUp6uz6vhNbDNRbvAmk16mw7R1WvxnmG1Xr"
          }
        ]
      }
    ],
    "status": {
      "SuccessValue": ""
    },
    "transaction": {
      "actions": [
        "CreateAccount",
        {
          "Transfer": {
            "deposit": "5000000000000000000000000"
          }
        },
        {
          "AddKey": {
            "access_key": {
              "nonce": 0,
              "permission": "FullAccess"
            },
            "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M"
          }
        }
      ],
      "hash": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
      "nonce": 187307146000001,
      "priority_fee": 0,
      "public_key": "ed25519:vJBU18AtvePANmepMoY3rtV3wt1RHwqoktak82E4d2M",
      "receiver_id": "contract.rpc-examples.testnet",
      "signature": "ed25519:34NgQAukvyKajXFDB6XzKpfd2YDUo3QyTdkUeCgwm24J3dkju7Ejm71VRkRsJwdpKwH1HQWqSV2frnF26yQYEZpJ",
      "signer_id": "rpc-examples.testnet"
    },
    "transaction_outcome": {
      "block_hash": "G1xSnhtrDiaEZNef41kiY8ePQCAwsF2gyVcRNa7B6xaP",
      "id": "7AfonAhbK4ZbdBU9VPcQdrTZVZBXE25HmZAMEABs9To1",
      "outcome": {
        "executor_id": "rpc-examples.testnet",
        "gas_burnt": 4174947687500,
        "logs": [],
        "metadata": {
          "gas_profile": null,
          "version": 1
        },
        "receipt_ids": ["23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE"],
        "status": {
          "SuccessReceiptId": "23r1wWsMAVtZysr9wNV6TCSdZTUyPbhBZ3McJ6zStpaE"
        },
        "tokens_burnt": "417494768750000000000"
      },
      "proof": [
        {
          "direction": "Left",
          "hash": "Ft2GVFu6zuQGbUU7DB7opgshYLPvuvfNnGqMAny1kgPj"
        },
        {
          "direction": "Left",
          "hash": "39hCSJBs64y18wcM8qtasQQnkfXYBhvHau3bEbULgV3E"
        },
        {
          "direction": "Right",
          "hash": "GkZCCuNqu2qpwd5Xwo2g4qwRvXXmgV2k71YM7EYhg5HK"
        }
      ]
    }
  },
  "id": "dontcare"
}
```


 This is the content for the doc website/src/components/docs/5.api/rpc/transactions/tx-status-result/index.mdx 

 ## Transaction Execution Levels {#tx-status-result}

All the methods listed above have `wait_until` request parameter, and
`final_execution_status` response value. They correspond to the same enum
`TxExecutionStatus`. See the detailed explanation for all the options:

```rust
#[serde(rename_all = "SCREAMING_SNAKE_CASE")]
pub enum TxExecutionStatus {
  /// Transaction is waiting to be included into the block
  None,
  /// Transaction is included into the block. The block may be not finalized yet
  Included,
  /// Transaction is included into the block +
  /// All non-refund transaction receipts finished their execution.
  /// The corresponding blocks for tx and each receipt may be not finalized yet
  #[default]
  ExecutedOptimistic,
  /// Transaction is included into finalized block
  IncludedFinal,
  /// Transaction is included into finalized block +
  /// All non-refund transaction receipts finished their execution.
  /// The corresponding blocks for each receipt may be not finalized yet
  Executed,
  /// Transaction is included into finalized block +
  /// Execution of all transaction receipts is finalized, including refund receipts
  Final,
}
```


 This is the content for the doc website/src/components/docs/primitives/dao/bos/create-dao.md 

 ```js
const args = {
  config: {
    name: "Primitives",
    purpose: "Building primitives on NEAR",
    metadata: ""
  },
  policy: ["bob.near"]
};
Near.call(
  "sputnik-dao.near",
  "create",
  {
    name: "primitives",
    args: Buffer.from(JSON.stringify(args)).toString("base64"),
  },
  300000000000000,
  6000000000000000000000000
);
```


:::note
The full list of roles and permissions you can find [here](https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions).
:::

 This is the content for the doc website/src/components/docs/primitives/dao/bos/create-proposal.md 

 ```js
Near.call(
  "primitives.sputnik-dao.near",
  "add_proposal",
  {
    proposal: {
      description: "My first proposal",
      kind: {
        Transfer: {
          token_id: "",
          receiver_id: "bob.near",
          amount: "10000000000000000000000000",
        },
      },
    },
  },
  300000000000000,
  100000000000000000000000
);
```

 This is the content for the doc website/src/components/docs/primitives/dao/bos/get-dao-list.md 

 ```js
const result = Near.view("sputnik-dao.near", "get_dao_list");
```

<details>
<summary>Example response</summary>
<p>

```js
[
  'ref-finance.sputnik-dao.near'
  'gaming-dao.sputnik-dao.near',
  ...
]
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dao/bos/get-proposal-list.md 

 ```js
const result = Near.view(
  "nearweek-news-contribution.sputnik-dao.near",
  "get_proposals",
  { from_index: 9262, limit: 2 }
);
```

<details>
<summary>Example response</summary>
<p>

```js
[
  {
    id: 9262,
    proposer: 'pasternag.near',
    description: 'NEAR, a top non-EVM blockchain, has gone live on Router‚Äôs Testnet Mandara. With Router Nitro, our flagship dApp, users in the NEAR ecosystem can now transfer test tokens to and from NEAR onto other supported chains. $$$$https://twitter.com/routerprotocol/status/1727732303491961232',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'pasternag.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'Approved',
    vote_counts: { council: [ 1, 0, 0 ] },
    votes: { 'brzk-93444.near': 'Approve' },
    submission_time: '1700828277659425683'
  },
  {
    id: 9263,
    proposer: 'fittedn.near',
    description: 'How to deploy BOS component$$$$https://twitter.com/BitkubAcademy/status/1728003163318563025?t=PiN6pwS380T1N4JuQXSONA&s=19',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'fittedn.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'InProgress',
    vote_counts: { 'Whitelisted Members': [ 1, 0, 0 ] },
    votes: { 'trendheo.near': 'Approve' },
    submission_time: '1700832601849419123'
  }
]
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dao/bos/vote-for-proposal.md 

 ```js
Near.call(
  "primitives.sputnik-dao.near",
  "act_proposal",
  { id: 0, action: "VoteApprove" },
  300000000000000
);
```

:::note
Available vote options: `VoteApprove`, `VoteReject`, `VoteRemove`.
:::

 This is the content for the doc website/src/components/docs/primitives/dao/near-cli/create-dao.md 

 ```bash

export COUNCIL='["bob.near"]'
export ARGS=`echo '{"config": {"name": "Primitives", "purpose": "Building primitives on NEAR", "metadata":""}, "policy": '$COUNCIL'}' | base64`

near call sputnikv2.testnet create "{\"name\": \"primitives\", \"args\": \"$ARGS\"}" --accountId bob.near --amount 6 --gas 150000000000000
```

:::note
The full list of roles and permissions you can find [here](https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions).
:::

 This is the content for the doc website/src/components/docs/primitives/dao/near-cli/create-proposal.md 

 ```bash
near call primitives.sputnik-dao.near add_proposal '{"proposal": {"description": "My first proposal", "kind": { "Transfer": {"token_id": "", "receiver_id": "bob.near", "amount": "10000000000000000000000000"}}}}'  --deposit 0.1 --gas 300000000000000 --accountId bob.near
```

 This is the content for the doc website/src/components/docs/primitives/dao/near-cli/get-dao-list.md 

 ```bash
near view sputnik-dao.near get_dao_list '{}'
```

<details>
<summary>Example response</summary>
<p>

```bash
[
  'ref-finance.sputnik-dao.near'
  'gaming-dao.sputnik-dao.near',
  ...
]
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dao/near-cli/get-proposal-list.md 

 ```bash
near view nearweek-news-contribution.sputnik-dao.near get_proposals '{"from_index": 9262, "limit": 2}'
```

<details>
<summary>Example response</summary>
<p>

```bash
[
  {
    id: 9262,
    proposer: 'pasternag.near',
    description: 'NEAR, a top non-EVM blockchain, has gone live on Router‚Äôs Testnet Mandara. With Router Nitro, our flagship dApp, users in the NEAR ecosystem can now transfer test tokens to and from NEAR onto other supported chains. $$$$https://twitter.com/routerprotocol/status/1727732303491961232',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'pasternag.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'Approved',
    vote_counts: { council: [ 1, 0, 0 ] },
    votes: { 'brzk-93444.near': 'Approve' },
    submission_time: '1700828277659425683'
  },
  {
    id: 9263,
    proposer: 'fittedn.near',
    description: 'How to deploy BOS component$$$$https://twitter.com/BitkubAcademy/status/1728003163318563025?t=PiN6pwS380T1N4JuQXSONA&s=19',
    kind: {
      Transfer: {
        token_id: '',
        receiver_id: 'fittedn.near',
        amount: '500000000000000000000000',
        msg: null
      }
    },
    status: 'InProgress',
    vote_counts: { 'Whitelisted Members': [ 1, 0, 0 ] },
    votes: { 'trendheo.near': 'Approve' },
    submission_time: '1700832601849419123'
  }
]
```

</p>

</details>


 This is the content for the doc website/src/components/docs/primitives/dao/near-cli/vote-for-proposal.md 

 ```bash
near call primitives.sputnik-dao.near act_proposal '{"id": 0, "action": "VoteApprove"}' --gas 300000000000000 --accountId bob.near
```

:::note
Available vote options: `VoteApprove`, `VoteReject`, `VoteRemove`.
:::

 This is the content for the doc website/src/components/docs/primitives/dao/smart-contract/create-dao.md 

 

```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_dao_factory_contract)]
trait ExternalDaoFactoryContract {
  fn create(&mut self, name: AccountId, args: Base64VecU8) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn create_dao(&mut self, name: AccountId, args: Base64VecU8) -> Promise {
    let promise = ext_dao_factory_contract::ext(self.dao_factory_contract.clone())
      .with_attached_deposit(env::attached_deposit())
      .with_static_gas(Gas(30*TGAS))
      .create(name, args);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(50*TGAS))
      .external_common_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_common_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract")
    }
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/dao/smart-contract/create-proposal.md 

 

```rust
// Account ID that represents a token in near-sdk v3
// Need to keep it around for backward compatibility
pub type OldAccountId = String;

// How the voting policy votes get weighted.
#[near(serializers = [json, borsh])
#[derive(Clone, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum WeightKind {
  // Using token amounts and total delegated at the moment.
  TokenWeight,
  // Weight of the group role. Roles that don't have scoped group are not supported.
  RoleWeight,
}

// Direct weight or ratio to total weight, used for the voting policy
#[near(serializers = [json, borsh])
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[serde(untagged)]
pub enum WeightOrRatio {
  Weight(U128),
  Ratio(u64, u64),
}

// Defines configuration of the vote
#[near(serializers = [json, borsh])
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct VotePolicy {
  // Kind of weight to use for votes.
  pub weight_kind: WeightKind,
  // Minimum number required for vote to finalize.
  // If weight kind is TokenWeight - this is minimum number of tokens required.
  //     This allows to avoid situation where the number of staked tokens from total supply is too small.
  // If RoleWeight - this is minimum number of votes.
  //     This allows to avoid situation where the role is got too small but policy kept at 1/2, for example.
  pub quorum: U128,
  // How many votes to pass this vote.
  pub threshold: WeightOrRatio,
}

#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub enum RoleKind {
  // Matches everyone, who is not matched by other roles.
  Everyone,
  // Member greater or equal than given balance. Can use `1` as non-zero balance.
  Member(U128),
  // Set of accounts.
  Group(HashSet<AccountId>),
}

#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct RolePermission {
  // Name of the role to display to the user.
  pub name: String,
  // Kind of the role: defines which users this permissions apply.
  pub kind: RoleKind,
  // Set of actions on which proposals that this role is allowed to execute.
  // <proposal_kind>:<action>
  pub permissions: HashSet<String>,
  // For each proposal kind, defines voting policy.
  pub vote_policy: HashMap<String, VotePolicy>,
}

// Defines voting / decision making policy of this DAO
#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct Policy {
  // List of roles and permissions for them in the current policy.
  pub roles: Vec<RolePermission>,
  // Default vote policy. Used when given proposal kind doesn't have special policy.
  pub default_vote_policy: VotePolicy,
  // Proposal bond.
  pub proposal_bond: U128,
  // Expiration period for proposals.
  pub proposal_period: U64,
  // Bond for claiming a bounty.
  pub bounty_bond: U128,
  // Period in which giving up on bounty is not punished.
  pub bounty_forgiveness_period: U64,
}

// Versioned policy
#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub enum VersionedPolicy {
  // Default policy with given accounts as council.
  Default(Vec<AccountId>),
  Current(Policy),
}

// Function call arguments
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub struct ActionCall {
  method_name: String,
  args: Base64VecU8,
  deposit: U128,
  gas: U64,
}

// Bounty information.
#[near(serializers = [json, borsh])]
#[derive(Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct Bounty {
  /// Description of the bounty.
  pub description: String,
  /// Token the bounty will be paid out.
  /// Can be "" for $NEAR or a valid account id.
  pub token: OldAccountId,
  /// Amount to be paid out.
  pub amount: U128,
  /// How many times this bounty can be done.
  pub times: u32,
  /// Max deadline from claim that can be spend on this bounty.
  pub max_deadline: U64,
}

// Info about factory that deployed this contract and if auto-update is allowed
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub struct FactoryInfo {
  pub factory_id: AccountId,
  pub auto_update: bool,
}

// Function call arguments
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub struct PolicyParameters {
  pub proposal_bond: Option<U128>,
  pub proposal_period: Option<U64>,
  pub bounty_bond: Option<U128>,
  pub bounty_forgiveness_period: Option<U64>,
}

// Votes recorded in the proposal
#[near(serializers = [json, borsh])]
#[derive(Clone, Debug)]
pub enum Vote {
  Approve = 0x0,
  Reject = 0x1,
  Remove = 0x2,
}

// Configuration of the DAO
#[near(serializers = [json, borsh])]
#[derive(Clone, Debug)]
pub struct Config {
  // Name of the DAO.
  pub name: String,
  // Purpose of this DAO.
  pub purpose: String,
  // Generic metadata. Can be used by specific UI to store additional data.
  // This is not used by anything in the contract.
  pub metadata: Base64VecU8,
}

// Kinds of proposals, doing different action
#[near(serializers = [json, borsh])]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
pub enum ProposalKind {
  // Change the DAO config.
  ChangeConfig { config: Config },
  // Change the full policy.
  ChangePolicy { policy: VersionedPolicy },
  // Add member to given role in the policy. This is short cut to updating the whole policy.
  AddMemberToRole { member_id: AccountId, role: String },
  // Remove member to given role in the policy. This is short cut to updating the whole policy.
  RemoveMemberFromRole { member_id: AccountId, role: String },
  // Calls `receiver_id` with list of method names in a single promise.
  // Allows this contract to execute any arbitrary set of actions in other contracts.
  FunctionCall {
      receiver_id: AccountId,
      actions: Vec<ActionCall>,
  },
  // Upgrade this contract with given hash from blob store.
  UpgradeSelf { hash: Base58CryptoHash },
  // Upgrade another contract, by calling method with the code from given hash from blob store.
  UpgradeRemote {
      receiver_id: AccountId,
      method_name: String,
      hash: Base58CryptoHash,
  },
  // Transfers given amount of `token_id` from this DAO to `receiver_id`.
  // If `msg` is not None, calls `ft_transfer_call` with given `msg`. Fails if this base token.
  // For `ft_transfer` and `ft_transfer_call` `memo` is the `description` of the proposal.
  Transfer {
      // Can be "" for $NEAR or a valid account id.
      token_id: OldAccountId,
      receiver_id: AccountId,
      amount: U128,
      msg: Option<String>,
  },
  // Sets staking contract. Can only be proposed if staking contract is not set yet.
  SetStakingContract { staking_id: AccountId },
  // Add new bounty.
  AddBounty { bounty: Bounty },
  // Indicates that given bounty is done by given user.
  BountyDone {
      bounty_id: u64,
      receiver_id: AccountId,
  },
  // Just a signaling vote, with no execution.
  Vote,
  // Change information about factory and auto update.
  FactoryInfoUpdate { factory_info: FactoryInfo },
  // Add new role to the policy. If the role already exists, update it. This is short cut to updating the whole policy.
  ChangePolicyAddOrUpdateRole { role: RolePermission },
  // Remove role from the policy. This is short cut to updating the whole policy.
  ChangePolicyRemoveRole { role: String },
  // Update the default vote policy from the policy. This is short cut to updating the whole policy.
  ChangePolicyUpdateDefaultVotePolicy { vote_policy: VotePolicy },
  // Update the parameters from the policy. This is short cut to updating the whole policy.
  ChangePolicyUpdateParameters { parameters: PolicyParameters },
}

#[near(serializers = [json])]
pub struct ProposalInput {
  /// Description of this proposal.
  pub description: String,
  /// Kind of proposal with relevant information.
  pub kind: ProposalKind,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_dao_contract)]
trait ExternalDaoContract {
  fn add_proposal(&mut self, proposal: ProposalInput) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn create_proposal(&mut self, proposal: ProposalInput) -> Promise {
    let promise = ext_dao_contract::ext(self.dao_contract.clone())
      .with_attached_deposit(env::attached_deposit())
      .with_static_gas(Gas(5*TGAS))
      .add_proposal(proposal);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(50*TGAS))
      .external_proposal_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_proposal_callback(&self, #[callback_result] call_result: Result<u64, PromiseError>) -> Option<u64> {
    if call_result.is_err() {
      log!("There was an error contacting external contract");
      return None;
    }

    // Return the proposal id
    let id = call_result.unwrap();
    return Some(id);
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/dao/smart-contract/vote-for-proposal.md 

 

```rust
// Set of possible action to take
#[near(serializers = [json, borsh])]
#[derive(Debug)]
pub enum Action {
  // Action to add proposal. Used internally.
  AddProposal,
  // Action to remove given proposal. Used for immediate deletion in special cases.
  RemoveProposal,
  // Vote to approve given proposal or bounty.
  VoteApprove,
  // Vote to reject given proposal or bounty.
  VoteReject,
  // Vote to remove given proposal or bounty (because it's spam).
  VoteRemove,
  // Finalize proposal, called when it's expired to return the funds
  // (or in the future can be used for early proposal closure).
  Finalize,
  // Move a proposal to the hub to shift into another DAO.
  MoveToHub,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_dao_contract)]
trait ExternalDaoContract {
  fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn act_proposal(&mut self, id: u64, action: Action, memo: Option<String>) -> Promise {
    let promise = ext_dao_contract::ext(self.dao_contract.clone())
      .with_attached_deposit(env::attached_deposit())
      .with_static_gas(Gas(10*TGAS))
      .act_proposal(id, action, memo);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .external_common_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_common_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract")
    }
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/dao/web-app/create-dao.md 

 

```js
import { Wallet } from './near-wallet';

const DAO_FACTORY_CONTRACT_ADDRESS = "sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_FACTORY_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'create',
  args: {
    name: "primitives",
    args: btoa({
      config: {
        name: "Primitives",
        purpose: "Building primitives on NEAR",
        metadata: ""
      },
      policy: ["bob.near"]
    }),
  },
  contractId: DAO_FACTORY_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 6000000000000000000000000
});
```

:::note
The full list of roles and permissions you can find [here](https://github.com/near-daos/sputnik-dao-contract#roles-and-permissions).
:::

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/dao/web-app/create-proposal.md 

 

```js
import { Wallet } from './near-wallet';

const DAO_CONTRACT_ADDRESS = "primitives.sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'add_proposal',
  args: {
    proposal: {
      description: "My first proposal",
      kind: {
        Transfer: {
          token_id: "",
          receiver_id: "bob.near",
          amount: "10000000000000000000000000",
        },
      },
    },
  },
  contractId: DAO_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 100000000000000000000000
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/dao/web-app/get-dao-list.md 

 

```js
import { Wallet } from './near-wallet';

const DAO_FACTORY_CONTRACT_ADDRESS = "sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_FACTORY_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_dao_list',
  args: {},
  contractId: DAO_FACTORY_CONTRACT_ADDRESS
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/dao/web-app/get-proposal-list.md 

 

```js
import { Wallet } from './near-wallet';

const DAO_CONTRACT_ADDRESS = "nearweek-news-contribution.sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_proposals',
  args: { from_index: 9262, limit: 2 },
  contractId: DAO_CONTRACT_ADDRESS
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/dao/web-app/vote-for-proposal.md 

 

```js
import { Wallet } from './near-wallet';

const DAO_CONTRACT_ADDRESS = "primitives.sputnik-dao.near";
const wallet = new Wallet({ createAccessKeyFor: DAO_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'act_proposal',
  args: { id: 0, action: "VoteApprove" },
  contractId: DAO_CONTRACT_ADDRESS,
  gas: 300000000000000,
});
```

:::note
Available vote options: `VoteApprove`, `VoteReject`, `VoteRemove`.
:::

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/dex/bos/get-deposit-balances.md 

 ```js
const ammContract = "v2.ref-finance.near";
const depositBalances = Near.view(
  ammContract,
  "get_deposits",
  {
    account_id: "bob.near"
  }
);
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "token.v2.ref-finance.near": "0",
  "wrap.near": "0"
}
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dex/bos/get-pools.md 

 ```js
const ammContract = "v2.ref-finance.near";
const result = Near.view(
  ammContract,
  "get_pools",
  {
    from_index: 0,
    limit: 1000
  }
);
```

<details>
<summary>Example response</summary>
<p>

```js
[
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [ 'token.skyward.near', 'wrap.near' ],
    amounts: [ '51865812079751349630100', '6254162663147994789053210138' ],
    total_fee: 30,
    shares_total_supply: '1305338644973934698612124055',
    amp: 0
  },
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [
      'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
      'wrap.near'
    ],
    amounts: [ '783621938569399817', '1100232280852443291118200599' ],
    total_fee: 30,
    shares_total_supply: '33923015415693335344747628',
    amp: 0
  }
]
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dex/bos/get-price.md 

 ```js
const tokenContract = "token.v2.ref-finance.near";
const tokenPriceResult = fetch(
  `https://indexer.ref.finance/get-token-price?token_id=${tokenContract}`
).body;
const tokenPriceValue = JSON.parse(tokenPriceResult);
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "token_contract_id": "token.v2.ref-finance.near",
  "price": "0.08153090"
}
```

</p>

</details>

:::tip
Ref Finance has a method to [get all token prices at once](https://indexer.ref.finance/list-token-price).
:::

 This is the content for the doc website/src/components/docs/primitives/dex/bos/swap.md 

 ```js
const ammContract = "v2.ref-finance.near";
const result = Near.call(
  ammContract,
  "swap",
  {
    actions: [
      {
        pool_id: 79,
        token_in: "token.v2.ref-finance.near",
        token_out: "wrap.near",
        amount_in: "100000000000000000",
        min_amount_out: "1",
      },
    ],
  },
  300000000000000,
  1
);
```

<details>
<summary>Example response</summary>

```json
"5019606679394603179450"
```
</details>

 This is the content for the doc website/src/components/docs/primitives/dex/near-cli/get-deposit-balances.md 

 ```bash
near view v2.ref-finance.near get_deposits '{"account_id": "bob.near"}'
```

<details>
<summary>Example response</summary>
<p>

```bash
{
  'token.v2.ref-finance.near': '0',
  'wrap.near': "0"
}
```

</p>

</details>


 This is the content for the doc website/src/components/docs/primitives/dex/near-cli/get-pools.md 

 ```bash
near view v2.ref-finance.near get_pools '{"from_index": 0, "limit": 1000}'
```

<details>
<summary>Example response</summary>
<p>

```bash
[
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [ 'token.skyward.near', 'wrap.near' ],
    amounts: [ '51865812079751349630100', '6254162663147994789053210138' ],
    total_fee: 30,
    shares_total_supply: '1305338644973934698612124055',
    amp: 0
  },
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [
      'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
      'wrap.near'
    ],
    amounts: [ '783621938569399817', '1100232280852443291118200599' ],
    total_fee: 30,
    shares_total_supply: '33923015415693335344747628',
    amp: 0
  }
]
```

</p>

</details>


 This is the content for the doc website/src/components/docs/primitives/dex/near-cli/swap.md 

 ```bash
near call v2.ref-finance.near swap "{\"actions\": [{\"pool_id\": 79, \"token_in\": \"token.v2.ref-finance.near\", \"amount_in\": \"100000000000000000\", \"token_out\": \"wrap.near\", \"min_amount_out\": \"1\"}]}" --gas 300000000000000 --depositYocto 1
 --accountId bob.near
```

<details>
<summary>Example response</summary>
<p>

```bash
'5019606679394603179450'
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dex/smart-contract/get-deposit-balances.md 

 ```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_amm_contract)]
trait ExternalAmmContract {
  fn get_deposits(&self, account_id: AccountId) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_get_deposits_callback(&self, #[callback_result] call_result: Result<HashMap<AccountId, U128>, PromiseError>) -> Option<HashMap<AccountId, U128>> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
      return None;
    }

    // Return the pools data
    let deposits_data = call_result.unwrap();
    return Some(deposits_data);
  }

  pub fn get_contract_deposits(&self) -> Promise {
    let promise = ext_amm_contract::ext(self.amm_contract.clone())
      .get_deposits(env::current_account_id());

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .external_get_deposits_callback()
    )
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/dex/smart-contract/get-pools.md 

 ```rust
#[near(serializers = [json])]
pub struct PoolInfo {
  /// Pool kind.
  pub pool_kind: String,
  /// List of tokens in the pool.
  pub token_account_ids: Vec<AccountId>,
  /// How much NEAR this contract has.
  pub amounts: Vec<U128>,
  /// Fee charged for swap.
  pub total_fee: u32,
  /// Total number of shares.
  pub shares_total_supply: U128,
  pub amp: u64,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_amm_contract)]
trait ExternalAmmContract {
  fn get_pools(&self, from_index: u64, limit: u64) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_get_pools_callback(&self, #[callback_result] call_result: Result<Vec<PoolInfo>, PromiseError>) -> Option<Vec<PoolInfo>> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
      return None;
    }

    // Return the pools data
    let pools_data = call_result.unwrap();
    return Some(pools_data);
  }

  pub fn get_amm_pools(&self, from_index: u64, limit: u64) -> Promise {
    let promise = ext_amm_contract::ext(self.amm_contract.clone())
      .get_pools(from_index, limit);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .external_get_pools_callback()
    )
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/dex/smart-contract/swap.md 

 ```rust
#[near(serializers = [json])]
pub struct SwapAction {
    /// Pool which should be used for swapping.
    pub pool_id: u64,
    /// Token to swap from.
    pub token_in: AccountId,
    /// Amount to exchange.
    /// If amount_in is None, it will take amount_out from previous step.
    /// Will fail if amount_in is None on the first step.
    pub amount_in: Option<U128>,
    /// Token to swap into.
    pub token_out: AccountId,
    /// Required minimum amount of token_out.
    pub min_amount_out: U128,
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_amm_contract)]
trait ExternalAmmContract {
  fn swap(&self, actions: Vec<SwapAction>) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_call_callback(&self, #[callback_result] call_result: Result<String, PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
    }
  }

  #[payable]
  pub fn swap_tokens(&mut self, pool_id: u64, token_in: AccountId, token_out: AccountId, amount_in: U128, min_amount_out: U128) -> Promise {
    assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");

    let swap_action = SwapAction {
      pool_id,
      token_in,
      token_out,
      amount_in: Some(amount_in),
      min_amount_out
    };

    let mut actions = Vec::new();
    actions.push(swap_action);

    let promise = ext_amm_contract::ext(self.amm_contract.clone())
      .with_static_gas(Gas(150*TGAS))
      .with_attached_deposit(YOCTO_NEAR)
      .swap(actions);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(100*TGAS))
      .external_call_callback()
    )
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/dex/web-app/get-deposit-balances.md 

 ```js
const AMM_CONTRACT_ADDRESS = "v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: AMM_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_deposits',
  args: {
   account_id: "bob.near"
  },
  contractId: AMM_CONTRACT_ADDRESS,
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>
<summary>Example response</summary>
<p>

```json
{
  "token.v2.ref-finance.near": "0",
  "wrap.near": "0"
}
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dex/web-app/get-pools.md 

 ```js
const AMM_CONTRACT_ADDRESS = "v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: AMM_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'get_pools',
  args: {
    from_index: 0,
    limit: 1000
  },
  contractId: AMM_CONTRACT_ADDRESS,
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>
<summary>Example response</summary>
<p>

```js
[
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [ 'token.skyward.near', 'wrap.near' ],
    amounts: [ '51865812079751349630100', '6254162663147994789053210138' ],
    total_fee: 30,
    shares_total_supply: '1305338644973934698612124055',
    amp: 0
  },
  {
    pool_kind: 'SIMPLE_POOL',
    token_account_ids: [
      'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
      'wrap.near'
    ],
    amounts: [ '783621938569399817', '1100232280852443291118200599' ],
    total_fee: 30,
    shares_total_supply: '33923015415693335344747628',
    amp: 0
  }
]
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/dex/web-app/get-price.md 

 ```js
const tokenContract = "token.v2.ref-finance.near";
const tokenPriceResult = await fetch(
  `https://indexer.ref.finance/get-token-price?token_id=${tokenContract}`
);
const tokenPriceValue = await tokenPriceResult.json();
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>
<summary>Example response</summary>
<p>

```json
{
  "token_contract_id": "token.v2.ref-finance.near",
  "price": "0.08153090"
}
```

</p>

</details>

:::tip
Ref Finance has a method to [get all token prices at once](https://indexer.ref.finance/list-token-price).
:::


 This is the content for the doc website/src/components/docs/primitives/dex/web-app/swap.md 

 ```js
import { Wallet } from './near-wallet';

const AMM_CONTRACT_ADDRESS = "v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: AMM_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'swap',
  args: {
   actions: [
      {
        pool_id: 79,
        token_in: "token.v2.ref-finance.near",
        token_out: "wrap.near",
        amount_in: "100000000000000000",
        min_amount_out: "1",
      },
    ],
  },
  contractId: AMM_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 1
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>
<summary>Example response</summary>

```json
"5019606679394603179450"
```
</details>

 This is the content for the doc website/src/components/docs/primitives/ft/bos/attach-to-call.md 

 ```js
const tokenContract = "token.v2.ref-finance.near";
const result = Near.call(
  tokenContract,
  "ft_transfer_call",
  {
    receiver_id: "v2.ref-finance.near",
    amount: "100000000000000000",
    msg: "",
  },
  300000000000000,
  1
);
```

<details>
<summary>Example response</summary>
<p>

```json
'100000000000000000'
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/ft/bos/check-balance.md 

 :::info
Remember about fungible token precision. You may need this value to show a response of balance requests in an understandable-to-user way in your app. How to get precision value (decimals) you may find [here](#querying-metadata).
:::

```js
const tokenContract = "token.v2.ref-finance.near";
const userTokenBalance = Near.view(tokenContract, "ft_balance_of", {
  account_id: "bob.near",
});
```

<details>
<summary>Example response</summary>
<p>

```json
"3479615037675962643842"
```

</p>

</details>


 This is the content for the doc website/src/components/docs/primitives/ft/bos/create.md 

 ```js
const args = {
  args: {
    owner_id: "bob.near",
    total_supply: "1000000000",
    metadata: {
      spec: "ft-1.0.0",
      name: "Test Token",
      symbol: "test",
      icon: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      decimals: 18,
    },
  },
  account_id: "bob.near",
};

Near.call("tkn.primitives.near", "create_token", args, 300000000000000, "2234830000000000000000000");
```


 This is the content for the doc website/src/components/docs/primitives/ft/bos/get-metadata.md 

 ```js
const tokenContract = "token.v2.ref-finance.near";
const tokenMetadata = Near.view(tokenContract, "ft_metadata", {});
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "spec": "ft-1.0.0",
  "name": "Ref Finance Token",
  "symbol": "REF",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
  "reference": null,
  "reference_hash": null,
  "decimals": 18
}
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/ft/bos/register.md 

 ```js
Near.call(
  tokenContract,
  "storage_deposit",
  { account_id: "alice.near" },
  undefined,
  1250000000000000000000
);
```


 This is the content for the doc website/src/components/docs/primitives/ft/bos/send.md 

 ```js
const tokenContract = "token.v2.ref-finance.near";
Near.call(
  tokenContract,
  "ft_transfer",
  {
    receiver_id: "alice.near",
    amount: "100000000000000000",
  },
  undefined,
  1
);
```

 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/attach-to-call.md 

 ```bash
near call token.v2.ref-finance.near ft_transfer_call '{"receiver_id": "v2.ref-finance.near", "amount": "100000000000000000", "msg": ""}' --gas 300000000000000 --depositYocto 1 --accountId bob.near
```

<details>
<summary>Example response</summary>
<p>

```bash
'100000000000000000'
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/check-balance.md 

 ```bash
near view token.v2.ref-finance.near ft_balance_of '{"account_id": "bob.near"}'
```

<details>
<summary>Example response</summary>
<p>

```bash
'376224322825327177426'
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/create-manually.md 

 ```bash
cargo near deploy build-non-reproducible-wasm <account-id> \
  with-init-call new \
  json-args '{
    "owner_id": "<owner-account>",
    "total_supply": "1000000000000000",
    "metadata": {
      "spec": "ft-1.0.0",
      "name": "Example Token Name",
      "symbol": "EXLT",
      "decimals": 8
    }
  }' \
  prepaid-gas '100.0 Tgas' \
  attached-deposit '0 NEAR' \
  network-config testnet \
  sign-with-keychain send
```


 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/create.md 

 ```bash
near call tkn.primitives.near create_token '{"args":{"owner_id": "bob.near","total_supply": "1000000000","metadata":{"spec": "ft-1.0.0","name": "Test Token","symbol": "TTTEST","icon": "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7","decimals": 18}},"account_id": "bob.near"}' --gas 300000000000000 --depositYocto 2234830000000000000000000 --accountId bob.near
```


 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/get-metadata.md 

 ```bash
near view token.v2.ref-finance.near ft_metadata
```

<details>
<summary>Example response</summary>
<p>

```bash
{
  spec: "ft-1.0.0",
  name: "Ref Finance Token",
  symbol: "REF",
  icon: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
  reference: null,
  reference_hash: null,
  decimals: 18
}
```

</p>

</details>

 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/register.md 

 ```bash
near call token.v2.ref-finance.near storage_deposit '{"account_id": "alice.near"}' --depositYocto 1250000000000000000000 --accountId bob.near
```


 This is the content for the doc website/src/components/docs/primitives/ft/near-cli/send.md 

 ```bash
near call token.v2.ref-finance.near ft_transfer '{"receiver_id": "alice.near", "amount": "100000000000000000"}' --depositYocto 1 --accountId bob.near
```

 This is the content for the doc website/src/components/docs/primitives/ft/smart-contract/attach-to-call.md 

 

```rust
#[payable]
pub fn call_with_attached_tokens(&mut self, receiver_id: AccountId, amount: U128) -> Promise {
  assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");

  let promise = ext(self.ft_contract.clone())
    .with_static_gas(Gas(150*TGAS))
    .with_attached_deposit(YOCTO_NEAR)
    .ft_transfer_call(receiver_id, amount, None, "".to_string());

  return promise.then( // Create a promise to callback query_greeting_callback
    Self::ext(env::current_account_id())
    .with_static_gas(Gas(100*TGAS))
    .external_call_callback()
  )
}
```

 This is the content for the doc website/src/components/docs/primitives/ft/smart-contract/send.md 

 ```rust
#[near]
impl Contract {
  #[payable]
  pub fn send_tokens(&mut self, receiver_id: AccountId, amount: U128) -> Promise {
    assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");

    let promise = ext(self.ft_contract.clone())
      .with_attached_deposit(YOCTO_NEAR)
      .ft_transfer(receiver_id, amount, None);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(30*TGAS))
      .external_call_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn external_call_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting external contract");
    }
  }
}
```
_This snippet assumes that the contract is already holding some FTs and that you want to send them to another account._


 This is the content for the doc website/src/components/docs/primitives/ft/web-app/attach-to-call.md 

 

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'ft_transfer_call',
  args: {
    receiver_id: "v2.ref-finance.near",
    amount: "100000000000000000",
    msg: "",
  },
  contractId: TOKEN_CONTRACT_ADDRESS,
  gas: 300000000000000,
  deposit: 1
});
```

<details>
<summary>Example response</summary>
<p>

```json
'100000000000000000'
```

</p>

</details>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/ft/web-app/check-balance.md 

 

:::info
Remember about fungible token precision. You may need this value to show a response of balance requests in an understandable-to-user way in your app. How to get precision value (decimals) you may find [here](#querying-metadata).
:::

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'ft_balance_of',
  args: {
    account_id: 'bob.near'
  },
  contractId: TOKEN_CONTRACT_ADDRESS
});
```

<details>
<summary>Example response</summary>
<p>

```json
"3479615037675962643842"
```

</p>

</details>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_


 This is the content for the doc website/src/components/docs/primitives/ft/web-app/create.md 

 ```js
import { Wallet } from './near-wallet';

const wallet = new Wallet({});

const args = {
  args: {
    owner_id: "bob.near",
    total_supply: "1000000000",
    metadata: {
      spec: "ft-1.0.0",
      name: "Test Token",
      symbol: "test",
      icon: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
      decimals: 18,
    },
  },
  account_id: "bob.near",
};

await wallet.callMethod({
  method: 'create_token',
  args,
  contractId: "tkn.primitives.near",
  gas: 300000000000000,
  deposit: "2234830000000000000000000"
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_


 This is the content for the doc website/src/components/docs/primitives/ft/web-app/get-metadata.md 

 

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.viewMethod({
  method: 'ft_metadata',
  args: {},
  contractId: TOKEN_CONTRACT_ADDRESS
});
```

<details>
<summary>Example response</summary>
<p>

```json
{
  "spec": "ft-1.0.0",
  "name": "Ref Finance Token",
  "symbol": "REF",
  "icon": "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='16 24 248 248' style='background: %23000'%3E%3Cpath d='M164,164v52h52Zm-45-45,20.4,20.4,20.6-20.6V81H119Zm0,18.39V216h41V137.19l-20.6,20.6ZM166.5,81H164v33.81l26.16-26.17A40.29,40.29,0,0,0,166.5,81ZM72,153.19V216h43V133.4l-11.6-11.61Zm0-18.38,31.4-31.4L115,115V81H72ZM207,121.5h0a40.29,40.29,0,0,0-7.64-23.66L164,133.19V162h2.5A40.5,40.5,0,0,0,207,121.5Z' fill='%23fff'/%3E%3Cpath d='M189 72l27 27V72h-27z' fill='%2300c08b'/%3E%3C/svg%3E%0A",
  "reference": null,
  "reference_hash": null,
  "decimals": 18
}
```

</p>

</details>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/ft/web-app/register.md 

 ```js
await wallet.callMethod({
  method: 'storage_deposit',
  args: {
    account_id: 'alice.near',
  },
  contractId: TOKEN_CONTRACT_ADDRESS,
  deposit: 1250000000000000000000
});
```
_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/ft/web-app/send.md 

 

```js
import { Wallet } from './near-wallet';

const TOKEN_CONTRACT_ADDRESS = "token.v2.ref-finance.near";
const wallet = new Wallet({ createAccessKeyFor: TOKEN_CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'ft_transfer',
  args: {
    receiver_id: 'alice.near',
    amount: '100000000000000000',
  },
  contractId: TOKEN_CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/nft/bos/buy.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras" default>

```js
const tokenData = Near.call(
  "x.paras.near",
  "nft_buy",
  {
    token_series_id: "299102",
    receiver_id: "bob.near",
  },
  undefined,
  205740000000000000000000 // NFT price + storage cost
);
```

**Example response:**

```json
"299102:1"
```


</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = Near.call(
  "simple.market.mintbase1.near",
  "buy",
  {
    nft_contract_id: "rubennnnnnnn.mintbase1.near",
    token_id: "38",
    referrer_id: null,
  },
  undefined,
  1000000000000000000000 // NFT price + storage cost (optional, depends on a contract)
);
```

**Example response:**

```json
{
  "payout": {
    "rub3n.near": "889200000000000000000",
    "rubenm4rcus.near": "85800000000000000000"
  }
}
```


</TabItem>

</Tabs>

 This is the content for the doc website/src/components/docs/primitives/nft/bos/list-for-sale.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras">

```js
Near.call(
  "marketplace.paras.near",
  "storage_deposit",
  {
    receiver_id: "bob.near"
  },
  undefined,
  9390000000000000000
);

Near.call(
  "nft.primitives.near",
  "nft_approve",
  {
    token_id: "1e95238d266e5497d735eb30",
    account_id: "marketplace.paras.near",
    msg: {
      price: "200000000000000000000000",
      market_type: "sale",
      ft_token_id: "near"
    }
  }
);
```

The method `nft_approve` will call `nft_on_approve` in `marketplace.paras.near`.

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
Near.call(
  "simple.market.mintbase1.near",
  "deposit_storage",
  {
    autotransfer: true
  },
  undefined,
  9390000000000000000
);

Near.call(
  "nft.primitives.near",
  "nft_approve",
  {
    token_id: "3c46b76cbd48e65f2fc88473",
    account_id: "simple.market.mintbase1.near",
    msg: {
      price: "200000000000000000000000"
    }
  }
);
```

The method `nft_approve` will call `nft_on_approve` in `simple.market.mintbase1.near`.

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/bos/mint.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
const tokenData = Near.call(
  "nft.primitives.near",
  "nft_mint",
  {
    token_id: "1",
    receiver_id: "bob.near", 
    token_metadata: {
      title: "NFT Primitive Token",
      description: "Awesome NFT Primitive Token",
      media: "string", // URL to associated media, preferably to decentralized, content-addressed storage
    }
  },
  undefined,
  10000000000000000000000, // Depends on your NFT metadata
);
```

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = Near.call(
  "x.paras.near",
  "nft_mint",
  {
    token_series_id: "490641",
    receiver_id: "bob.near",
  },
  undefined,
  10000000000000000000000 // Depends on your NFT metadata
);
```

:::note
In order to use `nft_mint` method of the `x.paras.near` contract you have to be a creator of a particular token series.
:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = Near.call(
  "thomasettorreiv.mintbase1.near",
  "nft_batch_mint",
  {
    num_to_mint: 1,
    owner_id: "bob.near",
    metadata: {},
  },
  undefined,
  10000000000000000000000
);
```

:::note
In order to use `nft_batch_mint` method of Mintbase store contract your account have to be a in the contract minters list.
:::

</TabItem>

</Tabs>

 This is the content for the doc website/src/components/docs/primitives/nft/bos/query.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
const tokenData = Near.view("nft.primitives.near", "nft_token", {
  token_id: "1",
});
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "1",
  "owner_id": "bob.near",
  "metadata": {
    "title": "string", // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    "description": "string", // free-form description
    "media": "string", // URL to associated media, preferably to decentralized, content-addressed storage
    "media_hash": "string", // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    "copies": 1, // number of copies of this set of metadata in existence when token was minted.
    "issued_at": 1642053411068358156, // When token was issued or minted, Unix epoch in milliseconds
    "expires_at": 1642053411168358156, // When token expires, Unix epoch in milliseconds
    "starts_at": 1642053411068358156, // When token starts being valid, Unix epoch in milliseconds
    "updated_at": 1642053411068358156, // When token was last updated, Unix epoch in milliseconds
    "extra": "string", // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    "reference": "string", // URL to an off-chain JSON file with more info.
    "reference_hash": "string" // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
  }
}
```

</details>

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = fetch("https://api-v2-mainnet.paras.id/token?token_id=84686:1154");
```

<details>

<summary> Example response </summary>

```json
{
  "status": 1,
  "data": {
    "results": [
      {
        "_id": "61dfbf27284abc1cc0b87c9d",
        "contract_id": "x.paras.near",
        "token_id": "84686:1154",
        "owner_id": "bob.near",
        "token_series_id": "84686",
        "edition_id": "1154",
        "metadata": {
          "title": "Tokenfox Silver Coin #1154",
          "description": "Holding this silver coin in your wallet will bring you health and happiness \uD83D\uDE0A",
          "media": "bafkreihpapfu7rzsmejjgl2twllge6pbrfmqaahj2wkz6nq55c6trhhtrq",
          "media_hash": null,
          "copies": 4063,
          "issued_at": null,
          "expires_at": null,
          "starts_at": null,
          "updated_at": null,
          "extra": null,
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "reference_hash": null,
          "collection": "Tokenfox Collection Cards",
          "collection_id": "tokenfox-collection-cards-by-tokenfoxnear",
          "creator_id": "tokenfox.near",
          "blurhash": "U7F~gc00_3D%00~q4n%M_39F-;RjM{xuWBRj",
          "score": 0,
          "mime_type": "image/png"
        },
        "royalty": {
          "tokenfox.near": 1000
        },
        "price": null,
        "approval_id": null,
        "ft_token_id": null,
        "has_price": null,
        "is_creator": true,
        "total_likes": 8,
        "likes": null,
        "categories": [],
        "view": 4
      }
    ],
    "count": 1,
    "skip": 0,
    "limit": 10
  }
}
```

</details>

:::info

See the [Paras API documentation](https://parashq.github.io/) for the full list of methods.

:::

:::note

Paras API methods returns data from all NFT contracts in NEAR. You might want to pass more parameters like `contract_id` or `owner_id` to make the response more accurate.

:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = fetch("https://graph.mintbase.xyz", {
  method: "POST",
  headers: {
    "mb-api-key": "anon",
    "Content-Type": "application/json",
    "x-hasura-role": "anonymous",
  },
  body: JSON.stringify({
    query: `
      query getToken{
        tokens: nft_tokens(
          where: {
            token_id: { _eq: "84686:1154" }
          }
        ) {
          tokenId: token_id
          ownerId: owner
          contractId: nft_contract_id
          reference
          issuedAt: issued_at
          copies
          metadataId: metadata_id
        }
      }
    `,
  }),
});
```

<details>

<summary> Example response </summary>

```json
{
  "ok": true,
  "status": 200,
  "contentType": "application/json",
  "body": {
    "data": {
      "tokens": [
        {
          "tokenId": "84686:1154",
          "ownerId": "bob.near",
          "contractId": "x.paras.near",
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "issuedAt": "2022-01-13T05:56:51.068358",
          "copies": 4063,
          "metadataId": "x.paras.near:5210047642790498956c9669d6a37b98"
        }
      ]
    }
  }
}
```

</details>

:::note

In the future, users may be required to register using an api key. For now, simply passing the value `anon` for `mb-api-key` will work.

:::

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/bos/transfer.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
const tokenData = Near.call(
  "nft.primitives.near",
  "nft_transfer",
  {
    token_id: "1",
    receiver_id: "bob.near"
  },
  undefined,
  1,
);
```

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = Near.call(
  "x.paras.near",
  "nft_transfer",
  {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  undefined,
  1
);
```

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = Near.call(
  "thomasettorreiv.mintbase1.near",
  "nft_transfer",
  {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  undefined,
  1
);
```

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/near-cli/buy.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras" default>

```bash
near call x.paras.near buy '{"token_series_id": "299102", "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.20574
```

**Example response:**

```json
"299102:1"
```


</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call simple.market.mintbase1.near buy '{"nft_contract_id": "rubennnnnnnn.mintbase1.near", "token_id": "38"}' --accountId bob.near --deposit 0.001
```

**Example response:**

```json
{
  "payout": {
    "rub3n.near": "889200000000000000000",
    "rubenm4rcus.near": "85800000000000000000"
  }
}
```


</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/near-cli/list-for-sale.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras">

```bash
near call marketplace.paras.near storage_deposit '{"receiver_id": "bob.near"}' --accountId bob.near --deposit 0.00939

near call nft.primitives.near nft_approve '{"token_id": "1e95238d266e5497d735eb30", "account_id": "marketplace.paras.near", "msg": {"price": "200000000000000000000000", "market_type": "sale", "ft_token_id": "near"}}' --accountId bob.near
```

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `marketplace.paras.near` as a callback.

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call simple.market.mintbase1.near deposit_storage '{"autotransfer": "true"}' --accountId bob.near --deposit 0.00939

near call nft.primitives.near nft_approve '{"token_id": "3c46b76cbd48e65f2fc88473", "account_id": "simple.market.mintbase1.near", "msg": {"price": "200000000000000000000000"}}' --accountId bob.near
```

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `simple.market.mintbase1.near` as a callback.

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/near-cli/mint.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```bash
near call nft.primitives.near nft_mint '{"token_id": "1", "receiver_id": "bob.near", "token_metadata": {"title": "NFT Primitive Token", "description": "Awesome NFT Primitive Token", "media": "string"}}' --depositYocto 10000000000000000000000, --accountId bob.near
```

</TabItem>

<TabItem value="Paras" label="Paras">

```bash
near call x.paras.near nft_mint '{"token_series_id": "490641", "receiver_id": "bob.near"}' --depositYocto 10000000000000000000000 --accountId bob.near
```

:::note
In order to use `nft_mint` method of the `x.paras.near` contract you have to be a creator of a particular token series.
:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call thomasettorreiv.mintbase1.near nft_batch_mint '{"num_to_mint": 1, "owner_id": "bob.near", "metadata": {}}' --accountId bob.near --depositYocto 10000000000000000000000
```

:::note
In order to use `nft_batch_mint` method of Mintbase store contract your account have to be a in the contract minters list.
:::

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/near-cli/query.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```bash
near view nft.primitives.near nft_token '{"token_id": "1"}'
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "1",
  "owner_id": "bob.near",
  "metadata": {
    "title": "string", // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    "description": "string", // free-form description
    "media": "string", // URL to associated media, preferably to decentralized, content-addressed storage
    "media_hash": "string", // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    "copies": 1, // number of copies of this set of metadata in existence when token was minted.
    "issued_at": 1642053411068358156, // When token was issued or minted, Unix epoch in milliseconds
    "expires_at": 1642053411168358156, // When token expires, Unix epoch in milliseconds
    "starts_at": 1642053411068358156, // When token starts being valid, Unix epoch in milliseconds
    "updated_at": 1642053411068358156, // When token was last updated, Unix epoch in milliseconds
    "extra": "string", // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    "reference": "string", // URL to an off-chain JSON file with more info.
    "reference_hash": "string" // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
  }
}
```
</details>

</TabItem>

<TabItem value="Paras" label="Paras">

```bash
near view x.paras.near nft_token '{"token_id": "84686:1154"}'
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "84686:1154",
  "owner_id": "bob.near",
  "metadata": {
    "title": "Tokenfox Silver Coin #1154",
    "description": null,
    "media": "bafkreihpapfu7rzsmejjgl2twllge6pbrfmqaahj2wkz6nq55c6trhhtrq",
    "media_hash": null,
    "copies": 4063,
    "issued_at": "1642053411068358156",
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
    "reference_hash": null
  },
  "approved_account_ids": {}
}
```

</details>

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near view anthropocene.mintbase1.near nft_token '{"token_id": "17960"}'
```

<details>

<summary> Example response </summary>

```json
{
  "token_id": "17960",
  "owner_id": "876f40299dd919f39252863e2136c4e1922cd5f78759215474cbc8f1fc361e14",
  "approved_account_ids": {},
  "metadata": {
    "title": null,
    "description": null,
    "media": null,
    "media_hash": null,
    "copies": 1,
    "issued_at": null,
    "expires_at": null,
    "starts_at": null,
    "updated_at": null,
    "extra": null,
    "reference": "F-30s_uQ3ZdAHZClY4DYatDPapaIRNLju41RxfMXC24",
    "reference_hash": null
  },
  "royalty": {
    "split_between": {
      "seventhage.near": {
        "numerator": 10000
      }
    },
    "percentage": {
      "numerator": 100
    }
  },
  "split_owners": null,
  "minter": "anthropocene.seventhage.near",
  "loan": null,
  "composeable_stats": { "local_depth": 0, "cross_contract_children": 0 },
  "origin_key": null
}
```

</details>

:::note
When someone creates a NFT on Mintbase they need to deploy their own NFT contract using Mintbase factory. Those smart contract are subaccounts of mintbase1.near, e.g. `anthropocene.mintbase1.near`.
:::

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/near-cli/transfer.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```bash
near call nft.primitives.near nft_transfer '{"token_id": "1", "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.000000000000000000000001
```

</TabItem>

<TabItem value="Paras" label="Paras">

```bash
near call x.paras.near nft_transfer '{"token_id": "490641", "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.000000000000000000000001
```

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```bash
near call thomasettorreiv.mintbase1.near nft_transfer '{"token_id": "490641" "receiver_id": "bob.near"}' --accountId bob.near --deposit 0.000000000000000000000001
```

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/smart-contract/buy.md 

 This is an example on how you can make your smart contract buy a NFT on some marketplace (Paras this case).

:::info
Please note that in this example the contract will be the owner of the NFT, however, some marketplaces allow you to buy NFT for somebody else.
:::

```rust
const NFT_MARKETPLACE_CONTRACT: &str = "paras-marketplace-v2.testnet";

// Define the contract structure
#[near(contract_state)]
pub struct Contract {
  nft_marketplace_contract: AccountId
}

impl Default for Contract {
    // The default trait with which to initialize the contract
    fn default() -> Self {
        Self {
          nft_marketplace_contract: NFT_MARKETPLACE_CONTRACT.parse().unwrap()
        }
    }
}

// Validator interface, for cross-contract calls
#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn buy(&self, nft_contract_id: AccountId, token_id: TokenId, ft_token_id: Option<AccountId>, price: Option<U128>) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn buy(&mut self, nft_contract_id: AccountId, token_id: TokenId, ft_token_id: Option<AccountId>, price: Option<U128>) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_marketplace_contract.clone())
      .with_static_gas(Gas(30*TGAS))
      .with_attached_deposit(env::attached_deposit())
      .buy(nft_contract_id, token_id, ft_token_id, price);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(30*TGAS))
      .buy_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn buy_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
    }
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/nft/smart-contract/mint.md 

 ```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn nft_mint(&self, token_series_id: String, receiver_id: AccountId) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  #[payable]
  pub fn nft_mint(&mut self, token_series_id: String, receiver_id: AccountId) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_contract.clone())
      .with_static_gas(Gas(30*TGAS))
      .with_attached_deposit(env::attached_deposit())
      .nft_mint(token_series_id, receiver_id);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .with_static_gas(Gas(30*TGAS))
      .nft_mint_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn nft_mint_callback(&self, #[callback_result] call_result: Result<TokenId, PromiseError>) -> Option<TokenId> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
      return None;
    }

    // Return the token data
    let token_id: TokenId = call_result.unwrap();
    return Some(token_id);
  }
}


 This is the content for the doc website/src/components/docs/primitives/nft/smart-contract/query.md 

 ```rust
// Validator interface, for cross-contract calls
#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn nft_token(&self, token_id: TokenId) -> Promise;
}

// Implement the contract structure
#[near]
impl Contract {
  pub fn nft_token(&self, token_id: TokenId) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_contract.clone())
      .nft_token(token_id);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .nft_token_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn nft_token_callback(&self, #[callback_result] call_result: Result<Token, PromiseError>) -> Option<Token> {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
      return None;
    }

    // Return the token data
    let token_data: Token = call_result.unwrap();
    return Some(token_data);
  }
}
```


 This is the content for the doc website/src/components/docs/primitives/nft/smart-contract/transfer.md 

 :::info
Please notice that a contract can only transfer an NFT that they own, or an NFT that they were approved to transfer.
:::

```rust
const YOCTO_NEAR: u128 = 1;

#[ext_contract(ext_nft_contract)]
trait ExternalNftContract {
  fn nft_transfer(&self, receiver_id: AccountId, token_id: TokenId) -> Promise;
}

impl Contract {
  #[payable]
  pub fn nft_transfer(&mut self, receiver_id: AccountId, token_id: TokenId) -> Promise {
    let promise = ext_nft_contract::ext(self.nft_contract.clone())
      .with_attached_deposit(YOCTO_NEAR)
      .nft_transfer(receiver_id, token_id);

    return promise.then( // Create a promise to callback query_greeting_callback
      Self::ext(env::current_account_id())
      .nft_transfer_callback()
    )
  }

  #[private] // Public - but only callable by env::current_account_id()
  pub fn nft_transfer_callback(&self, #[callback_result] call_result: Result<(), PromiseError>) {
    // Check if the promise succeeded
    if call_result.is_err() {
      log!("There was an error contacting NFT contract");
    }
  }
}
```

 This is the content for the doc website/src/components/docs/primitives/nft/web-app/buy.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "x.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_buy',
  args: {
    token_series_id: "299102",
    receiver_id: "bob.near",
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 205740000000000000000000 // attached deposit in yoctoNEAR, covers NFT price + storage cost
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>

<summary>Example response</summary>

```json
"299102:1"
```

</details>

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "simple.market.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'buy',
  args: {
    nft_contract_id: "rubennnnnnnn.mintbase1.near",
    token_id: "38"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1000000000000000000000 // attached deposit in yoctoNEAR, covers NFT price + storage cost (optional)
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>

<summary>Example response</summary>

```json
{
  "payout": {
    "rub3n.near": "889200000000000000000",
    "rubenm4rcus.near": "85800000000000000000"
  }
}
```

</details>

:::tip

Check how to do this using the [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/buy)

:::

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/web-app/list-for-sale.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="Paras" label="Paras">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "marketplace.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'storage_deposit',
  args: {
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  gas: 300000000000000, // attached GAS (optional)
  deposit: 9390000000000000000 // attached deposit in yoctoNEAR (optional)
});

await wallet.callMethod({
  method: 'nft_approve',
  args: {
    token_id: "1e95238d266e5497d735eb30",
    account_id: "marketplace.paras.near",
    msg: {
      price: "200000000000000000000000",
      market_type: "sale",
      ft_token_id: "near"
    }
  },
  contractId: "nft.primitives.near"
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `marketplace.paras.near` as a callback.

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "simple.market.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'deposit_storage',
  args: {
      autotransfer: true
    },
  contractId: CONTRACT_ADDRESS,
  gas: 300000000000000, // attached GAS (optional)
  deposit: 9390000000000000000 // attached deposit in yoctoNEAR (optional)
});

await wallet.callMethod({
  method: 'nft_approve',
  args: {
    args: {
      token_id: "3c46b76cbd48e65f2fc88473",
      account_id: "simple.market.mintbase1.near",
      msg: {
        price: "200000000000000000000000"
      }
    },
  },
  contractId: "nft.primitives.near"
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

Method `nft_approve` of a NFT contract also calls the `nft_on_approve` method in `simple.market.mintbase1.near` as a callback.

:::tip

Check how to also do this using the [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/list)

:::

</TabItem>

</Tabs>



 This is the content for the doc website/src/components/docs/primitives/nft/web-app/mint.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "nft.primitives.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_mint',
  args: {
    token_id: "1",
    receiver_id: "bob.near", 
    token_metadata: {
      title: "NFT Primitive Token",
      description: "Awesome NFT Primitive Token",
      media: "string", // URL to associated media, preferably to decentralized, content-addressed storage
    }
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 10000000000000000000000
});
```

</TabItem>

<TabItem value="Paras" label="Paras">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "x.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_mint',
  args: {
    token_series_id: "490641",
    receiver_id: "bob.near",
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 10000000000000000000000 // Depends on your NFT metadata
});
```

:::note
In order to use `nft_mint` method of the `x.paras.near` contract you have to be a creator of a particular token series.
:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "thomasettorreiv.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_batch_mint',
  args: {
    num_to_mint: 1,
    owner_id: "bob.near",
    metadata: {},
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 10000000000000000000000 // Depends on your NFT metadata
});
```

:::note
In order to use `nft_batch_mint` method of Mintbase store contract your account have to be a in the contract minters list.
:::

:::tip
Check how to do this using [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/mint)
:::

</TabItem>

</Tabs>

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

 This is the content for the doc website/src/components/docs/primitives/nft/web-app/query.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "nft.primitives.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
const response = await wallet.viewMethod({
  method: 'nft_token',
  args: {
    token_id: "1"
  }
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>

<summary> Example response </summary>

```json
{
  "token_id": "1",
  "owner_id": "bob.near",
  "metadata": {
    "title": "string", // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    "description": "string", // free-form description
    "media": "string", // URL to associated media, preferably to decentralized, content-addressed storage
    "media_hash": "string", // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    "copies": 1, // number of copies of this set of metadata in existence when token was minted.
    "issued_at": 1642053411068358156, // When token was issued or minted, Unix epoch in milliseconds
    "expires_at": 1642053411168358156, // When token expires, Unix epoch in milliseconds
    "starts_at": 1642053411068358156, // When token starts being valid, Unix epoch in milliseconds
    "updated_at": 1642053411068358156, // When token was last updated, Unix epoch in milliseconds
    "extra": "string", // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    "reference": "string", // URL to an off-chain JSON file with more info.
    "reference_hash": "string" // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
  }
}
```
</details>

</TabItem>

<TabItem value="Paras" label="Paras">

```js
const tokenData = fetch("https://api-v2-mainnet.paras.id/token?token_id=84686:1154");
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

<details>

<summary> Example response </summary>

```json
{
  "status": 1,
  "data": {
    "results": [
      {
        "_id": "61dfbf27284abc1cc0b87c9d",
        "contract_id": "x.paras.near",
        "token_id": "84686:1154",
        "owner_id": "bob.near",
        "token_series_id": "84686",
        "edition_id": "1154",
        "metadata": {
          "title": "Tokenfox Silver Coin #1154",
          "description": "Holding this silver coin in your wallet will bring you health and happiness \uD83D\uDE0A",
          "media": "bafkreihpapfu7rzsmejjgl2twllge6pbrfmqaahj2wkz6nq55c6trhhtrq",
          "media_hash": null,
          "copies": 4063,
          "issued_at": null,
          "expires_at": null,
          "starts_at": null,
          "updated_at": null,
          "extra": null,
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "reference_hash": null,
          "collection": "Tokenfox Collection Cards",
          "collection_id": "tokenfox-collection-cards-by-tokenfoxnear",
          "creator_id": "tokenfox.near",
          "blurhash": "U7F~gc00_3D%00~q4n%M_39F-;RjM{xuWBRj",
          "score": 0,
          "mime_type": "image/png"
        },
        "royalty": {
          "tokenfox.near": 1000
        },
        "price": null,
        "approval_id": null,
        "ft_token_id": null,
        "has_price": null,
        "is_creator": true,
        "total_likes": 8,
        "likes": null,
        "categories": [],
        "view": 4
      }
    ],
    "count": 1,
    "skip": 0,
    "limit": 10
  }
}
```

</details>

:::info

See the [Paras API documentation](https://parashq.github.io/) for the full list of methods.

:::

:::note

Paras API methods returns data from all NFT contracts in NEAR. You might want to pass more parameters like `contract_id` or `owner_id` to make the response more accurate.

:::

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
const tokenData = fetch("https://graph.mintbase.xyz", {
  method: "POST",
  headers: {
    "mb-api-key": "anon",
    "Content-Type": "application/json",
    "x-hasura-role": "anonymous",
  },
  body: JSON.stringify({
    query: `
      query getToken{
        tokens: nft_tokens(
          where: {
            token_id: { _eq: "84686:1154" }
          }
        ) {
          tokenId: token_id
          ownerId: owner
          contractId: nft_contract_id
          reference
          issuedAt: issued_at
          copies
          metadataId: metadata_id
        }
      }
    `,
  }),
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

<details>

<summary> Example response </summary>

```json
{
  "ok": true,
  "status": 200,
  "contentType": "application/json",
  "body": {
    "data": {
      "tokens": [
        {
          "tokenId": "84686:1154",
          "ownerId": "bob.near",
          "contractId": "x.paras.near",
          "reference": "bafkreib6uj5kxbadfvf6qes5flema7jx6u5dj5zyqcneaoyqqzlm6kpu5a",
          "issuedAt": "2022-01-13T05:56:51.068358",
          "copies": 4063,
          "metadataId": "x.paras.near:5210047642790498956c9669d6a37b98"
        }
      ]
    }
  }
}
```

</details>

:::note

In the future, users may be required to register using an api key. For now, simply passing the valueanon for `mb-api-key` will work.

:::

:::tip

Check how to do this also using the [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/data/api/tokenbyid)

:::

</TabItem>

</Tabs>


 This is the content for the doc website/src/components/docs/primitives/nft/web-app/transfer.md 

 import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs groupId="nft-contract-tabs" className="file-tabs">
<TabItem value="NFT Primitive" label="Reference" default>

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "nft.primitives.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_transfer',
  args: {
    token_id: "1",
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

</TabItem>

<TabItem value="Paras" label="Paras">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "x.paras.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_transfer',
  args: {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_ 

</TabItem>

<TabItem value="Mintbase" label="Mintbase">

```js
import { Wallet } from './near-wallet';

const CONTRACT_ADDRESS = "thomasettorreiv.mintbase1.near";
const wallet = new Wallet({ createAccessKeyFor: CONTRACT_ADDRESS });
 
await wallet.callMethod({
  method: 'nft_transfer',
  args: {
    token_id: "490641",
    receiver_id: "bob.near"
  },
  contractId: CONTRACT_ADDRESS,
  deposit: 1
});
```

_The `Wallet` object comes from our [quickstart template](https://github.com/near-examples/hello-near-examples/blob/main/frontend/near-wallet.js)_

:::tip

Check how to also do this using [`Mintbase JS`](https://docs.mintbase.xyz/dev/mintbase-sdk-ref/sdk/transfer)

:::

</TabItem>

</Tabs>
